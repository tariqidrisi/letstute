/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/babel-loader/lib/index.js?!./node_modules/vue-loader/lib/index.js?!./resources/js/components/ExampleComponent.vue?vue&type=script&lang=js&":
/*!***************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib??ref--4-0!./node_modules/vue-loader/lib??vue-loader-options!./resources/js/components/ExampleComponent.vue?vue&type=script&lang=js& ***!
  \***************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  mounted: function mounted() {\n    console.log('Component mounted.');\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvRXhhbXBsZUNvbXBvbmVudC52dWU/OTFiNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBLFNBREEscUJBQ0E7QUFDQTtBQUNBO0FBSEEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/IS4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvRXhhbXBsZUNvbXBvbmVudC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmLmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInJvdyBqdXN0aWZ5LWNvbnRlbnQtY2VudGVyXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sLW1kLThcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZFwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC1oZWFkZXJcIj5FeGFtcGxlIENvbXBvbmVudDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYXJkLWJvZHlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIEknbSBhbiBleGFtcGxlIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuICAgIGV4cG9ydCBkZWZhdWx0IHtcbiAgICAgICAgbW91bnRlZCgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb21wb25lbnQgbW91bnRlZC4nKVxuICAgICAgICB9XG4gICAgfVxuPC9zY3JpcHQ+XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js?!./node_modules/vue-loader/lib/index.js?!./resources/js/components/ExampleComponent.vue?vue&type=script&lang=js&\n");

/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v3.4.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2019-05-01T21:04Z\n */\n( function( global, factory ) {\n\n\t\"use strict\";\n\n\tif (  true && typeof module.exports === \"object\" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n\"use strict\";\n\nvar arr = [];\n\nvar document = window.document;\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\nvar isFunction = function isFunction( obj ) {\n\n      // Support: Chrome <=57, Firefox <=52\n      // In some browsers, typeof returns \"function\" for HTML <object> elements\n      // (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n      // We don't want to classify *any* DOM node as a function.\n      return typeof obj === \"function\" && typeof obj.nodeType !== \"number\";\n  };\n\n\nvar isWindow = function isWindow( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t};\n\n\n\n\n\tvar preservedScriptAttributes = {\n\t\ttype: true,\n\t\tsrc: true,\n\t\tnonce: true,\n\t\tnoModule: true\n\t};\n\n\tfunction DOMEval( code, node, doc ) {\n\t\tdoc = doc || document;\n\n\t\tvar i, val,\n\t\t\tscript = doc.createElement( \"script\" );\n\n\t\tscript.text = code;\n\t\tif ( node ) {\n\t\t\tfor ( i in preservedScriptAttributes ) {\n\n\t\t\t\t// Support: Firefox 64+, Edge 18+\n\t\t\t\t// Some browsers don't support the \"nonce\" property on scripts.\n\t\t\t\t// On the other hand, just using `getAttribute` is not enough as\n\t\t\t\t// the `nonce` attribute is reset to an empty string whenever it\n\t\t\t\t// becomes browsing-context connected.\n\t\t\t\t// See https://github.com/whatwg/html/issues/2369\n\t\t\t\t// See https://html.spec.whatwg.org/#nonce-attributes\n\t\t\t\t// The `node.getAttribute` check was added for the sake of\n\t\t\t\t// `jQuery.globalEval` so that it can fake a nonce-containing node\n\t\t\t\t// via an object.\n\t\t\t\tval = node[ i ] || node.getAttribute && node.getAttribute( i );\n\t\t\t\tif ( val ) {\n\t\t\t\t\tscript.setAttribute( i, val );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n\n\nfunction toType( obj ) {\n\tif ( obj == null ) {\n\t\treturn obj + \"\";\n\t}\n\n\t// Support: Android <=2.3 only (functionish RegExp)\n\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\ttypeof obj;\n}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar\n\tversion = \"3.4.1\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android <=4.0 only\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent Object.prototype pollution\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( name === \"__proto__\" || target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\n\t\t\t\t\tsrc = target[ name ];\n\n\t\t\t\t\t// Ensure proper type for the source value\n\t\t\t\t\tif ( copyIsArray && !Array.isArray( src ) ) {\n\t\t\t\t\t\tclone = [];\n\t\t\t\t\t} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {\n\t\t\t\t\t\tclone = {};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src;\n\t\t\t\t\t}\n\t\t\t\t\tcopyIsArray = false;\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code, options ) {\n\t\tDOMEval( code, { nonce: options && options.nonce } );\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android <=4.0 only\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === \"function\" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\nfunction( i, name ) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = toType( obj );\n\n\tif ( isFunction( obj ) || isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.3.4\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://js.foundation/\n *\n * Date: 2019-04-08\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tnonnativeSelectorCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\trdescend = new RegExp( whitespace + \"|>\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trhtml = /HTML$/i,\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tinDisabledFieldset = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && elem.nodeName.toLowerCase() === \"fieldset\";\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!nonnativeSelectorCache[ selector + \" \" ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) &&\n\n\t\t\t\t// Support: IE 8 only\n\t\t\t\t// Exclude object elements\n\t\t\t\t(nodeType !== 1 || context.nodeName.toLowerCase() !== \"object\") ) {\n\n\t\t\t\tnewSelector = selector;\n\t\t\t\tnewContext = context;\n\n\t\t\t\t// qSA considers elements outside a scoping root when evaluating child or\n\t\t\t\t// descendant combinators, which is not what we want.\n\t\t\t\t// In such cases, we work around the behavior by prefixing every selector in the\n\t\t\t\t// list with an ID selector referencing the scope context.\n\t\t\t\t// Thanks to Andrew Dupont for this technique.\n\t\t\t\tif ( nodeType === 1 && rdescend.test( selector ) ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t);\n\t\t\t\t\treturn results;\n\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\tnonnativeSelectorCache( selector, true );\n\t\t\t\t} finally {\n\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement(\"fieldset\");\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\tinDisabledFieldset( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\tvar namespace = elem.namespaceURI,\n\t\tdocElem = (elem.ownerDocument || elem).documentElement;\n\n\t// Support: IE <=8\n\t// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes\n\t// https://bugs.jquery.com/ticket/4833\n\treturn !rhtml.test( namespace || docElem && docElem.nodeName || \"HTML\" );\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\tif ( preferredDoc !== document &&\n\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( el ) {\n\t\tel.className = \"i\";\n\t\treturn !el.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( el ) {\n\t\tel.appendChild( document.createComment(\"\") );\n\t\treturn !el.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( el ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( el ) {\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( el ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!nonnativeSelectorCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tnonnativeSelectorCache( expr, true );\n\t\t}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn (sel + \"\").replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\"disabled\": createDisabledPseudo( true ),\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ?\n\t\t\t\targument + length :\n\t\t\t\targument > length ?\n\t\t\t\t\tlength :\n\t\t\t\t\targument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( el ) {\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( el ) {\n\tel.innerHTML = \"<a href='#'></a>\";\n\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( el ) {\n\tel.innerHTML = \"<input/>\";\n\tel.firstChild.setAttribute( \"value\", \"\" );\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( el ) {\n\treturn el.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\n\n// Deprecated\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\njQuery.escapeSelector = Sizzle.escape;\n\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\n\n\nfunction nodeName( elem, name ) {\n\n  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\n};\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== \"string\" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Filtered directly for both simple and complex selectors\n\treturn jQuery.filter( qualifier, elements, not );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there's no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\tif ( typeof elem.contentDocument !== \"undefined\" ) {\n\t\t\treturn elem.contentDocument;\n\t\t}\n\n\t\t// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n\t\t// Treat the template element as a regular one in browsers that\n\t\t// don't support it.\n\t\tif ( nodeName( elem, \"template\" ) ) {\n\t\t\telem = elem.content || elem;\n\t\t}\n\n\t\treturn jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = locked || options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && toType( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject, noValue ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\n\t\t\t// * true: [ value ].slice( 1 ) => resolve()\n\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.apply( undefined, [ value ] );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// rejected_handlers.disable\n\t\t\t\t\t// fulfilled_handlers.disable\n\t\t\t\t\ttuples[ 3 - i ][ 3 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock,\n\n\t\t\t\t\t// progress_handlers.lock\n\t\t\t\t\ttuples[ 0 ][ 3 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the master Deferred\n\t\t\tmaster = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\n\t\t\t\t!remaining );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( master.state() === \"pending\" ||\n\t\t\t\tisFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn master.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t}\n\n\t\treturn master.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\njQuery.Deferred.exceptionHook = function( error, stack ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\twindow.removeEventListener( \"load\", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals \"interactive\" too soon\nif ( document.readyState === \"complete\" ||\n\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( \"load\", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( toType( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\n\n\n// Matches dashed string for camelizing\nvar rmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g;\n\n// Used by camelCase as callback to replace()\nfunction fcamelCase( all, letter ) {\n\treturn letter.toUpperCase();\n}\n\n// Convert dashed to camelCase; used by the css and data modules\n// Support: IE <=9 - 11, Edge 12 - 15\n// Microsoft forgot to hump their vendor prefix (#9572)\nfunction camelCase( string ) {\n\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n}\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( Array.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( camelCase );\n\t\t\t} else {\n\t\t\t\tkey = camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there's no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === \"true\" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === \"false\" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === \"null\" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn't change the string\n\tif ( data === +data + \"\" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || Array.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar documentElement = document.documentElement;\n\n\n\n\tvar isAttached = function( elem ) {\n\t\t\treturn jQuery.contains( elem.ownerDocument, elem );\n\t\t},\n\t\tcomposed = { composed: true };\n\n\t// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only\n\t// Check attachment across shadow DOM boundaries when possible (gh-3504)\n\t// Support: iOS 10.0-10.2 only\n\t// Early iOS 10 versions support `attachShadow` but not `getRootNode`,\n\t// leading to errors. We need to check for `getRootNode`.\n\tif ( documentElement.getRootNode ) {\n\t\tisAttached = function( elem ) {\n\t\t\treturn jQuery.contains( elem.ownerDocument, elem ) ||\n\t\t\t\telem.getRootNode( composed ) === elem.ownerDocument;\n\t\t};\n\t}\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === \"none\" ||\n\t\t\telem.style.display === \"\" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tisAttached( elem ) &&\n\n\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n\t};\n\nvar swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted, scale,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = elem.nodeType &&\n\t\t\t( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Support: Firefox <=54\n\t\t// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n\t\tinitial = initial / 2;\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\twhile ( maxIterations-- ) {\n\n\t\t\t// Evaluate and update our best guess (doubling guesses that zero out).\n\t\t\t// Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\t\t\tif ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {\n\t\t\t\tmaxIterations = 0;\n\t\t\t}\n\t\t\tinitialInUnit = initialInUnit / scale;\n\n\t\t}\n\n\t\tinitialInUnit = initialInUnit * 2;\n\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, \"display\" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === \"none\" ) {\n\t\tdisplay = \"block\";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === \"none\" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== \"none\" ) {\n\t\t\t\tvalues[ index ] = \"none\";\n\n\t\t\t\t// Remember what we're overwriting\n\t\t\t\tdataPriv.set( elem, \"display\", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i );\n\nvar rscriptType = ( /^$|^module$|\\/(?:java|ecma)script/i );\n\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// Support: IE <=9 only\n\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, \"<table>\", \"</table>\" ],\n\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t_default: [ 0, \"\", \"\" ]\n};\n\n// Support: IE <=9 only\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\tret = context.getElementsByTagName( tag || \"*\" );\n\n\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n\t\tret = context.querySelectorAll( tag || \"*\" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t\"globalEval\",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, attached, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( toType( elem ) === \"object\" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = \"\";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tattached = isAttached( elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( attached ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n} )();\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE <=9 - 11+\n// focus() and blur() are asynchronous, except when they are no-op.\n// So expect focus to be synchronous when the element is already active,\n// and blur to be synchronous when the element is not already active.\n// (focus and blur are always synchronous in other supported browsers,\n// this just defines when we can count on it).\nfunction expectSync( elem, type ) {\n\treturn ( elem === safeActiveElement() ) === ( type === \"focus\" );\n}\n\n// Support: IE <=9 only\n// Accessing document.activeElement can throw unexpectedly\n// https://bugs.jquery.com/ticket/13393\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === \"object\" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== \"string\" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === \"string\" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tvar event = jQuery.event.fix( nativeEvent );\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\t\t\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// If the event is namespaced, then each handler is only invoked if it is\n\t\t\t\t// specially universal or its namespaces are a superset of the event's.\n\t\t\t\tif ( !event.rnamespace || handleObj.namespace === false ||\n\t\t\t\t\tevent.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tclick: {\n\n\t\t\t// Utilize native event to ensure correct state for checkable inputs\n\t\t\tsetup: function( data ) {\n\n\t\t\t\t// For mutual compressibility with _default, replace `this` access with a local var.\n\t\t\t\t// `|| data` is dead code meant only to preserve the variable through minification.\n\t\t\t\tvar el = this || data;\n\n\t\t\t\t// Claim the first handler\n\t\t\t\tif ( rcheckableType.test( el.type ) &&\n\t\t\t\t\tel.click && nodeName( el, \"input\" ) ) {\n\n\t\t\t\t\t// dataPriv.set( el, \"click\", ... )\n\t\t\t\t\tleverageNative( el, \"click\", returnTrue );\n\t\t\t\t}\n\n\t\t\t\t// Return false to allow normal processing in the caller\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\ttrigger: function( data ) {\n\n\t\t\t\t// For mutual compressibility with _default, replace `this` access with a local var.\n\t\t\t\t// `|| data` is dead code meant only to preserve the variable through minification.\n\t\t\t\tvar el = this || data;\n\n\t\t\t\t// Force setup before triggering a click\n\t\t\t\tif ( rcheckableType.test( el.type ) &&\n\t\t\t\t\tel.click && nodeName( el, \"input\" ) ) {\n\n\t\t\t\t\tleverageNative( el, \"click\" );\n\t\t\t\t}\n\n\t\t\t\t// Return non-false to allow normal event-path propagation\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, suppress native .click() on links\n\t\t\t// Also prevent it if we're currently inside a leveraged native-event stack\n\t\t\t_default: function( event ) {\n\t\t\t\tvar target = event.target;\n\t\t\t\treturn rcheckableType.test( target.type ) &&\n\t\t\t\t\ttarget.click && nodeName( target, \"input\" ) &&\n\t\t\t\t\tdataPriv.get( target, \"click\" ) ||\n\t\t\t\t\tnodeName( target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Ensure the presence of an event listener that handles manually-triggered\n// synthetic events by interrupting progress until reinvoked in response to\n// *native* events that it fires directly, ensuring that state changes have\n// already occurred before other listeners are invoked.\nfunction leverageNative( el, type, expectSync ) {\n\n\t// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add\n\tif ( !expectSync ) {\n\t\tif ( dataPriv.get( el, type ) === undefined ) {\n\t\t\tjQuery.event.add( el, type, returnTrue );\n\t\t}\n\t\treturn;\n\t}\n\n\t// Register the controller as a special universal handler for all event namespaces\n\tdataPriv.set( el, type, false );\n\tjQuery.event.add( el, type, {\n\t\tnamespace: false,\n\t\thandler: function( event ) {\n\t\t\tvar notAsync, result,\n\t\t\t\tsaved = dataPriv.get( this, type );\n\n\t\t\tif ( ( event.isTrigger & 1 ) && this[ type ] ) {\n\n\t\t\t\t// Interrupt processing of the outer synthetic .trigger()ed event\n\t\t\t\t// Saved data should be false in such cases, but might be a leftover capture object\n\t\t\t\t// from an async native handler (gh-4350)\n\t\t\t\tif ( !saved.length ) {\n\n\t\t\t\t\t// Store arguments for use when handling the inner native event\n\t\t\t\t\t// There will always be at least one argument (an event object), so this array\n\t\t\t\t\t// will not be confused with a leftover capture object.\n\t\t\t\t\tsaved = slice.call( arguments );\n\t\t\t\t\tdataPriv.set( this, type, saved );\n\n\t\t\t\t\t// Trigger the native event and capture its result\n\t\t\t\t\t// Support: IE <=9 - 11+\n\t\t\t\t\t// focus() and blur() are asynchronous\n\t\t\t\t\tnotAsync = expectSync( this, type );\n\t\t\t\t\tthis[ type ]();\n\t\t\t\t\tresult = dataPriv.get( this, type );\n\t\t\t\t\tif ( saved !== result || notAsync ) {\n\t\t\t\t\t\tdataPriv.set( this, type, false );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = {};\n\t\t\t\t\t}\n\t\t\t\t\tif ( saved !== result ) {\n\n\t\t\t\t\t\t// Cancel the outer synthetic event\n\t\t\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\treturn result.value;\n\t\t\t\t\t}\n\n\t\t\t\t// If this is an inner synthetic event for an event with a bubbling surrogate\n\t\t\t\t// (focus or blur), assume that the surrogate already propagated from triggering the\n\t\t\t\t// native event and prevent that from happening again here.\n\t\t\t\t// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the\n\t\t\t\t// bubbling surrogate propagates *after* the non-bubbling base), but that seems\n\t\t\t\t// less bad than duplication.\n\t\t\t\t} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t}\n\n\t\t\t// If this is a native event triggered above, everything is now in order\n\t\t\t// Fire an inner synthetic event with the original arguments\n\t\t\t} else if ( saved.length ) {\n\n\t\t\t\t// ...and capture the result\n\t\t\t\tdataPriv.set( this, type, {\n\t\t\t\t\tvalue: jQuery.event.trigger(\n\n\t\t\t\t\t\t// Support: IE <=9 - 11+\n\t\t\t\t\t\t// Extend with the prototype to reset the above stopImmediatePropagation()\n\t\t\t\t\t\tjQuery.extend( saved[ 0 ], jQuery.Event.prototype ),\n\t\t\t\t\t\tsaved.slice( 1 ),\n\t\t\t\t\t\tthis\n\t\t\t\t\t)\n\t\t\t\t} );\n\n\t\t\t\t// Abort handling of the native event\n\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t}\n\t\t}\n\t} );\n}\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This \"if\" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the 'new' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (#504, #13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || Date.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t\"char\": true,\n\tcode: true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\n\twhich: function( event ) {\n\t\tvar button = event.button;\n\n\t\t// Add which for key events\n\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t}\n\n\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\tif ( button & 1 ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ( button & 2 ) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tif ( button & 4 ) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn event.which;\n\t}\n}, jQuery.event.addProp );\n\njQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( type, delegateType ) {\n\tjQuery.event.special[ type ] = {\n\n\t\t// Utilize native event if possible so blur/focus sequence is correct\n\t\tsetup: function() {\n\n\t\t\t// Claim the first handler\n\t\t\t// dataPriv.set( this, \"focus\", ... )\n\t\t\t// dataPriv.set( this, \"blur\", ... )\n\t\t\tleverageNative( this, type, expectSync );\n\n\t\t\t// Return false to allow normal processing in the caller\n\t\t\treturn false;\n\t\t},\n\t\ttrigger: function() {\n\n\t\t\t// Force setup before trigger\n\t\t\tleverageNative( this, type );\n\n\t\t\t// Return non-false to allow normal event-path propagation\n\t\t\treturn true;\n\t\t},\n\n\t\tdelegateType: delegateType\n\t};\n} );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t/* eslint-disable max-len */\n\n\t// See https://github.com/eslint/eslint/issues/3229\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n\t/* eslint-enable */\n\n\t// Support: IE <=10 - 11, Edge 12 - 13 only\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n// Prefer a tbody over its parent table for containing new rows\nfunction manipulationTarget( elem, content ) {\n\tif ( nodeName( elem, \"table\" ) &&\n\t\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n\n\t\treturn jQuery( elem ).children( \"tbody\" )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tif ( ( elem.type || \"\" ).slice( 0, 5 ) === \"true/\" ) {\n\t\telem.type = elem.type.slice( 5 );\n\t} else {\n\t\telem.removeAttribute( \"type\" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.access( src );\n\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = concat.apply( [], args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tvalueIsFunction = isFunction( value );\n\n\t// We can't cloneNode fragments that contain checked, in WebKit\n\tif ( valueIsFunction ||\n\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src && ( node.type || \"\" ).toLowerCase()  !== \"module\" ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl && !node.noModule ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src, {\n\t\t\t\t\t\t\t\t\tnonce: node.nonce || node.getAttribute( \"nonce\" )\n\t\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), node, doc );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && isAttached( node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = isAttached( elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\nvar rboxStyle = new RegExp( cssExpand.join( \"|\" ), \"i\" );\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tcontainer.style.cssText = \"position:absolute;left:-11111px;width:60px;\" +\n\t\t\t\"margin-top:1px;padding:0;border:0\";\n\t\tdiv.style.cssText =\n\t\t\t\"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" +\n\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\"width:60%;top:1%\";\n\t\tdocumentElement.appendChild( container ).appendChild( div );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;\n\n\t\t// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\tdiv.style.right = \"60%\";\n\t\tpixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;\n\n\t\t// Support: IE 9 - 11 only\n\t\t// Detect misreporting of content dimensions for box-sizing:border-box elements\n\t\tboxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;\n\n\t\t// Support: IE 9 only\n\t\t// Detect overflow:scroll screwiness (gh-3699)\n\t\t// Support: Chrome <=64\n\t\t// Don't get tricked when zoom affects offsetWidth (gh-4029)\n\t\tdiv.style.position = \"absolute\";\n\t\tscrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tfunction roundPixelMeasures( measure ) {\n\t\treturn Math.round( parseFloat( measure ) );\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,\n\t\treliableMarginLeftVal,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tjQuery.extend( support, {\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelBoxStyles: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelBoxStylesVal;\n\t\t},\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t},\n\t\tscrollboxSize: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn scrollboxSizeVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\n\t\t// Support: Firefox 51+\n\t\t// Retrieving style before computed somehow\n\t\t// fixes an issue with getting wrong values\n\t\t// on detached elements\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// getPropertyValue is needed for:\n\t//   .css('filter') (IE 9 only, #12537)\n\t//   .css('--customProperty) (#3144)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( ret === \"\" && !isAttached( elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar cssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n\temptyStyle = document.createElement( \"div\" ).style,\n\tvendorProps = {};\n\n// Return a vendor-prefixed property or undefined\nfunction vendorPropName( name ) {\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\n// Return a potentially-mapped jQuery.cssProps or vendor prefixed property\nfunction finalPropName( name ) {\n\tvar final = jQuery.cssProps[ name ] || vendorProps[ name ];\n\n\tif ( final ) {\n\t\treturn final;\n\t}\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\treturn vendorProps[ name ] = vendorPropName( name ) || name;\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trcustomProp = /^--/,\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t};\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {\n\tvar i = dimension === \"width\" ? 1 : 0,\n\t\textra = 0,\n\t\tdelta = 0;\n\n\t// Adjustment may not be necessary\n\tif ( box === ( isBorderBox ? \"border\" : \"content\" ) ) {\n\t\treturn 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin\n\t\tif ( box === \"margin\" ) {\n\t\t\tdelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\t// If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n\t\tif ( !isBorderBox ) {\n\n\t\t\t// Add padding\n\t\t\tdelta += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// For \"border\" or \"margin\", add border\n\t\t\tif ( box !== \"padding\" ) {\n\t\t\t\tdelta += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\n\t\t\t// But still keep track of it otherwise\n\t\t\t} else {\n\t\t\t\textra += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\n\t\t// If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n\t\t// \"padding\" or \"margin\"\n\t\t} else {\n\n\t\t\t// For \"content\", subtract padding\n\t\t\tif ( box === \"content\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// For \"content\" or \"padding\", subtract border\n\t\t\tif ( box !== \"margin\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Account for positive content-box scroll gutter when requested by providing computedVal\n\tif ( !isBorderBox && computedVal >= 0 ) {\n\n\t\t// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n\t\t// Assuming integer scroll gutter, subtract the rest and round down\n\t\tdelta += Math.max( 0, Math.ceil(\n\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\tcomputedVal -\n\t\t\tdelta -\n\t\t\textra -\n\t\t\t0.5\n\n\t\t// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter\n\t\t// Use an explicit zero to avoid NaN (gh-3964)\n\t\t) ) || 0;\n\t}\n\n\treturn delta;\n}\n\nfunction getWidthOrHeight( elem, dimension, extra ) {\n\n\t// Start with computed style\n\tvar styles = getStyles( elem ),\n\n\t\t// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).\n\t\t// Fake content-box until we know it's needed to know the true value.\n\t\tboxSizingNeeded = !support.boxSizingReliable() || extra,\n\t\tisBorderBox = boxSizingNeeded &&\n\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\tvalueIsBorderBox = isBorderBox,\n\n\t\tval = curCSS( elem, dimension, styles ),\n\t\toffsetProp = \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );\n\n\t// Support: Firefox <=54\n\t// Return a confounding non-pixel value or feign ignorance, as appropriate.\n\tif ( rnumnonpx.test( val ) ) {\n\t\tif ( !extra ) {\n\t\t\treturn val;\n\t\t}\n\t\tval = \"auto\";\n\t}\n\n\n\t// Fall back to offsetWidth/offsetHeight when value is \"auto\"\n\t// This happens for inline elements with no explicit setting (gh-3571)\n\t// Support: Android <=4.1 - 4.3 only\n\t// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n\t// Support: IE 9-11 only\n\t// Also use offsetWidth/offsetHeight for when box sizing is unreliable\n\t// We use getClientRects() to check for hidden/disconnected.\n\t// In those cases, the computed value can be trusted to be border-box\n\tif ( ( !support.boxSizingReliable() && isBorderBox ||\n\t\tval === \"auto\" ||\n\t\t!parseFloat( val ) && jQuery.css( elem, \"display\", false, styles ) === \"inline\" ) &&\n\t\telem.getClientRects().length ) {\n\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t\t// Where available, offsetWidth/offsetHeight approximate border box dimensions.\n\t\t// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the\n\t\t// retrieved value as a content box dimension.\n\t\tvalueIsBorderBox = offsetProp in elem;\n\t\tif ( valueIsBorderBox ) {\n\t\t\tval = elem[ offsetProp ];\n\t\t}\n\t}\n\n\t// Normalize \"\" and auto\n\tval = parseFloat( val ) || 0;\n\n\t// Adjust for the element's box model\n\treturn ( val +\n\t\tboxModelAdjustment(\n\t\t\telem,\n\t\t\tdimension,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles,\n\n\t\t\t// Provide the current computed size to request scroll gutter calculation (gh-3589)\n\t\t\tval\n\t\t)\n\t) + \"px\";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"animationIterationCount\": true,\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"gridArea\": true,\n\t\t\"gridColumn\": true,\n\t\t\"gridColumnEnd\": true,\n\t\t\"gridColumnStart\": true,\n\t\t\"gridRow\": true,\n\t\t\"gridRowEnd\": true,\n\t\t\"gridRowStart\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name ),\n\t\t\tstyle = elem.style;\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to query the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\t// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append\n\t\t\t// \"px\" to a few hardcoded values.\n\t\t\tif ( type === \"number\" && !isCustomProp ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tif ( isCustomProp ) {\n\t\t\t\t\tstyle.setProperty( name, value );\n\t\t\t\t} else {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name );\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to modify the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ \"height\", \"width\" ], function( i, dimension ) {\n\tjQuery.cssHooks[ dimension ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, dimension, extra );\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, dimension, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = getStyles( elem ),\n\n\t\t\t\t// Only read styles.position if the test has a chance to fail\n\t\t\t\t// to avoid forcing a reflow.\n\t\t\t\tscrollboxSizeBuggy = !support.scrollboxSize() &&\n\t\t\t\t\tstyles.position === \"absolute\",\n\n\t\t\t\t// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)\n\t\t\t\tboxSizingNeeded = scrollboxSizeBuggy || extra,\n\t\t\t\tisBorderBox = boxSizingNeeded &&\n\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\tsubtract = extra ?\n\t\t\t\t\tboxModelAdjustment(\n\t\t\t\t\t\telem,\n\t\t\t\t\t\tdimension,\n\t\t\t\t\t\textra,\n\t\t\t\t\t\tisBorderBox,\n\t\t\t\t\t\tstyles\n\t\t\t\t\t) :\n\t\t\t\t\t0;\n\n\t\t\t// Account for unreliable border-box dimensions by comparing offset* to computed and\n\t\t\t// faking a content-box to get border and padding (gh-3699)\n\t\t\tif ( isBorderBox && scrollboxSizeBuggy ) {\n\t\t\t\tsubtract -= Math.ceil(\n\t\t\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\t\t\tparseFloat( styles[ dimension ] ) -\n\t\t\t\t\tboxModelAdjustment( elem, dimension, \"border\", false, styles ) -\n\t\t\t\t\t0.5\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\n\t\t\t\telem.style[ dimension ] = value;\n\t\t\t\tvalue = jQuery.css( elem, dimension );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t\t) + \"px\";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( prefix !== \"margin\" ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 && (\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ||\n\t\t\t\t\ttween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: \"swing\"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, inProgress,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction schedule() {\n\tif ( inProgress ) {\n\t\tif ( document.hidden === false && window.requestAnimationFrame ) {\n\t\t\twindow.requestAnimationFrame( schedule );\n\t\t} else {\n\t\t\twindow.setTimeout( schedule, jQuery.fx.interval );\n\t\t}\n\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = Date.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = \"width\" in props || \"height\" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict \"overflow\" and \"display\" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 15\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY and Edge just mirrors\n\t\t// the overflowX value there.\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\tif ( display === \"none\" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( Array.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\t// If there's more to do, yield\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t}\n\n\t\t\t// If this was an empty animation, synthesize a final progress notification\n\t\t\tif ( !length ) {\n\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t}\n\n\t\t\t// Resolve the animation and report its conclusion\n\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\treturn false;\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tresult.stop.bind( result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\t// Attach callbacks from options\n\tanimation\n\t\t.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\treturn animation;\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tisFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off\n\tif ( jQuery.fx.off ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== \"number\" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( \"show\" ),\n\tslideUp: genFx( \"hide\" ),\n\tslideToggle: genFx( \"toggle\" ),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = Date.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Run the timer and safely remove it when done (allowing for external removal)\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tjQuery.fx.start();\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( inProgress ) {\n\t\treturn;\n\t}\n\n\tinProgress = true;\n\tschedule();\n};\n\njQuery.fx.stop = function() {\n\tinProgress = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tnodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule \"no-unused-expressions\" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( \" \" );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n}\n\nfunction classesToArray( value ) {\n\tif ( Array.isArray( value ) ) {\n\t\treturn value;\n\t}\n\tif ( typeof value === \"string\" ) {\n\t\treturn value.match( rnothtmlwhite ) || [];\n\t}\n\treturn [];\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( \"class\", \"\" );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value,\n\t\t\tisValidValue = type === \"string\" || Array.isArray( value );\n\n\t\tif ( typeof stateVal === \"boolean\" && isValidValue ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( isValidValue ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = classesToArray( value );\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = \" \" + selector + \" \";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, valueIsFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === \"string\" ) {\n\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalueIsFunction = isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( Array.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( Array.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nsupport.focusin = \"onfocusin\" in window;\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\tstopPropagationCallback = function( e ) {\n\t\te.stopPropagation();\n\t};\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special, lastElement,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\n\t\tcur = lastElement = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( \".\" );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( \".\" );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tlastElement = cur;\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.addEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\telem[ type ]();\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.removeEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\n// Support: Firefox <=44\n// Firefox doesn't have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = Date.now();\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( Array.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && toType( obj ) === \"object\" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n\t\t};\n\n\tif ( a == null ) {\n\t\treturn \"\";\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} )\n\t\t.filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} )\n\t\t.map( function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( Array.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( \"a\" );\n\toriginAnchor.href = location.href;\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() + \" \" ] =\n\t\t\t\t\t\t\t\t\t( responseHeaders[ match[ 1 ].toLowerCase() + \" \" ] || [] )\n\t\t\t\t\t\t\t\t\t\t.concat( match[ 2 ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() + \" \" ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match.join( \", \" );\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( \"a\" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 15\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, \"\" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available and should be processed, append data to url\n\t\t\tif ( s.data && ( s.processData || typeof s.data === \"string\" ) ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce++ ) + uncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n} );\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\n\njQuery._evalUrl = function( url, options ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\n\t\t// Only evaluate the response if it is successful (gh-4126)\n\t\t// dataFilter is not invoked for failure responses, so using it instead\n\t\t// of the default converter is kludgy but it works.\n\t\tconverters: {\n\t\t\t\"text script\": function() {}\n\t\t},\n\t\tdataFilter: function( response ) {\n\t\t\tjQuery.globalEval( response, options );\n\t\t}\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar htmlIsFunction = isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.ontimeout =\n\t\t\t\t\t\t\t\t\txhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = xhr.ontimeout = callback( \"error\" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( \"abort\" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\n\t// This transport only deals with cross domain or forced-by-attrs requests\n\tif ( s.crossDomain || s.scriptAttrs ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( \"<script>\" )\n\t\t\t\t\t.attr( s.scriptAttrs || {} )\n\t\t\t\t\t.prop( { charset: s.scriptCharset, src: s.url } )\n\t\t\t\t\t.on( \"load error\", callback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ \"script json\" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn't exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n\tbody.innerHTML = \"<form></form><form></form>\";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument \"data\" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== \"string\" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document's URL (gh-2965)\n\t\t\tbase = context.createElement( \"base\" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( \" \" );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || \"GET\",\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [\n\t\"ajaxStart\",\n\t\"ajaxStop\",\n\t\"ajaxComplete\",\n\t\"ajaxError\",\n\t\"ajaxSuccess\",\n\t\"ajaxSend\"\n], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\n\t// offset() relates an element's border box to the document origin\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar rect, win,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\t// Get document-relative position by adding viewport scroll to viewport-relative gBCR\n\t\trect = elem.getBoundingClientRect();\n\t\twin = elem.ownerDocument.defaultView;\n\t\treturn {\n\t\t\ttop: rect.top + win.pageYOffset,\n\t\t\tleft: rect.left + win.pageXOffset\n\t\t};\n\t},\n\n\t// position() relates an element's margin box to its offset parent's padding box\n\t// This corresponds to the behavior of CSS absolute positioning\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset, doc,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// position:fixed elements are offset from the viewport, which itself always has zero offset\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\n\t\t\t// Assume position:fixed implies availability of getBoundingClientRect\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\toffset = this.offset();\n\n\t\t\t// Account for the *real* offset parent, which can be the document or its root element\n\t\t\t// when a statically positioned element is identified\n\t\t\tdoc = elem.ownerDocument;\n\t\t\toffsetParent = elem.offsetParent || doc.documentElement;\n\t\t\twhile ( offsetParent &&\n\t\t\t\t( offsetParent === doc.body || offsetParent === doc.documentElement ) &&\n\t\t\t\tjQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\n\t\t\t\toffsetParent = offsetParent.parentNode;\n\t\t\t}\n\t\t\tif ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {\n\n\t\t\t\t// Incorporate borders into its offset, since they are outside its content origin\n\t\t\t\tparentOffset = jQuery( offsetParent ).offset();\n\t\t\t\tparentOffset.top += jQuery.css( offsetParent, \"borderTopWidth\", true );\n\t\t\t\tparentOffset.left += jQuery.css( offsetParent, \"borderLeftWidth\", true );\n\t\t\t}\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\n\t\t\t// Coalesce documents and windows\n\t\t\tvar win;\n\t\t\tif ( isWindow( elem ) ) {\n\t\t\t\twin = elem;\n\t\t\t} else if ( elem.nodeType === 9 ) {\n\t\t\t\twin = elem.defaultView;\n\t\t\t}\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n\t\tfunction( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n\t\t\t\t\t\telem[ \"inner\" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n\tfunction( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n} );\n\njQuery.fn.extend( {\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\n\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, \"**\" ) :\n\t\t\tthis.off( types, selector || \"**\", fn );\n\t}\n} );\n\n// Bind a function to a context, optionally partially applying any\n// arguments.\n// jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n// However, it is not slated for removal any time soon\njQuery.proxy = function( fn, context ) {\n\tvar tmp, args, proxy;\n\n\tif ( typeof context === \"string\" ) {\n\t\ttmp = fn[ context ];\n\t\tcontext = fn;\n\t\tfn = tmp;\n\t}\n\n\t// Quick check to determine if target is callable, in the spec\n\t// this throws a TypeError, but we will just return undefined.\n\tif ( !isFunction( fn ) ) {\n\t\treturn undefined;\n\t}\n\n\t// Simulated bind\n\targs = slice.call( arguments, 2 );\n\tproxy = function() {\n\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t};\n\n\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\treturn proxy;\n};\n\njQuery.holdReady = function( hold ) {\n\tif ( hold ) {\n\t\tjQuery.readyWait++;\n\t} else {\n\t\tjQuery.ready( true );\n\t}\n};\njQuery.isArray = Array.isArray;\njQuery.parseJSON = JSON.parse;\njQuery.nodeName = nodeName;\njQuery.isFunction = isFunction;\njQuery.isWindow = isWindow;\njQuery.camelCase = camelCase;\njQuery.type = toType;\n\njQuery.now = Date.now;\n\njQuery.isNumeric = function( obj ) {\n\n\t// As of jQuery 3.0, isNumeric is limited to\n\t// strings and numbers (primitives or objects)\n\t// that can be coerced to finite numbers (gh-2662)\n\tvar type = jQuery.type( obj );\n\treturn ( type === \"number\" || type === \"string\" ) &&\n\n\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\t!isNaN( obj - parseFloat( obj ) );\n};\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( true ) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\treturn jQuery;\n\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( !noGlobal ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n} );\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzPzExNTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNLEtBQTBCOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFlBQVk7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixvQkFBb0I7O0FBRXBCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxrQkFBa0Isa0NBQWtDO0FBQ3BELEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixJQUFJOztBQUVwQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRLDZCQUE2QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWEsdUJBQXVCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGVBQWU7O0FBRWYsU0FBUzs7QUFFVDtBQUNBLFFBQVEsaUNBQWlDO0FBQ3pDLFFBQVEsb0JBQW9CO0FBQzVCLFFBQVEsc0NBQXNDO0FBQzlDLFFBQVE7QUFDUixFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYSxFQUFFO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpREFBaUQ7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsVUFBVSx3Q0FBd0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQSxDQUFDOzs7O0FBSUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsUUFBUSxHQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUEsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsMEJBQTBCLHdCQUF3Qjs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsMENBQTBDO0FBQzFDLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDLHNDQUFzQztBQUM5RSxvQ0FBb0MsdUNBQXVDO0FBQzNFLG9DQUFvQyxzQ0FBc0M7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQyxxQ0FBcUM7QUFDckMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsYUFBYTtBQUNwQyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOzs7QUFHQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnQkFBZ0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxjQUFjOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQXVEO0FBQzlFOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLCtDQUErQztBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsY0FBYyxxQ0FBcUM7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLCtCQUErQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLHFDQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLFNBQVMsOEJBQThCO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFdBQVc7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxjQUFjLFdBQVc7QUFDeEUsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQSxzQkFBc0IsY0FBYyxzQkFBc0IsZ0JBQWdCO0FBQzFFLGdCQUFnQixXQUFXLFlBQVk7QUFDdkMsY0FBYztBQUNkOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBK0Q7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlEQUFpRCwwQkFBMEI7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUEsSUFBSTtBQUNKOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFLO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQ0FBcUM7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7QUFDTDs7QUFFQSxXQUFXO0FBQ1gsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBLHNCQUFzQjtBQUN0QiwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLGFBQWEsdUNBQXVDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQSxjQUFjLHNEQUFzRDtBQUNwRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBLGNBQWMsbUNBQW1DO0FBQ2pELGVBQWUsNkRBQTZEO0FBQzVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLLElBQTBDO0FBQy9DLENBQUMsaUNBQWtCLEVBQUUsbUNBQUU7QUFDdkI7QUFDQSxFQUFFO0FBQUEsb0dBQUU7QUFDSjs7Ozs7QUFLQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuNC4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxOS0wNS0wMVQyMTowNFpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIGZuVG9TdHJpbmcgPSBoYXNPd24udG9TdHJpbmc7XG5cbnZhciBPYmplY3RGdW5jdGlvblN0cmluZyA9IGZuVG9TdHJpbmcuY2FsbCggT2JqZWN0ICk7XG5cbnZhciBzdXBwb3J0ID0ge307XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbiggb2JqICkge1xuXG4gICAgICAvLyBTdXBwb3J0OiBDaHJvbWUgPD01NywgRmlyZWZveCA8PTUyXG4gICAgICAvLyBJbiBzb21lIGJyb3dzZXJzLCB0eXBlb2YgcmV0dXJucyBcImZ1bmN0aW9uXCIgZm9yIEhUTUwgPG9iamVjdD4gZWxlbWVudHNcbiAgICAgIC8vIChpLmUuLCBgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib2JqZWN0XCIgKSA9PT0gXCJmdW5jdGlvblwiYCkuXG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGNsYXNzaWZ5ICphbnkqIERPTSBub2RlIGFzIGEgZnVuY3Rpb24uXG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBvYmoubm9kZVR5cGUgIT09IFwibnVtYmVyXCI7XG4gIH07XG5cblxudmFyIGlzV2luZG93ID0gZnVuY3Rpb24gaXNXaW5kb3coIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9O1xuXG5cblxuXG5cdHZhciBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzID0ge1xuXHRcdHR5cGU6IHRydWUsXG5cdFx0c3JjOiB0cnVlLFxuXHRcdG5vbmNlOiB0cnVlLFxuXHRcdG5vTW9kdWxlOiB0cnVlXG5cdH07XG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgbm9kZSwgZG9jICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBpLCB2YWwsXG5cdFx0XHRzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGlmICggbm9kZSApIHtcblx0XHRcdGZvciAoIGkgaW4gcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDY0KywgRWRnZSAxOCtcblx0XHRcdFx0Ly8gU29tZSBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBcIm5vbmNlXCIgcHJvcGVydHkgb24gc2NyaXB0cy5cblx0XHRcdFx0Ly8gT24gdGhlIG90aGVyIGhhbmQsIGp1c3QgdXNpbmcgYGdldEF0dHJpYnV0ZWAgaXMgbm90IGVub3VnaCBhc1xuXHRcdFx0XHQvLyB0aGUgYG5vbmNlYCBhdHRyaWJ1dGUgaXMgcmVzZXQgdG8gYW4gZW1wdHkgc3RyaW5nIHdoZW5ldmVyIGl0XG5cdFx0XHRcdC8vIGJlY29tZXMgYnJvd3NpbmctY29udGV4dCBjb25uZWN0ZWQuXG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2h0bWwvaXNzdWVzLzIzNjlcblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI25vbmNlLWF0dHJpYnV0ZXNcblx0XHRcdFx0Ly8gVGhlIGBub2RlLmdldEF0dHJpYnV0ZWAgY2hlY2sgd2FzIGFkZGVkIGZvciB0aGUgc2FrZSBvZlxuXHRcdFx0XHQvLyBgalF1ZXJ5Lmdsb2JhbEV2YWxgIHNvIHRoYXQgaXQgY2FuIGZha2UgYSBub25jZS1jb250YWluaW5nIG5vZGVcblx0XHRcdFx0Ly8gdmlhIGFuIG9iamVjdC5cblx0XHRcdFx0dmFsID0gbm9kZVsgaSBdIHx8IG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCBpICk7XG5cdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoIGksIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIHRvVHlwZSggb2JqICkge1xuXHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHR0eXBlb2Ygb2JqO1xufVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMy40LjFcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxuXHRydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFRoZSBkZWZhdWx0IGxlbmd0aCBvZiBhIGpRdWVyeSBvYmplY3QgaXMgMFxuXHRsZW5ndGg6IDAsXG5cblx0dG9BcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXG5cdC8vIEdldCB0aGUgd2hvbGUgbWF0Y2hlZCBlbGVtZW50IHNldCBhcyBhIGNsZWFuIGFycmF5XG5cdGdldDogZnVuY3Rpb24oIG51bSApIHtcblxuXHRcdC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY2xlYW4gYXJyYXlcblx0XHRpZiAoIG51bSA9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4ganVzdCB0aGUgb25lIGVsZW1lbnQgZnJvbSB0aGUgc2V0XG5cdFx0cmV0dXJuIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF07XG5cdH0sXG5cblx0Ly8gVGFrZSBhbiBhcnJheSBvZiBlbGVtZW50cyBhbmQgcHVzaCBpdCBvbnRvIHRoZSBzdGFja1xuXHQvLyAocmV0dXJuaW5nIHRoZSBuZXcgbWF0Y2hlZCBlbGVtZW50IHNldClcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cblx0XHQvLyBCdWlsZCBhIG5ldyBqUXVlcnkgbWF0Y2hlZCBlbGVtZW50IHNldFxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcblxuXHRcdC8vIEFkZCB0aGUgb2xkIG9iamVjdCBvbnRvIHRoZSBzdGFjayAoYXMgYSByZWZlcmVuY2UpXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xuXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdC8vIEV4ZWN1dGUgYSBjYWxsYmFjayBmb3IgZXZlcnkgZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBzZXQuXG5cdGVhY2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrICk7XG5cdH0sXG5cblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkubWFwKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XG5cdFx0fSApICk7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggc2xpY2UuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICk7XG5cdH0sXG5cblx0Zmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAwICk7XG5cdH0sXG5cblx0bGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XG5cdH0sXG5cblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xuXHRcdHZhciBsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdGogPSAraSArICggaSA8IDAgPyBsZW4gOiAwICk7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1sgaiBdIF0gOiBbXSApO1xuXHR9LFxuXG5cdGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKCk7XG5cdH0sXG5cblx0Ly8gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cblx0cHVzaDogcHVzaCxcblx0c29ydDogYXJyLnNvcnQsXG5cdHNwbGljZTogYXJyLnNwbGljZVxufTtcblxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgMCBdIHx8IHt9LFxuXHRcdGkgPSAxLFxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0ZGVlcCA9IGZhbHNlO1xuXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cblx0aWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRkZWVwID0gdGFyZ2V0O1xuXG5cdFx0Ly8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuXHRcdHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuXHRcdGkrKztcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24oIHRhcmdldCApICkge1xuXHRcdHRhcmdldCA9IHt9O1xuXHR9XG5cblx0Ly8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG5cdGlmICggaSA9PT0gbGVuZ3RoICkge1xuXHRcdHRhcmdldCA9IHRoaXM7XG5cdFx0aS0tO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAoIG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSApICE9IG51bGwgKSB7XG5cblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3Rcblx0XHRcdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IE9iamVjdC5wcm90b3R5cGUgcG9sbHV0aW9uXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3Bcblx0XHRcdFx0aWYgKCBuYW1lID09PSBcIl9fcHJvdG9fX1wiIHx8IHRhcmdldCA9PT0gY29weSApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuXHRcdFx0XHRpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb3B5ICkgfHxcblx0XHRcdFx0XHQoIGNvcHlJc0FycmF5ID0gQXJyYXkuaXNBcnJheSggY29weSApICkgKSApIHtcblx0XHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblxuXHRcdFx0XHRcdC8vIEVuc3VyZSBwcm9wZXIgdHlwZSBmb3IgdGhlIHNvdXJjZSB2YWx1ZVxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgJiYgIUFycmF5LmlzQXJyYXkoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBbXTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhY29weUlzQXJyYXkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0ge307XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgcHJvdG8sIEN0b3I7XG5cblx0XHQvLyBEZXRlY3Qgb2J2aW91cyBuZWdhdGl2ZXNcblx0XHQvLyBVc2UgdG9TdHJpbmcgaW5zdGVhZCBvZiBqUXVlcnkudHlwZSB0byBjYXRjaCBob3N0IG9iamVjdHNcblx0XHRpZiAoICFvYmogfHwgdG9TdHJpbmcuY2FsbCggb2JqICkgIT09IFwiW29iamVjdCBPYmplY3RdXCIgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cHJvdG8gPSBnZXRQcm90byggb2JqICk7XG5cblx0XHQvLyBPYmplY3RzIHdpdGggbm8gcHJvdG90eXBlIChlLmcuLCBgT2JqZWN0LmNyZWF0ZSggbnVsbCApYCkgYXJlIHBsYWluXG5cdFx0aWYgKCAhcHJvdG8gKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBPYmplY3RzIHdpdGggcHJvdG90eXBlIGFyZSBwbGFpbiBpZmYgdGhleSB3ZXJlIGNvbnN0cnVjdGVkIGJ5IGEgZ2xvYmFsIE9iamVjdCBmdW5jdGlvblxuXHRcdEN0b3IgPSBoYXNPd24uY2FsbCggcHJvdG8sIFwiY29uc3RydWN0b3JcIiApICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gXCJmdW5jdGlvblwiICYmIGZuVG9TdHJpbmcuY2FsbCggQ3RvciApID09PSBPYmplY3RGdW5jdGlvblN0cmluZztcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdC8vIEV2YWx1YXRlcyBhIHNjcmlwdCBpbiBhIGdsb2JhbCBjb250ZXh0XG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlLCBvcHRpb25zICkge1xuXHRcdERPTUV2YWwoIGNvZGUsIHsgbm9uY2U6IG9wdGlvbnMgJiYgb3B0aW9ucy5ub25jZSB9ICk7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGxlbmd0aCwgaSA9IDA7XG5cblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBvYmogKSApIHtcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iajtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcblx0dHJpbTogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XHRcIlwiIDpcblx0XHRcdCggdGV4dCArIFwiXCIgKS5yZXBsYWNlKCBydHJpbSwgXCJcIiApO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gY29uY2F0LmFwcGx5KCBbXSwgcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSB0b1R5cGUoIG9iaiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggb2JqICkgfHwgaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjRcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcy5mb3VuZGF0aW9uL1xuICpcbiAqIERhdGU6IDIwMTktMDQtMDhcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbaV0gPT09IGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXG5cblx0Ly8gUmVndWxhciBleHByZXNzaW9uc1xuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXG5cdHdoaXRlc3BhY2UgPSBcIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI3ZhbHVlLWRlZi1pZGVudGlmaWVyXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJkZXNjZW5kID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwifD5cIiApLFxuXG5cdHJwc2V1ZG8gPSBuZXcgUmVnRXhwKCBwc2V1ZG9zICksXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcblxuXHRtYXRjaEV4cHIgPSB7XG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGlkZW50aWZpZXIgKyBcInxbKl0pXCIgKSxcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXG5cdFx0XCJQU0VVRE9cIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBwc2V1ZG9zICksXG5cdFx0XCJDSElMRFwiOiBuZXcgUmVnRXhwKCBcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooXFxcXGQrKXwpKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfClcIiwgXCJpXCIgKSxcblx0XHRcImJvb2xcIjogbmV3IFJlZ0V4cCggXCJeKD86XCIgKyBib29sZWFucyArIFwiKSRcIiwgXCJpXCIgKSxcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqWz4rfl18OihldmVufG9kZHxlcXxndHxsdHxudGh8Zmlyc3R8bGFzdCkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxuXHR9LFxuXG5cdHJodG1sID0gL0hUTUwkL2ksXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyaGVhZGVyID0gL15oXFxkJC9pLFxuXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxuXG5cdC8vIEVhc2lseS1wYXJzZWFibGUvcmV0cmlldmFibGUgSUQgb3IgVEFHIG9yIENMQVNTIHNlbGVjdG9yc1xuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXG5cblx0cnNpYmxpbmcgPSAvWyt+XS8sXG5cblx0Ly8gQ1NTIGVzY2FwZXNcblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMjEvc3luZGF0YS5odG1sI2VzY2FwZWQtY2hhcmFjdGVyc1xuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggXywgZXNjYXBlZCwgZXNjYXBlZFdoaXRlc3BhY2UgKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGVkIC0gMHgxMDAwMDtcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjRcblx0XHQvLyBXb3JrYXJvdW5kIGVycm9uZW91cyBudW1lcmljIGludGVycHJldGF0aW9uIG9mICtcIjB4XCJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XG5cdFx0XHRlc2NhcGVkIDpcblx0XHRcdGhpZ2ggPCAwID9cblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0Ly8gU3VwcGxlbWVudGFsIFBsYW5lIGNvZGVwb2ludCAoc3Vycm9nYXRlIHBhaXIpXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xuXHR9LFxuXG5cdC8vIENTUyBzdHJpbmcvaWRlbnRpZmllciBzZXJpYWxpemF0aW9uXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jY29tbW9uLXNlcmlhbGl6aW5nLWlkaW9tc1xuXHRyY3NzZXNjYXBlID0gLyhbXFwwLVxceDFmXFx4N2ZdfF4tP1xcZCl8Xi0kfFteXFwwLVxceDFmXFx4N2YtXFx1RkZGRlxcdy1dL2csXG5cdGZjc3Nlc2NhcGUgPSBmdW5jdGlvbiggY2gsIGFzQ29kZVBvaW50ICkge1xuXHRcdGlmICggYXNDb2RlUG9pbnQgKSB7XG5cblx0XHRcdC8vIFUrMDAwMCBOVUxMIGJlY29tZXMgVStGRkZEIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0aWYgKCBjaCA9PT0gXCJcXDBcIiApIHtcblx0XHRcdFx0cmV0dXJuIFwiXFx1RkZGRFwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb250cm9sIGNoYXJhY3RlcnMgYW5kIChkZXBlbmRlbnQgdXBvbiBwb3NpdGlvbikgbnVtYmVycyBnZXQgZXNjYXBlZCBhcyBjb2RlIHBvaW50c1xuXHRcdFx0cmV0dXJuIGNoLnNsaWNlKCAwLCAtMSApICsgXCJcXFxcXCIgKyBjaC5jaGFyQ29kZUF0KCBjaC5sZW5ndGggLSAxICkudG9TdHJpbmcoIDE2ICkgKyBcIiBcIjtcblx0XHR9XG5cblx0XHQvLyBPdGhlciBwb3RlbnRpYWxseS1zcGVjaWFsIEFTQ0lJIGNoYXJhY3RlcnMgZ2V0IGJhY2tzbGFzaC1lc2NhcGVkXG5cdFx0cmV0dXJuIFwiXFxcXFwiICsgY2g7XG5cdH0sXG5cblx0Ly8gVXNlZCBmb3IgaWZyYW1lc1xuXHQvLyBTZWUgc2V0RG9jdW1lbnQoKVxuXHQvLyBSZW1vdmluZyB0aGUgZnVuY3Rpb24gd3JhcHBlciBjYXVzZXMgYSBcIlBlcm1pc3Npb24gRGVuaWVkXCJcblx0Ly8gZXJyb3IgaW4gSUVcblx0dW5sb2FkSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuXHRcdHNldERvY3VtZW50KCk7XG5cdH0sXG5cblx0aW5EaXNhYmxlZEZpZWxkc2V0ID0gYWRkQ29tYmluYXRvcihcblx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJmaWVsZHNldFwiO1xuXHRcdH0sXG5cdFx0eyBkaXI6IFwicGFyZW50Tm9kZVwiLCBuZXh0OiBcImxlZ2VuZFwiIH1cblx0KTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBtYXRjaCwgZ3JvdXBzLCBuZXdTZWxlY3Rvcixcblx0XHRuZXdDb250ZXh0ID0gY29udGV4dCAmJiBjb250ZXh0Lm93bmVyRG9jdW1lbnQsXG5cblx0XHQvLyBub2RlVHlwZSBkZWZhdWx0cyB0byA5LCBzaW5jZSBjb250ZXh0IGRlZmF1bHRzIHRvIGRvY3VtZW50XG5cdFx0bm9kZVR5cGUgPSBjb250ZXh0ID8gY29udGV4dC5ub2RlVHlwZSA6IDk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGZyb20gY2FsbHMgd2l0aCBpbnZhbGlkIHNlbGVjdG9yIG9yIGNvbnRleHRcblx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgfHwgIXNlbGVjdG9yIHx8XG5cdFx0bm9kZVR5cGUgIT09IDEgJiYgbm9kZVR5cGUgIT09IDkgJiYgbm9kZVR5cGUgIT09IDExICkge1xuXG5cdFx0cmV0dXJuIHJlc3VsdHM7XG5cdH1cblxuXHQvLyBUcnkgdG8gc2hvcnRjdXQgZmluZCBvcGVyYXRpb25zIChhcyBvcHBvc2VkIHRvIGZpbHRlcnMpIGluIEhUTUwgZG9jdW1lbnRzXG5cdGlmICggIXNlZWQgKSB7XG5cblx0XHRpZiAoICggY29udGV4dCA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogcHJlZmVycmVkRG9jICkgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0XHR9XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoIChtID0gbWF0Y2hbMV0pICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcblx0XHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJlxuXHRcdFx0XHRcdFx0XHRlbGVtLmlkID09PSBtICkge1xuXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKG0gPSBtYXRjaFszXSkgJiYgc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmXG5cdFx0XHRcdFx0Y29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICkge1xuXG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUYWtlIGFkdmFudGFnZSBvZiBxdWVyeVNlbGVjdG9yQWxsXG5cdFx0XHRpZiAoIHN1cHBvcnQucXNhICYmXG5cdFx0XHRcdCFub25uYXRpdmVTZWxlY3RvckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF0gJiZcblx0XHRcdFx0KCFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApKSAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDggb25seVxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHQobm9kZVR5cGUgIT09IDEgfHwgY29udGV4dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm9iamVjdFwiKSApIHtcblxuXHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblxuXHRcdFx0XHQvLyBxU0EgY29uc2lkZXJzIGVsZW1lbnRzIG91dHNpZGUgYSBzY29waW5nIHJvb3Qgd2hlbiBldmFsdWF0aW5nIGNoaWxkIG9yXG5cdFx0XHRcdC8vIGRlc2NlbmRhbnQgY29tYmluYXRvcnMsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnQuXG5cdFx0XHRcdC8vIEluIHN1Y2ggY2FzZXMsIHdlIHdvcmsgYXJvdW5kIHRoZSBiZWhhdmlvciBieSBwcmVmaXhpbmcgZXZlcnkgc2VsZWN0b3IgaW4gdGhlXG5cdFx0XHRcdC8vIGxpc3Qgd2l0aCBhbiBJRCBzZWxlY3RvciByZWZlcmVuY2luZyB0aGUgc2NvcGUgY29udGV4dC5cblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgdGVjaG5pcXVlLlxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSAxICYmIHJkZXNjZW5kLnRlc3QoIHNlbGVjdG9yICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdGlmICggKG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSkgKSB7XG5cdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAobmlkID0gZXhwYW5kbykgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1tpXSA9IFwiI1wiICsgbmlkICsgXCIgXCIgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIik7XG5cblx0dHJ5IHtcblx0XHRyZXR1cm4gISFmbiggZWwgKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xuXHRcdH1cblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxuXHRcdGVsID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoIChjdXIgPSBjdXIubmV4dFNpYmxpbmcpICkge1xuXHRcdFx0aWYgKCBjdXIgPT09IGIgKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYSA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgYnV0dG9uc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnV0dG9uUHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIChuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIikgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcblx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuXHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExXG5cdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRpbkRpc2FibGVkRmllbGRzZXQoIGVsZW0gKSA9PT0gZGlzYWJsZWQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblxuXHRcdC8vIFRyeSB0byB3aW5ub3cgb3V0IGVsZW1lbnRzIHRoYXQgY2FuJ3QgYmUgZGlzYWJsZWQgYmVmb3JlIHRydXN0aW5nIHRoZSBkaXNhYmxlZCBwcm9wZXJ0eS5cblx0XHQvLyBTb21lIHZpY3RpbXMgZ2V0IGNhdWdodCBpbiBvdXIgbmV0IChsYWJlbCwgbGVnZW5kLCBtZW51LCB0cmFjayksIGJ1dCBpdCBzaG91bGRuJ3Rcblx0XHQvLyBldmVuIGV4aXN0IG9uIHRoZW0sIGxldCBhbG9uZSBoYXZlIGEgYm9vbGVhbiB2YWx1ZS5cblx0XHR9IGVsc2UgaWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHR9XG5cblx0XHQvLyBSZW1haW5pbmcgZWxlbWVudHMgYXJlIG5laXRoZXIgOmVuYWJsZWQgbm9yIDpkaXNhYmxlZFxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbmFtZXNwYWNlID0gZWxlbS5uYW1lc3BhY2VVUkksXG5cdFx0ZG9jRWxlbSA9IChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSkuZG9jdW1lbnRFbGVtZW50O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OFxuXHQvLyBBc3N1bWUgSFRNTCB3aGVuIGRvY3VtZW50RWxlbWVudCBkb2Vzbid0IHlldCBleGlzdCwgc3VjaCBhcyBpbnNpZGUgbG9hZGluZyBpZnJhbWVzXG5cdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC80ODMzXG5cdHJldHVybiAhcmh0bWwudGVzdCggbmFtZXNwYWNlIHx8IGRvY0VsZW0gJiYgZG9jRWxlbS5ub2RlTmFtZSB8fCBcIkhUTUxcIiApO1xufTtcblxuLyoqXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IFtkb2NdIEFuIGVsZW1lbnQgb3IgZG9jdW1lbnQgb2JqZWN0IHRvIHVzZSB0byBzZXQgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKi9cbnNldERvY3VtZW50ID0gU2l6emxlLnNldERvY3VtZW50ID0gZnVuY3Rpb24oIG5vZGUgKSB7XG5cdHZhciBoYXNDb21wYXJlLCBzdWJXaW5kb3csXG5cdFx0ZG9jID0gbm9kZSA/IG5vZGUub3duZXJEb2N1bWVudCB8fCBub2RlIDogcHJlZmVycmVkRG9jO1xuXG5cdC8vIFJldHVybiBlYXJseSBpZiBkb2MgaXMgaW52YWxpZCBvciBhbHJlYWR5IHNlbGVjdGVkXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEsIEVkZ2Vcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHRpZiAoIHByZWZlcnJlZERvYyAhPT0gZG9jdW1lbnQgJiZcblx0XHQoc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHN1YldpbmRvdy50b3AgIT09IHN1YldpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDExLCBFZGdlXG5cdFx0aWYgKCBzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcInVubG9hZFwiLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDEwIG9ubHlcblx0XHR9IGVsc2UgaWYgKCBzdWJXaW5kb3cuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYXR0YWNoRXZlbnQoIFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlciApO1xuXHRcdH1cblx0fVxuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZWwuZ2V0QXR0cmlidXRlKFwiY2xhc3NOYW1lXCIpO1xuXHR9KTtcblxuXHQvKiBnZXRFbGVtZW50KHMpQnkqXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikgcmV0dXJucyBvbmx5IGVsZW1lbnRzXG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFlbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBTdXBwb3J0OiBJRTw5XG5cdHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDEwXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRCeUlkIHJldHVybnMgZWxlbWVudHMgYnkgbmFtZVxuXHQvLyBUaGUgYnJva2VuIGdldEVsZW1lbnRCeUlkIG1ldGhvZHMgZG9uJ3QgcGljayB1cCBwcm9ncmFtbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0pO1xuXG5cdC8vIElEIGZpbHRlciBhbmQgZmluZFxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA2IC0gNyBvbmx5XG5cdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgaXMgbm90IHJlbGlhYmxlIGFzIGEgZmluZCBzaG9ydGN1dFxuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG5vZGUsIGksIGVsZW1zLFxuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXG5cdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG5cdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcblx0XHRcdFx0XHRlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIGlkICk7XG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1zW2krK10pICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpO1xuXHRcdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kW1wiVEFHXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/XG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRG9jdW1lbnRGcmFnbWVudCBub2RlcyBkb24ndCBoYXZlIGdFQlROXG5cdFx0XHR9IGVsc2UgaWYgKCBzdXBwb3J0LnFzYSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnICk7XG5cdFx0XHR9XG5cdFx0fSA6XG5cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdG1wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0fTtcblxuXHQvLyBDbGFzc1xuXHRFeHByLmZpbmRbXCJDTEFTU1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwgKSkgKSB7XG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XG5cdFx0Ly8gUmVnZXggc3RyYXRlZ3kgYWRvcHRlZCBmcm9tIERpZWdvIFBlcmluaVxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbaWR+PVwiICsgZXhwYW5kbyArIFwiLV1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCJ+PVwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCI6Y2hlY2tlZFwiKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiLiMuK1srfl1cIik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG5cdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcImhpZGRlblwiICk7XG5cdFx0XHRlbC5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiW25hbWU9ZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6ZGlzYWJsZWRcIikubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKFwiLC4qOlwiKTtcblx0XHR9KTtcblx0fVxuXG5cdGlmICggKHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAobWF0Y2hlcyA9IGRvY0VsZW0ubWF0Y2hlcyB8fFxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm9NYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBlbCwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblx0XHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcblx0XHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIGV4cHIsIHRydWUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gU2l6emxlKCBleHByLCBkb2N1bWVudCwgbnVsbCwgWyBlbGVtIF0gKS5sZW5ndGggPiAwO1xufTtcblxuU2l6emxlLmNvbnRhaW5zID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW0gKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoc2VsICsgXCJcIikucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAobm9kZSA9IGVsZW1baSsrXSkgKSB7XG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblx0XHQvLyBVc2UgdGV4dENvbnRlbnQgZm9yIGVsZW1lbnRzXG5cdFx0Ly8gaW5uZXJUZXh0IHVzYWdlIHJlbW92ZWQgZm9yIGNvbnNpc3RlbmN5IG9mIG5ldyBsaW5lcyAoalF1ZXJ5ICMxMTE1Mylcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0udGV4dENvbnRlbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFszXSA9ICggbWF0Y2hbM10gfHwgbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbMl0gPT09IFwifj1cIiApIHtcblx0XHRcdFx0bWF0Y2hbM10gPSBcIiBcIiArIG1hdGNoWzNdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxuXHRcdFx0XHQxIHR5cGUgKG9ubHl8bnRofC4uLilcblx0XHRcdFx0MiB3aGF0IChjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxuXHRcdFx0XHQ0IHhuLWNvbXBvbmVudCBvZiB4bit5IGFyZ3VtZW50IChbKy1dP1xcZCpufClcblx0XHRcdFx0NSBzaWduIG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDcgc2lnbiBvZiB5LWNvbXBvbmVudFxuXHRcdFx0XHQ4IHkgb2YgeS1jb21wb25lbnRcblx0XHRcdCovXG5cdFx0XHRtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXG5cdFx0XHRcdC8vIHJlbWVtYmVyIHRoYXQgZmFsc2UvdHJ1ZSBjYXN0IHJlc3BlY3RpdmVseSB0byAwLzFcblx0XHRcdFx0bWF0Y2hbNF0gPSArKCBtYXRjaFs0XSA/IG1hdGNoWzVdICsgKG1hdGNoWzZdIHx8IDEpIDogMiAqICggbWF0Y2hbM10gPT09IFwiZXZlblwiIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICkgKTtcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XG5cblx0XHRcdGlmICggbWF0Y2hFeHByW1wiQ0hJTERcIl0udGVzdCggbWF0Y2hbMF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWzNdICkge1xuXHRcdFx0XHRtYXRjaFsyXSA9IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCI7XG5cblx0XHRcdC8vIFN0cmlwIGV4Y2VzcyBjaGFyYWN0ZXJzIGZyb20gdW5xdW90ZWQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCB1bnF1b3RlZCAmJiBycHNldWRvLnRlc3QoIHVucXVvdGVkICkgJiZcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KGV4Y2VzcyA9IHRva2VuaXplKCB1bnF1b3RlZCwgdHJ1ZSApKSAmJlxuXHRcdFx0XHQvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNsb3NpbmcgcGFyZW50aGVzaXNcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHRcdG1hdGNoWzJdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcblx0XHRcdFx0Y2xhc3NDYWNoZSggY2xhc3NOYW1lLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KCB0eXBlb2YgZWxlbS5jbGFzc05hbWUgPT09IFwic3RyaW5nXCIgJiYgZWxlbS5jbGFzc05hbWUgfHwgdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xuXHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiPVwiID8gcmVzdWx0ID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIl49XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA9PT0gMCA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiKj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIn49XCIgPyAoIFwiIFwiICsgcmVzdWx0LnJlcGxhY2UoIHJ3aGl0ZXNwYWNlLCBcIiBcIiApICsgXCIgXCIgKS5pbmRleE9mKCBjaGVjayApID4gLTEgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcInw9XCIgPyByZXN1bHQgPT09IGNoZWNrIHx8IHJlc3VsdC5zbGljZSggMCwgY2hlY2subGVuZ3RoICsgMSApID09PSBjaGVjayArIFwiLVwiIDpcblx0XHRcdFx0XHRmYWxzZTtcblx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIHR5cGUsIHdoYXQsIGFyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBSZXZlcnNlIGRpcmVjdGlvbiBmb3IgOm9ubHktKiAoaWYgd2UgaGF2ZW4ndCB5ZXQgZG9uZSBzbylcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGRpciA9IHR5cGUgPT09IFwib25seVwiICYmICFzdGFydCAmJiBcIm5leHRTaWJsaW5nXCI7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHN0YXJ0ID0gWyBmb3J3YXJkID8gcGFyZW50LmZpcnN0Q2hpbGQgOiBwYXJlbnQubGFzdENoaWxkIF07XG5cblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXG5cdFx0XHRcdFx0XHRpZiAoIGZvcndhcmQgJiYgdXNlQ2FjaGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU2VlayBgZWxlbWAgZnJvbSBhIHByZXZpb3VzbHktY2FjaGVkIGluZGV4XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRub2RlID0gcGFyZW50O1xuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgdGhlIG9mZnNldCwgdGhlbiBjaGVjayBhZ2FpbnN0IGN5Y2xlIHNpemVcblx0XHRcdFx0XHRcdGRpZmYgLT0gbGFzdDtcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIHBzZXVkbywgYXJndW1lbnQgKSB7XG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWR4LFxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXG5cdFx0XHRcdFx0XHRcdGkgPSBtYXRjaGVkLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mKCBzZWVkLCBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkW2ldICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcblx0XHRcdFx0XHRcdGkgPSBzZWVkLmxlbmd0aDtcblxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WzBdID0gbnVsbDtcblx0XHRcdFx0XHRyZXR1cm4gIXJlc3VsdHMucG9wKCk7XG5cdFx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJjb250YWluc1wiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBsYW5nOiBcIiArIGxhbmcgKTtcblx0XHRcdH1cblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIGVsZW1MYW5nO1xuXHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xuXG5cdFx0XHRcdFx0XHRlbGVtTGFuZyA9IGVsZW1MYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICggKGVsZW0gPSBlbGVtLnBhcmVudE5vZGUpICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdC8vIE1pc2NlbGxhbmVvdXNcblx0XHRcInRhcmdldFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXHRcdFx0cmV0dXJuIGhhc2ggJiYgaGFzaC5zbGljZSggMSApID09PSBlbGVtLmlkO1xuXHRcdH0sXG5cblx0XHRcInJvb3RcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jRWxlbTtcblx0XHR9LFxuXG5cdFx0XCJmb2N1c1wiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBJbiBDU1MzLCA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIGJvdGggY2hlY2tlZCBhbmQgc2VsZWN0ZWQgZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gKG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQpIHx8IChub2RlTmFtZSA9PT0gXCJvcHRpb25cIiAmJiAhIWVsZW0uc2VsZWN0ZWQpO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIHRoaXMgcHJvcGVydHkgbWFrZXMgc2VsZWN0ZWQtYnktZGVmYXVsdFxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zW1wiZW1wdHlcIl0oIGVsZW0gKTtcblx0XHR9LFxuXG5cdFx0Ly8gRWxlbWVudC9pbnB1dCB0eXBlc1xuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJoZWFkZXIudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImlucHV0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIHJpbnB1dHMudGVzdCggZWxlbS5ub2RlTmFtZSApO1xuXHRcdH0sXG5cblx0XHRcImJ1dHRvblwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IFwiYnV0dG9uXCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIjtcblx0XHR9LFxuXG5cdFx0XCJ0ZXh0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGF0dHI7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcblx0XHRcdFx0ZWxlbS50eXBlID09PSBcInRleHRcIiAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcblx0XHRcdFx0Ly8gTmV3IEhUTUw1IGF0dHJpYnV0ZSB2YWx1ZXMgKGUuZy4sIFwic2VhcmNoXCIpIGFwcGVhciB3aXRoIGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCJcblx0XHRcdFx0KCAoYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKFwidHlwZVwiKSkgPT0gbnVsbCB8fCBhdHRyLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dFwiICk7XG5cdFx0fSxcblxuXHRcdC8vIFBvc2l0aW9uLWluLWNvbGxlY3Rpb25cblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9KSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJsdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/XG5cdFx0XHRcdGFyZ3VtZW50ICsgbGVuZ3RoIDpcblx0XHRcdFx0YXJndW1lbnQgPiBsZW5ndGggP1xuXHRcdFx0XHRcdGxlbmd0aCA6XG5cdFx0XHRcdFx0YXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgKytpIDwgbGVuZ3RoOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSlcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zW1wibnRoXCJdID0gRXhwci5wc2V1ZG9zW1wiZXFcIl07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8IChtYXRjaCA9IHJjb21tYS5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRcdC8vIERvbid0IGNvbnN1bWUgdHJhaWxpbmcgY29tbWFzIGFzIHZhbGlkXG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoWzBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICh0b2tlbnMgPSBbXSkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHQvLyBDYXN0IGRlc2NlbmRhbnQgY29tYmluYXRvcnMgdG8gc3BhY2Vcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0pO1xuXHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGaWx0ZXJzXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcblx0XHRcdGlmICggKG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSkgJiYgKCFwcmVGaWx0ZXJzWyB0eXBlIF0gfHxcblx0XHRcdFx0KG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApKSkgKSB7XG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0XHR0b2tlbnMucHVzaCh7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9KTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zW2ldLnZhbHVlO1xuXHR9XG5cdHJldHVybiBzZWxlY3Rvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcblx0dmFyIGRpciA9IGNvbWJpbmF0b3IuZGlyLFxuXHRcdHNraXAgPSBjb21iaW5hdG9yLm5leHQsXG5cdFx0a2V5ID0gc2tpcCB8fCBkaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYga2V5ID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggc2tpcCAmJiBza2lwID09PSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGVsZW0gPSBlbGVtWyBkaXIgXSB8fCBlbGVtO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsga2V5IF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJiBFeHByLnJlbGF0aXZlWyB0b2tlbnNbMV0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByW1wibmVlZHNDb250ZXh0XCJdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xuXG5cdFx0XHQvLyBBYm9ydCBpZiB3ZSBoaXQgYSBjb21iaW5hdG9yXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xuXHRcdFx0XHQvLyBTZWFyY2gsIGV4cGFuZGluZyBjb250ZXh0IGZvciBsZWFkaW5nIHNpYmxpbmcgY29tYmluYXRvcnNcblx0XHRcdFx0aWYgKCAoc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxuXHRcdFx0XHRcdHJzaWJsaW5nLnRlc3QoIHRva2Vuc1swXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0XHRcdFx0KSkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGRlZmF1bHRWYWx1ZSBpbiBwbGFjZSBvZiBnZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKVxuaWYgKCAhc3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSA9PSBudWxsO1xufSkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0pKCB3aW5kb3cgKTtcblxuXG5cbmpRdWVyeS5maW5kID0gU2l6emxlO1xualF1ZXJ5LmV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzO1xuXG4vLyBEZXByZWNhdGVkXG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5qUXVlcnkuZXNjYXBlU2VsZWN0b3IgPSBTaXp6bGUuZXNjYXBlO1xuXG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG5cblxuZnVuY3Rpb24gbm9kZU5hbWUoIGVsZW0sIG5hbWUgKSB7XG5cbiAgcmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbn07XG52YXIgcnNpbmdsZVRhZyA9ICggL148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2kgKTtcblxuXG5cbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XG5mdW5jdGlvbiB3aW5ub3coIGVsZW1lbnRzLCBxdWFsaWZpZXIsIG5vdCApIHtcblx0aWYgKCBpc0Z1bmN0aW9uKCBxdWFsaWZpZXIgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAhIXF1YWxpZmllci5jYWxsKCBlbGVtLCBpLCBlbGVtICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBTaW5nbGUgZWxlbWVudFxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gQXJyYXlsaWtlIG9mIGVsZW1lbnRzIChqUXVlcnksIGFyZ3VtZW50cywgQXJyYXkpXG5cdGlmICggdHlwZW9mIHF1YWxpZmllciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPiAtMSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRmlsdGVyZWQgZGlyZWN0bHkgZm9yIGJvdGggc2ltcGxlIGFuZCBjb21wbGV4IHNlbGVjdG9yc1xuXHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG59XG5cbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcblx0dmFyIGVsZW0gPSBlbGVtc1sgMCBdO1xuXG5cdGlmICggbm90ICkge1xuXHRcdGV4cHIgPSBcIjpub3QoXCIgKyBleHByICsgXCIpXCI7XG5cdH1cblxuXHRpZiAoIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW107XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0fSApICk7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgcmV0LFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdHJldCA9IHRoaXMucHVzaFN0YWNrKCBbXSApO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbGVuID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCByZXQgKSA6IHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHQvLyBTaG9ydGN1dCBzaW1wbGUgI2lkIGNhc2UgZm9yIHNwZWVkXG5cdHJxdWlja0V4cHIgPSAvXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxcblxuXHRpbml0ID0galF1ZXJ5LmZuLmluaXQgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJvb3QgKSB7XG5cdFx0dmFyIG1hdGNoLCBlbGVtO1xuXG5cdFx0Ly8gSEFORExFOiAkKFwiXCIpLCAkKG51bGwpLCAkKHVuZGVmaW5lZCksICQoZmFsc2UpXG5cdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvLyBNZXRob2QgaW5pdCgpIGFjY2VwdHMgYW4gYWx0ZXJuYXRlIHJvb3RqUXVlcnlcblx0XHQvLyBzbyBtaWdyYXRlIGNhbiBzdXBwb3J0IGpRdWVyeS5zdWIgKGdoLTIxMDEpXG5cdFx0cm9vdCA9IHJvb3QgfHwgcm9vdGpRdWVyeTtcblxuXHRcdC8vIEhhbmRsZSBIVE1MIHN0cmluZ3Ncblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggc2VsZWN0b3JbIDAgXSA9PT0gXCI8XCIgJiZcblx0XHRcdFx0c2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiZcblx0XHRcdFx0c2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XG5cblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcblx0XHRcdFx0bWF0Y2ggPSBbIG51bGwsIHNlbGVjdG9yLCBudWxsIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1hdGNoID0gcnF1aWNrRXhwci5leGVjKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYXRjaCBodG1sIG9yIG1ha2Ugc3VyZSBubyBjb250ZXh0IGlzIHNwZWNpZmllZCBmb3IgI2lkXG5cdFx0XHRpZiAoIG1hdGNoICYmICggbWF0Y2hbIDEgXSB8fCAhY29udGV4dCApICkge1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJChodG1sKSAtPiAkKGFycmF5KVxuXHRcdFx0XHRpZiAoIG1hdGNoWyAxIF0gKSB7XG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WyAwIF0gOiBjb250ZXh0O1xuXG5cdFx0XHRcdFx0Ly8gT3B0aW9uIHRvIHJ1biBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdFx0Ly8gSW50ZW50aW9uYWxseSBsZXQgdGhlIGVycm9yIGJlIHRocm93biBpZiBwYXJzZUhUTUwgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMsIGpRdWVyeS5wYXJzZUhUTUwoXG5cdFx0XHRcdFx0XHRtYXRjaFsgMSBdLFxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcblx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQpICk7XG5cblx0XHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCwgcHJvcHMpXG5cdFx0XHRcdFx0aWYgKCByc2luZ2xlVGFnLnRlc3QoIG1hdGNoWyAxIF0gKSAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29udGV4dCApICkge1xuXHRcdFx0XHRcdFx0Zm9yICggbWF0Y2ggaW4gY29udGV4dCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBQcm9wZXJ0aWVzIG9mIGNvbnRleHQgYXJlIGNhbGxlZCBhcyBtZXRob2RzIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhpc1sgbWF0Y2ggXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgb3RoZXJ3aXNlIHNldCBhcyBhdHRyaWJ1dGVzXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5hdHRyKCBtYXRjaCwgY29udGV4dFsgbWF0Y2ggXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKCNpZClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG1hdGNoWyAyIF0gKTtcblxuXHRcdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXNbIDAgXSA9IGVsZW07XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXG5cdFx0XHR9IGVsc2UgaWYgKCAhY29udGV4dCB8fCBjb250ZXh0LmpxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuICggY29udGV4dCB8fCByb290ICkuZmluZCggc2VsZWN0b3IgKTtcblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsIGNvbnRleHQpXG5cdFx0XHQvLyAod2hpY2ggaXMganVzdCBlcXVpdmFsZW50IHRvOiAkKGNvbnRleHQpLmZpbmQoZXhwcilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKCBjb250ZXh0ICkuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdC8vIEhBTkRMRTogJChET01FbGVtZW50KVxuXHRcdH0gZWxzZSBpZiAoIHNlbGVjdG9yLm5vZGVUeXBlICkge1xuXHRcdFx0dGhpc1sgMCBdID0gc2VsZWN0b3I7XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcblx0XHQvLyBTaG9ydGN1dCBmb3IgZG9jdW1lbnQgcmVhZHlcblx0XHR9IGVsc2UgaWYgKCBpc0Z1bmN0aW9uKCBzZWxlY3RvciApICkge1xuXHRcdFx0cmV0dXJuIHJvb3QucmVhZHkgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHJvb3QucmVhZHkoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIEV4ZWN1dGUgaW1tZWRpYXRlbHkgaWYgcmVhZHkgaXMgbm90IHByZXNlbnRcblx0XHRcdFx0c2VsZWN0b3IoIGpRdWVyeSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWFrZUFycmF5KCBzZWxlY3RvciwgdGhpcyApO1xuXHR9O1xuXG4vLyBHaXZlIHRoZSBpbml0IGZ1bmN0aW9uIHRoZSBqUXVlcnkgcHJvdG90eXBlIGZvciBsYXRlciBpbnN0YW50aWF0aW9uXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcblxuLy8gSW5pdGlhbGl6ZSBjZW50cmFsIHJlZmVyZW5jZVxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcblxuXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXG5cblx0Ly8gTWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcblx0Z3VhcmFudGVlZFVuaXF1ZSA9IHtcblx0XHRjaGlsZHJlbjogdHJ1ZSxcblx0XHRjb250ZW50czogdHJ1ZSxcblx0XHRuZXh0OiB0cnVlLFxuXHRcdHByZXY6IHRydWVcblx0fTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRoYXM6IGZ1bmN0aW9uKCB0YXJnZXQgKSB7XG5cdFx0dmFyIHRhcmdldHMgPSBqUXVlcnkoIHRhcmdldCwgdGhpcyApLFxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xuXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGNsb3Nlc3Q6IGZ1bmN0aW9uKCBzZWxlY3RvcnMsIGNvbnRleHQgKSB7XG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0bCA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0bWF0Y2hlZCA9IFtdLFxuXHRcdFx0dGFyZ2V0cyA9IHR5cGVvZiBzZWxlY3RvcnMgIT09IFwic3RyaW5nXCIgJiYgalF1ZXJ5KCBzZWxlY3RvcnMgKTtcblxuXHRcdC8vIFBvc2l0aW9uYWwgc2VsZWN0b3JzIG5ldmVyIG1hdGNoLCBzaW5jZSB0aGVyZSdzIG5vIF9zZWxlY3Rpb25fIGNvbnRleHRcblx0XHRpZiAoICFybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9ycyApICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmb3IgKCBjdXIgPSB0aGlzWyBpIF07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xuXG5cdFx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPCAxMSAmJiAoIHRhcmdldHMgP1xuXHRcdFx0XHRcdFx0dGFyZ2V0cy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IHBhc3Mgbm9uLWVsZW1lbnRzIHRvIFNpenpsZVxuXHRcdFx0XHRcdFx0Y3VyLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApIDogbWF0Y2hlZCApO1xuXHR9LFxuXG5cdC8vIERldGVybWluZSB0aGUgcG9zaXRpb24gb2YgYW4gZWxlbWVudCB3aXRoaW4gdGhlIHNldFxuXHRpbmRleDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCB0aGlzWyAwIF0gJiYgdGhpc1sgMCBdLnBhcmVudE5vZGUgKSA/IHRoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoIDogLTE7XG5cdFx0fVxuXG5cdFx0Ly8gSW5kZXggaW4gc2VsZWN0b3Jcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggalF1ZXJ5KCBlbGVtICksIHRoaXNbIDAgXSApO1xuXHRcdH1cblxuXHRcdC8vIExvY2F0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGRlc2lyZWQgZWxlbWVudFxuXHRcdHJldHVybiBpbmRleE9mLmNhbGwoIHRoaXMsXG5cblx0XHRcdC8vIElmIGl0IHJlY2VpdmVzIGEgalF1ZXJ5IG9iamVjdCwgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdXNlZFxuXHRcdFx0ZWxlbS5qcXVlcnkgPyBlbGVtWyAwIF0gOiBlbGVtXG5cdFx0KTtcblx0fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soXG5cdFx0XHRqUXVlcnkudW5pcXVlU29ydChcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLmdldCgpLCBqUXVlcnkoIHNlbGVjdG9yLCBjb250ZXh0ICkgKVxuXHRcdFx0KVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLmFkZCggc2VsZWN0b3IgPT0gbnVsbCA/XG5cdFx0XHR0aGlzLnByZXZPYmplY3QgOiB0aGlzLnByZXZPYmplY3QuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0KTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBzaWJsaW5nKCBjdXIsIGRpciApIHtcblx0d2hpbGUgKCAoIGN1ciA9IGN1clsgZGlyIF0gKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxuXHRyZXR1cm4gY3VyO1xufVxuXG5qUXVlcnkuZWFjaCgge1xuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0cmV0dXJuIHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgIT09IDExID8gcGFyZW50IDogbnVsbDtcblx0fSxcblx0cGFyZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIgKTtcblx0fSxcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBpLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRzaWJsaW5nczogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCAoIGVsZW0ucGFyZW50Tm9kZSB8fCB7fSApLmZpcnN0Q2hpbGQsIGVsZW0gKTtcblx0fSxcblx0Y2hpbGRyZW46IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggZWxlbS5maXJzdENoaWxkICk7XG5cdH0sXG5cdGNvbnRlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmNvbnRlbnREb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcblx0XHQvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcblx0XHQvLyBkb24ndCBzdXBwb3J0IGl0LlxuXHRcdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuXHRcdFx0ZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcblx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTWFwIHR1cGxlcyAocHJvZ3Jlc3MsIGRvbmUsIGZhaWwpIHRvIGFyZ3VtZW50cyAoZG9uZSwgZmFpbCwgcHJvZ3Jlc3MpXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGlzRnVuY3Rpb24oIGZuc1sgdHVwbGVbIDQgXSBdICkgJiYgZm5zWyB0dXBsZVsgNCBdIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQucHJvZ3Jlc3MoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIubm90aWZ5IH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmRvbmUoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVzb2x2ZSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5mYWlsKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlamVjdCB9KVxuXHRcdFx0XHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDEgXSBdKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQgPSBmbiAmJiBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBpc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmbiA/IFsgcmV0dXJuZWQgXSA6IGFyZ3VtZW50c1xuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdGZucyA9IG51bGw7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBvblByb2dyZXNzICkge1xuXHRcdFx0XHRcdHZhciBtYXhEZXB0aCA9IDA7XG5cdFx0XHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZSggZGVwdGgsIGRlZmVycmVkLCBoYW5kbGVyLCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcmV0dXJuZWQsIHRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4zXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01OVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIGRvdWJsZS1yZXNvbHV0aW9uIGF0dGVtcHRzXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoIDwgbWF4RGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQgPSBoYW5kbGVyLmFwcGx5KCB0aGF0LCBhcmdzICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjFcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTQ4XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkID09PSBkZWZlcnJlZC5wcm9taXNlKCkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoIFwiVGhlbmFibGUgc2VsZi1yZXNvbHV0aW9uXCIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbnMgMi4zLjMuMSwgMy41XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01NFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNzVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIFJldHJpZXZlIGB0aGVuYCBvbmx5IG9uY2Vcblx0XHRcdFx0XHRcdFx0XHRcdHRoZW4gPSByZXR1cm5lZCAmJlxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBjaGVjayBvYmplY3RzIGFuZCBmdW5jdGlvbnMgZm9yIHRoZW5hYmlsaXR5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggdHlwZW9mIHJldHVybmVkID09PSBcIm9iamVjdFwiIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHJldHVybmVkID09PSBcImZ1bmN0aW9uXCIgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC50aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYSByZXR1cm5lZCB0aGVuYWJsZVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGVuICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3BlY2lhbCBwcm9jZXNzb3JzIChub3RpZnkpIGp1c3Qgd2FpdCBmb3IgcmVzb2x1dGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gTm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGFsc28gaG9vayBpbnRvIHByb2dyZXNzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZGlzcmVnYXJkIG9sZGVyIHJlc29sdXRpb24gdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWF4RGVwdGgrKztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhbGwgb3RoZXIgcmV0dXJuZWQgdmFsdWVzXG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gSWRlbnRpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyByZXR1cm5lZCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyB0aGUgdmFsdWUocylcblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmYXVsdCBwcm9jZXNzIGlzIHJlc29sdmVcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCBzcGVjaWFsIHx8IGRlZmVycmVkLnJlc29sdmVXaXRoICkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBub3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgY2F0Y2ggYW5kIHJlamVjdCBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcyA9IHNwZWNpYWwgP1xuXHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rKCBlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuNC4xXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgcG9zdC1yZXNvbHV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICsgMSA+PSBtYXhEZXB0aCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gYW5kIG11bHRpcGxlIHZhbHVlcyAobm9uLXNwZWMgYmVoYXZpb3IpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IFRocm93ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIGUgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuMVxuXHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC01N1xuXHRcdFx0XHRcdFx0XHQvLyBSZS1yZXNvbHZlIHByb21pc2VzIGltbWVkaWF0ZWx5IHRvIGRvZGdlIGZhbHNlIHJlamVjdGlvbiBmcm9tXG5cdFx0XHRcdFx0XHRcdC8vIHN1YnNlcXVlbnQgZXJyb3JzXG5cdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJvY2VzcygpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ2FsbCBhbiBvcHRpb25hbCBob29rIHRvIHJlY29yZCB0aGUgc3RhY2ssIGluIGNhc2Ugb2YgZXhjZXB0aW9uXG5cdFx0XHRcdFx0XHRcdFx0Ly8gc2luY2UgaXQncyBvdGhlcndpc2UgbG9zdCB3aGVuIGV4ZWN1dGlvbiBnb2VzIGFzeW5jXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlID0galF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggcHJvY2VzcyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblxuXHRcdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblByb2dyZXNzICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25Qcm9ncmVzcyA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlci5ub3RpZnlXaXRoXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDEgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uRnVsZmlsbGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25GdWxmaWxsZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHlcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAyIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvblJlamVjdGVkICkgP1xuXHRcdFx0XHRcdFx0XHRcdFx0b25SZWplY3RlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRUaHJvd2VyXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSApLnByb21pc2UoKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBHZXQgYSBwcm9taXNlIGZvciB0aGlzIGRlZmVycmVkXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3Rcblx0XHRcdFx0cHJvbWlzZTogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb2JqICE9IG51bGwgPyBqUXVlcnkuZXh0ZW5kKCBvYmosIHByb21pc2UgKSA6IHByb21pc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWZlcnJlZCA9IHt9O1xuXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuXHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgNSBdO1xuXG5cdFx0XHQvLyBwcm9taXNlLnByb2dyZXNzID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZG9uZSA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmZhaWwgPSBsaXN0LmFkZFxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbIDEgXSBdID0gbGlzdC5hZGQ7XG5cblx0XHRcdC8vIEhhbmRsZSBzdGF0ZVxuXHRcdFx0aWYgKCBzdGF0ZVN0cmluZyApIHtcblx0XHRcdFx0bGlzdC5hZGQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZXNvbHZlZFwiIChpLmUuLCBmdWxmaWxsZWQpXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVqZWN0ZWRcIlxuXHRcdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfY2FsbGJhY2tzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDIgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAzIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2NhbGxiYWNrcy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDIgXS5sb2NrLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0ubG9ja1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5maXJlXG5cdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gcmVqZWN0ZWRfaGFuZGxlcnMuZmlyZVxuXHRcdFx0bGlzdC5hZGQoIHR1cGxlWyAzIF0uZmlyZSApO1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQubm90aWZ5V2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmUgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVzb2x2ZVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbigpIHsgZGVmZXJyZWQucmVqZWN0V2l0aCguLi4pIH1cblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHVuZGVmaW5lZCA6IHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH07XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlV2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdFdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0gPSBsaXN0LmZpcmVXaXRoO1xuXHRcdH0gKTtcblxuXHRcdC8vIE1ha2UgdGhlIGRlZmVycmVkIGEgcHJvbWlzZVxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcblxuXHRcdC8vIENhbGwgZ2l2ZW4gZnVuYyBpZiBhbnlcblx0XHRpZiAoIGZ1bmMgKSB7XG5cdFx0XHRmdW5jLmNhbGwoIGRlZmVycmVkLCBkZWZlcnJlZCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbCBkb25lIVxuXHRcdHJldHVybiBkZWZlcnJlZDtcblx0fSxcblxuXHQvLyBEZWZlcnJlZCBoZWxwZXJcblx0d2hlbjogZnVuY3Rpb24oIHNpbmdsZVZhbHVlICkge1xuXHRcdHZhclxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcblx0XHRcdHJlbWFpbmluZyA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cblx0XHRcdC8vIGNvdW50IG9mIHVucHJvY2Vzc2VkIGFyZ3VtZW50c1xuXHRcdFx0aSA9IHJlbWFpbmluZyxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgZnVsZmlsbG1lbnQgZGF0YVxuXHRcdFx0cmVzb2x2ZUNvbnRleHRzID0gQXJyYXkoIGkgKSxcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZFxuXHRcdFx0bWFzdGVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGNhbGxiYWNrIGZhY3Rvcnlcblx0XHRcdHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXNvbHZlQ29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0cmVzb2x2ZVZhbHVlc1sgaSBdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSA6IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggISggLS1yZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRcdG1hc3Rlci5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblxuXHRcdC8vIFNpbmdsZS0gYW5kIGVtcHR5IGFyZ3VtZW50cyBhcmUgYWRvcHRlZCBsaWtlIFByb21pc2UucmVzb2x2ZVxuXHRcdGlmICggcmVtYWluaW5nIDw9IDEgKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCBzaW5nbGVWYWx1ZSwgbWFzdGVyLmRvbmUoIHVwZGF0ZUZ1bmMoIGkgKSApLnJlc29sdmUsIG1hc3Rlci5yZWplY3QsXG5cdFx0XHRcdCFyZW1haW5pbmcgKTtcblxuXHRcdFx0Ly8gVXNlIC50aGVuKCkgdG8gdW53cmFwIHNlY29uZGFyeSB0aGVuYWJsZXMgKGNmLiBnaC0zMDAwKVxuXHRcdFx0aWYgKCBtYXN0ZXIuc3RhdGUoKSA9PT0gXCJwZW5kaW5nXCIgfHxcblx0XHRcdFx0aXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIHJlc29sdmVWYWx1ZXNbIGkgXS50aGVuICkgKSB7XG5cblx0XHRcdFx0cmV0dXJuIG1hc3Rlci50aGVuKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gTXVsdGlwbGUgYXJndW1lbnRzIGFyZSBhZ2dyZWdhdGVkIGxpa2UgUHJvbWlzZS5hbGwgYXJyYXkgZWxlbWVudHNcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHJlc29sdmVWYWx1ZXNbIGkgXSwgdXBkYXRlRnVuYyggaSApLCBtYXN0ZXIucmVqZWN0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hc3Rlci5wcm9taXNlKCk7XG5cdH1cbn0gKTtcblxuXG4vLyBUaGVzZSB1c3VhbGx5IGluZGljYXRlIGEgcHJvZ3JhbW1lciBtaXN0YWtlIGR1cmluZyBkZXZlbG9wbWVudCxcbi8vIHdhcm4gYWJvdXQgdGhlbSBBU0FQIHJhdGhlciB0aGFuIHN3YWxsb3dpbmcgdGhlbSBieSBkZWZhdWx0LlxudmFyIHJlcnJvck5hbWVzID0gL14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87XG5cbmpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rID0gZnVuY3Rpb24oIGVycm9yLCBzdGFjayApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gOSBvbmx5XG5cdC8vIENvbnNvbGUgZXhpc3RzIHdoZW4gZGV2IHRvb2xzIGFyZSBvcGVuLCB3aGljaCBjYW4gaGFwcGVuIGF0IGFueSB0aW1lXG5cdGlmICggd2luZG93LmNvbnNvbGUgJiYgd2luZG93LmNvbnNvbGUud2FybiAmJiBlcnJvciAmJiByZXJyb3JOYW1lcy50ZXN0KCBlcnJvci5uYW1lICkgKSB7XG5cdFx0d2luZG93LmNvbnNvbGUud2FybiggXCJqUXVlcnkuRGVmZXJyZWQgZXhjZXB0aW9uOiBcIiArIGVycm9yLm1lc3NhZ2UsIGVycm9yLnN0YWNrLCBzdGFjayApO1xuXHR9XG59O1xuXG5cblxuXG5qUXVlcnkucmVhZHlFeGNlcHRpb24gPSBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHR0aHJvdyBlcnJvcjtcblx0fSApO1xufTtcblxuXG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XG5cbmpRdWVyeS5mbi5yZWFkeSA9IGZ1bmN0aW9uKCBmbiApIHtcblxuXHRyZWFkeUxpc3Rcblx0XHQudGhlbiggZm4gKVxuXG5cdFx0Ly8gV3JhcCBqUXVlcnkucmVhZHlFeGNlcHRpb24gaW4gYSBmdW5jdGlvbiBzbyB0aGF0IHRoZSBsb29rdXBcblx0XHQvLyBoYXBwZW5zIGF0IHRoZSB0aW1lIG9mIGVycm9yIGhhbmRsaW5nIGluc3RlYWQgb2YgY2FsbGJhY2tcblx0XHQvLyByZWdpc3RyYXRpb24uXG5cdFx0LmNhdGNoKCBmdW5jdGlvbiggZXJyb3IgKSB7XG5cdFx0XHRqUXVlcnkucmVhZHlFeGNlcHRpb24oIGVycm9yICk7XG5cdFx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIElzIHRoZSBET00gcmVhZHkgdG8gYmUgdXNlZD8gU2V0IHRvIHRydWUgb25jZSBpdCBvY2N1cnMuXG5cdGlzUmVhZHk6IGZhbHNlLFxuXG5cdC8vIEEgY291bnRlciB0byB0cmFjayBob3cgbWFueSBpdGVtcyB0byB3YWl0IGZvciBiZWZvcmVcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcblx0cmVhZHlXYWl0OiAxLFxuXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcblx0cmVhZHk6IGZ1bmN0aW9uKCB3YWl0ICkge1xuXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxuXHRcdGlmICggd2FpdCA9PT0gdHJ1ZSA/IC0talF1ZXJ5LnJlYWR5V2FpdCA6IGpRdWVyeS5pc1JlYWR5ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlbWVtYmVyIHRoYXQgdGhlIERPTSBpcyByZWFkeVxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcblxuXHRcdC8vIElmIGEgbm9ybWFsIERPTSBSZWFkeSBldmVudCBmaXJlZCwgZGVjcmVtZW50LCBhbmQgd2FpdCBpZiBuZWVkIGJlXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIGZ1bmN0aW9ucyBib3VuZCwgdG8gZXhlY3V0ZVxuXHRcdHJlYWR5TGlzdC5yZXNvbHZlV2l0aCggZG9jdW1lbnQsIFsgalF1ZXJ5IF0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkucmVhZHkudGhlbiA9IHJlYWR5TGlzdC50aGVuO1xuXG4vLyBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG4vLyBDYXRjaCBjYXNlcyB3aGVyZSAkKGRvY3VtZW50KS5yZWFkeSgpIGlzIGNhbGxlZFxuLy8gYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMCBvbmx5XG4vLyBPbGRlciBJRSBzb21ldGltZXMgc2lnbmFscyBcImludGVyYWN0aXZlXCIgdG9vIHNvb25cbmlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdCggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgJiYgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbCApICkge1xuXG5cdC8vIEhhbmRsZSBpdCBhc3luY2hyb25vdXNseSB0byBhbGxvdyBzY3JpcHRzIHRoZSBvcHBvcnR1bml0eSB0byBkZWxheSByZWFkeVxuXHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cbn0gZWxzZSB7XG5cblx0Ly8gVXNlIHRoZSBoYW5keSBldmVudCBjYWxsYmFja1xuXHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0Ly8gQSBmYWxsYmFjayB0byB3aW5kb3cub25sb2FkLCB0aGF0IHdpbGwgYWx3YXlzIHdvcmtcblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcbn1cblxuXG5cblxuLy8gTXVsdGlmdW5jdGlvbmFsIG1ldGhvZCB0byBnZXQgYW5kIHNldCB2YWx1ZXMgb2YgYSBjb2xsZWN0aW9uXG4vLyBUaGUgdmFsdWUvcyBjYW4gb3B0aW9uYWxseSBiZSBleGVjdXRlZCBpZiBpdCdzIGEgZnVuY3Rpb25cbnZhciBhY2Nlc3MgPSBmdW5jdGlvbiggZWxlbXMsIGZuLCBrZXksIHZhbHVlLCBjaGFpbmFibGUsIGVtcHR5R2V0LCByYXcgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBlbGVtcy5sZW5ndGgsXG5cdFx0YnVsayA9IGtleSA9PSBudWxsO1xuXG5cdC8vIFNldHMgbWFueSB2YWx1ZXNcblx0aWYgKCB0b1R5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cdFx0Zm9yICggaSBpbiBrZXkgKSB7XG5cdFx0XHRhY2Nlc3MoIGVsZW1zLCBmbiwgaSwga2V5WyBpIF0sIHRydWUsIGVtcHR5R2V0LCByYXcgKTtcblx0XHR9XG5cblx0Ly8gU2V0cyBvbmUgdmFsdWVcblx0fSBlbHNlIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXG5cdFx0aWYgKCAhaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJhdyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBidWxrICkge1xuXG5cdFx0XHQvLyBCdWxrIG9wZXJhdGlvbnMgcnVuIGFnYWluc3QgdGhlIGVudGlyZSBzZXRcblx0XHRcdGlmICggcmF3ICkge1xuXHRcdFx0XHRmbi5jYWxsKCBlbGVtcywgdmFsdWUgKTtcblx0XHRcdFx0Zm4gPSBudWxsO1xuXG5cdFx0XHQvLyAuLi5leGNlcHQgd2hlbiBleGVjdXRpbmcgZnVuY3Rpb24gdmFsdWVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRidWxrID0gZm47XG5cdFx0XHRcdGZuID0gZnVuY3Rpb24oIGVsZW0sIGtleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBjaGFpbmFibGUgKSB7XG5cdFx0cmV0dXJuIGVsZW1zO1xuXHR9XG5cblx0Ly8gR2V0c1xuXHRpZiAoIGJ1bGsgKSB7XG5cdFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG5cdH1cblxuXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xuXG5cbi8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xudmFyIHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZztcblxuLy8gVXNlZCBieSBjYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5mdW5jdGlvbiBmY2FtZWxDYXNlKCBhbGwsIGxldHRlciApIHtcblx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4vLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5mdW5jdGlvbiBjYW1lbENhc2UoIHN0cmluZyApIHtcblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG59XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcblx0aWYgKCBkYXRhID09PSBcInRydWVcIiApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJmYWxzZVwiICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJudWxsXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXCJcIiApIHtcblx0XHRyZXR1cm4gK2RhdGE7XG5cdH1cblxuXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBjYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cblx0dmFyIGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHRcdH0sXG5cdFx0Y29tcG9zZWQgPSB7IGNvbXBvc2VkOiB0cnVlIH07XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4KywgaU9TIDEwLjAgLSAxMC4yIG9ubHlcblx0Ly8gQ2hlY2sgYXR0YWNobWVudCBhY3Jvc3Mgc2hhZG93IERPTSBib3VuZGFyaWVzIHdoZW4gcG9zc2libGUgKGdoLTM1MDQpXG5cdC8vIFN1cHBvcnQ6IGlPUyAxMC4wLTEwLjIgb25seVxuXHQvLyBFYXJseSBpT1MgMTAgdmVyc2lvbnMgc3VwcG9ydCBgYXR0YWNoU2hhZG93YCBidXQgbm90IGBnZXRSb290Tm9kZWAsXG5cdC8vIGxlYWRpbmcgdG8gZXJyb3JzLiBXZSBuZWVkIHRvIGNoZWNrIGZvciBgZ2V0Um9vdE5vZGVgLlxuXHRpZiAoIGRvY3VtZW50RWxlbWVudC5nZXRSb290Tm9kZSApIHtcblx0XHRpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSB8fFxuXHRcdFx0XHRlbGVtLmdldFJvb3ROb2RlKCBjb21wb3NlZCApID09PSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0fTtcblx0fVxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGlzQXR0YWNoZWQoIGVsZW0gKSAmJlxuXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIjtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5hcHBseSggZWxlbSwgYXJncyB8fCBbXSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG5cblxuZnVuY3Rpb24gYWRqdXN0Q1NTKCBlbGVtLCBwcm9wLCB2YWx1ZVBhcnRzLCB0d2VlbiApIHtcblx0dmFyIGFkanVzdGVkLCBzY2FsZSxcblx0XHRtYXhJdGVyYXRpb25zID0gMjAsXG5cdFx0Y3VycmVudFZhbHVlID0gdHdlZW4gP1xuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5jdXIoKTtcblx0XHRcdH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7XG5cdFx0XHR9LFxuXHRcdGluaXRpYWwgPSBjdXJyZW50VmFsdWUoKSxcblx0XHR1bml0ID0gdmFsdWVQYXJ0cyAmJiB2YWx1ZVBhcnRzWyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICksXG5cblx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xuXHRcdGluaXRpYWxJblVuaXQgPSBlbGVtLm5vZGVUeXBlICYmXG5cdFx0XHQoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSB8fCB1bml0ICE9PSBcInB4XCIgJiYgK2luaXRpYWwgKSAmJlxuXHRcdFx0cmNzc051bS5leGVjKCBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wICkgKTtcblxuXHRpZiAoIGluaXRpYWxJblVuaXQgJiYgaW5pdGlhbEluVW5pdFsgMyBdICE9PSB1bml0ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTU0XG5cdFx0Ly8gSGFsdmUgdGhlIGl0ZXJhdGlvbiB0YXJnZXQgdmFsdWUgdG8gcHJldmVudCBpbnRlcmZlcmVuY2UgZnJvbSBDU1MgdXBwZXIgYm91bmRzIChnaC0yMTQ0KVxuXHRcdGluaXRpYWwgPSBpbml0aWFsIC8gMjtcblxuXHRcdC8vIFRydXN0IHVuaXRzIHJlcG9ydGVkIGJ5IGpRdWVyeS5jc3Ncblx0XHR1bml0ID0gdW5pdCB8fCBpbml0aWFsSW5Vbml0WyAzIF07XG5cblx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbCB8fCAxO1xuXG5cdFx0d2hpbGUgKCBtYXhJdGVyYXRpb25zLS0gKSB7XG5cblx0XHRcdC8vIEV2YWx1YXRlIGFuZCB1cGRhdGUgb3VyIGJlc3QgZ3Vlc3MgKGRvdWJsaW5nIGd1ZXNzZXMgdGhhdCB6ZXJvIG91dCkuXG5cdFx0XHQvLyBGaW5pc2ggaWYgdGhlIHNjYWxlIGVxdWFscyBvciBjcm9zc2VzIDEgKG1ha2luZyB0aGUgb2xkKm5ldyBwcm9kdWN0IG5vbi1wb3NpdGl2ZSkuXG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cdFx0XHRpZiAoICggMSAtIHNjYWxlICkgKiAoIDEgLSAoIHNjYWxlID0gY3VycmVudFZhbHVlKCkgLyBpbml0aWFsIHx8IDAuNSApICkgPD0gMCApIHtcblx0XHRcdFx0bWF4SXRlcmF0aW9ucyA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAvIHNjYWxlO1xuXG5cdFx0fVxuXG5cdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgKiAyO1xuXHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cblx0XHR2YWx1ZVBhcnRzID0gdmFsdWVQYXJ0cyB8fCBbXTtcblx0fVxuXG5cdGlmICggdmFsdWVQYXJ0cyApIHtcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWxJblVuaXQgfHwgK2luaXRpYWwgfHwgMDtcblxuXHRcdC8vIEFwcGx5IHJlbGF0aXZlIG9mZnNldCAoKz0vLT0pIGlmIHNwZWNpZmllZFxuXHRcdGFkanVzdGVkID0gdmFsdWVQYXJ0c1sgMSBdID9cblx0XHRcdGluaXRpYWxJblVuaXQgKyAoIHZhbHVlUGFydHNbIDEgXSArIDEgKSAqIHZhbHVlUGFydHNbIDIgXSA6XG5cdFx0XHQrdmFsdWVQYXJ0c1sgMiBdO1xuXHRcdGlmICggdHdlZW4gKSB7XG5cdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcblx0XHRcdHR3ZWVuLnN0YXJ0ID0gaW5pdGlhbEluVW5pdDtcblx0XHRcdHR3ZWVuLmVuZCA9IGFkanVzdGVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gYWRqdXN0ZWQ7XG59XG5cblxudmFyIGRlZmF1bHREaXNwbGF5TWFwID0ge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHREaXNwbGF5KCBlbGVtICkge1xuXHR2YXIgdGVtcCxcblx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQsXG5cdFx0bm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLFxuXHRcdGRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXTtcblxuXHRpZiAoIGRpc3BsYXkgKSB7XG5cdFx0cmV0dXJuIGRpc3BsYXk7XG5cdH1cblxuXHR0ZW1wID0gZG9jLmJvZHkuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApICk7XG5cdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCB0ZW1wLCBcImRpc3BsYXlcIiApO1xuXG5cdHRlbXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdGVtcCApO1xuXG5cdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0ZGlzcGxheSA9IFwiYmxvY2tcIjtcblx0fVxuXHRkZWZhdWx0RGlzcGxheU1hcFsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG5cbmZ1bmN0aW9uIHNob3dIaWRlKCBlbGVtZW50cywgc2hvdyApIHtcblx0dmFyIGRpc3BsYXksIGVsZW0sXG5cdFx0dmFsdWVzID0gW10sXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcblxuXHQvLyBEZXRlcm1pbmUgbmV3IGRpc3BsYXkgdmFsdWUgZm9yIGVsZW1lbnRzIHRoYXQgbmVlZCB0byBjaGFuZ2Vcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGRpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXk7XG5cdFx0aWYgKCBzaG93ICkge1xuXG5cdFx0XHQvLyBTaW5jZSB3ZSBmb3JjZSB2aXNpYmlsaXR5IHVwb24gY2FzY2FkZS1oaWRkZW4gZWxlbWVudHMsIGFuIGltbWVkaWF0ZSAoYW5kIHNsb3cpXG5cdFx0XHQvLyBjaGVjayBpcyByZXF1aXJlZCBpbiB0aGlzIGZpcnN0IGxvb3AgdW5sZXNzIHdlIGhhdmUgYSBub25lbXB0eSBkaXNwbGF5IHZhbHVlIChlaXRoZXJcblx0XHRcdC8vIGlubGluZSBvciBhYm91dC10by1iZS1yZXN0b3JlZClcblx0XHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKSB8fCBudWxsO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXNbIGluZGV4IF0gKSB7XG5cdFx0XHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICkgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGdldERlZmF1bHREaXNwbGF5KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggZGlzcGxheSAhPT0gXCJub25lXCIgKSB7XG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IFwibm9uZVwiO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHdoYXQgd2UncmUgb3ZlcndyaXRpbmdcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImRpc3BsYXlcIiwgZGlzcGxheSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFNldCB0aGUgZGlzcGxheSBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcCB0byBhdm9pZCBjb25zdGFudCByZWZsb3dcblx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoIHZhbHVlc1sgaW5kZXggXSAhPSBudWxsICkge1xuXHRcdFx0ZWxlbWVudHNbIGluZGV4IF0uc3R5bGUuZGlzcGxheSA9IHZhbHVlc1sgaW5kZXggXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2hvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XG5cdH0sXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xuXHR9LFxuXHR0b2dnbGU6IGZ1bmN0aW9uKCBzdGF0ZSApIHtcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0XHRyZXR1cm4gc3RhdGUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBpc0hpZGRlbldpdGhpblRyZWUoIHRoaXMgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuc2hvdygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkuaGlkZSgpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKikvaSApO1xuXG52YXIgcnNjcmlwdFR5cGUgPSAoIC9eJHxebW9kdWxlJHxcXC8oPzpqYXZhfGVjbWEpc2NyaXB0L2kgKTtcblxuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRvcHRpb246IFsgMSwgXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsIFwiPC9zZWxlY3Q+XCIgXSxcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldDtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2Uge1xuXHRcdHJldCA9IFtdO1xuXHR9XG5cblx0aWYgKCB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgbm9kZU5hbWUoIGNvbnRleHQsIHRhZyApICkge1xuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFsgY29udGV4dCBdLCByZXQgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cblxuLy8gTWFyayBzY3JpcHRzIGFzIGhhdmluZyBhbHJlYWR5IGJlZW4gZXZhbHVhdGVkXG5mdW5jdGlvbiBzZXRHbG9iYWxFdmFsKCBlbGVtcywgcmVmRWxlbWVudHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRkYXRhUHJpdi5zZXQoXG5cdFx0XHRlbGVtc1sgaSBdLFxuXHRcdFx0XCJnbG9iYWxFdmFsXCIsXG5cdFx0XHQhcmVmRWxlbWVudHMgfHwgZGF0YVByaXYuZ2V0KCByZWZFbGVtZW50c1sgaSBdLCBcImdsb2JhbEV2YWxcIiApXG5cdFx0KTtcblx0fVxufVxuXG5cbnZhciByaHRtbCA9IC88fCYjP1xcdys7LztcblxuZnVuY3Rpb24gYnVpbGRGcmFnbWVudCggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiwgaWdub3JlZCApIHtcblx0dmFyIGVsZW0sIHRtcCwgdGFnLCB3cmFwLCBhdHRhY2hlZCwgaixcblx0XHRmcmFnbWVudCA9IGNvbnRleHQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdG5vZGVzID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1zWyBpIF07XG5cblx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcblxuXHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XG5cdFx0XHRpZiAoIHRvVHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcblxuXHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXG5cdFx0XHR9IGVsc2UgaWYgKCAhcmh0bWwudGVzdCggZWxlbSApICkge1xuXHRcdFx0XHRub2Rlcy5wdXNoKCBjb250ZXh0LmNyZWF0ZVRleHROb2RlKCBlbGVtICkgKTtcblxuXHRcdFx0Ly8gQ29udmVydCBodG1sIGludG8gRE9NIG5vZGVzXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0bXAgPSB0bXAgfHwgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cblx0XHRcdFx0Ly8gRGVzZXJpYWxpemUgYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvblxuXHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0d3JhcCA9IHdyYXBNYXBbIHRhZyBdIHx8IHdyYXBNYXAuX2RlZmF1bHQ7XG5cdFx0XHRcdHRtcC5pbm5lckhUTUwgPSB3cmFwWyAxIF0gKyBqUXVlcnkuaHRtbFByZWZpbHRlciggZWxlbSApICsgd3JhcFsgMiBdO1xuXG5cdFx0XHRcdC8vIERlc2NlbmQgdGhyb3VnaCB3cmFwcGVycyB0byB0aGUgcmlnaHQgY29udGVudFxuXHRcdFx0XHRqID0gd3JhcFsgMCBdO1xuXHRcdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0XHR0bXAgPSB0bXAubGFzdENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgdG1wLmNoaWxkTm9kZXMgKTtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB0aGUgdG9wLWxldmVsIGNvbnRhaW5lclxuXHRcdFx0XHR0bXAgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSB0aGUgY3JlYXRlZCBub2RlcyBhcmUgb3JwaGFuZWQgKCMxMjM5Milcblx0XHRcdFx0dG1wLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgd3JhcHBlciBmcm9tIGZyYWdtZW50XG5cdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcblxuXHRpID0gMDtcblx0d2hpbGUgKCAoIGVsZW0gPSBub2Rlc1sgaSsrIF0gKSApIHtcblxuXHRcdC8vIFNraXAgZWxlbWVudHMgYWxyZWFkeSBpbiB0aGUgY29udGV4dCBjb2xsZWN0aW9uICh0cmFjLTQwODcpXG5cdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApID4gLTEgKSB7XG5cdFx0XHRpZiAoIGlnbm9yZWQgKSB7XG5cdFx0XHRcdGlnbm9yZWQucHVzaCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0YXR0YWNoZWQgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBBcHBlbmQgdG8gZnJhZ21lbnRcblx0XHR0bXAgPSBnZXRBbGwoIGZyYWdtZW50LmFwcGVuZENoaWxkKCBlbGVtICksIFwic2NyaXB0XCIgKTtcblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRpZiAoIGF0dGFjaGVkICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggdG1wICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FwdHVyZSBleGVjdXRhYmxlc1xuXHRcdGlmICggc2NyaXB0cyApIHtcblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0bXBbIGorKyBdICkgKSB7XG5cdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggZWxlbS50eXBlIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0XHRzY3JpcHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59ICkoKTtcblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTErXG4vLyBmb2N1cygpIGFuZCBibHVyKCkgYXJlIGFzeW5jaHJvbm91cywgZXhjZXB0IHdoZW4gdGhleSBhcmUgbm8tb3AuXG4vLyBTbyBleHBlY3QgZm9jdXMgdG8gYmUgc3luY2hyb25vdXMgd2hlbiB0aGUgZWxlbWVudCBpcyBhbHJlYWR5IGFjdGl2ZSxcbi8vIGFuZCBibHVyIHRvIGJlIHN5bmNocm9ub3VzIHdoZW4gdGhlIGVsZW1lbnQgaXMgbm90IGFscmVhZHkgYWN0aXZlLlxuLy8gKGZvY3VzIGFuZCBibHVyIGFyZSBhbHdheXMgc3luY2hyb25vdXMgaW4gb3RoZXIgc3VwcG9ydGVkIGJyb3dzZXJzLFxuLy8gdGhpcyBqdXN0IGRlZmluZXMgd2hlbiB3ZSBjYW4gY291bnQgb24gaXQpLlxuZnVuY3Rpb24gZXhwZWN0U3luYyggZWxlbSwgdHlwZSApIHtcblx0cmV0dXJuICggZWxlbSA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSApID09PSAoIHR5cGUgPT09IFwiZm9jdXNcIiApO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gQWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIHRocm93IHVuZXhwZWN0ZWRseVxuLy8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzkzXG5mdW5jdGlvbiBzYWZlQWN0aXZlRWxlbWVudCgpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0fSBjYXRjaCAoIGVyciApIHsgfVxufVxuXG5mdW5jdGlvbiBvbiggZWxlbSwgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lICkge1xuXHR2YXIgb3JpZ0ZuLCB0eXBlO1xuXG5cdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xuXHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcblx0XHRcdGRhdGEgPSBkYXRhIHx8IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRvbiggZWxlbSwgdHlwZSwgc2VsZWN0b3IsIGRhdGEsIHR5cGVzWyB0eXBlIF0sIG9uZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggZGF0YSA9PSBudWxsICYmIGZuID09IG51bGwgKSB7XG5cblx0XHQvLyAoIHR5cGVzLCBmbiApXG5cdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRkYXRhID0gc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vICggdHlwZXMsIGRhdGEsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHR9IGVsc2UgaWYgKCAhZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIG9uZSA9PT0gMSApIHtcblx0XHRvcmlnRm4gPSBmbjtcblx0XHRmbiA9IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0Ly8gQ2FuIHVzZSBhbiBlbXB0eSBzZXQsIHNpbmNlIGV2ZW50IGNvbnRhaW5zIHRoZSBpbmZvXG5cdFx0XHRqUXVlcnkoKS5vZmYoIGV2ZW50ICk7XG5cdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cblx0XHRmbi5ndWlkID0gb3JpZ0ZuLmd1aWQgfHwgKCBvcmlnRm4uZ3VpZCA9IGpRdWVyeS5ndWlkKysgKTtcblx0fVxuXHRyZXR1cm4gZWxlbS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRqUXVlcnkuZXZlbnQuYWRkKCB0aGlzLCB0eXBlcywgZm4sIGRhdGEsIHNlbGVjdG9yICk7XG5cdH0gKTtcbn1cblxuLypcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGV2ZW50cyAtLSBub3QgcGFydCBvZiB0aGUgcHVibGljIGludGVyZmFjZS5cbiAqIFByb3BzIHRvIERlYW4gRWR3YXJkcycgYWRkRXZlbnQgbGlicmFyeSBmb3IgbWFueSBvZiB0aGUgaWRlYXMuXG4gKi9cbmpRdWVyeS5ldmVudCA9IHtcblxuXHRnbG9iYWw6IHt9LFxuXG5cdGFkZDogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBkYXRhLCBzZWxlY3RvciApIHtcblxuXHRcdHZhciBoYW5kbGVPYmpJbiwgZXZlbnRIYW5kbGUsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdC8vIERvbid0IGF0dGFjaCBldmVudHMgdG8gbm9EYXRhIG9yIHRleHQvY29tbWVudCBub2RlcyAoYnV0IGFsbG93IHBsYWluIG9iamVjdHMpXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGFuIG9iamVjdCBvZiBjdXN0b20gZGF0YSBpbiBsaWV1IG9mIHRoZSBoYW5kbGVyXG5cdFx0aWYgKCBoYW5kbGVyLmhhbmRsZXIgKSB7XG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlT2JqSW4uaGFuZGxlcjtcblx0XHRcdHNlbGVjdG9yID0gaGFuZGxlT2JqSW4uc2VsZWN0b3I7XG5cdFx0fVxuXG5cdFx0Ly8gRW5zdXJlIHRoYXQgaW52YWxpZCBzZWxlY3RvcnMgdGhyb3cgZXhjZXB0aW9ucyBhdCBhdHRhY2ggdGltZVxuXHRcdC8vIEV2YWx1YXRlIGFnYWluc3QgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgZWxlbSBpcyBhIG5vbi1lbGVtZW50IG5vZGUgKGUuZy4sIGRvY3VtZW50KVxuXHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGRvY3VtZW50RWxlbWVudCwgc2VsZWN0b3IgKTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0dmFyIGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggbmF0aXZlRXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaiwgaGFuZGxlclF1ZXVlLFxuXHRcdFx0YXJncyA9IG5ldyBBcnJheSggYXJndW1lbnRzLmxlbmd0aCApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblxuXHRcdGZvciAoIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrICkge1xuXHRcdFx0YXJnc1sgaSBdID0gYXJndW1lbnRzWyBpIF07XG5cdFx0fVxuXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xuXG5cdFx0Ly8gQ2FsbCB0aGUgcHJlRGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlLCBhbmQgbGV0IGl0IGJhaWwgaWYgZGVzaXJlZFxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBoYW5kbGVyc1xuXHRcdGhhbmRsZXJRdWV1ZSA9IGpRdWVyeS5ldmVudC5oYW5kbGVycy5jYWxsKCB0aGlzLCBldmVudCwgaGFuZGxlcnMgKTtcblxuXHRcdC8vIFJ1biBkZWxlZ2F0ZXMgZmlyc3Q7IHRoZXkgbWF5IHdhbnQgdG8gc3RvcCBwcm9wYWdhdGlvbiBiZW5lYXRoIHVzXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIG1hdGNoZWQgPSBoYW5kbGVyUXVldWVbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xuXG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBoYW5kbGVPYmogPSBtYXRjaGVkLmhhbmRsZXJzWyBqKysgXSApICYmXG5cdFx0XHRcdCFldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZSBldmVudCBpcyBuYW1lc3BhY2VkLCB0aGVuIGVhY2ggaGFuZGxlciBpcyBvbmx5IGludm9rZWQgaWYgaXQgaXNcblx0XHRcdFx0Ly8gc3BlY2lhbGx5IHVuaXZlcnNhbCBvciBpdHMgbmFtZXNwYWNlcyBhcmUgYSBzdXBlcnNldCBvZiB0aGUgZXZlbnQncy5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBoYW5kbGVPYmoubmFtZXNwYWNlID09PSBmYWxzZSB8fFxuXHRcdFx0XHRcdGV2ZW50LnJuYW1lc3BhY2UudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xuXG5cdFx0XHRcdFx0ZXZlbnQuaGFuZGxlT2JqID0gaGFuZGxlT2JqO1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcblxuXHRcdFx0XHRcdHJldCA9ICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30gKS5oYW5kbGUgfHxcblx0XHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyICkuYXBwbHkoIG1hdGNoZWQuZWxlbSwgYXJncyApO1xuXG5cdFx0XHRcdFx0aWYgKCByZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGlmICggKCBldmVudC5yZXN1bHQgPSByZXQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGwgdGhlIHBvc3REaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGVcblx0XHRpZiAoIHNwZWNpYWwucG9zdERpc3BhdGNoICkge1xuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xuXHRcdHZhciBpLCBoYW5kbGVPYmosIHNlbCwgbWF0Y2hlZEhhbmRsZXJzLCBtYXRjaGVkU2VsZWN0b3JzLFxuXHRcdFx0aGFuZGxlclF1ZXVlID0gW10sXG5cdFx0XHRkZWxlZ2F0ZUNvdW50ID0gaGFuZGxlcnMuZGVsZWdhdGVDb3VudCxcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcblxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05XG5cdFx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAodHJhYy0xMzE4MClcblx0XHRcdGN1ci5ub2RlVHlwZSAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDJcblx0XHRcdC8vIFN1cHByZXNzIHNwZWMtdmlvbGF0aW5nIGNsaWNrcyBpbmRpY2F0aW5nIGEgbm9uLXByaW1hcnkgcG9pbnRlciBidXR0b24gKHRyYWMtMzg2MSlcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50LXR5cGUtY2xpY2tcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExIG9ubHlcblx0XHRcdC8vIC4uLmJ1dCBub3QgYXJyb3cga2V5IFwiY2xpY2tzXCIgb2YgcmFkaW8gaW5wdXRzLCB3aGljaCBjYW4gaGF2ZSBgYnV0dG9uYCAtMSAoZ2gtMjM0Mylcblx0XHRcdCEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b24gPj0gMSApICkge1xuXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjaGVjayBub24tZWxlbWVudHMgKCMxMzIwOClcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlID09PSAxICYmICEoIGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBjdXIuZGlzYWJsZWQgPT09IHRydWUgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMgPSBbXTtcblx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzID0ge307XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRIYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVkSGFuZGxlcnMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRjdXIgPSB0aGlzO1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IGhhbmRsZXJzLnNsaWNlKCBkZWxlZ2F0ZUNvdW50ICkgfSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBoYW5kbGVyUXVldWU7XG5cdH0sXG5cblx0YWRkUHJvcDogZnVuY3Rpb24oIG5hbWUsIGhvb2sgKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBqUXVlcnkuRXZlbnQucHJvdG90eXBlLCBuYW1lLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXG5cdFx0XHRnZXQ6IGlzRnVuY3Rpb24oIGhvb2sgKSA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gaG9vayggdGhpcy5vcmlnaW5hbEV2ZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IDpcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbIG5hbWUgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHR2YWx1ZTogdmFsdWVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRmaXg6IGZ1bmN0aW9uKCBvcmlnaW5hbEV2ZW50ICkge1xuXHRcdHJldHVybiBvcmlnaW5hbEV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdG9yaWdpbmFsRXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXHR9LFxuXG5cdHNwZWNpYWw6IHtcblx0XHRsb2FkOiB7XG5cblx0XHRcdC8vIFByZXZlbnQgdHJpZ2dlcmVkIGltYWdlLmxvYWQgZXZlbnRzIGZyb20gYnViYmxpbmcgdG8gd2luZG93LmxvYWRcblx0XHRcdG5vQnViYmxlOiB0cnVlXG5cdFx0fSxcblx0XHRjbGljazoge1xuXG5cdFx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCB0byBlbnN1cmUgY29ycmVjdCBzdGF0ZSBmb3IgY2hlY2thYmxlIGlucHV0c1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcblx0XHRcdFx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcblx0XHRcdFx0XHRlbC5jbGljayAmJiBub2RlTmFtZSggZWwsIFwiaW5wdXRcIiApICkge1xuXG5cdFx0XHRcdFx0Ly8gZGF0YVByaXYuc2V0KCBlbCwgXCJjbGlja1wiLCAuLi4gKVxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiLCByZXR1cm5UcnVlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG5cdFx0XHRcdC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG5cdFx0XHRcdHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuXHRcdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlcmluZyBhIGNsaWNrXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdGxldmVyYWdlTmF0aXZlKCBlbCwgXCJjbGlja1wiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIHN1cHByZXNzIG5hdGl2ZSAuY2xpY2soKSBvbiBsaW5rc1xuXHRcdFx0Ly8gQWxzbyBwcmV2ZW50IGl0IGlmIHdlJ3JlIGN1cnJlbnRseSBpbnNpZGUgYSBsZXZlcmFnZWQgbmF0aXZlLWV2ZW50IHN0YWNrXG5cdFx0XHRfZGVmYXVsdDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXHRcdFx0XHRyZXR1cm4gcmNoZWNrYWJsZVR5cGUudGVzdCggdGFyZ2V0LnR5cGUgKSAmJlxuXHRcdFx0XHRcdHRhcmdldC5jbGljayAmJiBub2RlTmFtZSggdGFyZ2V0LCBcImlucHV0XCIgKSAmJlxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGFyZ2V0LCBcImNsaWNrXCIgKSB8fFxuXHRcdFx0XHRcdG5vZGVOYW1lKCB0YXJnZXQsIFwiYVwiICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGJlZm9yZXVubG9hZDoge1xuXHRcdFx0cG9zdERpc3BhdGNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcblx0XHRcdFx0Ly8gRmlyZWZveCBkb2Vzbid0IGFsZXJ0IGlmIHRoZSByZXR1cm5WYWx1ZSBmaWVsZCBpcyBub3Qgc2V0LlxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gRW5zdXJlIHRoZSBwcmVzZW5jZSBvZiBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGhhbmRsZXMgbWFudWFsbHktdHJpZ2dlcmVkXG4vLyBzeW50aGV0aWMgZXZlbnRzIGJ5IGludGVycnVwdGluZyBwcm9ncmVzcyB1bnRpbCByZWludm9rZWQgaW4gcmVzcG9uc2UgdG9cbi8vICpuYXRpdmUqIGV2ZW50cyB0aGF0IGl0IGZpcmVzIGRpcmVjdGx5LCBlbnN1cmluZyB0aGF0IHN0YXRlIGNoYW5nZXMgaGF2ZVxuLy8gYWxyZWFkeSBvY2N1cnJlZCBiZWZvcmUgb3RoZXIgbGlzdGVuZXJzIGFyZSBpbnZva2VkLlxuZnVuY3Rpb24gbGV2ZXJhZ2VOYXRpdmUoIGVsLCB0eXBlLCBleHBlY3RTeW5jICkge1xuXG5cdC8vIE1pc3NpbmcgZXhwZWN0U3luYyBpbmRpY2F0ZXMgYSB0cmlnZ2VyIGNhbGwsIHdoaWNoIG11c3QgZm9yY2Ugc2V0dXAgdGhyb3VnaCBqUXVlcnkuZXZlbnQuYWRkXG5cdGlmICggIWV4cGVjdFN5bmMgKSB7XG5cdFx0aWYgKCBkYXRhUHJpdi5nZXQoIGVsLCB0eXBlICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCByZXR1cm5UcnVlICk7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlZ2lzdGVyIHRoZSBjb250cm9sbGVyIGFzIGEgc3BlY2lhbCB1bml2ZXJzYWwgaGFuZGxlciBmb3IgYWxsIGV2ZW50IG5hbWVzcGFjZXNcblx0ZGF0YVByaXYuc2V0KCBlbCwgdHlwZSwgZmFsc2UgKTtcblx0alF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHtcblx0XHRuYW1lc3BhY2U6IGZhbHNlLFxuXHRcdGhhbmRsZXI6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciBub3RBc3luYywgcmVzdWx0LFxuXHRcdFx0XHRzYXZlZCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRpZiAoICggZXZlbnQuaXNUcmlnZ2VyICYgMSApICYmIHRoaXNbIHR5cGUgXSApIHtcblxuXHRcdFx0XHQvLyBJbnRlcnJ1cHQgcHJvY2Vzc2luZyBvZiB0aGUgb3V0ZXIgc3ludGhldGljIC50cmlnZ2VyKCllZCBldmVudFxuXHRcdFx0XHQvLyBTYXZlZCBkYXRhIHNob3VsZCBiZSBmYWxzZSBpbiBzdWNoIGNhc2VzLCBidXQgbWlnaHQgYmUgYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdFxuXHRcdFx0XHQvLyBmcm9tIGFuIGFzeW5jIG5hdGl2ZSBoYW5kbGVyIChnaC00MzUwKVxuXHRcdFx0XHRpZiAoICFzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBhcmd1bWVudHMgZm9yIHVzZSB3aGVuIGhhbmRsaW5nIHRoZSBpbm5lciBuYXRpdmUgZXZlbnRcblx0XHRcdFx0XHQvLyBUaGVyZSB3aWxsIGFsd2F5cyBiZSBhdCBsZWFzdCBvbmUgYXJndW1lbnQgKGFuIGV2ZW50IG9iamVjdCksIHNvIHRoaXMgYXJyYXlcblx0XHRcdFx0XHQvLyB3aWxsIG5vdCBiZSBjb25mdXNlZCB3aXRoIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3QuXG5cdFx0XHRcdFx0c2F2ZWQgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHNhdmVkICk7XG5cblx0XHRcdFx0XHQvLyBUcmlnZ2VyIHRoZSBuYXRpdmUgZXZlbnQgYW5kIGNhcHR1cmUgaXRzIHJlc3VsdFxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdC8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzXG5cdFx0XHRcdFx0bm90QXN5bmMgPSBleHBlY3RTeW5jKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0dGhpc1sgdHlwZSBdKCk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0IHx8IG5vdEFzeW5jICkge1xuXHRcdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBmYWxzZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB7fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzYXZlZCAhPT0gcmVzdWx0ICkge1xuXG5cdFx0XHRcdFx0XHQvLyBDYW5jZWwgdGhlIG91dGVyIHN5bnRoZXRpYyBldmVudFxuXHRcdFx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdC52YWx1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgZm9yIGFuIGV2ZW50IHdpdGggYSBidWJibGluZyBzdXJyb2dhdGVcblx0XHRcdFx0Ly8gKGZvY3VzIG9yIGJsdXIpLCBhc3N1bWUgdGhhdCB0aGUgc3Vycm9nYXRlIGFscmVhZHkgcHJvcGFnYXRlZCBmcm9tIHRyaWdnZXJpbmcgdGhlXG5cdFx0XHRcdC8vIG5hdGl2ZSBldmVudCBhbmQgcHJldmVudCB0aGF0IGZyb20gaGFwcGVuaW5nIGFnYWluIGhlcmUuXG5cdFx0XHRcdC8vIFRoaXMgdGVjaG5pY2FsbHkgZ2V0cyB0aGUgb3JkZXJpbmcgd3Jvbmcgdy5yLnQuIHRvIGAudHJpZ2dlcigpYCAoaW4gd2hpY2ggdGhlXG5cdFx0XHRcdC8vIGJ1YmJsaW5nIHN1cnJvZ2F0ZSBwcm9wYWdhdGVzICphZnRlciogdGhlIG5vbi1idWJibGluZyBiYXNlKSwgYnV0IHRoYXQgc2VlbXNcblx0XHRcdFx0Ly8gbGVzcyBiYWQgdGhhbiBkdXBsaWNhdGlvbi5cblx0XHRcdFx0fSBlbHNlIGlmICggKCBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9ICkuZGVsZWdhdGVUeXBlICkge1xuXHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBuYXRpdmUgZXZlbnQgdHJpZ2dlcmVkIGFib3ZlLCBldmVyeXRoaW5nIGlzIG5vdyBpbiBvcmRlclxuXHRcdFx0Ly8gRmlyZSBhbiBpbm5lciBzeW50aGV0aWMgZXZlbnQgd2l0aCB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBzYXZlZC5sZW5ndGggKSB7XG5cblx0XHRcdFx0Ly8gLi4uYW5kIGNhcHR1cmUgdGhlIHJlc3VsdFxuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIHtcblx0XHRcdFx0XHR2YWx1ZTogalF1ZXJ5LmV2ZW50LnRyaWdnZXIoXG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuXHRcdFx0XHRcdFx0Ly8gRXh0ZW5kIHdpdGggdGhlIHByb3RvdHlwZSB0byByZXNldCB0aGUgYWJvdmUgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcblx0XHRcdFx0XHRcdGpRdWVyeS5leHRlbmQoIHNhdmVkWyAwIF0sIGpRdWVyeS5FdmVudC5wcm90b3R5cGUgKSxcblx0XHRcdFx0XHRcdHNhdmVkLnNsaWNlKCAxICksXG5cdFx0XHRcdFx0XHR0aGlzXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gQWJvcnQgaGFuZGxpbmcgb2YgdGhlIG5hdGl2ZSBldmVudFxuXHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxualF1ZXJ5LnJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIHR5cGUsIGhhbmRsZSApIHtcblxuXHQvLyBUaGlzIFwiaWZcIiBpcyBuZWVkZWQgZm9yIHBsYWluIG9iamVjdHNcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0ZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKCB0eXBlLCBoYW5kbGUgKTtcblx0fVxufTtcblxualF1ZXJ5LkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG5cblx0Ly8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCApICkge1xuXHRcdHJldHVybiBuZXcgalF1ZXJ5LkV2ZW50KCBzcmMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBFdmVudCBvYmplY3Rcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG5cdFx0dGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuXHRcdHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG5cdFx0Ly8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcblx0XHQvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XG5cdFx0XHRcdHNyYy5kZWZhdWx0UHJldmVudGVkID09PSB1bmRlZmluZWQgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9Mi4zIG9ubHlcblx0XHRcdFx0c3JjLnJldHVyblZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRyZXR1cm5UcnVlIDpcblx0XHRcdHJldHVybkZhbHNlO1xuXG5cdFx0Ly8gQ3JlYXRlIHRhcmdldCBwcm9wZXJ0aWVzXG5cdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDw9NiAtIDcgb25seVxuXHRcdC8vIFRhcmdldCBzaG91bGQgbm90IGJlIGEgdGV4dCBub2RlICgjNTA0LCAjMTMxNDMpXG5cdFx0dGhpcy50YXJnZXQgPSAoIHNyYy50YXJnZXQgJiYgc3JjLnRhcmdldC5ub2RlVHlwZSA9PT0gMyApID9cblx0XHRcdHNyYy50YXJnZXQucGFyZW50Tm9kZSA6XG5cdFx0XHRzcmMudGFyZ2V0O1xuXG5cdFx0dGhpcy5jdXJyZW50VGFyZ2V0ID0gc3JjLmN1cnJlbnRUYXJnZXQ7XG5cdFx0dGhpcy5yZWxhdGVkVGFyZ2V0ID0gc3JjLnJlbGF0ZWRUYXJnZXQ7XG5cblx0Ly8gRXZlbnQgdHlwZVxuXHR9IGVsc2Uge1xuXHRcdHRoaXMudHlwZSA9IHNyYztcblx0fVxuXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG5cdGlmICggcHJvcHMgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcblxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXG5cdHRoaXNbIGpRdWVyeS5leHBhbmRvIF0gPSB0cnVlO1xufTtcblxuLy8galF1ZXJ5LkV2ZW50IGlzIGJhc2VkIG9uIERPTTMgRXZlbnRzIGFzIHNwZWNpZmllZCBieSB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBCaW5kaW5nXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNTaW11bGF0ZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdH1cblxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdH1cbn07XG5cbi8vIEluY2x1ZGVzIGFsbCBjb21tb24gZXZlbnQgcHJvcHMgaW5jbHVkaW5nIEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50IHNwZWNpZmljIHByb3BzXG5qUXVlcnkuZWFjaCgge1xuXHRhbHRLZXk6IHRydWUsXG5cdGJ1YmJsZXM6IHRydWUsXG5cdGNhbmNlbGFibGU6IHRydWUsXG5cdGNoYW5nZWRUb3VjaGVzOiB0cnVlLFxuXHRjdHJsS2V5OiB0cnVlLFxuXHRkZXRhaWw6IHRydWUsXG5cdGV2ZW50UGhhc2U6IHRydWUsXG5cdG1ldGFLZXk6IHRydWUsXG5cdHBhZ2VYOiB0cnVlLFxuXHRwYWdlWTogdHJ1ZSxcblx0c2hpZnRLZXk6IHRydWUsXG5cdHZpZXc6IHRydWUsXG5cdFwiY2hhclwiOiB0cnVlLFxuXHRjb2RlOiB0cnVlLFxuXHRjaGFyQ29kZTogdHJ1ZSxcblx0a2V5OiB0cnVlLFxuXHRrZXlDb2RlOiB0cnVlLFxuXHRidXR0b246IHRydWUsXG5cdGJ1dHRvbnM6IHRydWUsXG5cdGNsaWVudFg6IHRydWUsXG5cdGNsaWVudFk6IHRydWUsXG5cdG9mZnNldFg6IHRydWUsXG5cdG9mZnNldFk6IHRydWUsXG5cdHBvaW50ZXJJZDogdHJ1ZSxcblx0cG9pbnRlclR5cGU6IHRydWUsXG5cdHNjcmVlblg6IHRydWUsXG5cdHNjcmVlblk6IHRydWUsXG5cdHRhcmdldFRvdWNoZXM6IHRydWUsXG5cdHRvRWxlbWVudDogdHJ1ZSxcblx0dG91Y2hlczogdHJ1ZSxcblxuXHR3aGljaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBidXR0b24gPSBldmVudC5idXR0b247XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGtleSBldmVudHNcblx0XHRpZiAoIGV2ZW50LndoaWNoID09IG51bGwgJiYgcmtleUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdHJldHVybiBldmVudC5jaGFyQ29kZSAhPSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHRcblx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBybW91c2VFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDEgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDIgKSB7XG5cdFx0XHRcdHJldHVybiAzO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGJ1dHRvbiAmIDQgKSB7XG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQud2hpY2g7XG5cdH1cbn0sIGpRdWVyeS5ldmVudC5hZGRQcm9wICk7XG5cbmpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCB0eXBlLCBkZWxlZ2F0ZVR5cGUgKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gPSB7XG5cblx0XHQvLyBVdGlsaXplIG5hdGl2ZSBldmVudCBpZiBwb3NzaWJsZSBzbyBibHVyL2ZvY3VzIHNlcXVlbmNlIGlzIGNvcnJlY3Rcblx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiZm9jdXNcIiwgLi4uIClcblx0XHRcdC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJibHVyXCIsIC4uLiApXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSwgZXhwZWN0U3luYyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gZmFsc2UgdG8gYWxsb3cgbm9ybWFsIHByb2Nlc3NpbmcgaW4gdGhlIGNhbGxlclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyXG5cdFx0XHRsZXZlcmFnZU5hdGl2ZSggdGhpcywgdHlwZSApO1xuXG5cdFx0XHQvLyBSZXR1cm4gbm9uLWZhbHNlIHRvIGFsbG93IG5vcm1hbCBldmVudC1wYXRoIHByb3BhZ2F0aW9uXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0ZGVsZWdhdGVUeXBlOiBkZWxlZ2F0ZVR5cGVcblx0fTtcbn0gKTtcblxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG4vLyBzbyB0aGF0IGV2ZW50IGRlbGVnYXRpb24gd29ya3MgaW4galF1ZXJ5LlxuLy8gRG8gdGhlIHNhbWUgZm9yIHBvaW50ZXJlbnRlci9wb2ludGVybGVhdmUgYW5kIHBvaW50ZXJvdmVyL3BvaW50ZXJvdXRcbi8vXG4vLyBTdXBwb3J0OiBTYWZhcmkgNyBvbmx5XG4vLyBTYWZhcmkgc2VuZHMgbW91c2VlbnRlciB0b28gb2Z0ZW47IHNlZTpcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0b246IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBvbiggdGhpcywgdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiwgMSApO1xuXHR9LFxuXHRvZmY6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGZuICkge1xuXHRcdHZhciBoYW5kbGVPYmosIHR5cGU7XG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XG5cblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcblx0XHRcdGhhbmRsZU9iaiA9IHR5cGVzLmhhbmRsZU9iajtcblx0XHRcdGpRdWVyeSggdHlwZXMuZGVsZWdhdGVUYXJnZXQgKS5vZmYoXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgP1xuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSArIFwiLlwiICsgaGFuZGxlT2JqLm5hbWVzcGFjZSA6XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlLFxuXHRcdFx0XHRoYW5kbGVPYmouc2VsZWN0b3IsXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLW9iamVjdCBbLCBzZWxlY3Rvcl0gKVxuXHRcdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gZmFsc2UgfHwgdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMgWywgZm5dIClcblx0XHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIHRoaXMsIHR5cGVzLCBmbiwgc2VsZWN0b3IgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG52YXJcblxuXHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy8zMjI5XG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKilbXj5dKilcXC8+L2dpLFxuXG5cdC8qIGVzbGludC1lbmFibGUgKi9cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTEwIC0gMTEsIEVkZ2UgMTIgLSAxMyBvbmx5XG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuLy8gUHJlZmVyIGEgdGJvZHkgb3ZlciBpdHMgcGFyZW50IHRhYmxlIGZvciBjb250YWluaW5nIG5ldyByb3dzXG5mdW5jdGlvbiBtYW5pcHVsYXRpb25UYXJnZXQoIGVsZW0sIGNvbnRlbnQgKSB7XG5cdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXG5cdFx0bm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4galF1ZXJ5KCBlbGVtICkuY2hpbGRyZW4oIFwidGJvZHlcIiApWyAwIF0gfHwgZWxlbTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG4vLyBSZXBsYWNlL3Jlc3RvcmUgdGhlIHR5cGUgYXR0cmlidXRlIG9mIHNjcmlwdCBlbGVtZW50cyBmb3Igc2FmZSBET00gbWFuaXB1bGF0aW9uXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xuXHRlbGVtLnR5cGUgPSAoIGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICE9PSBudWxsICkgKyBcIi9cIiArIGVsZW0udHlwZTtcblx0cmV0dXJuIGVsZW07XG59XG5mdW5jdGlvbiByZXN0b3JlU2NyaXB0KCBlbGVtICkge1xuXHRpZiAoICggZWxlbS50eXBlIHx8IFwiXCIgKS5zbGljZSggMCwgNSApID09PSBcInRydWUvXCIgKSB7XG5cdFx0ZWxlbS50eXBlID0gZWxlbS50eXBlLnNsaWNlKCA1ICk7XG5cdH0gZWxzZSB7XG5cdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDb3B5RXZlbnQoIHNyYywgZGVzdCApIHtcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5hY2Nlc3MoIHNyYyApO1xuXHRcdHBkYXRhQ3VyID0gZGF0YVByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGVsZXRlIHBkYXRhQ3VyLmhhbmRsZTtcblx0XHRcdHBkYXRhQ3VyLmV2ZW50cyA9IHt9O1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIHZhbHVlSXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyAmJiAoIG5vZGUudHlwZSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKSAgIT09IFwibW9kdWxlXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgJiYgIW5vZGUubm9Nb2R1bGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYywge1xuXHRcdFx0XHRcdFx0XHRcdFx0bm9uY2U6IG5vZGUubm9uY2UgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoIFwibm9uY2VcIiApXG5cdFx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBub2RlLCBkb2MgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGlzQXR0YWNoZWQoIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sLnJlcGxhY2UoIHJ4aHRtbFRhZywgXCI8JDE+PC8kMj5cIiApO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cbnZhciByYm94U3R5bGUgPSBuZXcgUmVnRXhwKCBjc3NFeHBhbmQuam9pbiggXCJ8XCIgKSwgXCJpXCIgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O1wiICtcblx0XHRcdFwibWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCI7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwid2lkdGg6NjAlO3RvcDoxJVwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLm1hcmdpbkxlZnQgKSA9PT0gMTI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBTYWZhcmkgPD05LjEgLSAxMC4xLCBpT1MgPD03LjAgLSA5LjNcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUucmlnaHQgPSBcIjYwJVwiO1xuXHRcdHBpeGVsQm94U3R5bGVzVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5yaWdodCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG1pc3JlcG9ydGluZyBvZiBjb250ZW50IGRpbWVuc2lvbnMgZm9yIGJveC1zaXppbmc6Ym9yZGVyLWJveCBlbGVtZW50c1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS53aWR0aCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD02NFxuXHRcdC8vIERvbid0IGdldCB0cmlja2VkIHdoZW4gem9vbSBhZmZlY3RzIG9mZnNldFdpZHRoIChnaC00MDI5KVxuXHRcdGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRzY3JvbGxib3hTaXplVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXYub2Zmc2V0V2lkdGggLyAzICkgPT09IDEyO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyggbWVhc3VyZSApIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCggcGFyc2VGbG9hdCggbWVhc3VyZSApICk7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHNjcm9sbGJveFNpemVWYWwsIHBpeGVsQm94U3R5bGVzVmFsLFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdFZhbCxcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXG5cdFx0ZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG5cdC8vIEZpbmlzaCBlYXJseSBpbiBsaW1pdGVkIChub24tYnJvd3NlcikgZW52aXJvbm1lbnRzXG5cdGlmICggIWRpdi5zdHlsZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdC8vIFN0eWxlIG9mIGNsb25lZCBlbGVtZW50IGFmZmVjdHMgc291cmNlIGVsZW1lbnQgY2xvbmVkICgjODkwOClcblx0ZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJjb250ZW50LWJveFwiO1xuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xuXHRzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSA9IGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9PT0gXCJjb250ZW50LWJveFwiO1xuXG5cdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcblx0XHRib3hTaXppbmdSZWxpYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxCb3hTdHlsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbEJveFN0eWxlc1ZhbDtcblx0XHR9LFxuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVNYXJnaW5MZWZ0VmFsO1xuXHRcdH0sXG5cdFx0c2Nyb2xsYm94U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHNjcm9sbGJveFNpemVWYWw7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA1MStcblx0XHQvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XG5cdFx0Ly8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuXHRcdC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBuZWVkZWQgZm9yOlxuXHQvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksICMxMjUzNylcblx0Ly8gICAuY3NzKCctLWN1c3RvbVByb3BlcnR5KSAoIzMxNDQpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhaXNBdHRhY2hlZCggZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuXHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbEJveFN0eWxlcygpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiByYm94U3R5bGUudGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXIgY3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlLFxuXHR2ZW5kb3JQcm9wcyA9IHt9O1xuXG4vLyBSZXR1cm4gYSB2ZW5kb3ItcHJlZml4ZWQgcHJvcGVydHkgb3IgdW5kZWZpbmVkXG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuLy8gUmV0dXJuIGEgcG90ZW50aWFsbHktbWFwcGVkIGpRdWVyeS5jc3NQcm9wcyBvciB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUoIG5hbWUgKSB7XG5cdHZhciBmaW5hbCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdIHx8IHZlbmRvclByb3BzWyBuYW1lIF07XG5cblx0aWYgKCBmaW5hbCApIHtcblx0XHRyZXR1cm4gZmluYWw7XG5cdH1cblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblx0cmV0dXJuIHZlbmRvclByb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0cmN1c3RvbVByb3AgPSAvXi0tLyxcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH07XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsICkge1xuXHR2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cdFx0ZXh0cmEgPSAwLFxuXHRcdGRlbHRhID0gMDtcblxuXHQvLyBBZGp1c3RtZW50IG1heSBub3QgYmUgbmVjZXNzYXJ5XG5cdGlmICggYm94ID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cblx0XHRpZiAoIGJveCA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIGJveCArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXG5cdFx0aWYgKCAhaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIEFkZCBwYWRkaW5nXG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gRm9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIiwgYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2Vcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4dHJhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFwiY29udGVudFwiIG9yXG5cdFx0Ly8gXCJwYWRkaW5nXCIgb3IgXCJtYXJnaW5cIlxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiwgc3VidHJhY3QgcGFkZGluZ1xuXHRcdFx0aWYgKCBib3ggPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiIG9yIFwicGFkZGluZ1wiLCBzdWJ0cmFjdCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG5cdGlmICggIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDAgKSB7XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXG5cdFx0Ly8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuXHRcdGRlbHRhICs9IE1hdGgubWF4KCAwLCBNYXRoLmNlaWwoXG5cdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0Y29tcHV0ZWRWYWwgLVxuXHRcdFx0ZGVsdGEgLVxuXHRcdFx0ZXh0cmEgLVxuXHRcdFx0MC41XG5cblx0XHQvLyBJZiBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgdW5rbm93biwgdGhlbiB3ZSBjYW4ndCBkZXRlcm1pbmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlclxuXHRcdC8vIFVzZSBhbiBleHBsaWNpdCB6ZXJvIHRvIGF2b2lkIE5hTiAoZ2gtMzk2NClcblx0XHQpICkgfHwgMDtcblx0fVxuXG5cdHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXG5cdHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTQzMjIpLlxuXHRcdC8vIEZha2UgY29udGVudC1ib3ggdW50aWwgd2Uga25vdyBpdCdzIG5lZWRlZCB0byBrbm93IHRoZSB0cnVlIHZhbHVlLlxuXHRcdGJveFNpemluZ05lZWRlZCA9ICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgZXh0cmEsXG5cdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94LFxuXG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBkaW1lbnNpb24sIHN0eWxlcyApLFxuXHRcdG9mZnNldFByb3AgPSBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApO1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHQvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cblx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0aWYgKCAhZXh0cmEgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0XHR2YWwgPSBcImF1dG9cIjtcblx0fVxuXG5cblx0Ly8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB3aGVuIHZhbHVlIGlzIFwiYXV0b1wiXG5cdC8vIFRoaXMgaGFwcGVucyBmb3IgaW5saW5lIGVsZW1lbnRzIHdpdGggbm8gZXhwbGljaXQgc2V0dGluZyAoZ2gtMzU3MSlcblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSAtIDQuMyBvbmx5XG5cdC8vIEFsc28gdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3IgbWlzcmVwb3J0ZWQgaW5saW5lIGRpbWVuc2lvbnMgKGdoLTM2MDIpXG5cdC8vIFN1cHBvcnQ6IElFIDktMTEgb25seVxuXHQvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIHdoZW4gYm94IHNpemluZyBpcyB1bnJlbGlhYmxlXG5cdC8vIFdlIHVzZSBnZXRDbGllbnRSZWN0cygpIHRvIGNoZWNrIGZvciBoaWRkZW4vZGlzY29ubmVjdGVkLlxuXHQvLyBJbiB0aG9zZSBjYXNlcywgdGhlIGNvbXB1dGVkIHZhbHVlIGNhbiBiZSB0cnVzdGVkIHRvIGJlIGJvcmRlci1ib3hcblx0aWYgKCAoICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgJiYgaXNCb3JkZXJCb3ggfHxcblx0XHR2YWwgPT09IFwiYXV0b1wiIHx8XG5cdFx0IXBhcnNlRmxvYXQoIHZhbCApICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiaW5saW5lXCIgKSAmJlxuXHRcdGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0XHQvLyBXaGVyZSBhdmFpbGFibGUsIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBhcHByb3hpbWF0ZSBib3JkZXIgYm94IGRpbWVuc2lvbnMuXG5cdFx0Ly8gV2hlcmUgbm90IGF2YWlsYWJsZSAoZS5nLiwgU1ZHKSwgYXNzdW1lIHVucmVsaWFibGUgYm94LXNpemluZyBhbmQgaW50ZXJwcmV0IHRoZVxuXHRcdC8vIHJldHJpZXZlZCB2YWx1ZSBhcyBhIGNvbnRlbnQgYm94IGRpbWVuc2lvbi5cblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gb2Zmc2V0UHJvcCBpbiBlbGVtO1xuXHRcdGlmICggdmFsdWVJc0JvcmRlckJveCApIHtcblx0XHRcdHZhbCA9IGVsZW1bIG9mZnNldFByb3AgXTtcblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgXCJcIiBhbmQgYXV0b1xuXHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG5cdC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcblx0cmV0dXJuICggdmFsICtcblx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlcyxcblxuXHRcdFx0Ly8gUHJvdmlkZSB0aGUgY3VycmVudCBjb21wdXRlZCBzaXplIHRvIHJlcXVlc3Qgc2Nyb2xsIGd1dHRlciBjYWxjdWxhdGlvbiAoZ2gtMzU4OSlcblx0XHRcdHZhbFxuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwiZ3JpZEFyZWFcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5cIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5FbmRcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5TdGFydFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1wiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd0VuZFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1N0YXJ0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge30sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHQvLyBUaGUgaXNDdXN0b21Qcm9wIGNoZWNrIGNhbiBiZSByZW1vdmVkIGluIGpRdWVyeSA0LjAgd2hlbiB3ZSBvbmx5IGF1dG8tYXBwZW5kXG5cdFx0XHQvLyBcInB4XCIgdG8gYSBmZXcgaGFyZGNvZGVkIHZhbHVlcy5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiAmJiAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHRcdHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBkaW1lbnNpb24gKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgZGltZW5zaW9uIF0gPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQsIGV4dHJhICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHQvLyBDZXJ0YWluIGVsZW1lbnRzIGNhbiBoYXZlIGRpbWVuc2lvbiBpbmZvIGlmIHdlIGludmlzaWJseSBzaG93IHRoZW1cblx0XHRcdFx0Ly8gYnV0IGl0IG11c3QgaGF2ZSBhIGN1cnJlbnQgZGlzcGxheSBzdHlsZSB0aGF0IHdvdWxkIGJlbmVmaXRcblx0XHRcdFx0cmV0dXJuIHJkaXNwbGF5c3dhcC50ZXN0KCBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApICkgJiZcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4K1xuXHRcdFx0XHRcdC8vIFRhYmxlIGNvbHVtbnMgaW4gU2FmYXJpIGhhdmUgbm9uLXplcm8gb2Zmc2V0V2lkdGggJiB6ZXJvXG5cdFx0XHRcdFx0Ly8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggdW5sZXNzIGRpc3BsYXkgaXMgY2hhbmdlZC5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHRcdFx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlXG5cdFx0XHRcdFx0Ly8gaW4gSUUgdGhyb3dzIGFuIGVycm9yLlxuXHRcdFx0XHRcdCggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggfHwgIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKSA/XG5cdFx0XHRcdFx0XHRzd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdFx0XHQvLyBPbmx5IHJlYWQgc3R5bGVzLnBvc2l0aW9uIGlmIHRoZSB0ZXN0IGhhcyBhIGNoYW5jZSB0byBmYWlsXG5cdFx0XHRcdC8vIHRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3cuXG5cdFx0XHRcdHNjcm9sbGJveFNpemVCdWdneSA9ICFzdXBwb3J0LnNjcm9sbGJveFNpemUoKSAmJlxuXHRcdFx0XHRcdHN0eWxlcy5wb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiLFxuXG5cdFx0XHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTM5OTEpXG5cdFx0XHRcdGJveFNpemluZ05lZWRlZCA9IHNjcm9sbGJveFNpemVCdWdneSB8fCBleHRyYSxcblx0XHRcdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdFx0XHRzdWJ0cmFjdCA9IGV4dHJhID9cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0XHRpc0JvcmRlckJveCxcblx0XHRcdFx0XHRcdHN0eWxlc1xuXHRcdFx0XHRcdCkgOlxuXHRcdFx0XHRcdDA7XG5cblx0XHRcdC8vIEFjY291bnQgZm9yIHVucmVsaWFibGUgYm9yZGVyLWJveCBkaW1lbnNpb25zIGJ5IGNvbXBhcmluZyBvZmZzZXQqIHRvIGNvbXB1dGVkIGFuZFxuXHRcdFx0Ly8gZmFraW5nIGEgY29udGVudC1ib3ggdG8gZ2V0IGJvcmRlciBhbmQgcGFkZGluZyAoZ2gtMzY5OSlcblx0XHRcdGlmICggaXNCb3JkZXJCb3ggJiYgc2Nyb2xsYm94U2l6ZUJ1Z2d5ICkge1xuXHRcdFx0XHRzdWJ0cmFjdCAtPSBNYXRoLmNlaWwoXG5cdFx0XHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdFx0XHRwYXJzZUZsb2F0KCBzdHlsZXNbIGRpbWVuc2lvbiBdICkgLVxuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBcImJvcmRlclwiLCBmYWxzZSwgc3R5bGVzICkgLVxuXHRcdFx0XHRcdDAuNVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb252ZXJ0IHRvIHBpeGVscyBpZiB2YWx1ZSBhZGp1c3RtZW50IGlzIG5lZWRlZFxuXHRcdFx0aWYgKCBzdWJ0cmFjdCAmJiAoIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJlxuXHRcdFx0XHQoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSAhPT0gXCJweFwiICkge1xuXG5cdFx0XHRcdGVsZW0uc3R5bGVbIGRpbWVuc2lvbiBdID0gdmFsdWU7XG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5LmNzcyggZWxlbSwgZGltZW5zaW9uICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCBwcmVmaXggIT09IFwibWFyZ2luXCIgKSB7XG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcblx0XHRcdFx0bWFwID0ge30sXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9XG59ICk7XG5cblxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xuXHRyZXR1cm4gbmV3IFR3ZWVuLnByb3RvdHlwZS5pbml0KCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApO1xufVxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XG5cblR3ZWVuLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxuXHRpbml0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcsIHVuaXQgKSB7XG5cdFx0dGhpcy5lbGVtID0gZWxlbTtcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xuXHRcdHRoaXMuZWFzaW5nID0gZWFzaW5nIHx8IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHQ7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpO1xuXHRcdHRoaXMuZW5kID0gZW5kO1xuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XG5cdH0sXG5cdGN1cjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdHJldHVybiBob29rcyAmJiBob29rcy5nZXQgP1xuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LmdldCggdGhpcyApO1xuXHR9LFxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xuXHRcdHZhciBlYXNlZCxcblx0XHRcdGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IGpRdWVyeS5lYXNpbmdbIHRoaXMuZWFzaW5nIF0oXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XG5cdFx0fVxuXHRcdHRoaXMubm93ID0gKCB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKSAqIGVhc2VkICsgdGhpcy5zdGFydDtcblxuXHRcdGlmICggdGhpcy5vcHRpb25zLnN0ZXAgKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKCB0aGlzLmVsZW0sIHRoaXMubm93LCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBob29rcy5zZXQgKSB7XG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VHdlZW4ucHJvcEhvb2tzLl9kZWZhdWx0LnNldCggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuVHdlZW4ucHJvdG90eXBlLmluaXQucHJvdG90eXBlID0gVHdlZW4ucHJvdG90eXBlO1xuXG5Ud2Vlbi5wcm9wSG9va3MgPSB7XG5cdF9kZWZhdWx0OiB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXG5cdFx0XHQvLyBVc2UgYSBwcm9wZXJ0eSBvbiB0aGUgZWxlbWVudCBkaXJlY3RseSB3aGVuIGl0IGlzIG5vdCBhIERPTSBlbGVtZW50LFxuXHRcdFx0Ly8gb3Igd2hlbiB0aGVyZSBpcyBubyBtYXRjaGluZyBzdHlsZSBwcm9wZXJ0eSB0aGF0IGV4aXN0cy5cblx0XHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAhPT0gMSB8fFxuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gIT0gbnVsbCAmJiB0d2Vlbi5lbGVtLnN0eWxlWyB0d2Vlbi5wcm9wIF0gPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUGFzc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgYSAzcmQgcGFyYW1ldGVyIHRvIC5jc3Mgd2lsbCBhdXRvbWF0aWNhbGx5XG5cdFx0XHQvLyBhdHRlbXB0IGEgcGFyc2VGbG9hdCBhbmQgZmFsbGJhY2sgdG8gYSBzdHJpbmcgaWYgdGhlIHBhcnNlIGZhaWxzLlxuXHRcdFx0Ly8gU2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQ7XG5cdFx0XHQvLyBjb21wbGV4IHZhbHVlcyBzdWNoIGFzIFwicm90YXRlKDFyYWQpXCIgYXJlIHJldHVybmVkIGFzLWlzLlxuXHRcdFx0cmVzdWx0ID0galF1ZXJ5LmNzcyggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgXCJcIiApO1xuXG5cdFx0XHQvLyBFbXB0eSBzdHJpbmdzLCBudWxsLCB1bmRlZmluZWQgYW5kIFwiYXV0b1wiIGFyZSBjb252ZXJ0ZWQgdG8gMC5cblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cblx0XHRcdC8vIFVzZSBzdGVwIGhvb2sgZm9yIGJhY2sgY29tcGF0LlxuXHRcdFx0Ly8gVXNlIGNzc0hvb2sgaWYgaXRzIHRoZXJlLlxuXHRcdFx0Ly8gVXNlIC5zdHlsZSBpZiBhdmFpbGFibGUgYW5kIHVzZSBwbGFpbiBwcm9wZXJ0aWVzIHdoZXJlIGF2YWlsYWJsZS5cblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcblx0XHRcdFx0alF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSggdHdlZW4gKTtcblx0XHRcdH0gZWxzZSBpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdIHx8XG5cdFx0XHRcdFx0dHdlZW4uZWxlbS5zdHlsZVsgZmluYWxQcm9wTmFtZSggdHdlZW4ucHJvcCApIF0gIT0gbnVsbCApICkge1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIHR3ZWVuLm5vdyArIHR3ZWVuLnVuaXQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBjb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgaW5Qcm9ncmVzcyxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdGlmICggZG9jdW1lbnQuaGlkZGVuID09PSBmYWxzZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggc2NoZWR1bGUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHNjaGVkdWxlLCBqUXVlcnkuZnguaW50ZXJ2YWwgKTtcblx0XHR9XG5cblx0XHRqUXVlcnkuZngudGljaygpO1xuXHR9XG59XG5cbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcbmZ1bmN0aW9uIGNyZWF0ZUZ4Tm93KCkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0ZnhOb3cgPSB1bmRlZmluZWQ7XG5cdH0gKTtcblx0cmV0dXJuICggZnhOb3cgPSBEYXRlLm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQ7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcblx0XHR3aGljaCA9IGNzc0V4cGFuZFsgaSBdO1xuXHRcdGF0dHJzWyBcIm1hcmdpblwiICsgd2hpY2ggXSA9IGF0dHJzWyBcInBhZGRpbmdcIiArIHdoaWNoIF0gPSB0eXBlO1xuXHR9XG5cblx0aWYgKCBpbmNsdWRlV2lkdGggKSB7XG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcblx0fVxuXG5cdHJldHVybiBhdHRycztcbn1cblxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XG5cdHZhciB0d2Vlbixcblx0XHRjb2xsZWN0aW9uID0gKCBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggQW5pbWF0aW9uLnR3ZWVuZXJzWyBcIipcIiBdICksXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggKCB0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApICkgKSB7XG5cblx0XHRcdC8vIFdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgaG9va3MsIG9sZGZpcmUsIHByb3BUd2VlbiwgcmVzdG9yZURpc3BsYXksIGRpc3BsYXksXG5cdFx0aXNCb3ggPSBcIndpZHRoXCIgaW4gcHJvcHMgfHwgXCJoZWlnaHRcIiBpbiBwcm9wcyxcblx0XHRhbmltID0gdGhpcyxcblx0XHRvcmlnID0ge30sXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlLFxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW5XaXRoaW5UcmVlKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBRdWV1ZS1za2lwcGluZyBhbmltYXRpb25zIGhpamFjayB0aGUgZnggaG9va3Ncblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcblx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgXCJmeFwiICk7XG5cdFx0aWYgKCBob29rcy51bnF1ZXVlZCA9PSBudWxsICkge1xuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xuXHRcdFx0b2xkZmlyZSA9IGhvb2tzLmVtcHR5LmZpcmU7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xuXHRcdFx0XHRcdG9sZGZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0aG9va3MudW5xdWV1ZWQrKztcblxuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5zdXJlIHRoZSBjb21wbGV0ZSBoYW5kbGVyIGlzIGNhbGxlZCBiZWZvcmUgdGhpcyBjb21wbGV0ZXNcblx0XHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aG9va3MudW5xdWV1ZWQtLTtcblx0XHRcdFx0aWYgKCAhalF1ZXJ5LnF1ZXVlKCBlbGVtLCBcImZ4XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdGZvciAoIHByb3AgaW4gcHJvcHMgKSB7XG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xuXHRcdGlmICggcmZ4dHlwZXMudGVzdCggdmFsdWUgKSApIHtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgcHJvcCBdO1xuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gKCBoaWRkZW4gPyBcImhpZGVcIiA6IFwic2hvd1wiICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJldGVuZCB0byBiZSBoaWRkZW4gaWYgdGhpcyBpcyBhIFwic2hvd1wiIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBzdGlsbCBkYXRhIGZyb20gYSBzdG9wcGVkIHNob3cvaGlkZVxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBJZ25vcmUgYWxsIG90aGVyIG5vLW9wIHNob3cvaGlkZSBkYXRhXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9yaWdbIHByb3AgXSA9IGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gfHwgalF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQmFpbCBvdXQgaWYgdGhpcyBpcyBhIG5vLW9wIGxpa2UgLmhpZGUoKS5oaWRlKClcblx0cHJvcFR3ZWVuID0gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wcyApO1xuXHRpZiAoICFwcm9wVHdlZW4gJiYgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZXN0cmljdCBcIm92ZXJmbG93XCIgYW5kIFwiZGlzcGxheVwiIHN0eWxlcyBkdXJpbmcgYm94IGFuaW1hdGlvbnNcblx0aWYgKCBpc0JveCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdC8vIFJlY29yZCBhbGwgMyBvdmVyZmxvdyBhdHRyaWJ1dGVzIGJlY2F1c2UgSUUgZG9lcyBub3QgaW5mZXIgdGhlIHNob3J0aGFuZFxuXHRcdC8vIGZyb20gaWRlbnRpY2FsbHktdmFsdWVkIG92ZXJmbG93WCBhbmQgb3ZlcmZsb3dZIGFuZCBFZGdlIGp1c3QgbWlycm9yc1xuXHRcdC8vIHRoZSBvdmVyZmxvd1ggdmFsdWUgdGhlcmUuXG5cdFx0b3B0cy5vdmVyZmxvdyA9IFsgc3R5bGUub3ZlcmZsb3csIHN0eWxlLm92ZXJmbG93WCwgc3R5bGUub3ZlcmZsb3dZIF07XG5cblx0XHQvLyBJZGVudGlmeSBhIGRpc3BsYXkgdHlwZSwgcHJlZmVycmluZyBvbGQgc2hvdy9oaWRlIGRhdGEgb3ZlciB0aGUgQ1NTIGNhc2NhZGVcblx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFTaG93ICYmIGRhdGFTaG93LmRpc3BsYXk7XG5cdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0fVxuXHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJub25lXCIgKSB7XG5cdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ICkge1xuXHRcdFx0XHRkaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEdldCBub25lbXB0eSB2YWx1ZShzKSBieSB0ZW1wb3JhcmlseSBmb3JjaW5nIHZpc2liaWxpdHlcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5IHx8IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQW5pbWF0ZSBpbmxpbmUgZWxlbWVudHMgYXMgaW5saW5lLWJsb2NrXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcImlubGluZVwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWJsb2NrXCIgJiYgcmVzdG9yZURpc3BsYXkgIT0gbnVsbCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJmbG9hdFwiICkgPT09IFwibm9uZVwiICkge1xuXG5cdFx0XHRcdC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWUgYXQgdGhlIGVuZCBvZiBwdXJlIHNob3cvaGlkZSBhbmltYXRpb25zXG5cdFx0XHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRkaXNwbGF5ID0gc3R5bGUuZGlzcGxheTtcblx0XHRcdFx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogZGlzcGxheTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xuXHRcdHN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRzdHlsZS5vdmVyZmxvdyA9IG9wdHMub3ZlcmZsb3dbIDAgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WCA9IG9wdHMub3ZlcmZsb3dbIDEgXTtcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBJbXBsZW1lbnQgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0cHJvcFR3ZWVuID0gZmFsc2U7XG5cdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblxuXHRcdC8vIEdlbmVyYWwgc2hvdy9oaWRlIHNldHVwIGZvciB0aGlzIGVsZW1lbnQgYW5pbWF0aW9uXG5cdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0aWYgKCBkYXRhU2hvdyApIHtcblx0XHRcdFx0aWYgKCBcImhpZGRlblwiIGluIGRhdGFTaG93ICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHsgZGlzcGxheTogcmVzdG9yZURpc3BsYXkgfSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdG9yZSBoaWRkZW4vdmlzaWJsZSBmb3IgdG9nZ2xlIHNvIGAuc3RvcCgpLnRvZ2dsZSgpYCBcInJldmVyc2VzXCJcblx0XHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0XHRkYXRhU2hvdy5oaWRkZW4gPSAhaGlkZGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTaG93IGVsZW1lbnRzIGJlZm9yZSBhbmltYXRpbmcgdGhlbVxuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1sb29wLWZ1bmMgKi9cblxuXHRcdFx0XHQvLyBUaGUgZmluYWwgc3RlcCBvZiBhIFwiaGlkZVwiIGFuaW1hdGlvbiBpcyBhY3R1YWxseSBoaWRpbmcgdGhlIGVsZW1lbnRcblx0XHRcdFx0aWYgKCAhaGlkZGVuICkge1xuXHRcdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJmeHNob3dcIiApO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFBlci1wcm9wZXJ0eSBzZXR1cFxuXHRcdHByb3BUd2VlbiA9IGNyZWF0ZVR3ZWVuKCBoaWRkZW4gPyBkYXRhU2hvd1sgcHJvcCBdIDogMCwgcHJvcCwgYW5pbSApO1xuXHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xuXHRcdFx0ZGF0YVNob3dbIHByb3AgXSA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRwcm9wVHdlZW4uZW5kID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0XHRwcm9wVHdlZW4uc3RhcnQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGNhbWVsQ2FzZSggaW5kZXggKTtcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XG5cdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRlYXNpbmcgPSB2YWx1ZVsgMSBdO1xuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcblx0XHRcdHByb3BzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgaW5kZXggXTtcblx0XHR9XG5cblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdO1xuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbHVlID0gaG9va3MuZXhwYW5kKCB2YWx1ZSApO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBuYW1lIF07XG5cblx0XHRcdC8vIE5vdCBxdWl0ZSAkLmV4dGVuZCwgdGhpcyB3b24ndCBvdmVyd3JpdGUgZXhpc3Rpbmcga2V5cy5cblx0XHRcdC8vIFJldXNpbmcgJ2luZGV4JyBiZWNhdXNlIHdlIGhhdmUgdGhlIGNvcnJlY3QgXCJuYW1lXCJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICEoIGluZGV4IGluIHByb3BzICkgKSB7XG5cdFx0XHRcdFx0cHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgaW5kZXggXTtcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNwZWNpYWxFYXNpbmdbIG5hbWUgXSA9IGVhc2luZztcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xuXHR2YXIgcmVzdWx0LFxuXHRcdHN0b3BwZWQsXG5cdFx0aW5kZXggPSAwLFxuXHRcdGxlbmd0aCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzLmxlbmd0aCxcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIERvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxuXHRcdFx0ZGVsZXRlIHRpY2suZWxlbTtcblx0XHR9ICksXG5cdFx0dGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3VycmVudFRpbWUgPSBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjMgb25seVxuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggcGVyY2VudCApO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgcGVyY2VudCwgcmVtYWluaW5nIF0gKTtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBtb3JlIHRvIGRvLCB5aWVsZFxuXHRcdFx0aWYgKCBwZXJjZW50IDwgMSAmJiBsZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiByZW1haW5pbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoaXMgd2FzIGFuIGVtcHR5IGFuaW1hdGlvbiwgc3ludGhlc2l6ZSBhIGZpbmFsIHByb2dyZXNzIG5vdGlmaWNhdGlvblxuXHRcdFx0aWYgKCAhbGVuZ3RoICkge1xuXHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlc29sdmUgdGhlIGFuaW1hdGlvbiBhbmQgcmVwb3J0IGl0cyBjb25jbHVzaW9uXG5cdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24gXSApO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZTsgb3RoZXJ3aXNlLCByZWplY3Rcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xuXHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9ICksXG5cdFx0cHJvcHMgPSBhbmltYXRpb24ucHJvcHM7XG5cblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcblxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdHJlc3VsdCA9IEFuaW1hdGlvbi5wcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XG5cdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0cmVzdWx0LnN0b3AuYmluZCggcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBpc0Z1bmN0aW9uKCBhbmltYXRpb24ub3B0cy5zdGFydCApICkge1xuXHRcdGFuaW1hdGlvbi5vcHRzLnN0YXJ0LmNhbGwoIGVsZW0sIGFuaW1hdGlvbiApO1xuXHR9XG5cblx0Ly8gQXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0YW5pbWF0aW9uXG5cdFx0LnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXG5cdFx0LmRvbmUoIGFuaW1hdGlvbi5vcHRzLmRvbmUsIGFuaW1hdGlvbi5vcHRzLmNvbXBsZXRlIClcblx0XHQuZmFpbCggYW5pbWF0aW9uLm9wdHMuZmFpbCApXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XG5cblx0alF1ZXJ5LmZ4LnRpbWVyKFxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRhbmltOiBhbmltYXRpb24sXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcblx0XHR9IClcblx0KTtcblxuXHRyZXR1cm4gYW5pbWF0aW9uO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cblx0dHdlZW5lcnM6IHtcblx0XHRcIipcIjogWyBmdW5jdGlvbiggcHJvcCwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgdHdlZW4gPSB0aGlzLmNyZWF0ZVR3ZWVuKCBwcm9wLCB2YWx1ZSApO1xuXHRcdFx0YWRqdXN0Q1NTKCB0d2Vlbi5lbGVtLCBwcm9wLCByY3NzTnVtLmV4ZWMoIHZhbHVlICksIHR3ZWVuICk7XG5cdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0fSBdXG5cdH0sXG5cblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIHByb3BzICkgKSB7XG5cdFx0XHRjYWxsYmFjayA9IHByb3BzO1xuXHRcdFx0cHJvcHMgPSBbIFwiKlwiIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByb3BzID0gcHJvcHMubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblx0XHR9XG5cblx0XHR2YXIgcHJvcCxcblx0XHRcdGluZGV4ID0gMCxcblx0XHRcdGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSA9IEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0udW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH0sXG5cblx0cHJlZmlsdGVyczogWyBkZWZhdWx0UHJlZmlsdGVyIF0sXG5cblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XG5cdFx0aWYgKCBwcmVwZW5kICkge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0QW5pbWF0aW9uLnByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xuXHR2YXIgb3B0ID0gc3BlZWQgJiYgdHlwZW9mIHNwZWVkID09PSBcIm9iamVjdFwiID8galF1ZXJ5LmV4dGVuZCgge30sIHNwZWVkICkgOiB7XG5cdFx0Y29tcGxldGU6IGZuIHx8ICFmbiAmJiBlYXNpbmcgfHxcblx0XHRcdGlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXG5cdH07XG5cblx0Ly8gR28gdG8gdGhlIGVuZCBzdGF0ZSBpZiBmeCBhcmUgb2ZmXG5cdGlmICggalF1ZXJ5LmZ4Lm9mZiApIHtcblx0XHRvcHQuZHVyYXRpb24gPSAwO1xuXG5cdH0gZWxzZSB7XG5cdFx0aWYgKCB0eXBlb2Ygb3B0LmR1cmF0aW9uICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0aWYgKCBvcHQuZHVyYXRpb24gaW4galF1ZXJ5LmZ4LnNwZWVkcyApIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF07XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHMuX2RlZmF1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIG9wdC5xdWV1ZSAtIHRydWUvdW5kZWZpbmVkL251bGwgLT4gXCJmeFwiXG5cdGlmICggb3B0LnF1ZXVlID09IG51bGwgfHwgb3B0LnF1ZXVlID09PSB0cnVlICkge1xuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcblx0fVxuXG5cdC8vIFF1ZXVlaW5nXG5cdG9wdC5vbGQgPSBvcHQuY29tcGxldGU7XG5cblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XG5cdFx0XHRvcHQub2xkLmNhbGwoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdC5xdWV1ZSApIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCBvcHQucXVldWUgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIG9wdDtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmFkZVRvOiBmdW5jdGlvbiggc3BlZWQsIHRvLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXG5cdFx0Ly8gU2hvdyBhbnkgaGlkZGVuIGVsZW1lbnRzIGFmdGVyIHNldHRpbmcgb3BhY2l0eSB0byAwXG5cdFx0cmV0dXJuIHRoaXMuZmlsdGVyKCBpc0hpZGRlbldpdGhpblRyZWUgKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXG5cblx0XHRcdC8vIEFuaW1hdGUgdG8gdGhlIHZhbHVlIHNwZWNpZmllZFxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoIHsgb3BhY2l0eTogdG8gfSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fSxcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHZhciBlbXB0eSA9IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBwcm9wICksXG5cdFx0XHRvcHRhbGwgPSBqUXVlcnkuc3BlZWQoIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICksXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XG5cdFx0XHRcdHZhciBhbmltID0gQW5pbWF0aW9uKCB0aGlzLCBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcCApLCBvcHRhbGwgKTtcblxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcblx0XHRcdFx0aWYgKCBlbXB0eSB8fCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcblx0XHRcdFx0XHRhbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGRvQW5pbWF0aW9uLmZpbmlzaCA9IGRvQW5pbWF0aW9uO1xuXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0dGhpcy5lYWNoKCBkb0FuaW1hdGlvbiApIDpcblx0XHRcdHRoaXMucXVldWUoIG9wdGFsbC5xdWV1ZSwgZG9BbmltYXRpb24gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIHR5cGUsIGNsZWFyUXVldWUsIGdvdG9FbmQgKSB7XG5cdFx0dmFyIHN0b3BRdWV1ZSA9IGZ1bmN0aW9uKCBob29rcyApIHtcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0c3RvcCggZ290b0VuZCApO1xuXHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XG5cdFx0XHRjbGVhclF1ZXVlID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggY2xlYXJRdWV1ZSAmJiB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGRlcXVldWUgPSB0cnVlLFxuXHRcdFx0XHRpbmRleCA9IHR5cGUgIT0gbnVsbCAmJiB0eXBlICsgXCJxdWV1ZUhvb2tzXCIsXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKTtcblxuXHRcdFx0aWYgKCBpbmRleCApIHtcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcblx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggaW5kZXggaW4gZGF0YSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICYmIHJydW4udGVzdCggaW5kZXggKSApIHtcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmXG5cdFx0XHRcdFx0KCB0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkgKSB7XG5cblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCBnb3RvRW5kICk7XG5cdFx0XHRcdFx0ZGVxdWV1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RhcnQgdGhlIG5leHQgaW4gdGhlIHF1ZXVlIGlmIHRoZSBsYXN0IHN0ZXAgd2Fzbid0IGZvcmNlZC5cblx0XHRcdC8vIFRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2hcblx0XHRcdC8vIHdpbGwgZGVxdWV1ZSBidXQgb25seSBpZiB0aGV5IHdlcmUgZ290b0VuZC5cblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0aWYgKCB0eXBlICE9PSBmYWxzZSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaW5kZXgsXG5cdFx0XHRcdGRhdGEgPSBkYXRhUHJpdi5nZXQoIHRoaXMgKSxcblx0XHRcdFx0cXVldWUgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZVwiIF0sXG5cdFx0XHRcdGhvb2tzID0gZGF0YVsgdHlwZSArIFwicXVldWVIb29rc1wiIF0sXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXG5cdFx0XHRcdGxlbmd0aCA9IHF1ZXVlID8gcXVldWUubGVuZ3RoIDogMDtcblxuXHRcdFx0Ly8gRW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxuXHRcdFx0ZGF0YS5maW5pc2ggPSB0cnVlO1xuXG5cdFx0XHQvLyBFbXB0eSB0aGUgcXVldWUgZmlyc3Rcblx0XHRcdGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgW10gKTtcblxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xuXHRcdFx0XHRob29rcy5zdG9wLmNhbGwoIHRoaXMsIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFjdGl2ZSBhbmltYXRpb25zLCBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIHRydWUgKTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRpZiAoIHF1ZXVlWyBpbmRleCBdICYmIHF1ZXVlWyBpbmRleCBdLmZpbmlzaCApIHtcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIGZpbmlzaGluZyBmbGFnXG5cdFx0XHRkZWxldGUgZGF0YS5maW5pc2g7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwidG9nZ2xlXCIsIFwic2hvd1wiLCBcImhpZGVcIiBdLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBEYXRlLm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gUnVuIHRoZSB0aW1lciBhbmQgc2FmZWx5IHJlbW92ZSBpdCB3aGVuIGRvbmUgKGFsbG93aW5nIGZvciBleHRlcm5hbCByZW1vdmFsKVxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGpRdWVyeS5meC5zdGFydCgpO1xufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGluUHJvZ3Jlc3MgPSB0cnVlO1xuXHRzY2hlZHVsZSgpO1xufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0aW5Qcm9ncmVzcyA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0bm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsXG5cdFx0XHRpID0gMCxcblxuXHRcdFx0Ly8gQXR0cmlidXRlIG5hbWVzIGNhbiBjb250YWluIG5vbi1IVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuXHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xuXG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxuZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHR9XG5cdHJldHVybiBbXTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsXG5cdFx0XHRpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgaXNWYWxpZFZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdGlmICggaXNWYWxpZFZhbHVlICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArIFwiIFwiICkuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIHZhbHVlSXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRpID0gbWF4O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0c3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiggZSApIHtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsIGxhc3RFbGVtZW50LFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGxhc3RFbGVtZW50ID0gY3VyO1xuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBpc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0gKTtcbn1cbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxudmFyIG5vbmNlID0gRGF0ZS5ub3coKTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiB0b1R5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0gaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdH07XG5cblx0aWYgKCBhID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIFwiXCI7XG5cdH1cblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbCApIHtcblx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0fSApLmdldCgpO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHIyMCA9IC8lMjAvZyxcblx0cmhhc2ggPSAvIy4qJC8sXG5cdHJhbnRpQ2FjaGUgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXG5cdFx0XHRpZiAoIGN1cnJlbnQgPT09IFwiKlwiICkge1xuXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xuXG5cdFx0XHQvLyBDb252ZXJ0IHJlc3BvbnNlIGlmIHByZXYgZGF0YVR5cGUgaXMgbm9uLWF1dG8gYW5kIGRpZmZlcnMgZnJvbSBjdXJyZW50XG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdC8vIFNlZWsgYSBkaXJlY3QgY29udmVydGVyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xuXG5cdFx0XHRcdC8vIElmIG5vbmUgZm91bmQsIHNlZWsgYSBwYWlyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XG5cdFx0XHRcdFx0Zm9yICggY29udjIgaW4gY29udmVydGVycyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XG5cdFx0XHRcdFx0XHR0bXAgPSBjb252Mi5zcGxpdCggXCIgXCIgKTtcblx0XHRcdFx0XHRcdGlmICggdG1wWyAxIF0gPT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gSWYgcHJldiBjYW4gYmUgY29udmVydGVkIHRvIGFjY2VwdGVkIGlucHV0XG5cdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyB0bXBbIDAgXSBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcblx0XHRcdFx0XHRcdFx0aWYgKCBjb252ICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29uZGVuc2UgZXF1aXZhbGVuY2UgY29udmVydGVyc1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY29udiA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpbnNlcnQgdGhlIGludGVybWVkaWF0ZSBkYXRhVHlwZVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gdG1wWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdG1wWyAxIF0gKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBcHBseSBjb252ZXJ0ZXIgKGlmIG5vdCBhbiBlcXVpdmFsZW5jZSlcblx0XHRcdFx0aWYgKCBjb252ICE9PSB0cnVlICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5sZXNzIGVycm9ycyBhcmUgYWxsb3dlZCB0byBidWJibGUsIGNhdGNoIGFuZCByZXR1cm4gdGhlbVxuXHRcdFx0XHRcdGlmICggY29udiAmJiBzLnRocm93cyApIHtcblx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdGU6IFwicGFyc2VyZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY29udiA/IGUgOiBcIk5vIGNvbnZlcnNpb24gZnJvbSBcIiArIHByZXYgKyBcIiB0byBcIiArIGN1cnJlbnRcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0ZTogXCJzdWNjZXNzXCIsIGRhdGE6IHJlc3BvbnNlIH07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBDb3VudGVyIGZvciBob2xkaW5nIHRoZSBudW1iZXIgb2YgYWN0aXZlIHF1ZXJpZXNcblx0YWN0aXZlOiAwLFxuXG5cdC8vIExhc3QtTW9kaWZpZWQgaGVhZGVyIGNhY2hlIGZvciBuZXh0IHJlcXVlc3Rcblx0bGFzdE1vZGlmaWVkOiB7fSxcblx0ZXRhZzoge30sXG5cblx0YWpheFNldHRpbmdzOiB7XG5cdFx0dXJsOiBsb2NhdGlvbi5ocmVmLFxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggbG9jYXRpb24ucHJvdG9jb2wgKSxcblx0XHRnbG9iYWw6IHRydWUsXG5cdFx0cHJvY2Vzc0RhdGE6IHRydWUsXG5cdFx0YXN5bmM6IHRydWUsXG5cdFx0Y29udGVudFR5cGU6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsXG5cblx0XHQvKlxuXHRcdHRpbWVvdXQ6IDAsXG5cdFx0ZGF0YTogbnVsbCxcblx0XHRkYXRhVHlwZTogbnVsbCxcblx0XHR1c2VybmFtZTogbnVsbCxcblx0XHRwYXNzd29yZDogbnVsbCxcblx0XHRjYWNoZTogbnVsbCxcblx0XHR0aHJvd3M6IGZhbHNlLFxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcblx0XHRoZWFkZXJzOiB7fSxcblx0XHQqL1xuXG5cdFx0YWNjZXB0czoge1xuXHRcdFx0XCIqXCI6IGFsbFR5cGVzLFxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXG5cdFx0XHRodG1sOiBcInRleHQvaHRtbFwiLFxuXHRcdFx0eG1sOiBcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcblx0XHR9LFxuXG5cdFx0Y29udGVudHM6IHtcblx0XHRcdHhtbDogL1xcYnhtbFxcYi8sXG5cdFx0XHRodG1sOiAvXFxiaHRtbC8sXG5cdFx0XHRqc29uOiAvXFxianNvblxcYi9cblx0XHR9LFxuXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcblx0XHRcdHhtbDogXCJyZXNwb25zZVhNTFwiLFxuXHRcdFx0dGV4dDogXCJyZXNwb25zZVRleHRcIixcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcblx0XHR9LFxuXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXG5cdFx0Ly8gS2V5cyBzZXBhcmF0ZSBzb3VyY2UgKG9yIGNhdGNoYWxsIFwiKlwiKSBhbmQgZGVzdGluYXRpb24gdHlwZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuXHRcdGNvbnZlcnRlcnM6IHtcblxuXHRcdFx0Ly8gQ29udmVydCBhbnl0aGluZyB0byB0ZXh0XG5cdFx0XHRcIiogdGV4dFwiOiBTdHJpbmcsXG5cblx0XHRcdC8vIFRleHQgdG8gaHRtbCAodHJ1ZSA9IG5vIHRyYW5zZm9ybWF0aW9uKVxuXHRcdFx0XCJ0ZXh0IGh0bWxcIjogdHJ1ZSxcblxuXHRcdFx0Ly8gRXZhbHVhdGUgdGV4dCBhcyBhIGpzb24gZXhwcmVzc2lvblxuXHRcdFx0XCJ0ZXh0IGpzb25cIjogSlNPTi5wYXJzZSxcblxuXHRcdFx0Ly8gUGFyc2UgdGV4dCBhcyB4bWxcblx0XHRcdFwidGV4dCB4bWxcIjogalF1ZXJ5LnBhcnNlWE1MXG5cdFx0fSxcblxuXHRcdC8vIEZvciBvcHRpb25zIHRoYXQgc2hvdWxkbid0IGJlIGRlZXAgZXh0ZW5kZWQ6XG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxuXHRcdC8vIGFuZCB3aGVuIHlvdSBjcmVhdGUgb25lIHRoYXQgc2hvdWxkbid0IGJlXG5cdFx0Ly8gZGVlcCBleHRlbmRlZCAoc2VlIGFqYXhFeHRlbmQpXG5cdFx0ZmxhdE9wdGlvbnM6IHtcblx0XHRcdHVybDogdHJ1ZSxcblx0XHRcdGNvbnRleHQ6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcblx0Ly8gd2l0aCBib3RoIGFqYXhTZXR0aW5ncyBhbmQgc2V0dGluZ3MgZmllbGRzLlxuXHQvLyBJZiB0YXJnZXQgaXMgb21pdHRlZCwgd3JpdGVzIGludG8gYWpheFNldHRpbmdzLlxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBzZXR0aW5ncyA/XG5cblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0XHRhamF4RXh0ZW5kKCBhamF4RXh0ZW5kKCB0YXJnZXQsIGpRdWVyeS5hamF4U2V0dGluZ3MgKSwgc2V0dGluZ3MgKSA6XG5cblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3Ncblx0XHRcdGFqYXhFeHRlbmQoIGpRdWVyeS5hamF4U2V0dGluZ3MsIHRhcmdldCApO1xuXHR9LFxuXG5cdGFqYXhQcmVmaWx0ZXI6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycyApLFxuXHRhamF4VHJhbnNwb3J0OiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMgKSxcblxuXHQvLyBNYWluIG1ldGhvZFxuXHRhamF4OiBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXG5cdFx0Ly8gSWYgdXJsIGlzIGFuIG9iamVjdCwgc2ltdWxhdGUgcHJlLTEuNSBzaWduYXR1cmVcblx0XHRpZiAoIHR5cGVvZiB1cmwgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRvcHRpb25zID0gdXJsO1xuXHRcdFx0dXJsID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIEZvcmNlIG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHR2YXIgdHJhbnNwb3J0LFxuXG5cdFx0XHQvLyBVUkwgd2l0aG91dCBhbnRpLWNhY2hlIHBhcmFtXG5cdFx0XHRjYWNoZVVSTCxcblxuXHRcdFx0Ly8gUmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzLFxuXG5cdFx0XHQvLyB0aW1lb3V0IGhhbmRsZVxuXHRcdFx0dGltZW91dFRpbWVyLFxuXG5cdFx0XHQvLyBVcmwgY2xlYW51cCB2YXJcblx0XHRcdHVybEFuY2hvcixcblxuXHRcdFx0Ly8gUmVxdWVzdCBzdGF0ZSAoYmVjb21lcyBmYWxzZSB1cG9uIHNlbmQgYW5kIHRydWUgdXBvbiBjb21wbGV0aW9uKVxuXHRcdFx0Y29tcGxldGVkLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyB1bmNhY2hlZCBwYXJ0IG9mIHRoZSB1cmxcblx0XHRcdHVuY2FjaGVkLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2Vcblx0XHRcdHN0ckFib3J0ID0gXCJjYW5jZWxlZFwiLFxuXG5cdFx0XHQvLyBGYWtlIHhoclxuXHRcdFx0anFYSFIgPSB7XG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXG5cblx0XHRcdFx0Ly8gQnVpbGRzIGhlYWRlcnMgaGFzaHRhYmxlIGlmIG5lZWRlZFxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSA9XG5cdFx0XHRcdFx0XHRcdFx0XHQoIHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXSB8fCBbXSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5jb25jYXQoIG1hdGNoWyAyIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpICsgXCIgXCIgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2guam9pbiggXCIsIFwiICk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBjb21wbGV0ZWQgPyByZXNwb25zZUhlYWRlcnNTdHJpbmcgOiBudWxsO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhY2hlcyB0aGUgaGVhZGVyXG5cdFx0XHRcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdID1cblx0XHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHwgbmFtZTtcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGVzIHJlc3BvbnNlIGNvbnRlbnQtdHlwZSBoZWFkZXJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gRXhlY3V0ZSB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG5cdFx0XHRcdFx0XHRcdGpxWEhSLmFsd2F5cyggbWFwWyBqcVhIUi5zdGF0dXMgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBMYXp5LWFkZCB0aGUgbmV3IGNhbGxiYWNrcyBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0dXNDb2RlWyBjb2RlIF0gPSBbIHN0YXR1c0NvZGVbIGNvZGUgXSwgbWFwWyBjb2RlIF0gXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYW5jZWwgdGhlIHJlcXVlc3Rcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHZhciBmaW5hbFRleHQgPSBzdGF0dXNUZXh0IHx8IHN0ckFib3J0O1xuXHRcdFx0XHRcdGlmICggdHJhbnNwb3J0ICkge1xuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZG9uZSggMCwgZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHQvLyBBdHRhY2ggZGVmZXJyZWRzXG5cdFx0ZGVmZXJyZWQucHJvbWlzZSgganFYSFIgKTtcblxuXHRcdC8vIEFkZCBwcm90b2NvbCBpZiBub3QgcHJvdmlkZWQgKHByZWZpbHRlcnMgbWlnaHQgZXhwZWN0IGl0KVxuXHRcdC8vIEhhbmRsZSBmYWxzeSB1cmwgaW4gdGhlIHNldHRpbmdzIG9iamVjdCAoIzEwMDkzOiBjb25zaXN0ZW5jeSB3aXRoIG9sZCBzaWduYXR1cmUpXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXG5cdFx0cy51cmwgPSAoICggdXJsIHx8IHMudXJsIHx8IGxvY2F0aW9uLmhyZWYgKSArIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSAoIHMuZGF0YVR5cGUgfHwgXCIqXCIgKS50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cblx0XHQvLyBBIGNyb3NzLWRvbWFpbiByZXF1ZXN0IGlzIGluIG9yZGVyIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IG1hdGNoIHRoZSBjdXJyZW50IG9yaWdpbi5cblx0XHRpZiAoIHMuY3Jvc3NEb21haW4gPT0gbnVsbCApIHtcblx0XHRcdHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHRcdC8vIElFIHRocm93cyBleGNlcHRpb24gb24gYWNjZXNzaW5nIHRoZSBocmVmIHByb3BlcnR5IGlmIHVybCBpcyBtYWxmb3JtZWQsXG5cdFx0XHQvLyBlLmcuIGh0dHA6Ly9leGFtcGxlLmNvbTo4MHgvXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHMudXJsO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OCAtIDExIG9ubHlcblx0XHRcdFx0Ly8gQW5jaG9yJ3MgaG9zdCBwcm9wZXJ0eSBpc24ndCBjb3JyZWN0bHkgc2V0IHdoZW4gcy51cmwgaXMgcmVsYXRpdmVcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSB1cmxBbmNob3IuaHJlZjtcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IG9yaWdpbkFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIG9yaWdpbkFuY2hvci5ob3N0ICE9PVxuXHRcdFx0XHRcdHVybEFuY2hvci5wcm90b2NvbCArIFwiLy9cIiArIHVybEFuY2hvci5ob3N0O1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgVVJMLCBhc3N1bWUgaXQgaXMgY3Jvc3NEb21haW4sXG5cdFx0XHRcdC8vIGl0IGNhbiBiZSByZWplY3RlZCBieSB0aGUgdHJhbnNwb3J0IGlmIGl0IGlzIGludmFsaWRcblx0XHRcdFx0cy5jcm9zc0RvbWFpbiA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBkYXRhIGlmIG5vdCBhbHJlYWR5IGEgc3RyaW5nXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cy5kYXRhID0galF1ZXJ5LnBhcmFtKCBzLmRhdGEsIHMudHJhZGl0aW9uYWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwcmVmaWx0ZXJzXG5cdFx0aW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhIHByZWZpbHRlciwgc3RvcCB0aGVyZVxuXHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdH1cblxuXHRcdC8vIFdlIGNhbiBmaXJlIGdsb2JhbCBldmVudHMgYXMgb2Ygbm93IGlmIGFza2VkIHRvXG5cdFx0Ly8gRG9uJ3QgZmlyZSBldmVudHMgaWYgalF1ZXJ5LmV2ZW50IGlzIHVuZGVmaW5lZCBpbiBhbiBBTUQtdXNhZ2Ugc2NlbmFyaW8gKCMxNTExOClcblx0XHRmaXJlR2xvYmFscyA9IGpRdWVyeS5ldmVudCAmJiBzLmdsb2JhbDtcblxuXHRcdC8vIFdhdGNoIGZvciBhIG5ldyBzZXQgb2YgcmVxdWVzdHNcblx0XHRpZiAoIGZpcmVHbG9iYWxzICYmIGpRdWVyeS5hY3RpdmUrKyA9PT0gMCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdGFydFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVXBwZXJjYXNlIHRoZSB0eXBlXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XG5cblx0XHQvLyBEZXRlcm1pbmUgaWYgcmVxdWVzdCBoYXMgY29udGVudFxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xuXG5cdFx0Ly8gU2F2ZSB0aGUgVVJMIGluIGNhc2Ugd2UncmUgdG95aW5nIHdpdGggdGhlIElmLU1vZGlmaWVkLVNpbmNlXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXG5cdFx0Ly8gUmVtb3ZlIGhhc2ggdG8gc2ltcGxpZnkgdXJsIG1hbmlwdWxhdGlvblxuXHRcdGNhY2hlVVJMID0gcy51cmwucmVwbGFjZSggcmhhc2gsIFwiXCIgKTtcblxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XG5cdFx0aWYgKCAhcy5oYXNDb250ZW50ICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgaGFzaCBzbyB3ZSBjYW4gcHV0IGl0IGJhY2tcblx0XHRcdHVuY2FjaGVkID0gcy51cmwuc2xpY2UoIGNhY2hlVVJMLmxlbmd0aCApO1xuXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSBhbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCwgYXBwZW5kIGRhdGEgdG8gdXJsXG5cdFx0XHRpZiAoIHMuZGF0YSAmJiAoIHMucHJvY2Vzc0RhdGEgfHwgdHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiApICkge1xuXHRcdFx0XHRjYWNoZVVSTCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhO1xuXG5cdFx0XHRcdC8vICM5NjgyOiByZW1vdmUgZGF0YSBzbyB0aGF0IGl0J3Mgbm90IHVzZWQgaW4gYW4gZXZlbnR1YWwgcmV0cnlcblx0XHRcdFx0ZGVsZXRlIHMuZGF0YTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIG9yIHVwZGF0ZSBhbnRpLWNhY2hlIHBhcmFtIGlmIG5lZWRlZFxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgPSBjYWNoZVVSTC5yZXBsYWNlKCByYW50aUNhY2hlLCBcIiQxXCIgKTtcblx0XHRcdFx0dW5jYWNoZWQgPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgKCBub25jZSsrICkgKyB1bmNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuXHRcdFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG5cdFx0Ly8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG5cdFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcblx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICkge1xuXHRcdFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuXHRcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuXHRcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG5cdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggaXNGdW5jdGlvbiggZGF0YSApICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgY2FsbGJhY2s7XG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblxuXHRcdC8vIFRoZSB1cmwgY2FuIGJlIGFuIG9wdGlvbnMgb2JqZWN0ICh3aGljaCB0aGVuIG11c3QgaGF2ZSAudXJsKVxuXHRcdHJldHVybiBqUXVlcnkuYWpheCggalF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cdFx0XHR0eXBlOiBtZXRob2QsXG5cdFx0XHRkYXRhVHlwZTogdHlwZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRzdWNjZXNzOiBjYWxsYmFja1xuXHRcdH0sIGpRdWVyeS5pc1BsYWluT2JqZWN0KCB1cmwgKSAmJiB1cmwgKSApO1xuXHR9O1xufSApO1xuXG5cbmpRdWVyeS5fZXZhbFVybCA9IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblxuXHRcdC8vIE9ubHkgZXZhbHVhdGUgdGhlIHJlc3BvbnNlIGlmIGl0IGlzIHN1Y2Nlc3NmdWwgKGdoLTQxMjYpXG5cdFx0Ly8gZGF0YUZpbHRlciBpcyBub3QgaW52b2tlZCBmb3IgZmFpbHVyZSByZXNwb25zZXMsIHNvIHVzaW5nIGl0IGluc3RlYWRcblx0XHQvLyBvZiB0aGUgZGVmYXVsdCBjb252ZXJ0ZXIgaXMga2x1ZGd5IGJ1dCBpdCB3b3Jrcy5cblx0XHRjb252ZXJ0ZXJzOiB7XG5cdFx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCkge31cblx0XHR9LFxuXHRcdGRhdGFGaWx0ZXI6IGZ1bmN0aW9uKCByZXNwb25zZSApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCByZXNwb25zZSwgb3B0aW9ucyApO1xuXHRcdH1cblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaHRtbElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWxJc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXCJib2R5XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xufTtcblxuXG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9XG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0geGhyLm9udGltZW91dCA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG5cdH1cbn0gKTtcblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiBvciBmb3JjZWQtYnktYXR0cnMgcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluIHx8IHMuc2NyaXB0QXR0cnMgKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKVxuXHRcdFx0XHRcdC5hdHRyKCBzLnNjcmlwdEF0dHJzIHx8IHt9IClcblx0XHRcdFx0XHQucHJvcCggeyBjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsIHNyYzogcy51cmwgfSApXG5cdFx0XHRcdFx0Lm9uKCBcImxvYWQgZXJyb3JcIiwgY2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlKysgKSApO1xuXHRcdHRoaXNbIGNhbGxiYWNrIF0gPSB0cnVlO1xuXHRcdHJldHVybiBjYWxsYmFjaztcblx0fVxufSApO1xuXG4vLyBEZXRlY3QsIG5vcm1hbGl6ZSBvcHRpb25zIGFuZCBpbnN0YWxsIGNhbGxiYWNrcyBmb3IganNvbnAgcmVxdWVzdHNcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xuXG5cdHZhciBjYWxsYmFja05hbWUsIG92ZXJ3cml0dGVuLCByZXNwb25zZUNvbnRhaW5lcixcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xuXHRcdFx0XCJ1cmxcIiA6XG5cdFx0XHR0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiIClcblx0XHRcdFx0XHQuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICYmXG5cdFx0XHRcdHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxuXHRcdCk7XG5cblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxuXHRpZiAoIGpzb25Qcm9wIHx8IHMuZGF0YVR5cGVzWyAwIF0gPT09IFwianNvbnBcIiApIHtcblxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcblx0XHRjYWxsYmFja05hbWUgPSBzLmpzb25wQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2soKSA6XG5cdFx0XHRzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHQvLyBJbnNlcnQgY2FsbGJhY2sgaW50byB1cmwgb3IgZm9ybSBkYXRhXG5cdFx0aWYgKCBqc29uUHJvcCApIHtcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XG5cdFx0fSBlbHNlIGlmICggcy5qc29ucCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBzLnVybCApID8gXCImXCIgOiBcIj9cIiApICsgcy5qc29ucCArIFwiPVwiICsgY2FsbGJhY2tOYW1lO1xuXHRcdH1cblxuXHRcdC8vIFVzZSBkYXRhIGNvbnZlcnRlciB0byByZXRyaWV2ZSBqc29uIGFmdGVyIHNjcmlwdCBleGVjdXRpb25cblx0XHRzLmNvbnZlcnRlcnNbIFwic2NyaXB0IGpzb25cIiBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcblx0XHRcdFx0alF1ZXJ5LmVycm9yKCBjYWxsYmFja05hbWUgKyBcIiB3YXMgbm90IGNhbGxlZFwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcblx0XHR9O1xuXG5cdFx0Ly8gRm9yY2UganNvbiBkYXRhVHlwZVxuXHRcdHMuZGF0YVR5cGVzWyAwIF0gPSBcImpzb25cIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcblx0XHRvdmVyd3JpdHRlbiA9IHdpbmRvd1sgY2FsbGJhY2tOYW1lIF07XG5cdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XG5cdFx0fTtcblxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxuXHRcdGpxWEhSLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIElmIHByZXZpb3VzIHZhbHVlIGRpZG4ndCBleGlzdCAtIHJlbW92ZSBpdFxuXHRcdFx0aWYgKCBvdmVyd3JpdHRlbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRqUXVlcnkoIHdpbmRvdyApLnJlbW92ZVByb3AoIGNhbGxiYWNrTmFtZSApO1xuXG5cdFx0XHQvLyBPdGhlcndpc2UgcmVzdG9yZSBwcmVleGlzdGluZyB2YWx1ZVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2luZG93WyBjYWxsYmFja05hbWUgXSA9IG92ZXJ3cml0dGVuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYXZlIGJhY2sgYXMgZnJlZVxuXHRcdFx0aWYgKCBzWyBjYWxsYmFja05hbWUgXSApIHtcblxuXHRcdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCByZS11c2luZyB0aGUgb3B0aW9ucyBkb2Vzbid0IHNjcmV3IHRoaW5ncyBhcm91bmRcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xuXG5cdFx0XHRcdC8vIFNhdmUgdGhlIGNhbGxiYWNrIG5hbWUgZm9yIGZ1dHVyZSB1c2Vcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2Vcblx0XHRcdGlmICggcmVzcG9uc2VDb250YWluZXIgJiYgaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCBvbmx5XG4vLyBJbiBTYWZhcmkgOCBkb2N1bWVudHMgY3JlYXRlZCB2aWEgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50XG4vLyBjb2xsYXBzZSBzaWJsaW5nIGZvcm1zOiB0aGUgc2Vjb25kIG9uZSBiZWNvbWVzIGEgY2hpbGQgb2YgdGhlIGZpcnN0IG9uZS5cbi8vIEJlY2F1c2Ugb2YgdGhhdCwgdGhpcyBzZWN1cml0eSBtZWFzdXJlIGhhcyB0byBiZSBkaXNhYmxlZCBpbiBTYWZhcmkgOC5cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzczMzdcbnN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID0gKCBmdW5jdGlvbigpIHtcblx0dmFyIGJvZHkgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKS5ib2R5O1xuXHRib2R5LmlubmVySFRNTCA9IFwiPGZvcm0+PC9mb3JtPjxmb3JtPjwvZm9ybT5cIjtcblx0cmV0dXJuIGJvZHkuY2hpbGROb2Rlcy5sZW5ndGggPT09IDI7XG59ICkoKTtcblxuXG4vLyBBcmd1bWVudCBcImRhdGFcIiBzaG91bGQgYmUgc3RyaW5nIG9mIGh0bWxcbi8vIGNvbnRleHQgKG9wdGlvbmFsKTogSWYgc3BlY2lmaWVkLCB0aGUgZnJhZ21lbnQgd2lsbCBiZSBjcmVhdGVkIGluIHRoaXMgY29udGV4dCxcbi8vIGRlZmF1bHRzIHRvIGRvY3VtZW50XG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXG5qUXVlcnkucGFyc2VIVE1MID0gZnVuY3Rpb24oIGRhdGEsIGNvbnRleHQsIGtlZXBTY3JpcHRzICkge1xuXHRpZiAoIHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRrZWVwU2NyaXB0cyA9IGNvbnRleHQ7XG5cdFx0Y29udGV4dCA9IGZhbHNlO1xuXHR9XG5cblx0dmFyIGJhc2UsIHBhcnNlZCwgc2NyaXB0cztcblxuXHRpZiAoICFjb250ZXh0ICkge1xuXG5cdFx0Ly8gU3RvcCBzY3JpcHRzIG9yIGlubGluZSBldmVudCBoYW5kbGVycyBmcm9tIGJlaW5nIGV4ZWN1dGVkIGltbWVkaWF0ZWx5XG5cdFx0Ly8gYnkgdXNpbmcgZG9jdW1lbnQuaW1wbGVtZW50YXRpb25cblx0XHRpZiAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ICkge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApO1xuXG5cdFx0XHQvLyBTZXQgdGhlIGJhc2UgaHJlZiBmb3IgdGhlIGNyZWF0ZWQgZG9jdW1lbnRcblx0XHRcdC8vIHNvIGFueSBwYXJzZWQgZWxlbWVudHMgd2l0aCBVUkxzXG5cdFx0XHQvLyBhcmUgYmFzZWQgb24gdGhlIGRvY3VtZW50J3MgVVJMIChnaC0yOTY1KVxuXHRcdFx0YmFzZSA9IGNvbnRleHQuY3JlYXRlRWxlbWVudCggXCJiYXNlXCIgKTtcblx0XHRcdGJhc2UuaHJlZiA9IGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG5cdFx0XHRjb250ZXh0LmhlYWQuYXBwZW5kQ2hpbGQoIGJhc2UgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29udGV4dCA9IGRvY3VtZW50O1xuXHRcdH1cblx0fVxuXG5cdHBhcnNlZCA9IHJzaW5nbGVUYWcuZXhlYyggZGF0YSApO1xuXHRzY3JpcHRzID0gIWtlZXBTY3JpcHRzICYmIFtdO1xuXG5cdC8vIFNpbmdsZSB0YWdcblx0aWYgKCBwYXJzZWQgKSB7XG5cdFx0cmV0dXJuIFsgY29udGV4dC5jcmVhdGVFbGVtZW50KCBwYXJzZWRbIDEgXSApIF07XG5cdH1cblxuXHRwYXJzZWQgPSBidWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xuXG5cdGlmICggc2NyaXB0cyAmJiBzY3JpcHRzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xufTtcblxuXG4vKipcbiAqIExvYWQgYSB1cmwgaW50byBhIHBhZ2VcbiAqL1xualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxuXHRcdHNlbGYgPSB0aGlzLFxuXHRcdG9mZiA9IHVybC5pbmRleE9mKCBcIiBcIiApO1xuXG5cdGlmICggb2ZmID4gLTEgKSB7XG5cdFx0c2VsZWN0b3IgPSBzdHJpcEFuZENvbGxhcHNlKCB1cmwuc2xpY2UoIG9mZiApICk7XG5cdFx0dXJsID0gdXJsLnNsaWNlKCAwLCBvZmYgKTtcblx0fVxuXG5cdC8vIElmIGl0J3MgYSBmdW5jdGlvblxuXHRpZiAoIGlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHRoaXMsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG5qUXVlcnkub2Zmc2V0ID0ge1xuXHRzZXRPZmZzZXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBpICkge1xuXHRcdHZhciBjdXJQb3NpdGlvbiwgY3VyTGVmdCwgY3VyQ1NTVG9wLCBjdXJUb3AsIGN1ck9mZnNldCwgY3VyQ1NTTGVmdCwgY2FsY3VsYXRlUG9zaXRpb24sXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxuXHRcdFx0Y3VyRWxlbSA9IGpRdWVyeSggZWxlbSApLFxuXHRcdFx0cHJvcHMgPSB7fTtcblxuXHRcdC8vIFNldCBwb3NpdGlvbiBmaXJzdCwgaW4tY2FzZSB0b3AvbGVmdCBhcmUgc2V0IGV2ZW4gb24gc3RhdGljIGVsZW1cblx0XHRpZiAoIHBvc2l0aW9uID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcblx0XHR9XG5cblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xuXHRcdGN1ckNTU1RvcCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwidG9wXCIgKTtcblx0XHRjdXJDU1NMZWZ0ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJsZWZ0XCIgKTtcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcblx0XHRcdCggY3VyQ1NTVG9wICsgY3VyQ1NTTGVmdCApLmluZGV4T2YoIFwiYXV0b1wiICkgPiAtMTtcblxuXHRcdC8vIE5lZWQgdG8gYmUgYWJsZSB0byBjYWxjdWxhdGUgcG9zaXRpb24gaWYgZWl0aGVyXG5cdFx0Ly8gdG9wIG9yIGxlZnQgaXMgYXV0byBhbmQgcG9zaXRpb24gaXMgZWl0aGVyIGFic29sdXRlIG9yIGZpeGVkXG5cdFx0aWYgKCBjYWxjdWxhdGVQb3NpdGlvbiApIHtcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xuXHRcdFx0Y3VyVG9wID0gY3VyUG9zaXRpb24udG9wO1xuXHRcdFx0Y3VyTGVmdCA9IGN1clBvc2l0aW9uLmxlZnQ7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyVG9wID0gcGFyc2VGbG9hdCggY3VyQ1NTVG9wICkgfHwgMDtcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcblx0XHR9XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdGlvbnMgKSApIHtcblxuXHRcdFx0Ly8gVXNlIGpRdWVyeS5leHRlbmQgaGVyZSB0byBhbGxvdyBtb2RpZmljYXRpb24gb2YgY29vcmRpbmF0ZXMgYXJndW1lbnQgKGdoLTE4NDgpXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucy5jYWxsKCBlbGVtLCBpLCBqUXVlcnkuZXh0ZW5kKCB7fSwgY3VyT2Zmc2V0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMudG9wICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy50b3AgPSAoIG9wdGlvbnMudG9wIC0gY3VyT2Zmc2V0LnRvcCApICsgY3VyVG9wO1xuXHRcdH1cblx0XHRpZiAoIG9wdGlvbnMubGVmdCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMubGVmdCA9ICggb3B0aW9ucy5sZWZ0IC0gY3VyT2Zmc2V0LmxlZnQgKSArIGN1ckxlZnQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBcInVzaW5nXCIgaW4gb3B0aW9ucyApIHtcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHQvLyBvZmZzZXQoKSByZWxhdGVzIGFuIGVsZW1lbnQncyBib3JkZXIgYm94IHRvIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciByZWN0LCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1Jcblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXG5cdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXRcblx0XHR9O1xuXHR9LFxuXG5cdC8vIHBvc2l0aW9uKCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgbWFyZ2luIGJveCB0byBpdHMgb2Zmc2V0IHBhcmVudCdzIHBhZGRpbmcgYm94XG5cdC8vIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGJlaGF2aW9yIG9mIENTUyBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCwgZG9jLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBwb3NpdGlvbjpmaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LCB3aGljaCBpdHNlbGYgYWx3YXlzIGhhcyB6ZXJvIG9mZnNldFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxuXHRcdFx0Ly8gd2hlbiBhIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50IGlzIGlkZW50aWZpZWRcblx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJlxuXHRcdFx0XHQoIG9mZnNldFBhcmVudCA9PT0gZG9jLmJvZHkgfHwgb2Zmc2V0UGFyZW50ID09PSBkb2MuZG9jdW1lbnRFbGVtZW50ICkgJiZcblx0XHRcdFx0alF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblxuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGlmICggb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWxlbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IGpRdWVyeSggb2Zmc2V0UGFyZW50ICkub2Zmc2V0KCk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cblx0XHRcdC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuXHRcdFx0dmFyIHdpbjtcblx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0d2luID0gZWxlbTtcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBpc1dpbmRvdyggZWxlbSApICkge1xuXG5cdFx0XHRcdFx0Ly8gJCggd2luZG93ICkub3V0ZXJXaWR0aC9IZWlnaHQgcmV0dXJuIHcvaCBpbmNsdWRpbmcgc2Nyb2xsYmFycyAoZ2gtMTcyOSlcblx0XHRcdFx0XHRyZXR1cm4gZnVuY05hbWUuaW5kZXhPZiggXCJvdXRlclwiICkgPT09IDAgP1xuXHRcdFx0XHRcdFx0ZWxlbVsgXCJpbm5lclwiICsgbmFtZSBdIDpcblx0XHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5lYWNoKCAoIFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgXCIgK1xuXHRcIm1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIFwiICtcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGNvbnRleHRtZW51XCIgKS5zcGxpdCggXCIgXCIgKSxcblx0ZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cblx0Ly8gSGFuZGxlIGV2ZW50IGJpbmRpbmdcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdHRoaXMub24oIG5hbWUsIG51bGwsIGRhdGEsIGZuICkgOlxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aG92ZXI6IGZ1bmN0aW9uKCBmbk92ZXIsIGZuT3V0ICkge1xuXHRcdHJldHVybiB0aGlzLm1vdXNlZW50ZXIoIGZuT3ZlciApLm1vdXNlbGVhdmUoIGZuT3V0IHx8IGZuT3ZlciApO1xuXHR9XG59ICk7XG5cblxuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG4vLyBhcmd1bWVudHMuXG4vLyBqUXVlcnkucHJveHkgaXMgZGVwcmVjYXRlZCB0byBwcm9tb3RlIHN0YW5kYXJkcyAoc3BlY2lmaWNhbGx5IEZ1bmN0aW9uI2JpbmQpXG4vLyBIb3dldmVyLCBpdCBpcyBub3Qgc2xhdGVkIGZvciByZW1vdmFsIGFueSB0aW1lIHNvb25cbmpRdWVyeS5wcm94eSA9IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdGNvbnRleHQgPSBmbjtcblx0XHRmbiA9IHRtcDtcblx0fVxuXG5cdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdGlmICggIWlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIFNpbXVsYXRlZCBiaW5kXG5cdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0fTtcblxuXHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0cmV0dXJuIHByb3h5O1xufTtcblxualF1ZXJ5LmhvbGRSZWFkeSA9IGZ1bmN0aW9uKCBob2xkICkge1xuXHRpZiAoIGhvbGQgKSB7XG5cdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHR9XG59O1xualF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG5qUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcbmpRdWVyeS5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmpRdWVyeS5pc1dpbmRvdyA9IGlzV2luZG93O1xualF1ZXJ5LmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbmpRdWVyeS50eXBlID0gdG9UeXBlO1xuXG5qUXVlcnkubm93ID0gRGF0ZS5ub3c7XG5cbmpRdWVyeS5pc051bWVyaWMgPSBmdW5jdGlvbiggb2JqICkge1xuXG5cdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcblx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdHJldHVybiAoIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiApICYmXG5cblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xufTtcblxuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/jquery/dist/jquery.js\n");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2YyOGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcz82MDE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/setimmediate/setImmediate.js\n");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcz81MTE4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxtQkFBTyxDQUFDLGlFQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/timers-browserify/main.js\n");

/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./resources/js/components/ExampleComponent.vue?vue&type=template&id=299e239e&":
/*!*******************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./resources/js/components/ExampleComponent.vue?vue&type=template&id=299e239e& ***!
  \*******************************************************************************************************************************************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return staticRenderFns; });\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _vm._m(0)\n}\nvar staticRenderFns = [\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"div\", { staticClass: \"container\" }, [\n      _c(\"div\", { staticClass: \"row justify-content-center\" }, [\n        _c(\"div\", { staticClass: \"col-md-8\" }, [\n          _c(\"div\", { staticClass: \"card\" }, [\n            _c(\"div\", { staticClass: \"card-header\" }, [\n              _vm._v(\"Example Component\")\n            ]),\n            _vm._v(\" \"),\n            _c(\"div\", { staticClass: \"card-body\" }, [\n              _vm._v(\n                \"\\n                    I'm an example component.\\n                \"\n              )\n            ])\n          ])\n        ])\n      ])\n    ])\n  }\n]\nrender._withStripped = true\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9FeGFtcGxlQ29tcG9uZW50LnZ1ZT81ZWNjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pELGlCQUFpQiw0Q0FBNEM7QUFDN0QsbUJBQW1CLDBCQUEwQjtBQUM3QyxxQkFBcUIsc0JBQXNCO0FBQzNDLHVCQUF1Qiw2QkFBNkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPyEuL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0V4YW1wbGVDb21wb25lbnQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTI5OWUyMzllJi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX3ZtLl9tKDApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW1xuICBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3ZtID0gdGhpc1xuICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICAgIHJldHVybiBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbnRhaW5lclwiIH0sIFtcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwicm93IGp1c3RpZnktY29udGVudC1jZW50ZXJcIiB9LCBbXG4gICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiY29sLW1kLThcIiB9LCBbXG4gICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjYXJkXCIgfSwgW1xuICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjYXJkLWhlYWRlclwiIH0sIFtcbiAgICAgICAgICAgICAgX3ZtLl92KFwiRXhhbXBsZSBDb21wb25lbnRcIilcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiY2FyZC1ib2R5XCIgfSwgW1xuICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgXCJcXG4gICAgICAgICAgICAgICAgICAgIEknbSBhbiBleGFtcGxlIGNvbXBvbmVudC5cXG4gICAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICBdKVxuICAgICAgICBdKVxuICAgICAgXSlcbiAgICBdKVxuICB9XG5dXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./resources/js/components/ExampleComponent.vue?vue&type=template&id=299e239e&\n");

/***/ }),

/***/ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js":
/*!********************************************************************!*\
  !*** ./node_modules/vue-loader/lib/runtime/componentNormalizer.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return normalizeComponent; });\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzPzI4NzciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gSU1QT1JUQU5UOiBEbyBOT1QgdXNlIEVTMjAxNSBmZWF0dXJlcyBpbiB0aGlzIGZpbGUgKGV4Y2VwdCBmb3IgbW9kdWxlcykuXG4vLyBUaGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGUuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXG4gIHNjcmlwdEV4cG9ydHMsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmdW5jdGlvbmFsVGVtcGxhdGUsXG4gIGluamVjdFN0eWxlcyxcbiAgc2NvcGVJZCxcbiAgbW9kdWxlSWRlbnRpZmllciwgLyogc2VydmVyIG9ubHkgKi9cbiAgc2hhZG93TW9kZSAvKiB2dWUtY2xpIG9ubHkgKi9cbikge1xuICAvLyBWdWUuZXh0ZW5kIGNvbnN0cnVjdG9yIGV4cG9ydCBpbnRlcm9wXG4gIHZhciBvcHRpb25zID0gdHlwZW9mIHNjcmlwdEV4cG9ydHMgPT09ICdmdW5jdGlvbidcbiAgICA/IHNjcmlwdEV4cG9ydHMub3B0aW9uc1xuICAgIDogc2NyaXB0RXhwb3J0c1xuXG4gIC8vIHJlbmRlciBmdW5jdGlvbnNcbiAgaWYgKHJlbmRlcikge1xuICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnNcbiAgICBvcHRpb25zLl9jb21waWxlZCA9IHRydWVcbiAgfVxuXG4gIC8vIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGZ1bmN0aW9uYWxUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMuZnVuY3Rpb25hbCA9IHRydWVcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9ICdkYXRhLXYtJyArIHNjb3BlSWRcbiAgfVxuXG4gIHZhciBob29rXG4gIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7IC8vIHNlcnZlciBidWlsZFxuICAgIGhvb2sgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgLy8gMi4zIGluamVjdGlvblxuICAgICAgY29udGV4dCA9XG4gICAgICAgIGNvbnRleHQgfHwgLy8gY2FjaGVkIGNhbGxcbiAgICAgICAgKHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQpIHx8IC8vIHN0YXRlZnVsXG4gICAgICAgICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC4kdm5vZGUgJiYgdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQpIC8vIGZ1bmN0aW9uYWxcbiAgICAgIC8vIDIuMiB3aXRoIHJ1bkluTmV3Q29udGV4dDogdHJ1ZVxuICAgICAgaWYgKCFjb250ZXh0ICYmIHR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250ZXh0ID0gX19WVUVfU1NSX0NPTlRFWFRfX1xuICAgICAgfVxuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCBzdHlsZXNcbiAgICAgIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgY29udGV4dClcbiAgICAgIH1cbiAgICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudCBtb2R1bGUgaWRlbnRpZmllciBmb3IgYXN5bmMgY2h1bmsgaW5mZXJyZW5jZVxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMpIHtcbiAgICAgICAgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMuYWRkKG1vZHVsZUlkZW50aWZpZXIpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVzZWQgYnkgc3NyIGluIGNhc2UgY29tcG9uZW50IGlzIGNhY2hlZCBhbmQgYmVmb3JlQ3JlYXRlXG4gICAgLy8gbmV2ZXIgZ2V0cyBjYWxsZWRcbiAgICBvcHRpb25zLl9zc3JSZWdpc3RlciA9IGhvb2tcbiAgfSBlbHNlIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICBob29rID0gc2hhZG93TW9kZVxuICAgICAgPyBmdW5jdGlvbiAoKSB7IGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIHRoaXMuJHJvb3QuJG9wdGlvbnMuc2hhZG93Um9vdCkgfVxuICAgICAgOiBpbmplY3RTdHlsZXNcbiAgfVxuXG4gIGlmIChob29rKSB7XG4gICAgaWYgKG9wdGlvbnMuZnVuY3Rpb25hbCkge1xuICAgICAgLy8gZm9yIHRlbXBsYXRlLW9ubHkgaG90LXJlbG9hZCBiZWNhdXNlIGluIHRoYXQgY2FzZSB0aGUgcmVuZGVyIGZuIGRvZXNuJ3RcbiAgICAgIC8vIGdvIHRocm91Z2ggdGhlIG5vcm1hbGl6ZXJcbiAgICAgIG9wdGlvbnMuX2luamVjdFN0eWxlcyA9IGhvb2tcbiAgICAgIC8vIHJlZ2lzdGVyIGZvciBmdW5jdGlvYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICB2YXIgb3JpZ2luYWxSZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlbmRlcihoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHJlZ2lzdHJhdGlvbiBhcyBiZWZvcmVDcmVhdGUgaG9va1xuICAgICAgdmFyIGV4aXN0aW5nID0gb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmdcbiAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spXG4gICAgICAgIDogW2hvb2tdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue-loader/lib/runtime/componentNormalizer.js\n");

/***/ }),

/***/ "./node_modules/vue/dist/vue.common.dev.js":
/*!*************************************************!*\
  !*** ./node_modules/vue/dist/vue.common.dev.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!\n * Vue.js v2.6.10\n * (c) 2014-2019 Evan You\n * Released under the MIT License.\n */\n\n\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n// These helpers produce better VM code in JS engines due to their\n// explicitness and function inlining.\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n\n/**\n * Check if value is primitive.\n */\nfunction isPrimitive (value) {\n  return (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    // $flow-disable-line\n    typeof value === 'symbol' ||\n    typeof value === 'boolean'\n  )\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Get the raw type string of a value, e.g., [object Object].\n */\nvar _toString = Object.prototype.toString;\n\nfunction toRawType (value) {\n  return _toString.call(value).slice(8, -1)\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex (val) {\n  var n = parseFloat(String(val));\n  return n >= 0 && Math.floor(n) === n && isFinite(val)\n}\n\nfunction isPromise (val) {\n  return (\n    isDef(val) &&\n    typeof val.then === 'function' &&\n    typeof val.catch === 'function'\n  )\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert an input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Check if an attribute is a reserved attribute.\n */\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n\n/**\n * Remove an item from an array.\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether an object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /\\B([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str.replace(hyphenateRE, '-$1').toLowerCase()\n});\n\n/**\n * Simple bind polyfill for environments that do not support it,\n * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n * since native bind is now performant enough in most browsers.\n * But removing it would mean breaking code that was able to run in\n * PhantomJS 1.x, so this must be kept for backward compatibility.\n */\n\n/* istanbul ignore next */\nfunction polyfillBind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n\n  boundFn._length = fn.length;\n  return boundFn\n}\n\nfunction nativeBind (fn, ctx) {\n  return fn.bind(ctx)\n}\n\nvar bind = Function.prototype.bind\n  ? nativeBind\n  : polyfillBind;\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/* eslint-disable no-unused-vars */\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n */\nfunction noop (a, b, c) {}\n\n/**\n * Always return false.\n */\nvar no = function (a, b, c) { return false; };\n\n/* eslint-enable no-unused-vars */\n\n/**\n * Return the same value.\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a string containing static keys from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  if (a === b) { return true }\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i])\n        })\n      } else if (a instanceof Date && b instanceof Date) {\n        return a.getTime() === b.getTime()\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key])\n        })\n      } else {\n        /* istanbul ignore next */\n        return false\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\n/**\n * Return the first index at which a loosely equal value can be\n * found in the array (if value is a plain object, the array must\n * contain an object of the same shape), or -1 if it is not present.\n */\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated',\n  'errorCaptured',\n  'serverPrefetch'\n];\n\n/*  */\n\n\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  // $flow-disable-line\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: \"development\" !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: \"development\" !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  // $flow-disable-line\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Perform updates asynchronously. Intended to be used by Vue Test Utils\n   * This will significantly reduce performance if set to false.\n   */\n  async: true,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n});\n\n/*  */\n\n/**\n * unicode letters used for parsing html tags, component names and property paths.\n * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n */\nvar unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = new RegExp((\"[^\" + (unicodeRegExp.source) + \".$_\\\\d]\"));\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\nvar weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');\nvar isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\nvar isPhantomJS = UA && /phantomjs/.test(UA);\nvar isFF = UA && UA.match(/firefox\\/(\\d+)/);\n\n// Firefox has a \"watch\" function on Object.prototype...\nvar nativeWatch = ({}).watch;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    })); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\nvar _Set;\n/* istanbul ignore if */ // $flow-disable-line\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = /*@__PURE__*/(function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar generateComponentTrace = (noop); // work around flow check\nvar formatComponentName = (noop);\n\n{\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    var trace = vm ? generateComponentTrace(vm) : '';\n\n    if (config.warnHandler) {\n      config.warnHandler.call(null, msg, vm, trace);\n    } else if (hasConsole && (!config.silent)) {\n      console.error((\"[Vue warn]: \" + msg + trace));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var options = typeof vm === 'function' && vm.cid != null\n      ? vm.options\n      : vm._isVue\n        ? vm.$options || vm.constructor.options\n        : vm;\n    var name = options.name || options._componentTag;\n    var file = options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };\n\n  generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n            : formatComponentName(vm))); })\n        .join('\\n')\n    } else {\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n    }\n  };\n}\n\n/*  */\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  if (!config.async) {\n    // subs aren't sorted in scheduler if not running async\n    // we need to sort them now to make sure they fire in correct\n    // order\n    subs.sort(function (a, b) { return a.id - b.id; });\n  }\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// The current target watcher being evaluated.\n// This is globally unique because only one watcher\n// can be evaluated at a time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (target) {\n  targetStack.push(target);\n  Dep.target = target;\n}\n\nfunction popTarget () {\n  targetStack.pop();\n  Dep.target = targetStack[targetStack.length - 1];\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions,\n  asyncFactory\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.fnContext = undefined;\n  this.fnOptions = undefined;\n  this.fnScopeId = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = { child: { configurable: true } };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function (text) {\n  if ( text === void 0 ) text = '';\n\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    // #7975\n    // clone children array to avoid mutating original in case of cloning\n    // a child.\n    vnode.children && vnode.children.slice(),\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions,\n    vnode.asyncFactory\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.fnContext = vnode.fnContext;\n  cloned.fnOptions = vnode.fnOptions;\n  cloned.fnScopeId = vnode.fnScopeId;\n  cloned.asyncMeta = vnode.asyncMeta;\n  cloned.isCloned = true;\n  return cloned\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);\n\nvar methodsToPatch = [\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n];\n\n/**\n * Intercept mutating methods and emit events\n */\nmethodsToPatch.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * In some cases we may want to disable observation inside a component's\n * update computation.\n */\nvar shouldObserve = true;\n\nfunction toggleObserving (value) {\n  shouldObserve = value;\n}\n\n/**\n * Observer class that is attached to each observed\n * object. Once attached, the observer converts the target\n * object's property keys into getter/setters that\n * collect dependencies and dispatch updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    if (hasProto) {\n      protoAugment(value, arrayMethods);\n    } else {\n      copyAugment(value, arrayMethods, arrayKeys);\n    }\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through all properties and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment a target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment a target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    shouldObserve &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter,\n  shallow\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key];\n  }\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (customSetter) {\n        customSetter();\n      }\n      // #7981: for accessor properties without setter\n      if (getter && !setter) { return }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (isUndef(target) || isPrimitive(target)\n  ) {\n    warn((\"Cannot set reactive property on undefined, null, or primitive value: \" + ((target))));\n  }\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (key in target && !(key in Object.prototype)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (isUndef(target) || isPrimitive(target)\n  ) {\n    warn((\"Cannot delete reactive property on undefined, null, or primitive value: \" + ((target))));\n  }\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\n{\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n\n  var keys = hasSymbol\n    ? Reflect.ownKeys(from)\n    : Object.keys(from);\n\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    // in case the object is already observed...\n    if (key === '__ob__') { continue }\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (\n      toVal !== fromVal &&\n      isPlainObject(toVal) &&\n      isPlainObject(fromVal)\n    ) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nfunction mergeDataOrFn (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        typeof childVal === 'function' ? childVal.call(this, this) : childVal,\n        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal\n      )\n    }\n  } else {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm, vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm, vm)\n        : parentVal;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n}\n\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n      warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n\n      return parentVal\n    }\n    return mergeDataOrFn(parentVal, childVal)\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm)\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  var res = childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal;\n  return res\n    ? dedupeHooks(res)\n    : res\n}\n\nfunction dedupeHooks (hooks) {\n  var res = [];\n  for (var i = 0; i < hooks.length; i++) {\n    if (res.indexOf(hooks[i]) === -1) {\n      res.push(hooks[i]);\n    }\n  }\n  return res\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  var res = Object.create(parentVal || null);\n  if (childVal) {\n    assertObjectType(key, childVal, vm);\n    return extend(res, childVal)\n  } else {\n    return res\n  }\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) { parentVal = undefined; }\n  if (childVal === nativeWatch) { childVal = undefined; }\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key$1 in childVal) {\n    var parent = ret[key$1];\n    var child = childVal[key$1];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key$1] = parent\n      ? parent.concat(child)\n      : Array.isArray(child) ? child : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.inject =\nstrats.computed = function (\n  parentVal,\n  childVal,\n  vm,\n  key\n) {\n  if (childVal && \"development\" !== 'production') {\n    assertObjectType(key, childVal, vm);\n  }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  if (childVal) { extend(ret, childVal); }\n  return ret\n};\nstrats.provide = mergeDataOrFn;\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    validateComponentName(key);\n  }\n}\n\nfunction validateComponentName (name) {\n  if (!new RegExp((\"^[a-zA-Z][\\\\-\\\\.0-9_\" + (unicodeRegExp.source) + \"]*$\")).test(name)) {\n    warn(\n      'Invalid component name: \"' + name + '\". Component names ' +\n      'should conform to valid custom element name in html5 specification.'\n    );\n  }\n  if (isBuiltInTag(name) || config.isReservedTag(name)) {\n    warn(\n      'Do not use built-in or reserved HTML elements as component ' +\n      'id: ' + name\n    );\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options, vm) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  } else {\n    warn(\n      \"Invalid value for option \\\"props\\\": expected an Array or an Object, \" +\n      \"but got \" + (toRawType(props)) + \".\",\n      vm\n    );\n  }\n  options.props = res;\n}\n\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject (options, vm) {\n  var inject = options.inject;\n  if (!inject) { return }\n  var normalized = options.inject = {};\n  if (Array.isArray(inject)) {\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = { from: inject[i] };\n    }\n  } else if (isPlainObject(inject)) {\n    for (var key in inject) {\n      var val = inject[key];\n      normalized[key] = isPlainObject(val)\n        ? extend({ from: key }, val)\n        : { from: val };\n    }\n  } else {\n    warn(\n      \"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" +\n      \"but got \" + (toRawType(inject)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def$$1 = dirs[key];\n      if (typeof def$$1 === 'function') {\n        dirs[key] = { bind: def$$1, update: def$$1 };\n      }\n    }\n  }\n}\n\nfunction assertObjectType (name, value, vm) {\n  if (!isPlainObject(value)) {\n    warn(\n      \"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" +\n      \"but got \" + (toRawType(value)) + \".\",\n      vm\n    );\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child, vm);\n  normalizeInject(child, vm);\n  normalizeDirectives(child);\n\n  // Apply extends and mixins on the child options,\n  // but only if it is a raw options object that isn't\n  // the result of another mergeOptions call.\n  // Only merged options has the _base property.\n  if (!child._base) {\n    if (child.extends) {\n      parent = mergeOptions(parent, child.extends, vm);\n    }\n    if (child.mixins) {\n      for (var i = 0, l = child.mixins.length; i < l; i++) {\n        parent = mergeOptions(parent, child.mixins[i], vm);\n      }\n    }\n  }\n\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\n\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // boolean casting\n  var booleanIndex = getTypeIndex(Boolean, prop.type);\n  if (booleanIndex > -1) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (value === '' || value === hyphenate(key)) {\n      // only cast empty string / same name to boolean if\n      // boolean has higher priority\n      var stringIndex = getTypeIndex(String, prop.type);\n      if (stringIndex < 0 || booleanIndex < stringIndex) {\n        value = true;\n      }\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldObserve = shouldObserve;\n    toggleObserving(true);\n    observe(value);\n    toggleObserving(prevShouldObserve);\n  }\n  {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (isObject(def)) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n\n  if (!valid) {\n    warn(\n      getInvalidTypeMessage(name, value, expectedTypes),\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    var t = typeof value;\n    valid = t === expectedType.toLowerCase();\n    // for primitive wrapper objects\n    if (!valid && t === 'object') {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isSameType (a, b) {\n  return getType(a) === getType(b)\n}\n\nfunction getTypeIndex (type, expectedTypes) {\n  if (!Array.isArray(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1\n  }\n  for (var i = 0, len = expectedTypes.length; i < len; i++) {\n    if (isSameType(expectedTypes[i], type)) {\n      return i\n    }\n  }\n  return -1\n}\n\nfunction getInvalidTypeMessage (name, value, expectedTypes) {\n  var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" +\n    \" Expected \" + (expectedTypes.map(capitalize).join(', '));\n  var expectedType = expectedTypes[0];\n  var receivedType = toRawType(value);\n  var expectedValue = styleValue(value, expectedType);\n  var receivedValue = styleValue(value, receivedType);\n  // check if we need to specify expected value\n  if (expectedTypes.length === 1 &&\n      isExplicable(expectedType) &&\n      !isBoolean(expectedType, receivedType)) {\n    message += \" with value \" + expectedValue;\n  }\n  message += \", got \" + receivedType + \" \";\n  // check if we need to specify received value\n  if (isExplicable(receivedType)) {\n    message += \"with value \" + receivedValue + \".\";\n  }\n  return message\n}\n\nfunction styleValue (value, type) {\n  if (type === 'String') {\n    return (\"\\\"\" + value + \"\\\"\")\n  } else if (type === 'Number') {\n    return (\"\" + (Number(value)))\n  } else {\n    return (\"\" + value)\n  }\n}\n\nfunction isExplicable (value) {\n  var explicitTypes = ['string', 'number', 'boolean'];\n  return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })\n}\n\nfunction isBoolean () {\n  var args = [], len = arguments.length;\n  while ( len-- ) args[ len ] = arguments[ len ];\n\n  return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n  // See: https://github.com/vuejs/vuex/issues/1505\n  pushTarget();\n  try {\n    if (vm) {\n      var cur = vm;\n      while ((cur = cur.$parent)) {\n        var hooks = cur.$options.errorCaptured;\n        if (hooks) {\n          for (var i = 0; i < hooks.length; i++) {\n            try {\n              var capture = hooks[i].call(cur, err, vm, info) === false;\n              if (capture) { return }\n            } catch (e) {\n              globalHandleError(e, cur, 'errorCaptured hook');\n            }\n          }\n        }\n      }\n    }\n    globalHandleError(err, vm, info);\n  } finally {\n    popTarget();\n  }\n}\n\nfunction invokeWithErrorHandling (\n  handler,\n  context,\n  args,\n  vm,\n  info\n) {\n  var res;\n  try {\n    res = args ? handler.apply(context, args) : handler.call(context);\n    if (res && !res._isVue && isPromise(res) && !res._handled) {\n      res.catch(function (e) { return handleError(e, vm, info + \" (Promise/async)\"); });\n      // issue #9511\n      // avoid catch triggering multiple times when nested calls\n      res._handled = true;\n    }\n  } catch (e) {\n    handleError(e, vm, info);\n  }\n  return res\n}\n\nfunction globalHandleError (err, vm, info) {\n  if (config.errorHandler) {\n    try {\n      return config.errorHandler.call(null, err, vm, info)\n    } catch (e) {\n      // if the user intentionally throws the original error in the handler,\n      // do not log it twice\n      if (e !== err) {\n        logError(e, null, 'config.errorHandler');\n      }\n    }\n  }\n  logError(err, vm, info);\n}\n\nfunction logError (err, vm, info) {\n  {\n    warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n  }\n  /* istanbul ignore else */\n  if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n    console.error(err);\n  } else {\n    throw err\n  }\n}\n\n/*  */\n\nvar isUsingMicroTask = false;\n\nvar callbacks = [];\nvar pending = false;\n\nfunction flushCallbacks () {\n  pending = false;\n  var copies = callbacks.slice(0);\n  callbacks.length = 0;\n  for (var i = 0; i < copies.length; i++) {\n    copies[i]();\n  }\n}\n\n// Here we have async deferring wrappers using microtasks.\n// In 2.5 we used (macro) tasks (in combination with microtasks).\n// However, it has subtle problems when state is changed right before repaint\n// (e.g. #6813, out-in transitions).\n// Also, using (macro) tasks in event handler would cause some weird behaviors\n// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n// So we now use microtasks everywhere, again.\n// A major drawback of this tradeoff is that there are some scenarios\n// where microtasks have too high a priority and fire in between supposedly\n// sequential events (e.g. #4521, #6690, which have workarounds)\n// or even between bubbling of the same event (#6566).\nvar timerFunc;\n\n// The nextTick behavior leverages the microtask queue, which can be accessed\n// via either native Promise.then or MutationObserver.\n// MutationObserver has wider support, however it is seriously bugged in\n// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n// completely stops working after triggering a few times... so, if native\n// Promise is available, we will use it:\n/* istanbul ignore next, $flow-disable-line */\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\n  var p = Promise.resolve();\n  timerFunc = function () {\n    p.then(flushCallbacks);\n    // In problematic UIWebViews, Promise.then doesn't completely break, but\n    // it can get stuck in a weird state where callbacks are pushed into the\n    // microtask queue but the queue isn't being flushed, until the browser\n    // needs to do some other work, e.g. handle a timer. Therefore we can\n    // \"force\" the microtask queue to be flushed by adding an empty timer.\n    if (isIOS) { setTimeout(noop); }\n  };\n  isUsingMicroTask = true;\n} else if (!isIE && typeof MutationObserver !== 'undefined' && (\n  isNative(MutationObserver) ||\n  // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]'\n)) {\n  // Use MutationObserver where native Promise is not available,\n  // e.g. PhantomJS, iOS7, Android 4.4\n  // (#6466 MutationObserver is unreliable in IE11)\n  var counter = 1;\n  var observer = new MutationObserver(flushCallbacks);\n  var textNode = document.createTextNode(String(counter));\n  observer.observe(textNode, {\n    characterData: true\n  });\n  timerFunc = function () {\n    counter = (counter + 1) % 2;\n    textNode.data = String(counter);\n  };\n  isUsingMicroTask = true;\n} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n  // Fallback to setImmediate.\n  // Techinically it leverages the (macro) task queue,\n  // but it is still a better choice than setTimeout.\n  timerFunc = function () {\n    setImmediate(flushCallbacks);\n  };\n} else {\n  // Fallback to setTimeout.\n  timerFunc = function () {\n    setTimeout(flushCallbacks, 0);\n  };\n}\n\nfunction nextTick (cb, ctx) {\n  var _resolve;\n  callbacks.push(function () {\n    if (cb) {\n      try {\n        cb.call(ctx);\n      } catch (e) {\n        handleError(e, ctx, 'nextTick');\n      }\n    } else if (_resolve) {\n      _resolve(ctx);\n    }\n  });\n  if (!pending) {\n    pending = true;\n    timerFunc();\n  }\n  // $flow-disable-line\n  if (!cb && typeof Promise !== 'undefined') {\n    return new Promise(function (resolve) {\n      _resolve = resolve;\n    })\n  }\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\n{\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      // perf.clearMeasures(name)\n    };\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\n{\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      'referenced during render. Make sure that this property is reactive, ' +\n      'either in the data option, or for class-based components, by ' +\n      'initializing the property. ' +\n      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',\n      target\n    );\n  };\n\n  var warnReservedPrefix = function (target, key) {\n    warn(\n      \"Property \\\"\" + key + \"\\\" must be accessed with \\\"$data.\" + key + \"\\\" because \" +\n      'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' +\n      'prevent conflicts with Vue internals' +\n      'See: https://vuejs.org/v2/api/#data',\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' && isNative(Proxy);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) ||\n        (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));\n      if (!has && !isAllowed) {\n        if (key in target.$data) { warnReservedPrefix(target, key); }\n        else { warnNonPresent(target, key); }\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        if (key in target.$data) { warnReservedPrefix(target, key); }\n        else { warnNonPresent(target, key); }\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar seenObjects = new _Set();\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nfunction traverse (val) {\n  _traverse(val, seenObjects);\n  seenObjects.clear();\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns, vm) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n      for (var i = 0; i < cloned.length; i++) {\n        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n      }\n    } else {\n      // return handler return value for single handlers\n      return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\")\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  createOnceHandler,\n  vm\n) {\n  var name, def$$1, cur, old, event;\n  for (name in on) {\n    def$$1 = cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (isUndef(cur)) {\n      warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur, vm);\n      }\n      if (isTrue(event.once)) {\n        cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n      }\n      add(event.name, cur, event.capture, event.passive, event.params);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  if (def instanceof VNode) {\n    def = def.data.hook || (def.data.hook = {});\n  }\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && hasOwn(attrs, keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, lastIndex, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    lastIndex = res.length - 1;\n    last = res[lastIndex];\n    //  nested\n    if (Array.isArray(c)) {\n      if (c.length > 0) {\n        c = normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i));\n        // merge adjacent text nodes\n        if (isTextNode(c[0]) && isTextNode(last)) {\n          res[lastIndex] = createTextVNode(last.text + (c[0]).text);\n          c.shift();\n        }\n        res.push.apply(res, c);\n      }\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        res[lastIndex] = createTextVNode(last.text + c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[lastIndex] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    toggleObserving(false);\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\n            \"Avoid mutating an injected value directly since the changes will be \" +\n            \"overwritten whenever the provided component re-renders. \" +\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        });\n      }\n    });\n    toggleObserving(true);\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol\n      ? Reflect.ownKeys(inject)\n      : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      // #6574 in case the inject object is observed...\n      if (key === '__ob__') { continue }\n      var provideKey = inject[key].from;\n      var source = vm;\n      while (source) {\n        if (source._provided && hasOwn(source._provided, provideKey)) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n      if (!source) {\n        if ('default' in inject[key]) {\n          var provideDefault = inject[key].default;\n          result[key] = typeof provideDefault === 'function'\n            ? provideDefault.call(vm)\n            : provideDefault;\n        } else {\n          warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\n        }\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\n\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  if (!children || !children.length) {\n    return {}\n  }\n  var slots = {};\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    var data = child.data;\n    // remove slot attribute if the node is resolved as a Vue slot node\n    if (data && data.attrs && data.attrs.slot) {\n      delete data.attrs.slot;\n    }\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.fnContext === context) &&\n      data && data.slot != null\n    ) {\n      var name = data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children || []);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      (slots.default || (slots.default = [])).push(child);\n    }\n  }\n  // ignore slots that contains only whitespace\n  for (var name$1 in slots) {\n    if (slots[name$1].every(isWhitespace)) {\n      delete slots[name$1];\n    }\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return (node.isComment && !node.asyncFactory) || node.text === ' '\n}\n\n/*  */\n\nfunction normalizeScopedSlots (\n  slots,\n  normalSlots,\n  prevSlots\n) {\n  var res;\n  var hasNormalSlots = Object.keys(normalSlots).length > 0;\n  var isStable = slots ? !!slots.$stable : !hasNormalSlots;\n  var key = slots && slots.$key;\n  if (!slots) {\n    res = {};\n  } else if (slots._normalized) {\n    // fast path 1: child component re-render only, parent did not change\n    return slots._normalized\n  } else if (\n    isStable &&\n    prevSlots &&\n    prevSlots !== emptyObject &&\n    key === prevSlots.$key &&\n    !hasNormalSlots &&\n    !prevSlots.$hasNormal\n  ) {\n    // fast path 2: stable scoped slots w/ no normal slots to proxy,\n    // only need to normalize once\n    return prevSlots\n  } else {\n    res = {};\n    for (var key$1 in slots) {\n      if (slots[key$1] && key$1[0] !== '$') {\n        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n      }\n    }\n  }\n  // expose normal slots on scopedSlots\n  for (var key$2 in normalSlots) {\n    if (!(key$2 in res)) {\n      res[key$2] = proxyNormalSlot(normalSlots, key$2);\n    }\n  }\n  // avoriaz seems to mock a non-extensible $scopedSlots object\n  // and when that is passed down this would cause an error\n  if (slots && Object.isExtensible(slots)) {\n    (slots)._normalized = res;\n  }\n  def(res, '$stable', isStable);\n  def(res, '$key', key);\n  def(res, '$hasNormal', hasNormalSlots);\n  return res\n}\n\nfunction normalizeScopedSlot(normalSlots, key, fn) {\n  var normalized = function () {\n    var res = arguments.length ? fn.apply(null, arguments) : fn({});\n    res = res && typeof res === 'object' && !Array.isArray(res)\n      ? [res] // single vnode\n      : normalizeChildren(res);\n    return res && (\n      res.length === 0 ||\n      (res.length === 1 && res[0].isComment) // #9658\n    ) ? undefined\n      : res\n  };\n  // this is a slot using the new v-slot syntax without scope. although it is\n  // compiled as a scoped slot, render fn users would expect it to be present\n  // on this.$slots because the usage is semantically a normal slot.\n  if (fn.proxy) {\n    Object.defineProperty(normalSlots, key, {\n      get: normalized,\n      enumerable: true,\n      configurable: true\n    });\n  }\n  return normalized\n}\n\nfunction proxyNormalSlot(slots, key) {\n  return function () { return slots[key]; }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    if (hasSymbol && val[Symbol.iterator]) {\n      ret = [];\n      var iterator = val[Symbol.iterator]();\n      var result = iterator.next();\n      while (!result.done) {\n        ret.push(render(result.value, ret.length));\n        result = iterator.next();\n      }\n    } else {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n  }\n  if (!isDef(ret)) {\n    ret = [];\n  }\n  (ret)._isVList = true;\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  var nodes;\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      if (!isObject(bindObject)) {\n        warn(\n          'slot v-bind without argument expects an Object',\n          this\n        );\n      }\n      props = extend(extend({}, bindObject), props);\n    }\n    nodes = scopedSlotFn(props) || fallback;\n  } else {\n    nodes = this.$slots[name] || fallback;\n  }\n\n  var target = props && props.slot;\n  if (target) {\n    return this.$createElement('template', { slot: target }, nodes)\n  } else {\n    return nodes\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\nfunction isKeyNotMatch (expect, actual) {\n  if (Array.isArray(expect)) {\n    return expect.indexOf(actual) === -1\n  } else {\n    return expect !== actual\n  }\n}\n\n/**\n * Runtime helper for checking keyCodes from config.\n * exposed as Vue.prototype._k\n * passing in eventKeyName as last argument separately for backwards compat\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInKeyCode,\n  eventKeyName,\n  builtInKeyName\n) {\n  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n    return isKeyNotMatch(builtInKeyName, eventKeyName)\n  } else if (mappedKeyCode) {\n    return isKeyNotMatch(mappedKeyCode, eventKeyCode)\n  } else if (eventKeyName) {\n    return hyphenate(eventKeyName) !== key\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp,\n  isSync\n) {\n  if (value) {\n    if (!isObject(value)) {\n      warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      var loop = function ( key ) {\n        if (\n          key === 'class' ||\n          key === 'style' ||\n          isReservedAttribute(key)\n        ) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        var camelizedKey = camelize(key);\n        var hyphenatedKey = hyphenate(key);\n        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n            on[(\"update:\" + key)] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) loop( key );\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var cached = this._staticTrees || (this._staticTrees = []);\n  var tree = cached[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree.\n  if (tree && !isInFor) {\n    return tree\n  }\n  // otherwise, render a fresh tree.\n  tree = cached[index] = this.$options.staticRenderFns[index].call(\n    this._renderProxy,\n    null,\n    this // for render fns generated for functional component templates\n  );\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction bindObjectListeners (data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n      warn(\n        'v-on without argument expects an Object value',\n        this\n      );\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(existing, ours) : ours;\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res,\n  // the following are added in 2.6\n  hasDynamicKeys,\n  contentHashKey\n) {\n  res = res || { $stable: !hasDynamicKeys };\n  for (var i = 0; i < fns.length; i++) {\n    var slot = fns[i];\n    if (Array.isArray(slot)) {\n      resolveScopedSlots(slot, res, hasDynamicKeys);\n    } else if (slot) {\n      // marker for reverse proxying v-slot without scope on this.$slots\n      if (slot.proxy) {\n        slot.fn.proxy = true;\n      }\n      res[slot.key] = slot.fn;\n    }\n  }\n  if (contentHashKey) {\n    (res).$key = contentHashKey;\n  }\n  return res\n}\n\n/*  */\n\nfunction bindDynamicKeys (baseObj, values) {\n  for (var i = 0; i < values.length; i += 2) {\n    var key = values[i];\n    if (typeof key === 'string' && key) {\n      baseObj[values[i]] = values[i + 1];\n    } else if (key !== '' && key !== null) {\n      // null is a speical value for explicitly removing a binding\n      warn(\n        (\"Invalid value for dynamic directive argument (expected string or null): \" + key),\n        this\n      );\n    }\n  }\n  return baseObj\n}\n\n// helper to dynamically append modifier runtime markers to event names.\n// ensure only append when value is already string, otherwise it will be cast\n// to string and cause the type check to miss.\nfunction prependModifier (value, symbol) {\n  return typeof value === 'string' ? symbol + value : value\n}\n\n/*  */\n\nfunction installRenderHelpers (target) {\n  target._o = markOnce;\n  target._n = toNumber;\n  target._s = toString;\n  target._l = renderList;\n  target._t = renderSlot;\n  target._q = looseEqual;\n  target._i = looseIndexOf;\n  target._m = renderStatic;\n  target._f = resolveFilter;\n  target._k = checkKeyCodes;\n  target._b = bindObjectProps;\n  target._v = createTextVNode;\n  target._e = createEmptyVNode;\n  target._u = resolveScopedSlots;\n  target._g = bindObjectListeners;\n  target._d = bindDynamicKeys;\n  target._p = prependModifier;\n}\n\n/*  */\n\nfunction FunctionalRenderContext (\n  data,\n  props,\n  children,\n  parent,\n  Ctor\n) {\n  var this$1 = this;\n\n  var options = Ctor.options;\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var contextVm;\n  if (hasOwn(parent, '_uid')) {\n    contextVm = Object.create(parent);\n    // $flow-disable-line\n    contextVm._original = parent;\n  } else {\n    // the context vm passed in is a functional context as well.\n    // in this case we want to make sure we are able to get a hold to the\n    // real context instance.\n    contextVm = parent;\n    // $flow-disable-line\n    parent = parent._original;\n  }\n  var isCompiled = isTrue(options._compiled);\n  var needNormalization = !isCompiled;\n\n  this.data = data;\n  this.props = props;\n  this.children = children;\n  this.parent = parent;\n  this.listeners = data.on || emptyObject;\n  this.injections = resolveInject(options.inject, parent);\n  this.slots = function () {\n    if (!this$1.$slots) {\n      normalizeScopedSlots(\n        data.scopedSlots,\n        this$1.$slots = resolveSlots(children, parent)\n      );\n    }\n    return this$1.$slots\n  };\n\n  Object.defineProperty(this, 'scopedSlots', ({\n    enumerable: true,\n    get: function get () {\n      return normalizeScopedSlots(data.scopedSlots, this.slots())\n    }\n  }));\n\n  // support for compiled functional template\n  if (isCompiled) {\n    // exposing $options for renderStatic()\n    this.$options = options;\n    // pre-resolve slots for renderSlot()\n    this.$slots = this.slots();\n    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n  }\n\n  if (options._scopeId) {\n    this._c = function (a, b, c, d) {\n      var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n      if (vnode && !Array.isArray(vnode)) {\n        vnode.fnScopeId = options._scopeId;\n        vnode.fnContext = parent;\n      }\n      return vnode\n    };\n  } else {\n    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };\n  }\n}\n\ninstallRenderHelpers(FunctionalRenderContext.prototype);\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  contextVm,\n  children\n) {\n  var options = Ctor.options;\n  var props = {};\n  var propOptions = options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || emptyObject);\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n\n  var renderContext = new FunctionalRenderContext(\n    data,\n    props,\n    children,\n    contextVm,\n    Ctor\n  );\n\n  var vnode = options.render.call(null, renderContext._c, renderContext);\n\n  if (vnode instanceof VNode) {\n    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)\n  } else if (Array.isArray(vnode)) {\n    var vnodes = normalizeChildren(vnode) || [];\n    var res = new Array(vnodes.length);\n    for (var i = 0; i < vnodes.length; i++) {\n      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n    }\n    return res\n  }\n}\n\nfunction cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {\n  // #7817 clone node before setting fnContext, otherwise if the node is reused\n  // (e.g. it was from a cached normal slot) the fnContext causes named slots\n  // that should not be matched to match.\n  var clone = cloneVNode(vnode);\n  clone.fnContext = contextVm;\n  clone.fnOptions = options;\n  {\n    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n  }\n  if (data.slot) {\n    (clone.data || (clone.data = {})).slot = data.slot;\n  }\n  return clone\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n/*  */\n\n/*  */\n\n/*  */\n\n// inline hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (vnode, hydrating) {\n    if (\n      vnode.componentInstance &&\n      !vnode.componentInstance._isDestroyed &&\n      vnode.data.keepAlive\n    ) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    } else {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  var asyncFactory;\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(\n        asyncFactory,\n        data,\n        context,\n        children,\n        tag\n      )\n    }\n  }\n\n  data = data || {};\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n\n    // work around flow\n    var slot = data.slot;\n    data = {};\n    if (slot) {\n      data.slot = slot;\n    }\n  }\n\n  // install component management hooks onto the placeholder node\n  installComponentHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n    asyncFactory\n  );\n\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent // activeInstance in lifecycle state\n) {\n  var options = {\n    _isComponent: true,\n    _parentVnode: vnode,\n    parent: parent\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnode.componentOptions.Ctor(options)\n}\n\nfunction installComponentHooks (data) {\n  var hooks = data.hook || (data.hook = {});\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var existing = hooks[key];\n    var toMerge = componentVNodeHooks[key];\n    if (existing !== toMerge && !(existing && existing._merged)) {\n      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n    }\n  }\n}\n\nfunction mergeHook$1 (f1, f2) {\n  var merged = function (a, b) {\n    // flow complains about extra args which is why we use any\n    f1(a, b);\n    f2(a, b);\n  };\n  merged._merged = true;\n  return merged\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input'\n  ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  var existing = on[event];\n  var callback = data.model.callback;\n  if (isDef(existing)) {\n    if (\n      Array.isArray(existing)\n        ? existing.indexOf(callback) === -1\n        : existing !== callback\n    ) {\n      on[event] = [callback].concat(existing);\n    }\n  } else {\n    on[event] = callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n    warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  // object syntax in v-bind\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // warn against non-primitive key\n  if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)\n  ) {\n    {\n      warn(\n        'Avoid using non-primitive value as key, ' +\n        'use string/number value instead.',\n        context\n      );\n    }\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (Array.isArray(vnode)) {\n    return vnode\n  } else if (isDef(vnode)) {\n    if (isDef(ns)) { applyNS(vnode, ns); }\n    if (isDef(data)) { registerDeepBindings(data); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns, force) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    ns = undefined;\n    force = true;\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && (\n        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\n        applyNS(child, ns, force);\n      }\n    }\n  }\n}\n\n// ref #5318\n// necessary to ensure parent re-render when deep bindings like :style and\n// :class are used on slot nodes\nfunction registerDeepBindings (data) {\n  if (isObject(data.style)) {\n    traverse(data.style);\n  }\n  if (isObject(data.class)) {\n    traverse(data.class);\n  }\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null; // v-once cached trees\n  var options = vm.$options;\n  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n  // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  var parentData = parentVnode && parentVnode.data;\n\n  /* istanbul ignore else */\n  {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n    }, true);\n    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {\n      !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n    }, true);\n  }\n}\n\nvar currentRenderingInstance = null;\n\nfunction renderMixin (Vue) {\n  // install runtime convenience helpers\n  installRenderHelpers(Vue.prototype);\n\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var _parentVnode = ref._parentVnode;\n\n    if (_parentVnode) {\n      vm.$scopedSlots = normalizeScopedSlots(\n        _parentVnode.data.scopedSlots,\n        vm.$slots,\n        vm.$scopedSlots\n      );\n    }\n\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      // There's no need to maintain a stack becaues all render fns are called\n      // separately from one another. Nested component's render fns are called\n      // when parent component is patched.\n      currentRenderingInstance = vm;\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (vm.$options.renderError) {\n        try {\n          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n        } catch (e) {\n          handleError(e, vm, \"renderError\");\n          vnode = vm._vnode;\n        }\n      } else {\n        vnode = vm._vnode;\n      }\n    } finally {\n      currentRenderingInstance = null;\n    }\n    // if the returned array contains only a single node, allow it\n    if (Array.isArray(vnode) && vnode.length === 1) {\n      vnode = vnode[0];\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  if (\n    comp.__esModule ||\n    (hasSymbol && comp[Symbol.toStringTag] === 'Module')\n  ) {\n    comp = comp.default;\n  }\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction createAsyncPlaceholder (\n  factory,\n  data,\n  context,\n  children,\n  tag\n) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n  return node\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  var owner = currentRenderingInstance;\n  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n    // already pending\n    factory.owners.push(owner);\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (owner && !isDef(factory.owners)) {\n    var owners = factory.owners = [owner];\n    var sync = true;\n    var timerLoading = null;\n    var timerTimeout = null\n\n    ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });\n\n    var forceRender = function (renderCompleted) {\n      for (var i = 0, l = owners.length; i < l; i++) {\n        (owners[i]).$forceUpdate();\n      }\n\n      if (renderCompleted) {\n        owners.length = 0;\n        if (timerLoading !== null) {\n          clearTimeout(timerLoading);\n          timerLoading = null;\n        }\n        if (timerTimeout !== null) {\n          clearTimeout(timerTimeout);\n          timerTimeout = null;\n        }\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender(true);\n      } else {\n        owners.length = 0;\n      }\n    });\n\n    var reject = once(function (reason) {\n      warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender(true);\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (isPromise(res)) {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isPromise(res.component)) {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            timerLoading = setTimeout(function () {\n              timerLoading = null;\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender(false);\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          timerTimeout = setTimeout(function () {\n            timerTimeout = null;\n            if (isUndef(factory.resolved)) {\n              reject(\n                \"timeout (\" + (res.timeout) + \"ms)\"\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction isAsyncPlaceholder (node) {\n  return node.isComment && node.asyncFactory\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn) {\n  target.$on(event, fn);\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction createOnceHandler (event, fn) {\n  var _target = target;\n  return function onceHandler () {\n    var res = fn.apply(null, arguments);\n    if (res !== null) {\n      _target.$off(event, onceHandler);\n    }\n  }\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n  target = undefined;\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        vm.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        vm.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (!fn) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      var info = \"event handler for \\\"\" + event + \"\\\"\";\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction setActiveInstance(vm) {\n  var prevActiveInstance = activeInstance;\n  activeInstance = vm;\n  return function () {\n    activeInstance = prevActiveInstance;\n  }\n}\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var restoreActiveInstance = setActiveInstance(vm);\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    restoreActiveInstance();\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // release circular reference (#6759)\n    if (vm.$vnode) {\n      vm.$vnode.parent = null;\n    }\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((\"vue \" + name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((\"vue \" + name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  new Watcher(vm, updateComponent, noop, {\n    before: function before () {\n      if (vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'beforeUpdate');\n      }\n    }\n  }, true /* isRenderWatcher */);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  {\n    isUpdatingChildComponent = true;\n  }\n\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren.\n\n  // check if there are dynamic scopedSlots (hand-written or compiled but with\n  // dynamic slot names). Static scoped slots compiled from template has the\n  // \"$stable\" marker.\n  var newScopedSlots = parentVnode.data.scopedSlots;\n  var oldScopedSlots = vm.$scopedSlots;\n  var hasDynamicScopedSlot = !!(\n    (newScopedSlots && !newScopedSlots.$stable) ||\n    (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||\n    (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)\n  );\n\n  // Any static slot children from the parent may have changed during parent's\n  // update. Dynamic scoped slots may also have changed. In such cases, a forced\n  // update is necessary to ensure correctness.\n  var needsForceUpdate = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    hasDynamicScopedSlot\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update $attrs and $listeners hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n  vm.$attrs = parentVnode.data.attrs || emptyObject;\n  vm.$listeners = listeners || emptyObject;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    toggleObserving(false);\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      var propOptions = vm.$options.props; // wtf flow?\n      props[key] = validateProp(key, propOptions, propsData, vm);\n    }\n    toggleObserving(true);\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n\n  // update listeners\n  listeners = listeners || emptyObject;\n  var oldListeners = vm.$options._parentListeners;\n  vm.$options._parentListeners = listeners;\n  updateComponentListeners(vm, listeners, oldListeners);\n\n  // resolve slots + force update if has children\n  if (needsForceUpdate) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  {\n    isUpdatingChildComponent = false;\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  // #7573 disable dep collection when invoking lifecycle hooks\n  pushTarget();\n  var handlers = vm.$options[hook];\n  var info = hook + \" hook\";\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n  popTarget();\n}\n\n/*  */\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n// Async edge case #6566 requires saving the timestamp when event listeners are\n// attached. However, calling performance.now() has a perf overhead especially\n// if the page has thousands of event listeners. Instead, we take a timestamp\n// every time the scheduler flushes and use that for all event listeners\n// attached during that flush.\nvar currentFlushTimestamp = 0;\n\n// Async edge case fix requires storing an event listener's attach timestamp.\nvar getNow = Date.now;\n\n// Determine what event timestamp the browser is using. Annoyingly, the\n// timestamp can either be hi-res (relative to page load) or low-res\n// (relative to UNIX epoch), so in order to compare time we have to use the\n// same timestamp type when saving the flush timestamp.\n// All IE versions use low-res event timestamps, and have problematic clock\n// implementations (#9632)\nif (inBrowser && !isIE) {\n  var performance = window.performance;\n  if (\n    performance &&\n    typeof performance.now === 'function' &&\n    getNow() > document.createEvent('Event').timeStamp\n  ) {\n    // if the event timestamp, although evaluated AFTER the Date.now(), is\n    // smaller than it, it means the event is using a hi-res timestamp,\n    // and we need to use the hi-res version for event listener timestamps as\n    // well.\n    getNow = function () { return performance.now(); };\n  }\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  currentFlushTimestamp = getNow();\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    if (watcher.before) {\n      watcher.before();\n    }\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n\n      if (!config.async) {\n        flushSchedulerQueue();\n        return\n      }\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\n\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options,\n  isRenderWatcher\n) {\n  this.vm = vm;\n  if (isRenderWatcher) {\n    vm._watcher = this;\n  }\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n    this.before = options.before;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = expOrFn.toString();\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = noop;\n      warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    } else {\n      throw e\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    popTarget();\n    this.cleanupDeps();\n  }\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this.deps[i];\n    if (!this.newDepIds.has(dep.id)) {\n      dep.removeSub(this);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n  var i = this.deps.length;\n  while (i--) {\n    this.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this.deps[i].removeSub(this);\n    }\n    this.active = false;\n  }\n};\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  if (!isRoot) {\n    toggleObserving(false);\n  }\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    {\n      var hyphenatedKey = hyphenate(key);\n      if (isReservedAttribute(hyphenatedKey) ||\n          config.isReservedAttr(hyphenatedKey)) {\n        warn(\n          (\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (!isRoot && !isUpdatingChildComponent) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  toggleObserving(true);\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n  while (i--) {\n    var key = keys[i];\n    {\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\n          vm\n        );\n      }\n    }\n    if (props && hasOwn(props, key)) {\n      warn(\n        \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  // #7573 disable dep collection when invoking data getters\n  pushTarget();\n  try {\n    return data.call(vm, vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  } finally {\n    popTarget();\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  // $flow-disable-line\n  var watchers = vm._computedWatchers = Object.create(null);\n  // computed properties are just getters during SSR\n  var isSSR = isServerRendering();\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (getter == null) {\n      warn(\n        (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\n        vm\n      );\n    }\n\n    if (!isSSR) {\n      // create internal watcher for the computed property.\n      watchers[key] = new Watcher(\n        vm,\n        getter || noop,\n        noop,\n        computedWatcherOptions\n      );\n    }\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else {\n      if (key in vm.$data) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed (\n  target,\n  key,\n  userDef\n) {\n  var shouldCache = !isServerRendering();\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = shouldCache\n      ? createComputedGetter(key)\n      : createGetterInvoker(userDef);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? shouldCache && userDef.cache !== false\n        ? createComputedGetter(key)\n        : createGetterInvoker(userDef.get)\n      : noop;\n    sharedPropertyDefinition.set = userDef.set || noop;\n  }\n  if (sharedPropertyDefinition.set === noop) {\n    sharedPropertyDefinition.set = function () {\n      warn(\n        (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\n        this\n      );\n    };\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction createGetterInvoker(fn) {\n  return function computedGetter () {\n    return fn.call(this, this)\n  }\n}\n\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    {\n      if (typeof methods[key] !== 'function') {\n        warn(\n          \"Method \\\"\" + key + \"\\\" has type \\\"\" + (typeof methods[key]) + \"\\\" in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n      if ((key in vm) && isReserved(key)) {\n        warn(\n          \"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" +\n          \"Avoid defining component methods that start with _ or $.\"\n        );\n      }\n    }\n    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n  }\n}\n\nfunction initWatch (vm, watch) {\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (\n  vm,\n  expOrFn,\n  handler,\n  options\n) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  return vm.$watch(expOrFn, handler, options)\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  {\n    dataDef.set = function () {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      try {\n        cb.call(vm, watcher.value);\n      } catch (error) {\n        handleError(error, vm, (\"callback for immediate watcher \\\"\" + (watcher.expression) + \"\\\"\"));\n      }\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nvar uid$3 = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$3++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (config.performance && mark) {\n      startTag = \"vue-perf-start:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    {\n      initProxy(vm);\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure((\"vue \" + (vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  var parentVnode = options._parentVnode;\n  opts.parent = options.parent;\n  opts._parentVnode = parentVnode;\n\n  var vnodeComponentOptions = parentVnode.componentOptions;\n  opts.propsData = vnodeComponentOptions.propsData;\n  opts._parentListeners = vnodeComponentOptions.listeners;\n  opts._renderChildren = vnodeComponentOptions.children;\n  opts._componentTag = vnodeComponentOptions.tag;\n\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = latest[key];\n    }\n  }\n  return modified\n}\n\nfunction Vue (options) {\n  if (!(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue);\nstateMixin(Vue);\neventsMixin(Vue);\nlifecycleMixin(Vue);\nrenderMixin(Vue);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this\n    }\n\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    installedPlugins.push(plugin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (name) {\n      validateComponentName(name);\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (type === 'component') {\n          validateComponentName(id);\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\n\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (keepAliveInstance, filter) {\n  var cache = keepAliveInstance.cache;\n  var keys = keepAliveInstance.keys;\n  var _vnode = keepAliveInstance._vnode;\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        pruneCacheEntry(cache, key, keys, _vnode);\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (\n  cache,\n  key,\n  keys,\n  current\n) {\n  var cached$$1 = cache[key];\n  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n    cached$$1.componentInstance.$destroy();\n  }\n  cache[key] = null;\n  remove(keys, key);\n}\n\nvar patternTypes = [String, RegExp, Array];\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes,\n    max: [String, Number]\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n    this.keys = [];\n  },\n\n  destroyed: function destroyed () {\n    for (var key in this.cache) {\n      pruneCacheEntry(this.cache, key, this.keys);\n    }\n  },\n\n  mounted: function mounted () {\n    var this$1 = this;\n\n    this.$watch('include', function (val) {\n      pruneCache(this$1, function (name) { return matches(val, name); });\n    });\n    this.$watch('exclude', function (val) {\n      pruneCache(this$1, function (name) { return !matches(val, name); });\n    });\n  },\n\n  render: function render () {\n    var slot = this.$slots.default;\n    var vnode = getFirstComponentChild(slot);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      var ref = this;\n      var include = ref.include;\n      var exclude = ref.exclude;\n      if (\n        // not included\n        (include && (!name || !matches(include, name))) ||\n        // excluded\n        (exclude && name && matches(exclude, name))\n      ) {\n        return vnode\n      }\n\n      var ref$1 = this;\n      var cache = ref$1.cache;\n      var keys = ref$1.keys;\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (cache[key]) {\n        vnode.componentInstance = cache[key].componentInstance;\n        // make current key freshest\n        remove(keys, key);\n        keys.push(key);\n      } else {\n        cache[key] = vnode;\n        keys.push(key);\n        // prune oldest entry\n        if (this.max && keys.length > parseInt(this.max)) {\n          pruneCacheEntry(cache, keys[0], keys, this._vnode);\n        }\n      }\n\n      vnode.data.keepAlive = true;\n    }\n    return vnode || (slot && slot[0])\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  // 2.6 explicit observable API\n  Vue.observable = function (obj) {\n    observe(obj);\n    return obj\n  };\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue);\n\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n});\n\n// expose FunctionalRenderContext for ssr runtime helper installation\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n});\n\nVue.version = '2.6.10';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select,progress');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\nvar convertEnumeratedValue = function (key, value) {\n  return isFalsyAttrValue(value) || value === 'false'\n    ? 'false'\n    // allow arbitrary string value for contenteditable\n    : key === 'contenteditable' && isValidContentEditableValue(value)\n      ? value\n      : 'true'\n};\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode && childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode && parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return renderClass(data.staticClass, data.class)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction renderClass (\n  staticClass,\n  dynamicClass\n) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value)\n  }\n  if (isObject(value)) {\n    return stringifyObject(value)\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction stringifyArray (value) {\n  var res = '';\n  var stringified;\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) { res += ' '; }\n      res += stringified;\n    }\n  }\n  return res\n}\n\nfunction stringifyObject (value) {\n  var res = '';\n  for (var key in value) {\n    if (value[key]) {\n      if (res) { res += ' '; }\n      res += key;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template,blockquote,iframe,tfoot'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setStyleScope (node, scopeId) {\n  node.setAttribute(scopeId, '');\n}\n\nvar nodeOps = /*#__PURE__*/Object.freeze({\n  createElement: createElement$1,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setStyleScope: setStyleScope\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!isDef(key)) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  function isUnknownElement$$1 (vnode, inVPre) {\n    return (\n      !inVPre &&\n      !vnode.ns &&\n      !(\n        config.ignoredElements.length &&\n        config.ignoredElements.some(function (ignore) {\n          return isRegExp(ignore)\n            ? ignore.test(vnode.tag)\n            : ignore === vnode.tag\n        })\n      ) &&\n      config.isUnknownElement(vnode.tag)\n    )\n  }\n\n  var creatingElmInVPre = 0;\n\n  function createElm (\n    vnode,\n    insertedVnodeQueue,\n    parentElm,\n    refElm,\n    nested,\n    ownerArray,\n    index\n  ) {\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // This vnode was used in a previous render!\n      // now it's used as a new node, overwriting its elm would cause\n      // potential patch errors down the road when it's used as an insertion\n      // reference node. Instead, we clone the node on-demand before creating\n      // associated DOM element for it.\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      {\n        if (data && data.pre) {\n          creatingElmInVPre++;\n        }\n        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (data && data.pre) {\n        creatingElmInVPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        insert(parentElm, vnode.elm, refElm);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (nodeOps.parentNode(ref$$1) === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      {\n        checkDuplicateKeys(children);\n      }\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    if (isDef(i = vnode.fnScopeId)) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    } else {\n      var ancestor = vnode;\n      while (ancestor) {\n        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n          nodeOps.setStyleScope(vnode.elm, i);\n        }\n        ancestor = ancestor.parent;\n      }\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      i !== vnode.fnContext &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setStyleScope(vnode.elm, i);\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    {\n      checkDuplicateKeys(newCh);\n    }\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key)\n          ? oldKeyToIdx[newStartVnode.key]\n          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n        } else {\n          vnodeToMove = oldCh[idxInOld];\n          if (sameVnode(vnodeToMove, newStartVnode)) {\n            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          }\n        }\n        newStartVnode = newCh[++newStartIdx];\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function checkDuplicateKeys (children) {\n    var seenKeys = {};\n    for (var i = 0; i < children.length; i++) {\n      var vnode = children[i];\n      var key = vnode.key;\n      if (isDef(key)) {\n        if (seenKeys[key]) {\n          warn(\n            (\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\"),\n            vnode.context\n          );\n        } else {\n          seenKeys[key] = true;\n        }\n      }\n    }\n  }\n\n  function findIdxInOld (node, oldCh, start, end) {\n    for (var i = start; i < end; i++) {\n      var c = oldCh[i];\n      if (isDef(c) && sameVnode(node, c)) { return i }\n    }\n  }\n\n  function patchVnode (\n    oldVnode,\n    vnode,\n    insertedVnodeQueue,\n    ownerArray,\n    index,\n    removeOnly\n  ) {\n    if (oldVnode === vnode) {\n      return\n    }\n\n    if (isDef(vnode.elm) && isDef(ownerArray)) {\n      // clone reused vnode\n      vnode = ownerArray[index] = cloneVNode(vnode);\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n      return\n    }\n\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        {\n          checkDuplicateKeys(ch);\n        }\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var hydrationBailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  // Note: style is excluded because it relies on initial clone for future\n  // deep updates (#7063).\n  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {\n    var i;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    inVPre = inVPre || (data && data.pre);\n    vnode.elm = elm;\n\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.isAsyncPlaceholder = true;\n      return true\n    }\n    // assert node match\n    {\n      if (!assertNodeMatch(elm, vnode, inVPre)) {\n        return false\n      }\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          // v-html and domProps: innerHTML\n          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n            if (i !== elm.innerHTML) {\n              /* istanbul ignore if */\n              if (typeof console !== 'undefined' &&\n                !hydrationBailed\n              ) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('server innerHTML: ', i);\n                console.warn('client innerHTML: ', elm.innerHTML);\n              }\n              return false\n            }\n          } else {\n            // iterate and compare children lists\n            var childrenMatch = true;\n            var childNode = elm.firstChild;\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\n              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                childrenMatch = false;\n                break\n              }\n              childNode = childNode.nextSibling;\n            }\n            // if childNode is not null, it means the actual childNodes list is\n            // longer than the virtual children list.\n            if (!childrenMatch || childNode) {\n              /* istanbul ignore if */\n              if (typeof console !== 'undefined' &&\n                !hydrationBailed\n              ) {\n                hydrationBailed = true;\n                console.warn('Parent: ', elm);\n                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n              }\n              return false\n            }\n          }\n        }\n      }\n      if (isDef(data)) {\n        var fullInvoke = false;\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            fullInvoke = true;\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n        if (!fullInvoke && data['class']) {\n          // ensure collecting deps for deep class bindings for future updates\n          traverse(data['class']);\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode, inVPre) {\n    if (isDef(vnode.tag)) {\n      return vnode.tag.indexOf('vue-component') === 0 || (\n        !isUnknownElement$$1(vnode, inVPre) &&\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm = nodeOps.parentNode(oldElm);\n\n        // create new node\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        // update parent placeholder node element, recursively\n        if (isDef(vnode.parent)) {\n          var ancestor = vnode.parent;\n          var patchable = isPatchable(vnode);\n          while (ancestor) {\n            for (var i = 0; i < cbs.destroy.length; ++i) {\n              cbs.destroy[i](ancestor);\n            }\n            ancestor.elm = vnode.elm;\n            if (patchable) {\n              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                cbs.create[i$1](emptyNode, ancestor);\n              }\n              // #6513\n              // invoke insert hooks that may have been merged by create hooks.\n              // e.g. for directives that uses the \"inserted\" hook.\n              var insert = ancestor.data.hook.insert;\n              if (insert.merged) {\n                // start at index 1 to avoid re-invoking component mounted hook\n                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                  insert.fns[i$2]();\n                }\n              }\n            } else {\n              registerRef(ancestor);\n            }\n            ancestor = ancestor.parent;\n          }\n        }\n\n        // destroy old node\n        if (isDef(parentElm)) {\n          removeVnodes(parentElm, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      dir.oldArg = oldDir.arg;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode, 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode, 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    // $flow-disable-line\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      // $flow-disable-line\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  // $flow-disable-line\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return\n  }\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  // #6666: IE/Edge forces progress value down to 1 before setting a max\n  /* istanbul ignore if */\n  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (el.tagName.indexOf('-') > -1) {\n    baseSetAttr(el, key, value);\n  } else if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // technically allowfullscreen is a boolean attribute for <iframe>,\n      // but Flash expects a value of \"true\" when used on <embed> tag\n      value = key === 'allowfullscreen' && el.tagName === 'EMBED'\n        ? 'true'\n        : key;\n      el.setAttribute(key, value);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, convertEnumeratedValue(key, value));\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    baseSetAttr(el, key, value);\n  }\n}\n\nfunction baseSetAttr (el, key, value) {\n  if (isFalsyAttrValue(value)) {\n    el.removeAttribute(key);\n  } else {\n    // #7138: IE10 & 11 fires input event when setting placeholder on\n    // <textarea>... block the first input event and remove the blocker\n    // immediately.\n    /* istanbul ignore if */\n    if (\n      isIE && !isIE9 &&\n      el.tagName === 'TEXTAREA' &&\n      key === 'placeholder' && value !== '' && !el.__ieph\n    ) {\n      var blocker = function (e) {\n        e.stopImmediatePropagation();\n        el.removeEventListener('input', blocker);\n      };\n      el.addEventListener('input', blocker);\n      // $flow-disable-line\n      el.__ieph = true; /* IE placeholder patched */\n    }\n    el.setAttribute(key, value);\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args))\n  }\n}\n\n/*  */\n\n\n\n/* eslint-disable no-unused-vars */\nfunction baseWarn (msg, range) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n/* eslint-enable no-unused-vars */\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value, range, dynamic) {\n  (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n  el.plain = false;\n}\n\nfunction addAttr (el, name, value, range, dynamic) {\n  var attrs = dynamic\n    ? (el.dynamicAttrs || (el.dynamicAttrs = []))\n    : (el.attrs || (el.attrs = []));\n  attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n  el.plain = false;\n}\n\n// add a raw attr (use this in preTransforms)\nfunction addRawAttr (el, name, value, range) {\n  el.attrsMap[name] = value;\n  el.attrsList.push(rangeSetItem({ name: name, value: value }, range));\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  isDynamicArg,\n  modifiers,\n  range\n) {\n  (el.directives || (el.directives = [])).push(rangeSetItem({\n    name: name,\n    rawName: rawName,\n    value: value,\n    arg: arg,\n    isDynamicArg: isDynamicArg,\n    modifiers: modifiers\n  }, range));\n  el.plain = false;\n}\n\nfunction prependModifierMarker (symbol, name, dynamic) {\n  return dynamic\n    ? (\"_p(\" + name + \",\\\"\" + symbol + \"\\\")\")\n    : symbol + name // mark the event as captured\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important,\n  warn,\n  range,\n  dynamic\n) {\n  modifiers = modifiers || emptyObject;\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (\n    warn &&\n    modifiers.prevent && modifiers.passive\n  ) {\n    warn(\n      'passive and prevent can\\'t be used together. ' +\n      'Passive handler can\\'t prevent default event.',\n      range\n    );\n  }\n\n  // normalize click.right and click.middle since they don't actually fire\n  // this is technically browser-specific, but at least for now browsers are\n  // the only target envs that have right/middle clicks.\n  if (modifiers.right) {\n    if (dynamic) {\n      name = \"(\" + name + \")==='click'?'contextmenu':(\" + name + \")\";\n    } else if (name === 'click') {\n      name = 'contextmenu';\n      delete modifiers.right;\n    }\n  } else if (modifiers.middle) {\n    if (dynamic) {\n      name = \"(\" + name + \")==='click'?'mouseup':(\" + name + \")\";\n    } else if (name === 'click') {\n      name = 'mouseup';\n    }\n  }\n\n  // check capture modifier\n  if (modifiers.capture) {\n    delete modifiers.capture;\n    name = prependModifierMarker('!', name, dynamic);\n  }\n  if (modifiers.once) {\n    delete modifiers.once;\n    name = prependModifierMarker('~', name, dynamic);\n  }\n  /* istanbul ignore if */\n  if (modifiers.passive) {\n    delete modifiers.passive;\n    name = prependModifierMarker('&', name, dynamic);\n  }\n\n  var events;\n  if (modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n\n  var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);\n  if (modifiers !== emptyObject) {\n    newHandler.modifiers = modifiers;\n  }\n\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n\n  el.plain = false;\n}\n\nfunction getRawBindingAttr (\n  el,\n  name\n) {\n  return el.rawAttrsMap[':' + name] ||\n    el.rawAttrsMap['v-bind:' + name] ||\n    el.rawAttrsMap[name]\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\n// note: this only removes the attr from the Array (attrsList) so that it\n// doesn't get processed by processAttrs.\n// By default it does NOT remove it from the map (attrsMap) because the map is\n// needed during codegen.\nfunction getAndRemoveAttr (\n  el,\n  name,\n  removeFromMap\n) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  if (removeFromMap) {\n    delete el.attrsMap[name];\n  }\n  return val\n}\n\nfunction getAndRemoveAttrByRegex (\n  el,\n  name\n) {\n  var list = el.attrsList;\n  for (var i = 0, l = list.length; i < l; i++) {\n    var attr = list[i];\n    if (name.test(attr.name)) {\n      list.splice(i, 1);\n      return attr\n    }\n  }\n}\n\nfunction rangeSetItem (\n  item,\n  range\n) {\n  if (range) {\n    if (range.start != null) {\n      item.start = range.start;\n    }\n    if (range.end != null) {\n      item.end = range.end;\n    }\n  }\n  return item\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n      \"? \" + baseValueExpression + \".trim()\" +\n      \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: JSON.stringify(value),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var res = parseModel(value);\n  if (res.key === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return (\"$set(\" + (res.exp) + \", \" + (res.key) + \", \" + assignment + \")\")\n  }\n}\n\n/**\n * Parse a v-model expression into a base path and a final key segment.\n * Handles both dot-path and possible square brackets.\n *\n * Possible cases:\n *\n * - test\n * - test[key]\n * - test[test1[key]]\n * - test[\"a\"][key]\n * - xxx.test[a[a].test1[key]]\n * - test.xxx.a[\"asa\"][test1[key]]\n *\n */\n\nvar len, str, chr, index$1, expressionPos, expressionEndPos;\n\n\n\nfunction parseModel (val) {\n  // Fix https://github.com/vuejs/vue/pull/7730\n  // allow v-model=\"obj.val \" (trailing whitespace)\n  val = val.trim();\n  len = val.length;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    index$1 = val.lastIndexOf('.');\n    if (index$1 > -1) {\n      return {\n        exp: val.slice(0, index$1),\n        key: '\"' + val.slice(index$1 + 1) + '\"'\n      }\n    } else {\n      return {\n        exp: val,\n        key: null\n      }\n    }\n  }\n\n  str = val;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.slice(0, expressionPos),\n    key: val.slice(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  {\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\",\n        el.rawAttrsMap['v-model']\n      );\n    }\n  }\n\n  if (el.component) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.',\n      el.rawAttrsMap['v-model']\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n    \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n      trueValueBinding === 'true'\n        ? (\":(\" + value + \")\")\n        : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n    )\n  );\n  addHandler(el, 'change',\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$el.checked){$$i<0&&(\" + (genAssignmentCode(value, '$$a.concat([$$v])')) + \")}\" +\n      \"else{$$i>-1&&(\" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + \")}\" +\n    \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n\n  // warn if v-bind:value conflicts with v-model\n  // except for inputs with v-bind:type\n  {\n    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (value$1 && !typeBinding) {\n      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n      warn$1(\n        binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" +\n        'because the latter already expands to a value binding internally',\n        el.rawAttrsMap[binding]\n      );\n    }\n  }\n\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number) {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    var event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  // This was originally intended to fix #4521 but no longer necessary\n  // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n  /* istanbul ignore if */\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction createOnceHandler$1 (event, handler, capture) {\n  var _target = target$1; // save current target element in closure\n  return function onceHandler () {\n    var res = handler.apply(null, arguments);\n    if (res !== null) {\n      remove$2(event, onceHandler, capture, _target);\n    }\n  }\n}\n\n// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n// implementation and does not fire microtasks in between event propagation, so\n// safe to exclude.\nvar useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\nfunction add$1 (\n  name,\n  handler,\n  capture,\n  passive\n) {\n  // async edge case #6566: inner click event triggers patch, event handler\n  // attached to outer element during patch, and triggered again. This\n  // happens because browsers fire microtask ticks between event propagation.\n  // the solution is simple: we save the timestamp when a handler is attached,\n  // and the handler would only fire if the event passed to it was fired\n  // AFTER it was attached.\n  if (useMicrotaskFix) {\n    var attachedTimestamp = currentFlushTimestamp;\n    var original = handler;\n    handler = original._wrapper = function (e) {\n      if (\n        // no bubbling, should always fire.\n        // this is just a safety net in case event.timeStamp is unreliable in\n        // certain weird environments...\n        e.target === e.currentTarget ||\n        // event is fired after handler attachment\n        e.timeStamp >= attachedTimestamp ||\n        // bail for environments that have buggy event.timeStamp implementations\n        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n        // #9681 QtWebEngine event.timeStamp is negative value\n        e.timeStamp <= 0 ||\n        // #9448 bail if event is fired in another document in a multi-page\n        // electron/nw.js app, since event.timeStamp will be using a different\n        // starting reference\n        e.target.ownerDocument !== document\n      ) {\n        return original.apply(this, arguments)\n      }\n    };\n  }\n  target$1.addEventListener(\n    name,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  name,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(\n    name,\n    handler._wrapper || handler,\n    capture\n  );\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n  target$1 = undefined;\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nvar svgContainer;\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (!(key in props)) {\n      elm[key] = '';\n    }\n  }\n\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n      // #6601 work around Chrome version <= 55 bug where single textNode\n      // replaced by innerHTML/textContent retains its parentNode property\n      if (elm.childNodes.length === 1) {\n        elm.removeChild(elm.childNodes[0]);\n      }\n    }\n\n    if (key === 'value' && elm.tagName !== 'PROGRESS') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, strCur)) {\n        elm.value = strCur;\n      }\n    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n      // IE doesn't support innerHTML for SVG elements\n      svgContainer = svgContainer || document.createElement('div');\n      svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n      var svg = svgContainer.firstChild;\n      while (elm.firstChild) {\n        elm.removeChild(elm.firstChild);\n      }\n      while (svg.firstChild) {\n        elm.appendChild(svg.firstChild);\n      }\n    } else if (\n      // skip the update if old and new VDOM state is the same.\n      // `value` is handled separately because the DOM value may be temporarily\n      // out of sync with VDOM state due to focus, composition and modifiers.\n      // This  #4521 by skipping the unnecesarry `checked` update.\n      cur !== oldProps[key]\n    ) {\n      // some property updates can throw\n      // e.g. `value` on <progress> w/ non-finite value\n      try {\n        elm[key] = cur;\n      } catch (e) {}\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (elm, checkVal) {\n  return (!elm.composing && (\n    elm.tagName === 'OPTION' ||\n    isNotInFocusAndDirty(elm, checkVal) ||\n    isDirtyWithModifiers(elm, checkVal)\n  ))\n}\n\nfunction isNotInFocusAndDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true;\n  // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n  try { notInFocus = document.activeElement !== elm; } catch (e) {}\n  return notInFocus && elm.value !== checkVal\n}\n\nfunction isDirtyWithModifiers (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (isDef(modifiers)) {\n    if (modifiers.number) {\n      return toNumber(value) !== toNumber(newVal)\n    }\n    if (modifiers.trim) {\n      return value.trim() !== newVal.trim()\n    }\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (\n        childNode && childNode.data &&\n        (styleData = normalizeStyleData(childNode.data))\n      ) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\n\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in emptyStyle)) {\n    return prop\n  }\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n    if (name in emptyStyle) {\n      return name\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likely wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\nvar whitespaceRE = /\\s+/;\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    cur = cur.trim();\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser\n  ? window.requestAnimationFrame\n    ? window.requestAnimationFrame.bind(window)\n    : setTimeout\n  : /* istanbul ignore next */ function (fn) { return fn(); };\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  // JSDOM may return undefined for transition properties\n  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n// in a locale-dependent way, using a comma instead of a dot.\n// If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n// as a floor function) causing unexpected behaviors\nfunction toMs (s) {\n  return Number(s.slice(0, -1).replace(',', '.')) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    context = transitionNode.context;\n    transitionNode = transitionNode.parent;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode, 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled) {\n        addTransitionClass(el, toClass);\n        if (!userWantsControl) {\n          if (isValidDuration(explicitEnterDuration)) {\n            setTimeout(cb, explicitEnterDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data) || el.nodeType !== 1) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb)) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (isDef(explicitLeaveDuration)) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show && el.parentNode) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled) {\n          addTransitionClass(el, leaveToClass);\n          if (!userWantsControl) {\n            if (isValidDuration(explicitLeaveDuration)) {\n              setTimeout(cb, explicitLeaveDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar directive = {\n  inserted: function inserted (el, binding, vnode, oldVnode) {\n    if (vnode.tag === 'select') {\n      // #6903\n      if (oldVnode.elm && !oldVnode.elm._vOptions) {\n        mergeVNodeHook(vnode, 'postpatch', function () {\n          directive.componentUpdated(el, binding, vnode);\n        });\n      } else {\n        setSelected(el, binding, vnode.context);\n      }\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        el.addEventListener('compositionstart', onCompositionStart);\n        el.addEventListener('compositionend', onCompositionEnd);\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n        // trigger change event if\n        // no matching option found for at least one value\n        var needReset = el.multiple\n          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\n          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n        if (needReset) {\n          trigger(el, 'change');\n        }\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  actuallySetSelected(el, binding, vm);\n  /* istanbul ignore if */\n  if (isIE || isEdge) {\n    setTimeout(function () {\n      actuallySetSelected(el, binding, vm);\n    }, 0);\n  }\n}\n\nfunction actuallySetSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  return options.every(function (o) { return !looseEqual(o, value); })\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (!value === !oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    if (transition$$1) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: directive,\n  show: show\n};\n\n/*  */\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nvar isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };\n\nvar isVShowDirective = function (d) { return d.name === 'show'; };\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(isNotTextNode);\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (mode && mode !== 'in-out' && mode !== 'out-in'\n    ) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? child.isComment\n        ? id + 'comment'\n        : id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n      child.data.show = true;\n    }\n\n    if (\n      oldChild &&\n      oldChild.data &&\n      !isSameChild(child, oldChild) &&\n      !isAsyncPlaceholder(oldChild) &&\n      // #6687 component root is a comment node\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)\n    ) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild.data.transition = extend({}, data);\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild\n        }\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  beforeMount: function beforeMount () {\n    var this$1 = this;\n\n    var update = this._update;\n    this._update = function (vnode, hydrating) {\n      var restoreActiveInstance = setActiveInstance(this$1);\n      // force removing pass\n      this$1.__patch__(\n        this$1._vnode,\n        this$1.kept,\n        false, // hydrating\n        true // removeOnly (!important, avoids unnecessary moves)\n      );\n      this$1._vnode = this$1.kept;\n      restoreActiveInstance();\n      update.call(this$1, vnode, hydrating);\n    };\n  },\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    // assign to this to avoid being removed in tree-shaking\n    // $flow-disable-line\n    this._reflow = document.body.offsetHeight;\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (e && e.target !== el) {\n            return\n          }\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      /* istanbul ignore if */\n      if (this._hasMove) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue.config.mustUseProp = mustUseProp;\nVue.config.isReservedTag = isReservedTag;\nVue.config.isReservedAttr = isReservedAttr;\nVue.config.getTagNamespace = getTagNamespace;\nVue.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue.options.directives, platformDirectives);\nextend(Vue.options.components, platformComponents);\n\n// install platform patch function\nVue.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nif (inBrowser) {\n  setTimeout(function () {\n    if (config.devtools) {\n      if (devtools) {\n        devtools.emit('init', Vue);\n      } else {\n        console[console.info ? 'info' : 'log'](\n          'Download the Vue Devtools extension for a better development experience:\\n' +\n          'https://github.com/vuejs/vue-devtools'\n        );\n      }\n    }\n    if (config.productionTip !== false &&\n      typeof console !== 'undefined'\n    ) {\n      console[console.info ? 'info' : 'log'](\n        \"You are running Vue in development mode.\\n\" +\n        \"Make sure to turn on production mode when deploying for production.\\n\" +\n        \"See more tips at https://vuejs.org/guide/deployment.html\"\n      );\n    }\n  }, 0);\n}\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\n\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var rawTokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index, tokenValue;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      rawTokens.push(tokenValue = text.slice(lastIndex, index));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    rawTokens.push({ '@binding': exp });\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    rawTokens.push(tokenValue = text.slice(lastIndex));\n    tokens.push(JSON.stringify(tokenValue));\n  }\n  return {\n    expression: tokens.join('+'),\n    tokens: rawTokens\n  }\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (staticClass) {\n    var res = parseText(staticClass, options.delimiters);\n    if (res) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.',\n        el.rawAttrsMap['class']\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    {\n      var res = parseText(staticStyle, options.delimiters);\n      if (res) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.',\n          el.rawAttrsMap['style']\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$1\n};\n\n/*  */\n\nvar decoder;\n\nvar he = {\n  decode: function decode (html) {\n    decoder = decoder || document.createElement('div');\n    decoder.innerHTML = html;\n    return decoder.textContent\n  }\n};\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n// Regular Expressions for parsing tags and attributes\nvar attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\nvar ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\" + (unicodeRegExp.source) + \"]*\";\nvar qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\nvar startTagOpen = new RegExp((\"^<\" + qnameCapture));\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp((\"^<\\\\/\" + qnameCapture + \"[^>]*>\"));\nvar doctype = /^<!DOCTYPE [^>]+>/i;\n// #7298: escape - to avoid being pased as HTML comment when inlined in page\nvar comment = /^<!\\--/;\nvar conditionalComment = /^<!\\[/;\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n',\n  '&#9;': '\\t',\n  '&#39;': \"'\"\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;\n\n// #5992\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\nvar shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n'; };\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n            }\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n            advance(1);\n          }\n          continue\n        }\n      }\n\n      var text = (void 0), rest = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n        while (\n          !endTag.test(rest) &&\n          !startTagOpen.test(rest) &&\n          !comment.test(rest) &&\n          !conditionalComment.test(rest)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n      }\n\n      if (text) {\n        advance(text.length);\n      }\n\n      if (options.chars && text) {\n        options.chars(text, index - text.length, index);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!\\--([\\s\\S]*?)-->/g, '$1') // #7298\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (shouldIgnoreFirstNewline(stackedTag, text)) {\n          text = text.slice(1);\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (!stack.length && options.warn) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"), { start: index + html.length });\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n        attr.start = index;\n        advance(attr[0].length);\n        attr.end = index;\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      var value = args[3] || args[4] || args[5] || '';\n      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n        ? options.shouldDecodeNewlinesForHref\n        : options.shouldDecodeNewlines;\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(value, shouldDecodeNewlines)\n      };\n      if (options.outputSourceRange) {\n        attrs[i].start = args.start + args[0].match(/^\\s*/).length;\n        attrs[i].end = args.end;\n      }\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (i > pos || !tagName &&\n          options.warn\n        ) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\"),\n            { start: stack[i].start, end: stack[i].end }\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\nvar forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\nvar stripParensRE = /^\\(|\\)$/g;\nvar dynamicArgRE = /^\\[.*\\]$/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^\\.|^v-bind:/;\nvar modifierRE = /\\.[^.\\]]+(?=[^\\]]*$)/g;\n\nvar slotRE = /^v-slot(:|$)|^#/;\n\nvar lineBreakRE = /[\\r\\n]/;\nvar whitespaceRE$1 = /\\s+/g;\n\nvar invalidAttributeRE = /[\\s\"'<>\\/=]/;\n\nvar decodeHTMLCached = cached(he.decode);\n\nvar emptySlotScopeToken = \"_empty_\";\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\nvar maybeComponent;\n\nfunction createASTElement (\n  tag,\n  attrs,\n  parent\n) {\n  return {\n    type: 1,\n    tag: tag,\n    attrsList: attrs,\n    attrsMap: makeAttrsMap(attrs),\n    rawAttrsMap: {},\n    parent: parent,\n    children: []\n  }\n}\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n\n  platformIsPreTag = options.isPreTag || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformGetTagNamespace = options.getTagNamespace || no;\n  var isReservedTag = options.isReservedTag || no;\n  maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var whitespaceOption = options.whitespace;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg, range) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg, range);\n    }\n  }\n\n  function closeElement (element) {\n    trimEndingWhitespace(element);\n    if (!inVPre && !element.processed) {\n      element = processElement(element, options);\n    }\n    // tree management\n    if (!stack.length && element !== root) {\n      // allow root elements with v-if, v-else-if and v-else\n      if (root.if && (element.elseif || element.else)) {\n        {\n          checkRootConstraints(element);\n        }\n        addIfCondition(root, {\n          exp: element.elseif,\n          block: element\n        });\n      } else {\n        warnOnce(\n          \"Component template should contain exactly one root element. \" +\n          \"If you are using v-if on multiple elements, \" +\n          \"use v-else-if to chain them instead.\",\n          { start: element.start }\n        );\n      }\n    }\n    if (currentParent && !element.forbidden) {\n      if (element.elseif || element.else) {\n        processIfConditions(element, currentParent);\n      } else {\n        if (element.slotScope) {\n          // scoped slot\n          // keep it in the children list so that v-else(-if) conditions can\n          // find it as the prev node.\n          var name = element.slotTarget || '\"default\"'\n          ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        }\n        currentParent.children.push(element);\n        element.parent = currentParent;\n      }\n    }\n\n    // final children cleanup\n    // filter out scoped slots\n    element.children = element.children.filter(function (c) { return !(c).slotScope; });\n    // remove trailing whitespace node again\n    trimEndingWhitespace(element);\n\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n    // apply post-transforms\n    for (var i = 0; i < postTransforms.length; i++) {\n      postTransforms[i](element, options);\n    }\n  }\n\n  function trimEndingWhitespace (el) {\n    // remove trailing whitespace node\n    if (!inPre) {\n      var lastNode;\n      while (\n        (lastNode = el.children[el.children.length - 1]) &&\n        lastNode.type === 3 &&\n        lastNode.text === ' '\n      ) {\n        el.children.pop();\n      }\n    }\n  }\n\n  function checkRootConstraints (el) {\n    if (el.tag === 'slot' || el.tag === 'template') {\n      warnOnce(\n        \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n        'contain multiple nodes.',\n        { start: el.start }\n      );\n    }\n    if (el.attrsMap.hasOwnProperty('v-for')) {\n      warnOnce(\n        'Cannot use v-for on stateful component root element because ' +\n        'it renders multiple elements.',\n        el.rawAttrsMap['v-for']\n      );\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n    shouldKeepComment: options.comments,\n    outputSourceRange: options.outputSourceRange,\n    start: function start (tag, attrs, unary, start$1, end) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = createASTElement(tag, attrs, currentParent);\n      if (ns) {\n        element.ns = ns;\n      }\n\n      {\n        if (options.outputSourceRange) {\n          element.start = start$1;\n          element.end = end;\n          element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {\n            cumulated[attr.name] = attr;\n            return cumulated\n          }, {});\n        }\n        attrs.forEach(function (attr) {\n          if (invalidAttributeRE.test(attr.name)) {\n            warn$2(\n              \"Invalid dynamic argument expression: attribute names cannot contain \" +\n              \"spaces, quotes, <, >, / or =.\",\n              {\n                start: attr.start + attr.name.indexOf(\"[\"),\n                end: attr.start + attr.name.length\n              }\n            );\n          }\n        });\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.',\n          { start: element.start }\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        element = preTransforms[i](element, options) || element;\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else if (!element.processed) {\n        // structural directives\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n      }\n\n      if (!root) {\n        root = element;\n        {\n          checkRootConstraints(root);\n        }\n      }\n\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        closeElement(element);\n      }\n    },\n\n    end: function end (tag, start, end$1) {\n      var element = stack[stack.length - 1];\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      if (options.outputSourceRange) {\n        element.end = end$1;\n      }\n      closeElement(element);\n    },\n\n    chars: function chars (text, start, end) {\n      if (!currentParent) {\n        {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.',\n              { start: start }\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\"),\n              { start: start }\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n        currentParent.tag === 'textarea' &&\n        currentParent.attrsMap.placeholder === text\n      ) {\n        return\n      }\n      var children = currentParent.children;\n      if (inPre || text.trim()) {\n        text = isTextTag(currentParent) ? text : decodeHTMLCached(text);\n      } else if (!children.length) {\n        // remove the whitespace-only node right after an opening tag\n        text = '';\n      } else if (whitespaceOption) {\n        if (whitespaceOption === 'condense') {\n          // in condense mode, remove the whitespace node if it contains\n          // line break, otherwise condense to a single space\n          text = lineBreakRE.test(text) ? '' : ' ';\n        } else {\n          text = ' ';\n        }\n      } else {\n        text = preserveWhitespace ? ' ' : '';\n      }\n      if (text) {\n        if (!inPre && whitespaceOption === 'condense') {\n          // condense consecutive whitespaces into single space\n          text = text.replace(whitespaceRE$1, ' ');\n        }\n        var res;\n        var child;\n        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n          child = {\n            type: 2,\n            expression: res.expression,\n            tokens: res.tokens,\n            text: text\n          };\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          child = {\n            type: 3,\n            text: text\n          };\n        }\n        if (child) {\n          if (options.outputSourceRange) {\n            child.start = start;\n            child.end = end;\n          }\n          children.push(child);\n        }\n      }\n    },\n    comment: function comment (text, start, end) {\n      // adding anyting as a sibling to the root node is forbidden\n      // comments should still be allowed, but ignored\n      if (currentParent) {\n        var child = {\n          type: 3,\n          text: text,\n          isComment: true\n        };\n        if (options.outputSourceRange) {\n          child.start = start;\n          child.end = end;\n        }\n        currentParent.children.push(child);\n      }\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var list = el.attrsList;\n  var len = list.length;\n  if (len) {\n    var attrs = el.attrs = new Array(len);\n    for (var i = 0; i < len; i++) {\n      attrs[i] = {\n        name: list[i].name,\n        value: JSON.stringify(list[i].value)\n      };\n      if (list[i].start != null) {\n        attrs[i].start = list[i].start;\n        attrs[i].end = list[i].end;\n      }\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processElement (\n  element,\n  options\n) {\n  processKey(element);\n\n  // determine whether this is a plain element after\n  // removing structural attributes\n  element.plain = (\n    !element.key &&\n    !element.scopedSlots &&\n    !element.attrsList.length\n  );\n\n  processRef(element);\n  processSlotContent(element);\n  processSlotOutlet(element);\n  processComponent(element);\n  for (var i = 0; i < transforms.length; i++) {\n    element = transforms[i](element, options) || element;\n  }\n  processAttrs(element);\n  return element\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    {\n      if (el.tag === 'template') {\n        warn$2(\n          \"<template> cannot be keyed. Place the key on real elements instead.\",\n          getRawBindingAttr(el, 'key')\n        );\n      }\n      if (el.for) {\n        var iterator = el.iterator2 || el.iterator1;\n        var parent = el.parent;\n        if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {\n          warn$2(\n            \"Do not use v-for index as key on <transition-group> children, \" +\n            \"this is the same as not using keys.\",\n            getRawBindingAttr(el, 'key'),\n            true /* tip */\n          );\n        }\n      }\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var res = parseFor(exp);\n    if (res) {\n      extend(el, res);\n    } else {\n      warn$2(\n        (\"Invalid v-for expression: \" + exp),\n        el.rawAttrsMap['v-for']\n      );\n    }\n  }\n}\n\n\n\nfunction parseFor (exp) {\n  var inMatch = exp.match(forAliasRE);\n  if (!inMatch) { return }\n  var res = {};\n  res.for = inMatch[2].trim();\n  var alias = inMatch[1].trim().replace(stripParensRE, '');\n  var iteratorMatch = alias.match(forIteratorRE);\n  if (iteratorMatch) {\n    res.alias = alias.replace(forIteratorRE, '').trim();\n    res.iterator1 = iteratorMatch[1].trim();\n    if (iteratorMatch[2]) {\n      res.iterator2 = iteratorMatch[2].trim();\n    }\n  } else {\n    res.alias = alias;\n  }\n  return res\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\",\n      el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (children[i].text !== ' ') {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\",\n          children[i]\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\n// handle content being passed to a component as slot,\n// e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\nfunction processSlotContent (el) {\n  var slotScope;\n  if (el.tag === 'template') {\n    slotScope = getAndRemoveAttr(el, 'scope');\n    /* istanbul ignore if */\n    if (slotScope) {\n      warn$2(\n        \"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" +\n        \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" +\n        \"can also be used on plain elements in addition to <template> to \" +\n        \"denote scoped slots.\",\n        el.rawAttrsMap['scope'],\n        true\n      );\n    }\n    el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n  } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {\n    /* istanbul ignore if */\n    if (el.attrsMap['v-for']) {\n      warn$2(\n        \"Ambiguous combined usage of slot-scope and v-for on <\" + (el.tag) + \"> \" +\n        \"(v-for takes higher priority). Use a wrapper <template> for the \" +\n        \"scoped slot to make it clearer.\",\n        el.rawAttrsMap['slot-scope'],\n        true\n      );\n    }\n    el.slotScope = slotScope;\n  }\n\n  // slot=\"xxx\"\n  var slotTarget = getBindingAttr(el, 'slot');\n  if (slotTarget) {\n    el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);\n    // preserve slot as an attribute for native shadow DOM compat\n    // only for non-scoped slots.\n    if (el.tag !== 'template' && !el.slotScope) {\n      addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n    }\n  }\n\n  // 2.6 v-slot syntax\n  {\n    if (el.tag === 'template') {\n      // v-slot on <template>\n      var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n      if (slotBinding) {\n        {\n          if (el.slotTarget || el.slotScope) {\n            warn$2(\n              \"Unexpected mixed usage of different slot syntaxes.\",\n              el\n            );\n          }\n          if (el.parent && !maybeComponent(el.parent)) {\n            warn$2(\n              \"<template v-slot> can only appear at the root level inside \" +\n              \"the receiving the component\",\n              el\n            );\n          }\n        }\n        var ref = getSlotName(slotBinding);\n        var name = ref.name;\n        var dynamic = ref.dynamic;\n        el.slotTarget = name;\n        el.slotTargetDynamic = dynamic;\n        el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\n      }\n    } else {\n      // v-slot on component, denotes default slot\n      var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);\n      if (slotBinding$1) {\n        {\n          if (!maybeComponent(el)) {\n            warn$2(\n              \"v-slot can only be used on components or <template>.\",\n              slotBinding$1\n            );\n          }\n          if (el.slotScope || el.slotTarget) {\n            warn$2(\n              \"Unexpected mixed usage of different slot syntaxes.\",\n              el\n            );\n          }\n          if (el.scopedSlots) {\n            warn$2(\n              \"To avoid scope ambiguity, the default slot should also use \" +\n              \"<template> syntax when there are other named slots.\",\n              slotBinding$1\n            );\n          }\n        }\n        // add the component's children to its default slot\n        var slots = el.scopedSlots || (el.scopedSlots = {});\n        var ref$1 = getSlotName(slotBinding$1);\n        var name$1 = ref$1.name;\n        var dynamic$1 = ref$1.dynamic;\n        var slotContainer = slots[name$1] = createASTElement('template', [], el);\n        slotContainer.slotTarget = name$1;\n        slotContainer.slotTargetDynamic = dynamic$1;\n        slotContainer.children = el.children.filter(function (c) {\n          if (!c.slotScope) {\n            c.parent = slotContainer;\n            return true\n          }\n        });\n        slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;\n        // remove children as they are returned from scopedSlots now\n        el.children = [];\n        // mark el non-plain so data gets generated\n        el.plain = false;\n      }\n    }\n  }\n}\n\nfunction getSlotName (binding) {\n  var name = binding.name.replace(slotRE, '');\n  if (!name) {\n    if (binding.name[0] !== '#') {\n      name = 'default';\n    } else {\n      warn$2(\n        \"v-slot shorthand syntax requires a slot name.\",\n        binding\n      );\n    }\n  }\n  return dynamicArgRE.test(name)\n    // dynamic [name]\n    ? { name: name.slice(1, -1), dynamic: true }\n    // static name\n    : { name: (\"\\\"\" + name + \"\\\"\"), dynamic: false }\n}\n\n// handle <slot/> outlets\nfunction processSlotOutlet (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (el.key) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\",\n        getRawBindingAttr(el, 'key')\n      );\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name.replace(dirRE, ''));\n      // support .foo shorthand syntax for the .prop modifier\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isDynamic = dynamicArgRE.test(name);\n        if (isDynamic) {\n          name = name.slice(1, -1);\n        }\n        if (\n          value.trim().length === 0\n        ) {\n          warn$2(\n            (\"The value for a v-bind expression cannot be empty. Found in \\\"v-bind:\" + name + \"\\\"\")\n          );\n        }\n        if (modifiers) {\n          if (modifiers.prop && !isDynamic) {\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel && !isDynamic) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            syncGen = genAssignmentCode(value, \"$event\");\n            if (!isDynamic) {\n              addHandler(\n                el,\n                (\"update:\" + (camelize(name))),\n                syncGen,\n                null,\n                false,\n                warn$2,\n                list[i]\n              );\n              if (hyphenate(name) !== camelize(name)) {\n                addHandler(\n                  el,\n                  (\"update:\" + (hyphenate(name))),\n                  syncGen,\n                  null,\n                  false,\n                  warn$2,\n                  list[i]\n                );\n              }\n            } else {\n              // handler w/ dynamic event name\n              addHandler(\n                el,\n                (\"\\\"update:\\\"+(\" + name + \")\"),\n                syncGen,\n                null,\n                false,\n                warn$2,\n                list[i],\n                true // dynamic\n              );\n            }\n          }\n        }\n        if ((modifiers && modifiers.prop) || (\n          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\n        )) {\n          addProp(el, name, value, list[i], isDynamic);\n        } else {\n          addAttr(el, name, value, list[i], isDynamic);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        isDynamic = dynamicArgRE.test(name);\n        if (isDynamic) {\n          name = name.slice(1, -1);\n        }\n        addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        isDynamic = false;\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n          if (dynamicArgRE.test(arg)) {\n            arg = arg.slice(1, -1);\n            isDynamic = true;\n          }\n        }\n        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n        if (name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      {\n        var res = parseText(value, delimiters);\n        if (res) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.',\n            list[i]\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value), list[i]);\n      // #6887 firefox doesn't update muted state if set via attribute\n      // even immediately after element creation\n      if (!el.component &&\n          name === 'muted' &&\n          platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n        addProp(el, name, 'true', list[i]);\n      }\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (\n      map[attrs[i].name] && !isIE && !isEdge\n    ) {\n      warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag (el) {\n  return el.tag === 'script' || el.tag === 'style'\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\",\n        el.rawAttrsMap['v-model']\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nfunction preTransformNode (el, options) {\n  if (el.tag === 'input') {\n    var map = el.attrsMap;\n    if (!map['v-model']) {\n      return\n    }\n\n    var typeBinding;\n    if (map[':type'] || map['v-bind:type']) {\n      typeBinding = getBindingAttr(el, 'type');\n    }\n    if (!map.type && !typeBinding && map['v-bind']) {\n      typeBinding = \"(\" + (map['v-bind']) + \").type\";\n    }\n\n    if (typeBinding) {\n      var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n      var ifConditionExtra = ifCondition ? (\"&&(\" + ifCondition + \")\") : \"\";\n      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\n      // 1. checkbox\n      var branch0 = cloneASTElement(el);\n      // process for on the main node\n      processFor(branch0);\n      addRawAttr(branch0, 'type', 'checkbox');\n      processElement(branch0, options);\n      branch0.processed = true; // prevent it from double-processed\n      branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n      addIfCondition(branch0, {\n        exp: branch0.if,\n        block: branch0\n      });\n      // 2. add radio else-if condition\n      var branch1 = cloneASTElement(el);\n      getAndRemoveAttr(branch1, 'v-for', true);\n      addRawAttr(branch1, 'type', 'radio');\n      processElement(branch1, options);\n      addIfCondition(branch0, {\n        exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n        block: branch1\n      });\n      // 3. other\n      var branch2 = cloneASTElement(el);\n      getAndRemoveAttr(branch2, 'v-for', true);\n      addRawAttr(branch2, ':type', typeBinding);\n      processElement(branch2, options);\n      addIfCondition(branch0, {\n        exp: ifCondition,\n        block: branch2\n      });\n\n      if (hasElse) {\n        branch0.else = true;\n      } else if (elseIfCondition) {\n        branch0.elseif = elseIfCondition;\n      }\n\n      return branch0\n    }\n  }\n}\n\nfunction cloneASTElement (el) {\n  return createASTElement(el.tag, el.attrsList.slice(), el.parent)\n}\n\nvar model$1 = {\n  preTransformNode: preTransformNode\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1,\n  model$1\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"), dir);\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"), dir);\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        var block = node.ifConditions[i$1].block;\n        markStatic$1(block);\n        if (!block.static) {\n          node.static = false;\n        }\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        markStaticRoots(node.ifConditions[i$1].block, isInFor);\n      }\n    }\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*(?:[\\w$]+)?\\s*\\(/;\nvar fnInvokeRE = /\\([^)]*?\\);*$/;\nvar simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/;\n\n// KeyboardEvent.keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// KeyboardEvent.key aliases\nvar keyNames = {\n  // #7880: IE11 and Edge use `Esc` for Escape key name.\n  esc: ['Esc', 'Escape'],\n  tab: 'Tab',\n  enter: 'Enter',\n  // #9112: IE11 uses `Spacebar` for Space key name.\n  space: [' ', 'Spacebar'],\n  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n  up: ['Up', 'ArrowUp'],\n  left: ['Left', 'ArrowLeft'],\n  right: ['Right', 'ArrowRight'],\n  down: ['Down', 'ArrowDown'],\n  // #9112: IE11 uses `Del` for Delete key name.\n  'delete': ['Backspace', 'Delete', 'Del']\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (\n  events,\n  isNative\n) {\n  var prefix = isNative ? 'nativeOn:' : 'on:';\n  var staticHandlers = \"\";\n  var dynamicHandlers = \"\";\n  for (var name in events) {\n    var handlerCode = genHandler(events[name]);\n    if (events[name] && events[name].dynamic) {\n      dynamicHandlers += name + \",\" + handlerCode + \",\";\n    } else {\n      staticHandlers += \"\\\"\" + name + \"\\\":\" + handlerCode + \",\";\n    }\n  }\n  staticHandlers = \"{\" + (staticHandlers.slice(0, -1)) + \"}\";\n  if (dynamicHandlers) {\n    return prefix + \"_d(\" + staticHandlers + \",[\" + (dynamicHandlers.slice(0, -1)) + \"])\"\n  } else {\n    return prefix + staticHandlers\n  }\n}\n\nfunction genHandler (handler) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n  var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n\n  if (!handler.modifiers) {\n    if (isMethodPath || isFunctionExpression) {\n      return handler.value\n    }\n    return (\"function($event){\" + (isFunctionInvocation ? (\"return \" + (handler.value)) : handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else if (key === 'exact') {\n        var modifiers = (handler.modifiers);\n        genModifierCode += genGuard(\n          ['ctrl', 'shift', 'alt', 'meta']\n            .filter(function (keyModifier) { return !modifiers[keyModifier]; })\n            .map(function (keyModifier) { return (\"$event.\" + keyModifier + \"Key\"); })\n            .join('||')\n        );\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? (\"return \" + (handler.value) + \"($event)\")\n      : isFunctionExpression\n        ? (\"return (\" + (handler.value) + \")($event)\")\n        : isFunctionInvocation\n          ? (\"return \" + (handler.value))\n          : handler.value;\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\n    // make sure the key filters only apply to KeyboardEvents\n    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\n    // key events that do not have keyCode property...\n    \"if(!$event.type.indexOf('key')&&\" +\n    (keys.map(genFilterCode).join('&&')) + \")return null;\"\n  )\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var keyCode = keyCodes[key];\n  var keyName = keyNames[key];\n  return (\n    \"_k($event.keyCode,\" +\n    (JSON.stringify(key)) + \",\" +\n    (JSON.stringify(keyCode)) + \",\" +\n    \"$event.key,\" +\n    \"\" + (JSON.stringify(keyName)) +\n    \")\"\n  )\n}\n\n/*  */\n\nfunction on (el, dir) {\n  if (dir.modifiers) {\n    warn(\"v-on without argument does not support modifiers.\");\n  }\n  el.wrapListeners = function (code) { return (\"_g(\" + code + \",\" + (dir.value) + \")\"); };\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  on: on,\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\n\n\n\n\nvar CodegenState = function CodegenState (options) {\n  this.options = options;\n  this.warn = options.warn || baseWarn;\n  this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  this.directives = extend(extend({}, baseDirectives), options.directives);\n  var isReservedTag = options.isReservedTag || no;\n  this.maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n  this.onceId = 0;\n  this.staticRenderFns = [];\n  this.pre = false;\n};\n\n\n\nfunction generate (\n  ast,\n  options\n) {\n  var state = new CodegenState(options);\n  var code = ast ? genElement(ast, state) : '_c(\"div\")';\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: state.staticRenderFns\n  }\n}\n\nfunction genElement (el, state) {\n  if (el.parent) {\n    el.pre = el.pre || el.parent.pre;\n  }\n\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n    return genChildren(el, state) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el, state);\n    } else {\n      var data;\n      if (!el.plain || (el.pre && state.maybeComponent(el))) {\n        data = genData$2(el, state);\n      }\n\n      var children = el.inlineTemplate ? null : genChildren(el, state, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el, state) {\n  el.staticProcessed = true;\n  // Some elements (templates) need to behave differently inside of a v-pre\n  // node.  All pre nodes are static roots, so we can use this as a location to\n  // wrap a state change and reset it upon exiting the pre node.\n  var originalPreState = state.pre;\n  if (el.pre) {\n    state.pre = el.pre;\n  }\n  state.staticRenderFns.push((\"with(this){return \" + (genElement(el, state)) + \"}\"));\n  state.pre = originalPreState;\n  return (\"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el, state) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      state.warn(\n        \"v-once can only be used inside v-for that is keyed. \",\n        el.rawAttrsMap['v-once']\n      );\n      return genElement(el, state)\n    }\n    return (\"_o(\" + (genElement(el, state)) + \",\" + (state.onceId++) + \",\" + key + \")\")\n  } else {\n    return genStatic(el, state)\n  }\n}\n\nfunction genIf (\n  el,\n  state,\n  altGen,\n  altEmpty\n) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)\n}\n\nfunction genIfConditions (\n  conditions,\n  state,\n  altGen,\n  altEmpty\n) {\n  if (!conditions.length) {\n    return altEmpty || '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions, state, altGen, altEmpty)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return altGen\n      ? altGen(el, state)\n      : el.once\n        ? genOnce(el, state)\n        : genElement(el, state)\n  }\n}\n\nfunction genFor (\n  el,\n  state,\n  altGen,\n  altHelper\n) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (state.maybeComponent(el) &&\n    el.tag !== 'slot' &&\n    el.tag !== 'template' &&\n    !el.key\n  ) {\n    state.warn(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      el.rawAttrsMap['v-for'],\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return (altHelper || '_l') + \"((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + ((altGen || genElement)(el, state)) +\n    '})'\n}\n\nfunction genData$2 (el, state) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el, state);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < state.dataGenFns.length; i++) {\n    data += state.dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:\" + (genProps(el.attrs)) + \",\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:\" + (genProps(el.props)) + \",\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events, false)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true)) + \",\";\n  }\n  // slot target\n  // only for non-scoped slots\n  if (el.slotTarget && !el.slotScope) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el, el.scopedSlots, state)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el, state);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind dynamic argument wrap\n  // v-bind with dynamic arguments must be applied using the same v-bind object\n  // merge helper so that class/style/mustUseProp attrs are handled correctly.\n  if (el.dynamicAttrs) {\n    data = \"_b(\" + data + \",\\\"\" + (el.tag) + \"\\\",\" + (genProps(el.dynamicAttrs)) + \")\";\n  }\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  // v-on data wrap\n  if (el.wrapListeners) {\n    data = el.wrapListeners(data);\n  }\n  return data\n}\n\nfunction genDirectives (el, state) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = state.directives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, state.warn);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\" + (dir.isDynamicArg ? dir.arg : (\"\\\"\" + (dir.arg) + \"\\\"\"))) : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el, state) {\n  var ast = el.children[0];\n  if (el.children.length !== 1 || ast.type !== 1) {\n    state.warn(\n      'Inline-template components must have exactly one child element.',\n      { start: el.start }\n    );\n  }\n  if (ast && ast.type === 1) {\n    var inlineRenderFns = generate(ast, state.options);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (\n  el,\n  slots,\n  state\n) {\n  // by default scoped slots are considered \"stable\", this allows child\n  // components with only scoped slots to skip forced updates from parent.\n  // but in some cases we have to bail-out of this optimization\n  // for example if the slot contains dynamic names, has v-if or v-for on them...\n  var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {\n    var slot = slots[key];\n    return (\n      slot.slotTargetDynamic ||\n      slot.if ||\n      slot.for ||\n      containsSlotChild(slot) // is passing down slot from parent which may be dynamic\n    )\n  });\n\n  // #9534: if a component with scoped slots is inside a conditional branch,\n  // it's possible for the same component to be reused but with different\n  // compiled slot content. To avoid that, we generate a unique key based on\n  // the generated code of all the slot contents.\n  var needsKey = !!el.if;\n\n  // OR when it is inside another scoped slot or v-for (the reactivity may be\n  // disconnected due to the intermediate scope variable)\n  // #9438, #9506\n  // TODO: this can be further optimized by properly analyzing in-scope bindings\n  // and skip force updating ones that do not actually use scope variables.\n  if (!needsForceUpdate) {\n    var parent = el.parent;\n    while (parent) {\n      if (\n        (parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||\n        parent.for\n      ) {\n        needsForceUpdate = true;\n        break\n      }\n      if (parent.if) {\n        needsKey = true;\n      }\n      parent = parent.parent;\n    }\n  }\n\n  var generatedSlots = Object.keys(slots)\n    .map(function (key) { return genScopedSlot(slots[key], state); })\n    .join(',');\n\n  return (\"scopedSlots:_u([\" + generatedSlots + \"]\" + (needsForceUpdate ? \",null,true\" : \"\") + (!needsForceUpdate && needsKey ? (\",null,false,\" + (hash(generatedSlots))) : \"\") + \")\")\n}\n\nfunction hash(str) {\n  var hash = 5381;\n  var i = str.length;\n  while(i) {\n    hash = (hash * 33) ^ str.charCodeAt(--i);\n  }\n  return hash >>> 0\n}\n\nfunction containsSlotChild (el) {\n  if (el.type === 1) {\n    if (el.tag === 'slot') {\n      return true\n    }\n    return el.children.some(containsSlotChild)\n  }\n  return false\n}\n\nfunction genScopedSlot (\n  el,\n  state\n) {\n  var isLegacySyntax = el.attrsMap['slot-scope'];\n  if (el.if && !el.ifProcessed && !isLegacySyntax) {\n    return genIf(el, state, genScopedSlot, \"null\")\n  }\n  if (el.for && !el.forProcessed) {\n    return genFor(el, state, genScopedSlot)\n  }\n  var slotScope = el.slotScope === emptySlotScopeToken\n    ? \"\"\n    : String(el.slotScope);\n  var fn = \"function(\" + slotScope + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? el.if && isLegacySyntax\n        ? (\"(\" + (el.if) + \")?\" + (genChildren(el, state) || 'undefined') + \":undefined\")\n        : genChildren(el, state) || 'undefined'\n      : genElement(el, state)) + \"}\";\n  // reverse proxy v-slot without scope on this.$slots\n  var reverseProxy = slotScope ? \"\" : \",proxy:true\";\n  return (\"{key:\" + (el.slotTarget || \"\\\"default\\\"\") + \",fn:\" + fn + reverseProxy + \"}\")\n}\n\nfunction genChildren (\n  el,\n  state,\n  checkSkip,\n  altGenElement,\n  altGenNode\n) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n      el$1.for &&\n      el$1.tag !== 'template' &&\n      el$1.tag !== 'slot'\n    ) {\n      var normalizationType = checkSkip\n        ? state.maybeComponent(el$1) ? \",1\" : \",0\"\n        : \"\";\n      return (\"\" + ((altGenElement || genElement)(el$1, state)) + normalizationType)\n    }\n    var normalizationType$1 = checkSkip\n      ? getNormalizationType(children, state.maybeComponent)\n      : 0;\n    var gen = altGenNode || genNode;\n    return (\"[\" + (children.map(function (c) { return gen(c, state); }).join(',')) + \"]\" + (normalizationType$1 ? (\",\" + normalizationType$1) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (\n  children,\n  maybeComponent\n) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction genNode (node, state) {\n  if (node.type === 1) {\n    return genElement(node, state)\n  } else if (node.type === 3 && node.isComment) {\n    return genComment(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genComment (comment) {\n  return (\"_e(\" + (JSON.stringify(comment.text)) + \")\")\n}\n\nfunction genSlot (el, state) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el, state);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs || el.dynamicAttrs\n    ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({\n        // slot props are camelized\n        name: camelize(attr.name),\n        value: attr.value,\n        dynamic: attr.dynamic\n      }); }))\n    : null;\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (\n  componentName,\n  el,\n  state\n) {\n  var children = el.inlineTemplate ? null : genChildren(el, state, true);\n  return (\"_c(\" + componentName + \",\" + (genData$2(el, state)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var staticProps = \"\";\n  var dynamicProps = \"\";\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    var value = transformSpecialNewlines(prop.value);\n    if (prop.dynamic) {\n      dynamicProps += (prop.name) + \",\" + value + \",\";\n    } else {\n      staticProps += \"\\\"\" + (prop.name) + \"\\\":\" + value + \",\";\n    }\n  }\n  staticProps = \"{\" + (staticProps.slice(0, -1)) + \"}\";\n  if (dynamicProps) {\n    return (\"_d(\" + staticProps + \",[\" + (dynamicProps.slice(0, -1)) + \"])\")\n  } else {\n    return staticProps\n  }\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast, warn) {\n  if (ast) {\n    checkNode(ast, warn);\n  }\n}\n\nfunction checkNode (node, warn) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          var range = node.rawAttrsMap[name];\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), warn, range);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], warn);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, warn, node);\n  }\n}\n\nfunction checkEvent (exp, text, warn, range) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    warn(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim()),\n      range\n    );\n  }\n  checkExpression(exp, text, warn, range);\n}\n\nfunction checkFor (node, text, warn, range) {\n  checkExpression(node.for || '', text, warn, range);\n  checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n}\n\nfunction checkIdentifier (\n  ident,\n  type,\n  text,\n  warn,\n  range\n) {\n  if (typeof ident === 'string') {\n    try {\n      new Function((\"var \" + ident + \"=_\"));\n    } catch (e) {\n      warn((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())), range);\n    }\n  }\n}\n\nfunction checkExpression (exp, text, warn, range) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      warn(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\"\\n  Raw expression: \" + (text.trim()),\n        range\n      );\n    } else {\n      warn(\n        \"invalid expression: \" + (e.message) + \" in\\n\\n\" +\n        \"    \" + exp + \"\\n\\n\" +\n        \"  Raw expression: \" + (text.trim()) + \"\\n\",\n        range\n      );\n    }\n  }\n}\n\n/*  */\n\nvar range = 2;\n\nfunction generateCodeFrame (\n  source,\n  start,\n  end\n) {\n  if ( start === void 0 ) start = 0;\n  if ( end === void 0 ) end = source.length;\n\n  var lines = source.split(/\\r?\\n/);\n  var count = 0;\n  var res = [];\n  for (var i = 0; i < lines.length; i++) {\n    count += lines[i].length + 1;\n    if (count >= start) {\n      for (var j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) { continue }\n        res.push((\"\" + (j + 1) + (repeat$1(\" \", 3 - String(j + 1).length)) + \"|  \" + (lines[j])));\n        var lineLength = lines[j].length;\n        if (j === i) {\n          // push underline\n          var pad = start - (count - lineLength) + 1;\n          var length = end > count ? lineLength - pad : end - start;\n          res.push(\"   |  \" + repeat$1(\" \", pad) + repeat$1(\"^\", length));\n        } else if (j > i) {\n          if (end > count) {\n            var length$1 = Math.min(end - count, lineLength);\n            res.push(\"   |  \" + repeat$1(\"^\", length$1));\n          }\n          count += lineLength + 1;\n        }\n      }\n      break\n    }\n  }\n  return res.join('\\n')\n}\n\nfunction repeat$1 (str, n) {\n  var result = '';\n  if (n > 0) {\n    while (true) { // eslint-disable-line\n      if (n & 1) { result += str; }\n      n >>>= 1;\n      if (n <= 0) { break }\n      str += str;\n    }\n  }\n  return result\n}\n\n/*  */\n\n\n\nfunction createFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompileToFunctionFn (compile) {\n  var cache = Object.create(null);\n\n  return function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = extend({}, options);\n    var warn$$1 = options.warn || warn;\n    delete options.warn;\n\n    /* istanbul ignore if */\n    {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn$$1(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (cache[key]) {\n      return cache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    {\n      if (compiled.errors && compiled.errors.length) {\n        if (options.outputSourceRange) {\n          compiled.errors.forEach(function (e) {\n            warn$$1(\n              \"Error compiling template:\\n\\n\" + (e.msg) + \"\\n\\n\" +\n              generateCodeFrame(template, e.start, e.end),\n              vm\n            );\n          });\n        } else {\n          warn$$1(\n            \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n            compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n            vm\n          );\n        }\n      }\n      if (compiled.tips && compiled.tips.length) {\n        if (options.outputSourceRange) {\n          compiled.tips.forEach(function (e) { return tip(e.msg, vm); });\n        } else {\n          compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n        }\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = createFunction(compiled.render, fnGenErrors);\n    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n      return createFunction(code, fnGenErrors)\n    });\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn$$1(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (cache[key] = res)\n  }\n}\n\n/*  */\n\nfunction createCompilerCreator (baseCompile) {\n  return function createCompiler (baseOptions) {\n    function compile (\n      template,\n      options\n    ) {\n      var finalOptions = Object.create(baseOptions);\n      var errors = [];\n      var tips = [];\n\n      var warn = function (msg, range, tip) {\n        (tip ? tips : errors).push(msg);\n      };\n\n      if (options) {\n        if (options.outputSourceRange) {\n          // $flow-disable-line\n          var leadingSpaceLength = template.match(/^\\s*/)[0].length;\n\n          warn = function (msg, range, tip) {\n            var data = { msg: msg };\n            if (range) {\n              if (range.start != null) {\n                data.start = range.start + leadingSpaceLength;\n              }\n              if (range.end != null) {\n                data.end = range.end + leadingSpaceLength;\n              }\n            }\n            (tip ? tips : errors).push(data);\n          };\n        }\n        // merge custom modules\n        if (options.modules) {\n          finalOptions.modules =\n            (baseOptions.modules || []).concat(options.modules);\n        }\n        // merge custom directives\n        if (options.directives) {\n          finalOptions.directives = extend(\n            Object.create(baseOptions.directives || null),\n            options.directives\n          );\n        }\n        // copy other options\n        for (var key in options) {\n          if (key !== 'modules' && key !== 'directives') {\n            finalOptions[key] = options[key];\n          }\n        }\n      }\n\n      finalOptions.warn = warn;\n\n      var compiled = baseCompile(template.trim(), finalOptions);\n      {\n        detectErrors(compiled.ast, warn);\n      }\n      compiled.errors = errors;\n      compiled.tips = tips;\n      return compiled\n    }\n\n    return {\n      compile: compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    }\n  }\n}\n\n/*  */\n\n// `createCompilerCreator` allows creating compilers that use alternative\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// Here we just export a default compiler using the default parts.\nvar createCompiler = createCompilerCreator(function baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  if (options.optimize !== false) {\n    optimize(ast, options);\n  }\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n});\n\n/*  */\n\nvar ref$1 = createCompiler(baseOptions);\nvar compile = ref$1.compile;\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nvar div;\nfunction getShouldDecode (href) {\n  div = div || document.createElement('div');\n  div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n  return div.innerHTML.indexOf('&#10;') > 0\n}\n\n// #3663: IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\n// #6828: chrome encodes content in a[href]\nvar shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue.prototype.$mount;\nVue.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (!template) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (config.performance && mark) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        outputSourceRange: \"development\" !== 'production',\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (config.performance && mark) {\n        mark('compile end');\n        measure((\"vue \" + (this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue.compile = compileToFunctions;\n\nmodule.exports = Vue;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmNvbW1vbi5kZXYuanM/NDY1MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7O0FBRUEsa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtCQUErQjtBQUNyRCxzQkFBc0IsaUJBQWlCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGlDQUFpQyxFQUFFO0FBQ3JGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixVQUFVOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsdUNBQXVDLHdCQUF3QixFQUFFO0FBQ2pFLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQyxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSx3Q0FBd0MsRUFBRTtBQUMxQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvQkFBb0IsRUFBRTtBQUNyRDtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixTQUFTLHFCQUFxQjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNB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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssdUZBQXVGO0FBQzVGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7O0FBRTFCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQywyQkFBMkIsRUFBRTtBQUN2RSxLQUFLO0FBQ0w7QUFDQSwwQ0FBMEMsNEJBQTRCLEVBQUU7QUFDeEUsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixzQkFBc0I7O0FBRXJEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJEO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsbUJBQW1CO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEMsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGLDRCQUE0QjtBQUM1QjtBQUNBLDJCQUEyQjtBQUMzQix3QkFBd0IsaUVBQWlFO0FBQ3pGLFlBQVksMEZBQTBGO0FBQ3RHLE1BQU0sS0FBSywwQ0FBMEM7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCO0FBQy9ELHNCQUFzQiwrQ0FBK0M7QUFDckUsaURBQWlEOztBQUVqRDtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3RELGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyw2Q0FBNkMsRUFBRTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDRCQUE0QixFQUFFO0FBQ2xGLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELCtCQUErQixFQUFFO0FBQ3JGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxxQ0FBcUM7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx1Q0FBdUMsRUFBRTtBQUNwRjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMkNBQTJDLEVBQUU7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLDhCQUE4QixFQUFFO0FBQ3JFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLHVDQUF1Qzs7QUFFekUscUNBQXFDLDBCQUEwQjs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxnQkFBZ0I7QUFDeEQ7QUFDQTtBQUNBLGdFQUFnRSxzQkFBc0IsRUFBRTtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QseUJBQXlCLEVBQUU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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QTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0JBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU8sNEJBQTRCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sT0FBTztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3QkFBd0IsRUFBRTtBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5jb21tb24uZGV2LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBWdWUuanMgdjIuNi4xMFxuICogKGMpIDIwMTQtMjAxOSBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLy8gVGhlc2UgaGVscGVycyBwcm9kdWNlIGJldHRlciBWTSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nLlxuZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICByZXR1cm4gdiA9PT0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG4gIHJldHVybiB2ID09PSBmYWxzZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZS5cbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbidcbiAgKVxufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJhdyB0eXBlIHN0cmluZyBvZiBhIHZhbHVlLCBlLmcuLCBbb2JqZWN0IE9iamVjdF0uXG4gKi9cbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiB0b1Jhd1R5cGUgKHZhbHVlKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KFN0cmluZyh2YWwpKTtcbiAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbClcbn1cblxuZnVuY3Rpb24gaXNQcm9taXNlICh2YWwpIHtcbiAgcmV0dXJuIChcbiAgICBpc0RlZih2YWwpICYmXG4gICAgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHZhbC5jYXRjaCA9PT0gJ2Z1bmN0aW9uJ1xuICApXG59XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogQXJyYXkuaXNBcnJheSh2YWwpIHx8IChpc1BsYWluT2JqZWN0KHZhbCkgJiYgdmFsLnRvU3RyaW5nID09PSBfdG9TdHJpbmcpXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4gKi9cbnZhciBpc1Jlc2VydmVkQXR0cmlidXRlID0gbWFrZU1hcCgna2V5LHJlZixzbG90LHNsb3Qtc2NvcGUsaXMnKTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGFuIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH0pXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbn0pO1xuXG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbnZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufSk7XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xudmFyIGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCBwb2x5ZmlsbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHN1cHBvcnQgaXQsXG4gKiBlLmcuLCBQaGFudG9tSlMgMS54LiBUZWNobmljYWxseSwgd2UgZG9uJ3QgbmVlZCB0aGlzIGFueW1vcmVcbiAqIHNpbmNlIG5hdGl2ZSBiaW5kIGlzIG5vdyBwZXJmb3JtYW50IGVub3VnaCBpbiBtb3N0IGJyb3dzZXJzLlxuICogQnV0IHJlbW92aW5nIGl0IHdvdWxkIG1lYW4gYnJlYWtpbmcgY29kZSB0aGF0IHdhcyBhYmxlIHRvIHJ1biBpblxuICogUGhhbnRvbUpTIDEueCwgc28gdGhpcyBtdXN0IGJlIGtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIHBvbHlmaWxsQmluZCAoZm4sIGN0eCkge1xuICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsXG4gICAgICA/IGwgPiAxXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICA6IGZuLmNhbGwoY3R4KVxuICB9XG5cbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICByZXR1cm4gYm91bmRGblxufVxuXG5mdW5jdGlvbiBuYXRpdmVCaW5kIChmbiwgY3R4KSB7XG4gIHJldHVybiBmbi5iaW5kKGN0eClcbn1cblxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICA/IG5hdGl2ZUJpbmRcbiAgOiBwb2x5ZmlsbEJpbmQ7XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pLlxuICovXG5mdW5jdGlvbiBub29wIChhLCBiLCBjKSB7fVxuXG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbnZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcblxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIFJldHVybiB0aGUgc2FtZSB2YWx1ZS5cbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdHJpbmcgY29udGFpbmluZyBzdGF0aWMga2V5cyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG4gKi9cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMgKG1vZHVsZXMpIHtcbiAgcmV0dXJuIG1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChrZXlzLCBtKSB7XG4gICAgcmV0dXJuIGtleXMuY29uY2F0KG0uc3RhdGljS2V5cyB8fCBbXSlcbiAgfSwgW10pLmpvaW4oJywnKVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuICovXG5mdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICB2YXIgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xuICAgICAgaWYgKGlzQXJyYXlBICYmIGlzQXJyYXlCKSB7XG4gICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGUsIGJbaV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKClcbiAgICAgIH0gZWxzZSBpZiAoIWlzQXJyYXlBICYmICFpc0FycmF5Qikge1xuICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJiBrZXlzQS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBmaXJzdCBpbmRleCBhdCB3aGljaCBhIGxvb3NlbHkgZXF1YWwgdmFsdWUgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgYXJyYXkgKGlmIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGUgYXJyYXkgbXVzdFxuICogY29udGFpbiBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgc2hhcGUpLCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cbiAqL1xuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxudmFyIEFTU0VUX1RZUEVTID0gW1xuICAnY29tcG9uZW50JyxcbiAgJ2RpcmVjdGl2ZScsXG4gICdmaWx0ZXInXG5dO1xuXG52YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnLFxuICAnZXJyb3JDYXB0dXJlZCcsXG4gICdzZXJ2ZXJQcmVmZXRjaCdcbl07XG5cbi8qICAqL1xuXG5cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogV2FybiBoYW5kbGVyIGZvciB3YXRjaGVyIHdhcm5zXG4gICAqL1xuICB3YXJuSGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZFRhZzogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XG4gICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkQXR0cjogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgaXNVbmtub3duRWxlbWVudDogbm8sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICovXG4gIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAvKipcbiAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICovXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgbXVzdFVzZVByb3A6IG5vLFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIHVwZGF0ZXMgYXN5bmNocm9ub3VzbHkuIEludGVuZGVkIHRvIGJlIHVzZWQgYnkgVnVlIFRlc3QgVXRpbHNcbiAgICogVGhpcyB3aWxsIHNpZ25pZmljYW50bHkgcmVkdWNlIHBlcmZvcm1hbmNlIGlmIHNldCB0byBmYWxzZS5cbiAgICovXG4gIGFzeW5jOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xuICAgKi9cbiAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1Ncbn0pO1xuXG4vKiAgKi9cblxuLyoqXG4gKiB1bmljb2RlIGxldHRlcnMgdXNlZCBmb3IgcGFyc2luZyBodG1sIHRhZ3MsIGNvbXBvbmVudCBuYW1lcyBhbmQgcHJvcGVydHkgcGF0aHMuXG4gKiB1c2luZyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUzL3NlbWFudGljcy1zY3JpcHRpbmcuaHRtbCNwb3RlbnRpYWxjdXN0b21lbGVtZW50bmFtZVxuICogc2tpcHBpbmcgXFx1MTAwMDAtXFx1RUZGRkYgZHVlIHRvIGl0IGZyZWV6aW5nIHVwIFBoYW50b21KU1xuICovXG52YXIgdW5pY29kZVJlZ0V4cCA9IC9hLXpBLVpcXHUwMEI3XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjAzRi1cXHUyMDQwXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZELztcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gKi9cbnZhciBiYWlsUkUgPSBuZXcgUmVnRXhwKChcIlteXCIgKyAodW5pY29kZVJlZ0V4cC5zb3VyY2UpICsgXCIuJF9cXFxcZF1cIikpO1xuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW9iaikgeyByZXR1cm4gfVxuICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9XG59XG5cbi8qICAqL1xuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgaW5XZWV4ID0gdHlwZW9mIFdYRW52aXJvbm1lbnQgIT09ICd1bmRlZmluZWQnICYmICEhV1hFbnZpcm9ubWVudC5wbGF0Zm9ybTtcbnZhciB3ZWV4UGxhdGZvcm0gPSBpbldlZXggJiYgV1hFbnZpcm9ubWVudC5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG52YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG52YXIgaXNBbmRyb2lkID0gKFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDApIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG52YXIgaXNJT1MgPSAoVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKSkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2lvcycpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG52YXIgaXNQaGFudG9tSlMgPSBVQSAmJiAvcGhhbnRvbWpzLy50ZXN0KFVBKTtcbnZhciBpc0ZGID0gVUEgJiYgVUEubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKTtcblxuLy8gRmlyZWZveCBoYXMgYSBcIndhdGNoXCIgZnVuY3Rpb24gb24gT2JqZWN0LnByb3RvdHlwZS4uLlxudmFyIG5hdGl2ZVdhdGNoID0gKHt9KS53YXRjaDtcblxudmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuaWYgKGluQnJvd3Nlcikge1xuICB0cnkge1xuICAgIHZhciBvcHRzID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdHMsICdwYXNzaXZlJywgKHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdC1wYXNzaXZlJywgbnVsbCwgb3B0cyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbi8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxuLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcbnZhciBfaXNTZXJ2ZXI7XG52YXIgaXNTZXJ2ZXJSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaW5Ccm93c2VyICYmICFpbldlZXggJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10gJiYgZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9pc1NlcnZlclxufTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbnZhciBfU2V0O1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovIC8vICRmbG93LWRpc2FibGUtbGluZVxuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXQgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2V0O1xuICB9KCkpO1xufVxuXG4vKiAgKi9cblxudmFyIHdhcm4gPSBub29wO1xudmFyIHRpcCA9IG5vb3A7XG52YXIgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IChub29wKTsgLy8gd29yayBhcm91bmQgZmxvdyBjaGVja1xudmFyIGZvcm1hdENvbXBvbmVudE5hbWUgPSAobm9vcCk7XG5cbntcbiAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHJcbiAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpOyB9KVxuICAgIC5yZXBsYWNlKC9bLV9dL2csICcnKTsgfTtcblxuICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICB2YXIgdHJhY2UgPSB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJyc7XG5cbiAgICBpZiAoY29uZmlnLndhcm5IYW5kbGVyKSB7XG4gICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XG4gICAgfSBlbHNlIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSB3YXJuXTogXCIgKyBtc2cgKyB0cmFjZSkpO1xuICAgIH1cbiAgfTtcblxuICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltWdWUgdGlwXTogXCIgKyBtc2cgKyAoXG4gICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIHZhciBvcHRpb25zID0gdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLmNpZCAhPSBudWxsXG4gICAgICA/IHZtLm9wdGlvbnNcbiAgICAgIDogdm0uX2lzVnVlXG4gICAgICAgID8gdm0uJG9wdGlvbnMgfHwgdm0uY29uc3RydWN0b3Iub3B0aW9uc1xuICAgICAgICA6IHZtO1xuICAgIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lIHx8IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgICB2YXIgZmlsZSA9IG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyAoXCI8XCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuICAgIClcbiAgfTtcblxuICB2YXIgcmVwZWF0ID0gZnVuY3Rpb24gKHN0ciwgbikge1xuICAgIHZhciByZXMgPSAnJztcbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKG4gJSAyID09PSAxKSB7IHJlcyArPSBzdHI7IH1cbiAgICAgIGlmIChuID4gMSkgeyBzdHIgKz0gc3RyOyB9XG4gICAgICBuID4+PSAxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH07XG5cbiAgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IGZ1bmN0aW9uICh2bSkge1xuICAgIGlmICh2bS5faXNWdWUgJiYgdm0uJHBhcmVudCkge1xuICAgICAgdmFyIHRyZWUgPSBbXTtcbiAgICAgIHZhciBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgd2hpbGUgKHZtKSB7XG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgbGFzdCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAobGFzdC5jb25zdHJ1Y3RvciA9PT0gdm0uY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSsrO1xuICAgICAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA+IDApIHtcbiAgICAgICAgICAgIHRyZWVbdHJlZS5sZW5ndGggLSAxXSA9IFtsYXN0LCBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2VdO1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJlZS5wdXNoKHZtKTtcbiAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuICdcXG5cXG5mb3VuZCBpblxcblxcbicgKyB0cmVlXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHZtLCBpKSB7IHJldHVybiAoXCJcIiArIChpID09PSAwID8gJy0tLT4gJyA6IHJlcGVhdCgnICcsIDUgKyBpICogMikpICsgKEFycmF5LmlzQXJyYXkodm0pXG4gICAgICAgICAgICA/ICgoZm9ybWF0Q29tcG9uZW50TmFtZSh2bVswXSkpICsgXCIuLi4gKFwiICsgKHZtWzFdKSArIFwiIHJlY3Vyc2l2ZSBjYWxscylcIilcbiAgICAgICAgICAgIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpKTsgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXCJcXG5cXG4oZm91bmQgaW4gXCIgKyAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIpXCIpXG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHVpZCA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICovXG52YXIgRGVwID0gZnVuY3Rpb24gRGVwICgpIHtcbiAgdGhpcy5pZCA9IHVpZCsrO1xuICB0aGlzLnN1YnMgPSBbXTtcbn07XG5cbkRlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViIChzdWIpIHtcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gcmVtb3ZlU3ViIChzdWIpIHtcbiAgcmVtb3ZlKHRoaXMuc3Vicywgc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgaWYgKERlcC50YXJnZXQpIHtcbiAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgfVxufTtcblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkgKCkge1xuICAvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICB2YXIgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICBpZiAoIWNvbmZpZy5hc3luYykge1xuICAgIC8vIHN1YnMgYXJlbid0IHNvcnRlZCBpbiBzY2hlZHVsZXIgaWYgbm90IHJ1bm5pbmcgYXN5bmNcbiAgICAvLyB3ZSBuZWVkIHRvIHNvcnQgdGhlbSBub3cgdG8gbWFrZSBzdXJlIHRoZXkgZmlyZSBpbiBjb3JyZWN0XG4gICAgLy8gb3JkZXJcbiAgICBzdWJzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3Vic1tpXS51cGRhdGUoKTtcbiAgfVxufTtcblxuLy8gVGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuLy8gVGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSBvbmx5IG9uZSB3YXRjaGVyXG4vLyBjYW4gYmUgZXZhbHVhdGVkIGF0IGEgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xudmFyIHRhcmdldFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIHB1c2hUYXJnZXQgKHRhcmdldCkge1xuICB0YXJnZXRTdGFjay5wdXNoKHRhcmdldCk7XG4gIERlcC50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG4gIHRhcmdldFN0YWNrLnBvcCgpO1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2tbdGFyZ2V0U3RhY2subGVuZ3RoIC0gMV07XG59XG5cbi8qICAqL1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIHRleHQsXG4gIGVsbSxcbiAgY29udGV4dCxcbiAgY29tcG9uZW50T3B0aW9ucyxcbiAgYXN5bmNGYWN0b3J5XG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZm5Db250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmZuT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mblNjb3BlSWQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGNoaWxkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgaWYgKCB0ZXh0ID09PSB2b2lkIDAgKSB0ZXh0ID0gJyc7XG5cbiAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgbm9kZS50ZXh0ID0gdGV4dDtcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlKSB7XG4gIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgLy8gIzc5NzVcbiAgICAvLyBjbG9uZSBjaGlsZHJlbiBhcnJheSB0byBhdm9pZCBtdXRhdGluZyBvcmlnaW5hbCBpbiBjYXNlIG9mIGNsb25pbmdcbiAgICAvLyBhIGNoaWxkLlxuICAgIHZub2RlLmNoaWxkcmVuICYmIHZub2RlLmNoaWxkcmVuLnNsaWNlKCksXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zLFxuICAgIHZub2RlLmFzeW5jRmFjdG9yeVxuICApO1xuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XG4gIGNsb25lZC5mbkNvbnRleHQgPSB2bm9kZS5mbkNvbnRleHQ7XG4gIGNsb25lZC5mbk9wdGlvbnMgPSB2bm9kZS5mbk9wdGlvbnM7XG4gIGNsb25lZC5mblNjb3BlSWQgPSB2bm9kZS5mblNjb3BlSWQ7XG4gIGNsb25lZC5hc3luY01ldGEgPSB2bm9kZS5hc3luY01ldGE7XG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gIHJldHVybiBjbG9uZWRcbn1cblxuLypcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gKi9cblxudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtcblxudmFyIG1ldGhvZHNUb1BhdGNoID0gW1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXTtcblxuLyoqXG4gKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcbiAqL1xubWV0aG9kc1RvUGF0Y2guZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogSW4gc29tZSBjYXNlcyB3ZSBtYXkgd2FudCB0byBkaXNhYmxlIG9ic2VydmF0aW9uIGluc2lkZSBhIGNvbXBvbmVudCdzXG4gKiB1cGRhdGUgY29tcHV0YXRpb24uXG4gKi9cbnZhciBzaG91bGRPYnNlcnZlID0gdHJ1ZTtcblxuZnVuY3Rpb24gdG9nZ2xlT2JzZXJ2aW5nICh2YWx1ZSkge1xuICBzaG91bGRPYnNlcnZlID0gdmFsdWU7XG59XG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBpcyBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0aGUgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgaWYgKGhhc1Byb3RvKSB7XG4gICAgICBwcm90b0F1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvcHlBdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgfVxuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBhbGwgcHJvcGVydGllcyBhbmQgY29udmVydCB0aGVtIGludG9cbiAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXlzW2ldKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIG9ic2VydmVBcnJheSAoaXRlbXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgfVxufTtcblxuLy8gaGVscGVyc1xuXG4vKipcbiAqIEF1Z21lbnQgYSB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iO1xuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgfSBlbHNlIGlmIChcbiAgICBzaG91bGRPYnNlcnZlICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlJCQxIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyLFxuICBzaGFsbG93XG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuICBpZiAoKCFnZXR0ZXIgfHwgc2V0dGVyKSAmJiBhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFsID0gb2JqW2tleV07XG4gIH1cblxuICB2YXIgY2hpbGRPYiA9ICFzaGFsbG93ICYmIG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICAvLyAjNzk4MTogZm9yIGFjY2Vzc29yIHByb3BlcnRpZXMgd2l0aG91dCBzZXR0ZXJcbiAgICAgIGlmIChnZXR0ZXIgJiYgIXNldHRlcikgeyByZXR1cm4gfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpXG4gICkge1xuICAgIHdhcm4oKFwiQ2Fubm90IHNldCByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgd2FybihcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKCFvYikge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBkZWZpbmVSZWFjdGl2ZSQkMShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICBvYi5kZXAubm90aWZ5KCk7XG4gIHJldHVybiB2YWxcbn1cblxuLyoqXG4gKiBEZWxldGUgYSBwcm9wZXJ0eSBhbmQgdHJpZ2dlciBjaGFuZ2UgaWYgbmVjZXNzYXJ5LlxuICovXG5mdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG4gIGlmIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KVxuICApIHtcbiAgICB3YXJuKChcIkNhbm5vdCBkZWxldGUgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHdhcm4oXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldO1xuICBpZiAoIW9iKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG4gIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4vKipcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAqL1xue1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuXG4gIHZhciBrZXlzID0gaGFzU3ltYm9sXG4gICAgPyBSZWZsZWN0Lm93bktleXMoZnJvbSlcbiAgICA6IE9iamVjdC5rZXlzKGZyb20pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgLy8gaW4gY2FzZSB0aGUgb2JqZWN0IGlzIGFscmVhZHkgb2JzZXJ2ZWQuLi5cbiAgICBpZiAoa2V5ID09PSAnX19vYl9fJykgeyBjb250aW51ZSB9XG4gICAgdG9WYWwgPSB0b1trZXldO1xuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdG9WYWwgIT09IGZyb21WYWwgJiZcbiAgICAgIGlzUGxhaW5PYmplY3QodG9WYWwpICYmXG4gICAgICBpc1BsYWluT2JqZWN0KGZyb21WYWwpXG4gICAgKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YU9yRm4gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogY2hpbGRWYWwsXG4gICAgICAgIHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbicgPyBwYXJlbnRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IHBhcmVudFZhbFxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogcGFyZW50VmFsO1xuICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIGlmIChjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2RlZmluaXRpb25zLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwpXG4gIH1cblxuICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSlcbn07XG5cbi8qKlxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUhvb2sgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsXG4pIHtcbiAgdmFyIHJlcyA9IGNoaWxkVmFsXG4gICAgPyBwYXJlbnRWYWxcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcbiAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICA6IFtjaGlsZFZhbF1cbiAgICA6IHBhcmVudFZhbDtcbiAgcmV0dXJuIHJlc1xuICAgID8gZGVkdXBlSG9va3MocmVzKVxuICAgIDogcmVzXG59XG5cbmZ1bmN0aW9uIGRlZHVwZUhvb2tzIChob29rcykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocmVzLmluZGV4T2YoaG9va3NbaV0pID09PSAtMSkge1xuICAgICAgcmVzLnB1c2goaG9va3NbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIGlmIChjaGlsZFZhbCkge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkkMSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5JDFdO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleSQxXTtcbiAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5JDFdID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5pbmplY3QgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgaWYgKGNoaWxkVmFsICYmIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lIChuYW1lKSB7XG4gIGlmICghbmV3IFJlZ0V4cCgoXCJeW2EtekEtWl1bXFxcXC1cXFxcLjAtOV9cIiArICh1bmljb2RlUmVnRXhwLnNvdXJjZSkgKyBcIl0qJFwiKSkudGVzdChuYW1lKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgJ3Nob3VsZCBjb25mb3JtIHRvIHZhbGlkIGN1c3RvbSBlbGVtZW50IG5hbWUgaW4gaHRtbDUgc3BlY2lmaWNhdGlvbi4nXG4gICAgKTtcbiAgfVxuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgJ2lkOiAnICsgbmFtZVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB7IHR5cGU6IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcInByb3BzXFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHByb3BzKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICBvcHRpb25zLnByb3BzID0gcmVzO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhbGwgaW5qZWN0aW9ucyBpbnRvIE9iamVjdC1iYXNlZCBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0IChvcHRpb25zLCB2bSkge1xuICB2YXIgaW5qZWN0ID0gb3B0aW9ucy5pbmplY3Q7XG4gIGlmICghaW5qZWN0KSB7IHJldHVybiB9XG4gIHZhciBub3JtYWxpemVkID0gb3B0aW9ucy5pbmplY3QgPSB7fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSB7IGZyb206IGluamVjdFtpXSB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gaW5qZWN0KSB7XG4gICAgICB2YXIgdmFsID0gaW5qZWN0W2tleV07XG4gICAgICBub3JtYWxpemVkW2tleV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyBleHRlbmQoeyBmcm9tOiBrZXkgfSwgdmFsKVxuICAgICAgICA6IHsgZnJvbTogdmFsIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKGluamVjdCkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmJCQxID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYkJDEsIHVwZGF0ZTogZGVmJCQxIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGUgKG5hbWUsIHZhbHVlLCB2bSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCI6IGV4cGVjdGVkIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgfVxuXG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZUluamVjdChjaGlsZCwgdm0pO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcblxuICAvLyBBcHBseSBleHRlbmRzIGFuZCBtaXhpbnMgb24gdGhlIGNoaWxkIG9wdGlvbnMsXG4gIC8vIGJ1dCBvbmx5IGlmIGl0IGlzIGEgcmF3IG9wdGlvbnMgb2JqZWN0IHRoYXQgaXNuJ3RcbiAgLy8gdGhlIHJlc3VsdCBvZiBhbm90aGVyIG1lcmdlT3B0aW9ucyBjYWxsLlxuICAvLyBPbmx5IG1lcmdlZCBvcHRpb25zIGhhcyB0aGUgX2Jhc2UgcHJvcGVydHkuXG4gIGlmICghY2hpbGQuX2Jhc2UpIHtcbiAgICBpZiAoY2hpbGQuZXh0ZW5kcykge1xuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQuZXh0ZW5kcywgdm0pO1xuICAgIH1cbiAgICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxuICBrZXksXG4gIHByb3BPcHRpb25zLFxuICBwcm9wc0RhdGEsXG4gIHZtXG4pIHtcbiAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAvLyBib29sZWFuIGNhc3RpbmdcbiAgdmFyIGJvb2xlYW5JbmRleCA9IGdldFR5cGVJbmRleChCb29sZWFuLCBwcm9wLnR5cGUpO1xuICBpZiAoYm9vbGVhbkluZGV4ID4gLTEpIHtcbiAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpIHtcbiAgICAgIC8vIG9ubHkgY2FzdCBlbXB0eSBzdHJpbmcgLyBzYW1lIG5hbWUgdG8gYm9vbGVhbiBpZlxuICAgICAgLy8gYm9vbGVhbiBoYXMgaGlnaGVyIHByaW9yaXR5XG4gICAgICB2YXIgc3RyaW5nSW5kZXggPSBnZXRUeXBlSW5kZXgoU3RyaW5nLCBwcm9wLnR5cGUpO1xuICAgICAgaWYgKHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleCkge1xuICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIHZhciBwcmV2U2hvdWxkT2JzZXJ2ZSA9IHNob3VsZE9ic2VydmU7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIHRvZ2dsZU9ic2VydmluZyhwcmV2U2hvdWxkT2JzZXJ2ZSk7XG4gIH1cbiAge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAoaXNPYmplY3QoZGVmKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuICAgID8gZGVmLmNhbGwodm0pXG4gICAgOiBkZWZcbn1cblxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxuICBwcm9wLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgdm0sXG4gIGFic2VudFxuKSB7XG4gIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuICAgIHdhcm4oXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sKSQvO1xuXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcbiAgICB2YXIgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIGZvciBwcmltaXRpdmUgd3JhcHBlciBvYmplY3RzXG4gICAgaWYgKCF2YWxpZCAmJiB0ID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfVxufVxuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXG59XG5cbmZ1bmN0aW9uIGlzU2FtZVR5cGUgKGEsIGIpIHtcbiAgcmV0dXJuIGdldFR5cGUoYSkgPT09IGdldFR5cGUoYilcbn1cblxuZnVuY3Rpb24gZ2V0VHlwZUluZGV4ICh0eXBlLCBleHBlY3RlZFR5cGVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFR5cGVzKSkge1xuICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGV4cGVjdGVkVHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzW2ldLCB0eXBlKSkge1xuICAgICAgcmV0dXJuIGlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbmZ1bmN0aW9uIGdldEludmFsaWRUeXBlTWVzc2FnZSAobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgdmFyIG1lc3NhZ2UgPSBcIkludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXFxcIlwiICsgbmFtZSArIFwiXFxcIi5cIiArXG4gICAgXCIgRXhwZWN0ZWQgXCIgKyAoZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSk7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xuICB2YXIgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcbiAgdmFyIGV4cGVjdGVkVmFsdWUgPSBzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpO1xuICB2YXIgcmVjZWl2ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSk7XG4gIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSBleHBlY3RlZCB2YWx1ZVxuICBpZiAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmXG4gICAgICAhaXNCb29sZWFuKGV4cGVjdGVkVHlwZSwgcmVjZWl2ZWRUeXBlKSkge1xuICAgIG1lc3NhZ2UgKz0gXCIgd2l0aCB2YWx1ZSBcIiArIGV4cGVjdGVkVmFsdWU7XG4gIH1cbiAgbWVzc2FnZSArPSBcIiwgZ290IFwiICsgcmVjZWl2ZWRUeXBlICsgXCIgXCI7XG4gIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSByZWNlaXZlZCB2YWx1ZVxuICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcbiAgICBtZXNzYWdlICs9IFwid2l0aCB2YWx1ZSBcIiArIHJlY2VpdmVkVmFsdWUgKyBcIi5cIjtcbiAgfVxuICByZXR1cm4gbWVzc2FnZVxufVxuXG5mdW5jdGlvbiBzdHlsZVZhbHVlICh2YWx1ZSwgdHlwZSkge1xuICBpZiAodHlwZSA9PT0gJ1N0cmluZycpIHtcbiAgICByZXR1cm4gKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIilcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnTnVtYmVyJykge1xuICAgIHJldHVybiAoXCJcIiArIChOdW1iZXIodmFsdWUpKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiXCIgKyB2YWx1ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0V4cGxpY2FibGUgKHZhbHVlKSB7XG4gIHZhciBleHBsaWNpdFR5cGVzID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcbiAgcmV0dXJuIGV4cGxpY2l0VHlwZXMuc29tZShmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gZWxlbTsgfSlcbn1cblxuZnVuY3Rpb24gaXNCb29sZWFuICgpIHtcbiAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICByZXR1cm4gYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09ICdib29sZWFuJzsgfSlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIC8vIERlYWN0aXZhdGUgZGVwcyB0cmFja2luZyB3aGlsZSBwcm9jZXNzaW5nIGVycm9yIGhhbmRsZXIgdG8gYXZvaWQgcG9zc2libGUgaW5maW5pdGUgcmVuZGVyaW5nLlxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWV4L2lzc3Vlcy8xNTA1XG4gIHB1c2hUYXJnZXQoKTtcbiAgdHJ5IHtcbiAgICBpZiAodm0pIHtcbiAgICAgIHZhciBjdXIgPSB2bTtcbiAgICAgIHdoaWxlICgoY3VyID0gY3VyLiRwYXJlbnQpKSB7XG4gICAgICAgIHZhciBob29rcyA9IGN1ci4kb3B0aW9ucy5lcnJvckNhcHR1cmVkO1xuICAgICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7IHJldHVybiB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBwb3BUYXJnZXQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyAoXG4gIGhhbmRsZXIsXG4gIGNvbnRleHQsXG4gIGFyZ3MsXG4gIHZtLFxuICBpbmZvXG4pIHtcbiAgdmFyIHJlcztcbiAgdHJ5IHtcbiAgICByZXMgPSBhcmdzID8gaGFuZGxlci5hcHBseShjb250ZXh0LCBhcmdzKSA6IGhhbmRsZXIuY2FsbChjb250ZXh0KTtcbiAgICBpZiAocmVzICYmICFyZXMuX2lzVnVlICYmIGlzUHJvbWlzZShyZXMpICYmICFyZXMuX2hhbmRsZWQpIHtcbiAgICAgIHJlcy5jYXRjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8gKyBcIiAoUHJvbWlzZS9hc3luYylcIik7IH0pO1xuICAgICAgLy8gaXNzdWUgIzk1MTFcbiAgICAgIC8vIGF2b2lkIGNhdGNoIHRyaWdnZXJpbmcgbXVsdGlwbGUgdGltZXMgd2hlbiBuZXN0ZWQgY2FsbHNcbiAgICAgIHJlcy5faGFuZGxlZCA9IHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8pO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGlmIHRoZSB1c2VyIGludGVudGlvbmFsbHkgdGhyb3dzIHRoZSBvcmlnaW5hbCBlcnJvciBpbiB0aGUgaGFuZGxlcixcbiAgICAgIC8vIGRvIG5vdCBsb2cgaXQgdHdpY2VcbiAgICAgIGlmIChlICE9PSBlcnIpIHtcbiAgICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGxvZ0Vycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIHtcbiAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOiBcXFwiXCIgKyAoZXJyLnRvU3RyaW5nKCkpICsgXCJcXFwiXCIpLCB2bSk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKChpbkJyb3dzZXIgfHwgaW5XZWV4KSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBpc1VzaW5nTWljcm9UYXNrID0gZmFsc2U7XG5cbnZhciBjYWxsYmFja3MgPSBbXTtcbnZhciBwZW5kaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsdXNoQ2FsbGJhY2tzICgpIHtcbiAgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3BpZXNbaV0oKTtcbiAgfVxufVxuXG4vLyBIZXJlIHdlIGhhdmUgYXN5bmMgZGVmZXJyaW5nIHdyYXBwZXJzIHVzaW5nIG1pY3JvdGFza3MuXG4vLyBJbiAyLjUgd2UgdXNlZCAobWFjcm8pIHRhc2tzIChpbiBjb21iaW5hdGlvbiB3aXRoIG1pY3JvdGFza3MpLlxuLy8gSG93ZXZlciwgaXQgaGFzIHN1YnRsZSBwcm9ibGVtcyB3aGVuIHN0YXRlIGlzIGNoYW5nZWQgcmlnaHQgYmVmb3JlIHJlcGFpbnRcbi8vIChlLmcuICM2ODEzLCBvdXQtaW4gdHJhbnNpdGlvbnMpLlxuLy8gQWxzbywgdXNpbmcgKG1hY3JvKSB0YXNrcyBpbiBldmVudCBoYW5kbGVyIHdvdWxkIGNhdXNlIHNvbWUgd2VpcmQgYmVoYXZpb3JzXG4vLyB0aGF0IGNhbm5vdCBiZSBjaXJjdW12ZW50ZWQgKGUuZy4gIzcxMDksICM3MTUzLCAjNzU0NiwgIzc4MzQsICM4MTA5KS5cbi8vIFNvIHdlIG5vdyB1c2UgbWljcm90YXNrcyBldmVyeXdoZXJlLCBhZ2Fpbi5cbi8vIEEgbWFqb3IgZHJhd2JhY2sgb2YgdGhpcyB0cmFkZW9mZiBpcyB0aGF0IHRoZXJlIGFyZSBzb21lIHNjZW5hcmlvc1xuLy8gd2hlcmUgbWljcm90YXNrcyBoYXZlIHRvbyBoaWdoIGEgcHJpb3JpdHkgYW5kIGZpcmUgaW4gYmV0d2VlbiBzdXBwb3NlZGx5XG4vLyBzZXF1ZW50aWFsIGV2ZW50cyAoZS5nLiAjNDUyMSwgIzY2OTAsIHdoaWNoIGhhdmUgd29ya2Fyb3VuZHMpXG4vLyBvciBldmVuIGJldHdlZW4gYnViYmxpbmcgb2YgdGhlIHNhbWUgZXZlbnQgKCM2NTY2KS5cbnZhciB0aW1lckZ1bmM7XG5cbi8vIFRoZSBuZXh0VGljayBiZWhhdmlvciBsZXZlcmFnZXMgdGhlIG1pY3JvdGFzayBxdWV1ZSwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkXG4vLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cbi8vIE11dGF0aW9uT2JzZXJ2ZXIgaGFzIHdpZGVyIHN1cHBvcnQsIGhvd2V2ZXIgaXQgaXMgc2VyaW91c2x5IGJ1Z2dlZCBpblxuLy8gVUlXZWJWaWV3IGluIGlPUyA+PSA5LjMuMyB3aGVuIHRyaWdnZXJlZCBpbiB0b3VjaCBldmVudCBoYW5kbGVycy4gSXRcbi8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcbi8vIFByb21pc2UgaXMgYXZhaWxhYmxlLCB3ZSB3aWxsIHVzZSBpdDpcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0LCAkZmxvdy1kaXNhYmxlLWxpbmUgKi9cbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHAudGhlbihmbHVzaENhbGxiYWNrcyk7XG4gICAgLy8gSW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuICB9O1xuICBpc1VzaW5nTWljcm9UYXNrID0gdHJ1ZTtcbn0gZWxzZSBpZiAoIWlzSUUgJiYgdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmIChcbiAgaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcbiAgLy8gUGhhbnRvbUpTIGFuZCBpT1MgNy54XG4gIE11dGF0aW9uT2JzZXJ2ZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXSdcbikpIHtcbiAgLy8gVXNlIE11dGF0aW9uT2JzZXJ2ZXIgd2hlcmUgbmF0aXZlIFByb21pc2UgaXMgbm90IGF2YWlsYWJsZSxcbiAgLy8gZS5nLiBQaGFudG9tSlMsIGlPUzcsIEFuZHJvaWQgNC40XG4gIC8vICgjNjQ2NiBNdXRhdGlvbk9ic2VydmVyIGlzIHVucmVsaWFibGUgaW4gSUUxMSlcbiAgdmFyIGNvdW50ZXIgPSAxO1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmbHVzaENhbGxiYWNrcyk7XG4gIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XG4gIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gIH0pO1xuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XG4gIH07XG4gIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xufSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShzZXRJbW1lZGlhdGUpKSB7XG4gIC8vIEZhbGxiYWNrIHRvIHNldEltbWVkaWF0ZS5cbiAgLy8gVGVjaGluaWNhbGx5IGl0IGxldmVyYWdlcyB0aGUgKG1hY3JvKSB0YXNrIHF1ZXVlLFxuICAvLyBidXQgaXQgaXMgc3RpbGwgYSBiZXR0ZXIgY2hvaWNlIHRoYW4gc2V0VGltZW91dC5cbiAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBGYWxsYmFjayB0byBzZXRUaW1lb3V0LlxuICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0VGltZW91dChmbHVzaENhbGxiYWNrcywgMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XG4gIHZhciBfcmVzb2x2ZTtcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgcGVuZGluZyA9IHRydWU7XG4gICAgdGltZXJGdW5jKCk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSlcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxue1xuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICAvLyBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSlcbiAgICB9O1xuICB9XG59XG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xuXG52YXIgaW5pdFByb3h5O1xuXG57XG4gIHZhciBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgJ3JlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyByZWFjdGl2ZSwgJyArXG4gICAgICAnZWl0aGVyIGluIHRoZSBkYXRhIG9wdGlvbiwgb3IgZm9yIGNsYXNzLWJhc2VkIGNvbXBvbmVudHMsIGJ5ICcgK1xuICAgICAgJ2luaXRpYWxpemluZyB0aGUgcHJvcGVydHkuICcgK1xuICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvcmVhY3Rpdml0eS5odG1sI0RlY2xhcmluZy1SZWFjdGl2ZS1Qcm9wZXJ0aWVzLicsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciB3YXJuUmVzZXJ2ZWRQcmVmaXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgbXVzdCBiZSBhY2Nlc3NlZCB3aXRoIFxcXCIkZGF0YS5cIiArIGtleSArIFwiXFxcIiBiZWNhdXNlIFwiICtcbiAgICAgICdwcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggXCIkXCIgb3IgXCJfXCIgYXJlIG5vdCBwcm94aWVkIGluIHRoZSBWdWUgaW5zdGFuY2UgdG8gJyArXG4gICAgICAncHJldmVudCBjb25mbGljdHMgd2l0aCBWdWUgaW50ZXJuYWxzJyArXG4gICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9hcGkvI2RhdGEnLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICB2YXIgaGFzUHJveHkgPVxuICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJveHkpO1xuXG4gIGlmIChoYXNQcm94eSkge1xuICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QnKTtcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgd2FybigoXCJBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC5cIiArIGtleSkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhhc0hhbmRsZXIgPSB7XG4gICAgaGFzOiBmdW5jdGlvbiBoYXMgKHRhcmdldCwga2V5KSB7XG4gICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgIHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8XG4gICAgICAgICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiBrZXkuY2hhckF0KDApID09PSAnXycgJiYgIShrZXkgaW4gdGFyZ2V0LiRkYXRhKSk7XG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0LiRkYXRhKSB7IHdhcm5SZXNlcnZlZFByZWZpeCh0YXJnZXQsIGtleSk7IH1cbiAgICAgICAgZWxzZSB7IHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRIYW5kbGVyID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHsgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTsgfVxuICAgICAgICBlbHNlIHsgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV1cbiAgICB9XG4gIH07XG5cbiAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuICAgIGlmIChoYXNQcm94eSkge1xuICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgdmFyIGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxuICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgOiBoYXNIYW5kbGVyO1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcbn1cblxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcbiAgdmFyIGksIGtleXM7XG4gIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgT2JqZWN0LmlzRnJvemVuKHZhbCkgfHwgdmFsIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsLl9fb2JfXykge1xuICAgIHZhciBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xuICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzZWVuLmFkZChkZXBJZCk7XG4gIH1cbiAgaWYgKGlzQSkge1xuICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7IH1cbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2tleXNbaV1dLCBzZWVuKTsgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIHBhc3NpdmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyYnO1xuICBuYW1lID0gcGFzc2l2ZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgbmFtZSA9IG9uY2UkJDEgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIGNhcHR1cmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyEnO1xuICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgb25jZTogb25jZSQkMSxcbiAgICBjYXB0dXJlOiBjYXB0dXJlLFxuICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZuSW52b2tlciAoZm5zLCB2bSkge1xuICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgdmFyIGNsb25lZCA9IGZucy5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2xvbmVkW2ldLCBudWxsLCBhcmd1bWVudHMkMSwgdm0sIFwidi1vbiBoYW5kbGVyXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuICAgICAgcmV0dXJuIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGZucywgbnVsbCwgYXJndW1lbnRzLCB2bSwgXCJ2LW9uIGhhbmRsZXJcIilcbiAgICB9XG4gIH1cbiAgaW52b2tlci5mbnMgPSBmbnM7XG4gIHJldHVybiBpbnZva2VyXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gIG9uLFxuICBvbGRPbixcbiAgYWRkLFxuICByZW1vdmUkJDEsXG4gIGNyZWF0ZU9uY2VIYW5kbGVyLFxuICB2bVxuKSB7XG4gIHZhciBuYW1lLCBkZWYkJDEsIGN1ciwgb2xkLCBldmVudDtcbiAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgZGVmJCQxID0gY3VyID0gb25bbmFtZV07XG4gICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICBpZiAoaXNVbmRlZihjdXIpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1ciwgdm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzVHJ1ZShldmVudC5vbmNlKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZU9uY2VIYW5kbGVyKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSk7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlLCBldmVudC5wYXJhbXMpO1xuICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgIG9sZC5mbnMgPSBjdXI7XG4gICAgICBvbltuYW1lXSA9IG9sZDtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgcmVtb3ZlJCQxKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLCBldmVudC5jYXB0dXJlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2spIHtcbiAgaWYgKGRlZiBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcbiAgfVxuICB2YXIgaW52b2tlcjtcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXG4gIGRhdGEsXG4gIEN0b3IsXG4gIHRhZ1xuKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICB7XG4gICAgICAgIHZhciBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxuICAgICAgICAgIGF0dHJzICYmIGhhc093bihhdHRycywga2V5SW5Mb3dlckNhc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIHRpcChcbiAgICAgICAgICAgIFwiUHJvcCBcXFwiXCIgKyBrZXlJbkxvd2VyQ2FzZSArIFwiXFxcIiBpcyBwYXNzZWQgdG8gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHRhZyB8fCBDdG9yKSkgKyBcIiwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNcIiArXG4gICAgICAgICAgICBcIiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBcIiArXG4gICAgICAgICAgICBcInByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gXCIgK1xuICAgICAgICAgICAgXCJ0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIGFsdEtleSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGtleSArIFwiXFxcIi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcCAoXG4gIHJlcyxcbiAgaGFzaCxcbiAga2V5LFxuICBhbHRLZXksXG4gIHByZXNlcnZlXG4pIHtcbiAgaWYgKGlzRGVmKGhhc2gpKSB7XG4gICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cbi8vXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxuLy8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOlxuXG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXG4vLyBub3JtYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxuZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbltpXSkpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcbi8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgIDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGlzVGV4dE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIGlzRGVmKG5vZGUpICYmIGlzRGVmKG5vZGUudGV4dCkgJiYgaXNGYWxzZShub2RlLmlzQ29tbWVudClcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIGksIGMsIGxhc3RJbmRleCwgbGFzdDtcbiAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IGNoaWxkcmVuW2ldO1xuICAgIGlmIChpc1VuZGVmKGMpIHx8IHR5cGVvZiBjID09PSAnYm9vbGVhbicpIHsgY29udGludWUgfVxuICAgIGxhc3RJbmRleCA9IHJlcy5sZW5ndGggLSAxO1xuICAgIGxhc3QgPSByZXNbbGFzdEluZGV4XTtcbiAgICAvLyAgbmVzdGVkXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgIGlmIChjLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYyA9IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oYywgKChuZXN0ZWRJbmRleCB8fCAnJykgKyBcIl9cIiArIGkpKTtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICBpZiAoaXNUZXh0Tm9kZShjWzBdKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgKGNbMF0pLnRleHQpO1xuICAgICAgICAgIGMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaC5hcHBseShyZXMsIGMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUoYykpIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIFNTUiBoeWRyYXRpb24gYmVjYXVzZSB0ZXh0IG5vZGVzIGFyZVxuICAgICAgICAvLyBlc3NlbnRpYWxseSBtZXJnZWQgd2hlbiByZW5kZXJlZCB0byBIVE1MIHN0cmluZ3NcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYyk7XG4gICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlXG4gICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjLnRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVmYXVsdCBrZXkgZm9yIG5lc3RlZCBhcnJheSBjaGlsZHJlbiAobGlrZWx5IGdlbmVyYXRlZCBieSB2LWZvcilcbiAgICAgICAgaWYgKGlzVHJ1ZShjaGlsZHJlbi5faXNWTGlzdCkgJiZcbiAgICAgICAgICBpc0RlZihjLnRhZykgJiZcbiAgICAgICAgICBpc1VuZGVmKGMua2V5KSAmJlxuICAgICAgICAgIGlzRGVmKG5lc3RlZEluZGV4KSkge1xuICAgICAgICAgIGMua2V5ID0gXCJfX3ZsaXN0XCIgKyBuZXN0ZWRJbmRleCArIFwiX1wiICsgaSArIFwiX19cIjtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgaWYgKHByb3ZpZGUpIHtcbiAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwcm92aWRlLmNhbGwodm0pXG4gICAgICA6IHByb3ZpZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEluamVjdGlvbnMgKHZtKSB7XG4gIHZhciByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICBpZiAocmVzdWx0KSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAvLyAjNjU3NCBpbiBjYXNlIHRoZSBpbmplY3Qgb2JqZWN0IGlzIG9ic2VydmVkLi4uXG4gICAgICBpZiAoa2V5ID09PSAnX19vYl9fJykgeyBjb250aW51ZSB9XG4gICAgICB2YXIgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XG4gICAgICB2YXIgc291cmNlID0gdm07XG4gICAgICB3aGlsZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIGhhc093bihzb3VyY2UuX3Byb3ZpZGVkLCBwcm92aWRlS2V5KSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBpbmplY3Rba2V5XSkge1xuICAgICAgICAgIHZhciBwcm92aWRlRGVmYXVsdCA9IGluamVjdFtrZXldLmRlZmF1bHQ7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB0eXBlb2YgcHJvdmlkZURlZmF1bHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcbiAgICAgICAgICAgIDogcHJvdmlkZURlZmF1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybigoXCJJbmplY3Rpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICBpZiAoIWNoaWxkcmVuIHx8ICFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICByZXR1cm4ge31cbiAgfVxuICB2YXIgc2xvdHMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICB2YXIgZGF0YSA9IGNoaWxkLmRhdGE7XG4gICAgLy8gcmVtb3ZlIHNsb3QgYXR0cmlidXRlIGlmIHRoZSBub2RlIGlzIHJlc29sdmVkIGFzIGEgVnVlIHNsb3Qgbm9kZVxuICAgIGlmIChkYXRhICYmIGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5zbG90KSB7XG4gICAgICBkZWxldGUgZGF0YS5hdHRycy5zbG90O1xuICAgIH1cbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZuQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgIGRhdGEgJiYgZGF0YS5zbG90ICE9IG51bGxcbiAgICApIHtcbiAgICAgIHZhciBuYW1lID0gZGF0YS5zbG90O1xuICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIChzbG90cy5kZWZhdWx0IHx8IChzbG90cy5kZWZhdWx0ID0gW10pKS5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLy8gaWdub3JlIHNsb3RzIHRoYXQgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlXG4gIGZvciAodmFyIG5hbWUkMSBpbiBzbG90cykge1xuICAgIGlmIChzbG90c1tuYW1lJDFdLmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICAgIGRlbGV0ZSBzbG90c1tuYW1lJDFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2xvdHNcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gIHJldHVybiAobm9kZS5pc0NvbW1lbnQgJiYgIW5vZGUuYXN5bmNGYWN0b3J5KSB8fCBub2RlLnRleHQgPT09ICcgJ1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdHMgKFxuICBzbG90cyxcbiAgbm9ybWFsU2xvdHMsXG4gIHByZXZTbG90c1xuKSB7XG4gIHZhciByZXM7XG4gIHZhciBoYXNOb3JtYWxTbG90cyA9IE9iamVjdC5rZXlzKG5vcm1hbFNsb3RzKS5sZW5ndGggPiAwO1xuICB2YXIgaXNTdGFibGUgPSBzbG90cyA/ICEhc2xvdHMuJHN0YWJsZSA6ICFoYXNOb3JtYWxTbG90cztcbiAgdmFyIGtleSA9IHNsb3RzICYmIHNsb3RzLiRrZXk7XG4gIGlmICghc2xvdHMpIHtcbiAgICByZXMgPSB7fTtcbiAgfSBlbHNlIGlmIChzbG90cy5fbm9ybWFsaXplZCkge1xuICAgIC8vIGZhc3QgcGF0aCAxOiBjaGlsZCBjb21wb25lbnQgcmUtcmVuZGVyIG9ubHksIHBhcmVudCBkaWQgbm90IGNoYW5nZVxuICAgIHJldHVybiBzbG90cy5fbm9ybWFsaXplZFxuICB9IGVsc2UgaWYgKFxuICAgIGlzU3RhYmxlICYmXG4gICAgcHJldlNsb3RzICYmXG4gICAgcHJldlNsb3RzICE9PSBlbXB0eU9iamVjdCAmJlxuICAgIGtleSA9PT0gcHJldlNsb3RzLiRrZXkgJiZcbiAgICAhaGFzTm9ybWFsU2xvdHMgJiZcbiAgICAhcHJldlNsb3RzLiRoYXNOb3JtYWxcbiAgKSB7XG4gICAgLy8gZmFzdCBwYXRoIDI6IHN0YWJsZSBzY29wZWQgc2xvdHMgdy8gbm8gbm9ybWFsIHNsb3RzIHRvIHByb3h5LFxuICAgIC8vIG9ubHkgbmVlZCB0byBub3JtYWxpemUgb25jZVxuICAgIHJldHVybiBwcmV2U2xvdHNcbiAgfSBlbHNlIHtcbiAgICByZXMgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkkMSBpbiBzbG90cykge1xuICAgICAgaWYgKHNsb3RzW2tleSQxXSAmJiBrZXkkMVswXSAhPT0gJyQnKSB7XG4gICAgICAgIHJlc1trZXkkMV0gPSBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXkkMSwgc2xvdHNba2V5JDFdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gZXhwb3NlIG5vcm1hbCBzbG90cyBvbiBzY29wZWRTbG90c1xuICBmb3IgKHZhciBrZXkkMiBpbiBub3JtYWxTbG90cykge1xuICAgIGlmICghKGtleSQyIGluIHJlcykpIHtcbiAgICAgIHJlc1trZXkkMl0gPSBwcm94eU5vcm1hbFNsb3Qobm9ybWFsU2xvdHMsIGtleSQyKTtcbiAgICB9XG4gIH1cbiAgLy8gYXZvcmlheiBzZWVtcyB0byBtb2NrIGEgbm9uLWV4dGVuc2libGUgJHNjb3BlZFNsb3RzIG9iamVjdFxuICAvLyBhbmQgd2hlbiB0aGF0IGlzIHBhc3NlZCBkb3duIHRoaXMgd291bGQgY2F1c2UgYW4gZXJyb3JcbiAgaWYgKHNsb3RzICYmIE9iamVjdC5pc0V4dGVuc2libGUoc2xvdHMpKSB7XG4gICAgKHNsb3RzKS5fbm9ybWFsaXplZCA9IHJlcztcbiAgfVxuICBkZWYocmVzLCAnJHN0YWJsZScsIGlzU3RhYmxlKTtcbiAgZGVmKHJlcywgJyRrZXknLCBrZXkpO1xuICBkZWYocmVzLCAnJGhhc05vcm1hbCcsIGhhc05vcm1hbFNsb3RzKTtcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXksIGZuKSB7XG4gIHZhciBub3JtYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXMgPSBhcmd1bWVudHMubGVuZ3RoID8gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKSA6IGZuKHt9KTtcbiAgICByZXMgPSByZXMgJiYgdHlwZW9mIHJlcyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocmVzKVxuICAgICAgPyBbcmVzXSAvLyBzaW5nbGUgdm5vZGVcbiAgICAgIDogbm9ybWFsaXplQ2hpbGRyZW4ocmVzKTtcbiAgICByZXR1cm4gcmVzICYmIChcbiAgICAgIHJlcy5sZW5ndGggPT09IDAgfHxcbiAgICAgIChyZXMubGVuZ3RoID09PSAxICYmIHJlc1swXS5pc0NvbW1lbnQpIC8vICM5NjU4XG4gICAgKSA/IHVuZGVmaW5lZFxuICAgICAgOiByZXNcbiAgfTtcbiAgLy8gdGhpcyBpcyBhIHNsb3QgdXNpbmcgdGhlIG5ldyB2LXNsb3Qgc3ludGF4IHdpdGhvdXQgc2NvcGUuIGFsdGhvdWdoIGl0IGlzXG4gIC8vIGNvbXBpbGVkIGFzIGEgc2NvcGVkIHNsb3QsIHJlbmRlciBmbiB1c2VycyB3b3VsZCBleHBlY3QgaXQgdG8gYmUgcHJlc2VudFxuICAvLyBvbiB0aGlzLiRzbG90cyBiZWNhdXNlIHRoZSB1c2FnZSBpcyBzZW1hbnRpY2FsbHkgYSBub3JtYWwgc2xvdC5cbiAgaWYgKGZuLnByb3h5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vcm1hbFNsb3RzLCBrZXksIHtcbiAgICAgIGdldDogbm9ybWFsaXplZCxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZFxufVxuXG5mdW5jdGlvbiBwcm94eU5vcm1hbFNsb3Qoc2xvdHMsIGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2xvdHNba2V5XTsgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGlmIChoYXNTeW1ib2wgJiYgdmFsW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgIHJldCA9IFtdO1xuICAgICAgdmFyIGl0ZXJhdG9yID0gdmFsW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgIHJldC5wdXNoKHJlbmRlcihyZXN1bHQudmFsdWUsIHJldC5sZW5ndGgpKTtcbiAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzRGVmKHJldCkpIHtcbiAgICByZXQgPSBbXTtcbiAgfVxuICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gIHJldHVybiByZXRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gIG5hbWUsXG4gIGZhbGxiYWNrLFxuICBwcm9wcyxcbiAgYmluZE9iamVjdFxuKSB7XG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgdmFyIG5vZGVzO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChiaW5kT2JqZWN0KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdzbG90IHYtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0JyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XG4gICAgfVxuICAgIG5vZGVzID0gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFjaztcbiAgfSBlbHNlIHtcbiAgICBub2RlcyA9IHRoaXMuJHNsb3RzW25hbWVdIHx8IGZhbGxiYWNrO1xuICB9XG5cbiAgdmFyIHRhcmdldCA9IHByb3BzICYmIHByb3BzLnNsb3Q7XG4gIGlmICh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnLCB7IHNsb3Q6IHRhcmdldCB9LCBub2RlcylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNLZXlOb3RNYXRjaCAoZXhwZWN0LCBhY3R1YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0KSkge1xuICAgIHJldHVybiBleHBlY3QuaW5kZXhPZihhY3R1YWwpID09PSAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBleHBlY3QgIT09IGFjdHVhbFxuICB9XG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxuICogZXhwb3NlZCBhcyBWdWUucHJvdG90eXBlLl9rXG4gKiBwYXNzaW5nIGluIGV2ZW50S2V5TmFtZSBhcyBsYXN0IGFyZ3VtZW50IHNlcGFyYXRlbHkgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gIGV2ZW50S2V5Q29kZSxcbiAga2V5LFxuICBidWlsdEluS2V5Q29kZSxcbiAgZXZlbnRLZXlOYW1lLFxuICBidWlsdEluS2V5TmFtZVxuKSB7XG4gIHZhciBtYXBwZWRLZXlDb2RlID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbktleUNvZGU7XG4gIGlmIChidWlsdEluS2V5TmFtZSAmJiBldmVudEtleU5hbWUgJiYgIWNvbmZpZy5rZXlDb2Rlc1trZXldKSB7XG4gICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2goYnVpbHRJbktleU5hbWUsIGV2ZW50S2V5TmFtZSlcbiAgfSBlbHNlIGlmIChtYXBwZWRLZXlDb2RlKSB7XG4gICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2gobWFwcGVkS2V5Q29kZSwgZXZlbnRLZXlDb2RlKVxuICB9IGVsc2UgaWYgKGV2ZW50S2V5TmFtZSkge1xuICAgIHJldHVybiBoeXBoZW5hdGUoZXZlbnRLZXlOYW1lKSAhPT0ga2V5XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wLFxuICBpc1N5bmNcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFyIGhhc2g7XG4gICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ID09PSAnY2xhc3MnIHx8XG4gICAgICAgICAga2V5ID09PSAnc3R5bGUnIHx8XG4gICAgICAgICAgaXNSZXNlcnZlZEF0dHJpYnV0ZShrZXkpXG4gICAgICAgICkge1xuICAgICAgICAgIGhhc2ggPSBkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XG4gICAgICAgICAgaGFzaCA9IGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXG4gICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcbiAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FtZWxpemVkS2V5ID0gY2FtZWxpemUoa2V5KTtcbiAgICAgICAgdmFyIGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgICAgaWYgKCEoY2FtZWxpemVkS2V5IGluIGhhc2gpICYmICEoaHlwaGVuYXRlZEtleSBpbiBoYXNoKSkge1xuICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG5cbiAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICAgICAgICAgICAgb25bKFwidXBkYXRlOlwiICsga2V5KV0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSBsb29wKCBrZXkgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gIGluZGV4LFxuICBpc0luRm9yXG4pIHtcbiAgdmFyIGNhY2hlZCA9IHRoaXMuX3N0YXRpY1RyZWVzIHx8ICh0aGlzLl9zdGF0aWNUcmVlcyA9IFtdKTtcbiAgdmFyIHRyZWUgPSBjYWNoZWRbaW5kZXhdO1xuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUuXG4gIGlmICh0cmVlICYmICFpc0luRm9yKSB7XG4gICAgcmV0dXJuIHRyZWVcbiAgfVxuICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gIHRyZWUgPSBjYWNoZWRbaW5kZXhdID0gdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwoXG4gICAgdGhpcy5fcmVuZGVyUHJveHksXG4gICAgbnVsbCxcbiAgICB0aGlzIC8vIGZvciByZW5kZXIgZm5zIGdlbmVyYXRlZCBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgdGVtcGxhdGVzXG4gICk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZE9iamVjdExpc3RlbmVycyAoZGF0YSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ3Ytb24gd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbiA9IGRhdGEub24gPSBkYXRhLm9uID8gZXh0ZW5kKHt9LCBkYXRhLm9uKSA6IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIHZhciBleGlzdGluZyA9IG9uW2tleV07XG4gICAgICAgIHZhciBvdXJzID0gdmFsdWVba2V5XTtcbiAgICAgICAgb25ba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBvdXJzKSA6IG91cnM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuICBmbnMsIC8vIHNlZSBmbG93L3Zub2RlXG4gIHJlcyxcbiAgLy8gdGhlIGZvbGxvd2luZyBhcmUgYWRkZWQgaW4gMi42XG4gIGhhc0R5bmFtaWNLZXlzLFxuICBjb250ZW50SGFzaEtleVxuKSB7XG4gIHJlcyA9IHJlcyB8fCB7ICRzdGFibGU6ICFoYXNEeW5hbWljS2V5cyB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzbG90ID0gZm5zW2ldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNsb3QpKSB7XG4gICAgICByZXNvbHZlU2NvcGVkU2xvdHMoc2xvdCwgcmVzLCBoYXNEeW5hbWljS2V5cyk7XG4gICAgfSBlbHNlIGlmIChzbG90KSB7XG4gICAgICAvLyBtYXJrZXIgZm9yIHJldmVyc2UgcHJveHlpbmcgdi1zbG90IHdpdGhvdXQgc2NvcGUgb24gdGhpcy4kc2xvdHNcbiAgICAgIGlmIChzbG90LnByb3h5KSB7XG4gICAgICAgIHNsb3QuZm4ucHJveHkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmVzW3Nsb3Qua2V5XSA9IHNsb3QuZm47XG4gICAgfVxuICB9XG4gIGlmIChjb250ZW50SGFzaEtleSkge1xuICAgIChyZXMpLiRrZXkgPSBjb250ZW50SGFzaEtleTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kRHluYW1pY0tleXMgKGJhc2VPYmosIHZhbHVlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBrZXkgPSB2YWx1ZXNbaV07XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleSkge1xuICAgICAgYmFzZU9ialt2YWx1ZXNbaV1dID0gdmFsdWVzW2kgKyAxXTtcbiAgICB9IGVsc2UgaWYgKGtleSAhPT0gJycgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICAvLyBudWxsIGlzIGEgc3BlaWNhbCB2YWx1ZSBmb3IgZXhwbGljaXRseSByZW1vdmluZyBhIGJpbmRpbmdcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkludmFsaWQgdmFsdWUgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IChleHBlY3RlZCBzdHJpbmcgb3IgbnVsbCk6IFwiICsga2V5KSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJhc2VPYmpcbn1cblxuLy8gaGVscGVyIHRvIGR5bmFtaWNhbGx5IGFwcGVuZCBtb2RpZmllciBydW50aW1lIG1hcmtlcnMgdG8gZXZlbnQgbmFtZXMuXG4vLyBlbnN1cmUgb25seSBhcHBlbmQgd2hlbiB2YWx1ZSBpcyBhbHJlYWR5IHN0cmluZywgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgY2FzdFxuLy8gdG8gc3RyaW5nIGFuZCBjYXVzZSB0aGUgdHlwZSBjaGVjayB0byBtaXNzLlxuZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyICh2YWx1ZSwgc3ltYm9sKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gc3ltYm9sICsgdmFsdWUgOiB2YWx1ZVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnMgKHRhcmdldCkge1xuICB0YXJnZXQuX28gPSBtYXJrT25jZTtcbiAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XG4gIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xuICB0YXJnZXQuX2wgPSByZW5kZXJMaXN0O1xuICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xuICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xuICB0YXJnZXQuX2kgPSBsb29zZUluZGV4T2Y7XG4gIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcbiAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgdGFyZ2V0Ll9rID0gY2hlY2tLZXlDb2RlcztcbiAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xuICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIHRhcmdldC5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcbiAgdGFyZ2V0Ll9kID0gYmluZER5bmFtaWNLZXlzO1xuICB0YXJnZXQuX3AgPSBwcmVwZW5kTW9kaWZpZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCAoXG4gIGRhdGEsXG4gIHByb3BzLFxuICBjaGlsZHJlbixcbiAgcGFyZW50LFxuICBDdG9yXG4pIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgY29udGV4dFZtO1xuICBpZiAoaGFzT3duKHBhcmVudCwgJ191aWQnKSkge1xuICAgIGNvbnRleHRWbSA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBjb250ZXh0Vm0uX29yaWdpbmFsID0gcGFyZW50O1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjb250ZXh0IHZtIHBhc3NlZCBpbiBpcyBhIGZ1bmN0aW9uYWwgY29udGV4dCBhcyB3ZWxsLlxuICAgIC8vIGluIHRoaXMgY2FzZSB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBhcmUgYWJsZSB0byBnZXQgYSBob2xkIHRvIHRoZVxuICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cbiAgICBjb250ZXh0Vm0gPSBwYXJlbnQ7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcGFyZW50ID0gcGFyZW50Ll9vcmlnaW5hbDtcbiAgfVxuICB2YXIgaXNDb21waWxlZCA9IGlzVHJ1ZShvcHRpb25zLl9jb21waWxlZCk7XG4gIHZhciBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xuXG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5saXN0ZW5lcnMgPSBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0O1xuICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICB0aGlzLnNsb3RzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcyQxLiRzbG90cykge1xuICAgICAgbm9ybWFsaXplU2NvcGVkU2xvdHMoXG4gICAgICAgIGRhdGEuc2NvcGVkU2xvdHMsXG4gICAgICAgIHRoaXMkMS4kc2xvdHMgPSByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudClcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzJDEuJHNsb3RzXG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY29wZWRTbG90cycsICh7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplU2NvcGVkU2xvdHMoZGF0YS5zY29wZWRTbG90cywgdGhpcy5zbG90cygpKVxuICAgIH1cbiAgfSkpO1xuXG4gIC8vIHN1cHBvcnQgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGlzQ29tcGlsZWQpIHtcbiAgICAvLyBleHBvc2luZyAkb3B0aW9ucyBmb3IgcmVuZGVyU3RhdGljKClcbiAgICB0aGlzLiRvcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyBwcmUtcmVzb2x2ZSBzbG90cyBmb3IgcmVuZGVyU2xvdCgpXG4gICAgdGhpcy4kc2xvdHMgPSB0aGlzLnNsb3RzKCk7XG4gICAgdGhpcy4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLiRzbG90cyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5fc2NvcGVJZCkge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgICAgdmFyIHZub2RlID0gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICAgIGlmICh2bm9kZSAmJiAhQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgdm5vZGUuZm5TY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZub2RlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7IH07XG4gIH1cbn1cblxuaW5zdGFsbFJlbmRlckhlbHBlcnMoRnVuY3Rpb25hbFJlbmRlckNvbnRleHQucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dFZtLFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwgZW1wdHlPYmplY3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cbiAgfVxuXG4gIHZhciByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxuICAgIGRhdGEsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dFZtLFxuICAgIEN0b3JcbiAgKTtcblxuICB2YXIgdm5vZGUgPSBvcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIHJlbmRlckNvbnRleHQuX2MsIHJlbmRlckNvbnRleHQpO1xuXG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGUsIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zLCByZW5kZXJDb250ZXh0KVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgdmFyIHZub2RlcyA9IG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlKSB8fCBbXTtcbiAgICB2YXIgcmVzID0gbmV3IEFycmF5KHZub2Rlcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNbaV0gPSBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2Rlc1tpXSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCAodm5vZGUsIGRhdGEsIGNvbnRleHRWbSwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCkge1xuICAvLyAjNzgxNyBjbG9uZSBub2RlIGJlZm9yZSBzZXR0aW5nIGZuQ29udGV4dCwgb3RoZXJ3aXNlIGlmIHRoZSBub2RlIGlzIHJldXNlZFxuICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcbiAgLy8gdGhhdCBzaG91bGQgbm90IGJlIG1hdGNoZWQgdG8gbWF0Y2guXG4gIHZhciBjbG9uZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICBjbG9uZS5mbkNvbnRleHQgPSBjb250ZXh0Vm07XG4gIGNsb25lLmZuT3B0aW9ucyA9IG9wdGlvbnM7XG4gIHtcbiAgICAoY2xvbmUuZGV2dG9vbHNNZXRhID0gY2xvbmUuZGV2dG9vbHNNZXRhIHx8IHt9KS5yZW5kZXJDb250ZXh0ID0gcmVuZGVyQ29udGV4dDtcbiAgfVxuICBpZiAoZGF0YS5zbG90KSB7XG4gICAgKGNsb25lLmRhdGEgfHwgKGNsb25lLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gIH1cbiAgcmV0dXJuIGNsb25lXG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8vIGlubGluZSBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIGlmIChcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmXG4gICAgICAhdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkICYmXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZVxuICAgICkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZVxuICAgICAgKTtcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICBjaGlsZCxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayhjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY29udGV4dC5faXNNb3VudGVkKSB7XG4gICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgIC8vIGNoYW5nZSwgc28gZGlyZWN0bHkgd2Fsa2luZyB0aGUgdHJlZSBoZXJlIG1heSBjYWxsIGFjdGl2YXRlZCBob29rc1xuICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgcXVldWVBY3RpdmF0ZWRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG4gIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICB9XG5cbiAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAvLyByZWplY3QuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGFzeW5jIGNvbXBvbmVudFxuICB2YXIgYXN5bmNGYWN0b3J5O1xuICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICBhc3luY0ZhY3RvcnkgPSBDdG9yO1xuICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoYXN5bmNGYWN0b3J5LCBiYXNlQ3Rvcik7XG4gICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgbm9kZSBmb3IgYXN5bmMgY29tcG9uZW50LCB3aGljaCBpcyByZW5kZXJlZFxuICAgICAgLy8gYXMgYSBjb21tZW50IG5vZGUgYnV0IHByZXNlcnZlcyBhbGwgdGhlIHJhdyBpbmZvcm1hdGlvbiBmb3IgdGhlIG5vZGUuXG4gICAgICAvLyB0aGUgaW5mb3JtYXRpb24gd2lsbCBiZSB1c2VkIGZvciBhc3luYyBzZXJ2ZXItcmVuZGVyaW5nIGFuZCBoeWRyYXRpb24uXG4gICAgICByZXR1cm4gY3JlYXRlQXN5bmNQbGFjZWhvbGRlcihcbiAgICAgICAgYXN5bmNGYWN0b3J5LFxuICAgICAgICBkYXRhLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgdGFnXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gIH1cblxuICAvLyBleHRyYWN0IHByb3BzXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIC8vIHNvIGl0IGdldHMgcHJvY2Vzc2VkIGR1cmluZyBwYXJlbnQgY29tcG9uZW50IHBhdGNoLlxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVycyAmIHNsb3RcblxuICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICB2YXIgc2xvdCA9IGRhdGEuc2xvdDtcbiAgICBkYXRhID0ge307XG4gICAgaWYgKHNsb3QpIHtcbiAgICAgIGRhdGEuc2xvdCA9IHNsb3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5zdGFsbCBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gIGluc3RhbGxDb21wb25lbnRIb29rcyhkYXRhKTtcblxuICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciB2bm9kZVxuICB2YXIgbmFtZSA9IEN0b3Iub3B0aW9ucy5uYW1lIHx8IHRhZztcbiAgdmFyIHZub2RlID0gbmV3IFZOb2RlKFxuICAgIChcInZ1ZS1jb21wb25lbnQtXCIgKyAoQ3Rvci5jaWQpICsgKG5hbWUgPyAoXCItXCIgKyBuYW1lKSA6ICcnKSksXG4gICAgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCxcbiAgICB7IEN0b3I6IEN0b3IsIHByb3BzRGF0YTogcHJvcHNEYXRhLCBsaXN0ZW5lcnM6IGxpc3RlbmVycywgdGFnOiB0YWcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9LFxuICAgIGFzeW5jRmFjdG9yeVxuICApO1xuXG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgdm5vZGUsIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuICBwYXJlbnQgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXG4gICAgcGFyZW50OiBwYXJlbnRcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgaWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGUuY29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIGluc3RhbGxDb21wb25lbnRIb29rcyAoZGF0YSkge1xuICB2YXIgaG9va3MgPSBkYXRhLmhvb2sgfHwgKGRhdGEuaG9vayA9IHt9KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgIHZhciBleGlzdGluZyA9IGhvb2tzW2tleV07XG4gICAgdmFyIHRvTWVyZ2UgPSBjb21wb25lbnRWTm9kZUhvb2tzW2tleV07XG4gICAgaWYgKGV4aXN0aW5nICE9PSB0b01lcmdlICYmICEoZXhpc3RpbmcgJiYgZXhpc3RpbmcuX21lcmdlZCkpIHtcbiAgICAgIGhvb2tzW2tleV0gPSBleGlzdGluZyA/IG1lcmdlSG9vayQxKHRvTWVyZ2UsIGV4aXN0aW5nKSA6IHRvTWVyZ2U7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9vayQxIChmMSwgZjIpIHtcbiAgdmFyIG1lcmdlZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgLy8gZmxvdyBjb21wbGFpbnMgYWJvdXQgZXh0cmEgYXJncyB3aGljaCBpcyB3aHkgd2UgdXNlIGFueVxuICAgIGYxKGEsIGIpO1xuICAgIGYyKGEsIGIpO1xuICB9O1xuICBtZXJnZWQuX21lcmdlZCA9IHRydWU7XG4gIHJldHVybiBtZXJnZWRcbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0J1xuICA7KGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcbiAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgdmFyIGV4aXN0aW5nID0gb25bZXZlbnRdO1xuICB2YXIgY2FsbGJhY2sgPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICBpZiAoaXNEZWYoZXhpc3RpbmcpKSB7XG4gICAgaWYgKFxuICAgICAgQXJyYXkuaXNBcnJheShleGlzdGluZylcbiAgICAgICAgPyBleGlzdGluZy5pbmRleE9mKGNhbGxiYWNrKSA9PT0gLTFcbiAgICAgICAgOiBleGlzdGluZyAhPT0gY2FsbGJhY2tcbiAgICApIHtcbiAgICAgIG9uW2V2ZW50XSA9IFtjYWxsYmFja10uY29uY2F0KGV4aXN0aW5nKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb25bZXZlbnRdID0gY2FsbGJhY2s7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcbnZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcblxuLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2Vcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlLFxuICBhbHdheXNOb3JtYWxpemVcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG4gICAgY2hpbGRyZW4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGlzVHJ1ZShhbHdheXNOb3JtYWxpemUpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFO1xuICB9XG4gIHJldHVybiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSlcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZVxuKSB7XG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZigoZGF0YSkuX19vYl9fKSkge1xuICAgIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmtleSkgJiYgIWlzUHJpbWl0aXZlKGRhdGEua2V5KVxuICApIHtcbiAgICB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgdXNpbmcgbm9uLXByaW1pdGl2ZSB2YWx1ZSBhcyBrZXksICcgK1xuICAgICAgICAndXNlIHN0cmluZy9udW1iZXIgdmFsdWUgaW5zdGVhZC4nLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfVxuICB2YXIgdm5vZGUsIG5zO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgQ3RvcjtcbiAgICBucyA9IChjb250ZXh0LiR2bm9kZSAmJiBjb250ZXh0LiR2bm9kZS5ucykgfHwgY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICgoIWRhdGEgfHwgIWRhdGEucHJlKSAmJiBpc0RlZihDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcbiAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVua25vd24gb3IgdW5saXN0ZWQgbmFtZXNwYWNlZCBlbGVtZW50c1xuICAgICAgLy8gY2hlY2sgYXQgcnVudGltZSBiZWNhdXNlIGl0IG1heSBnZXQgYXNzaWduZWQgYSBuYW1lc3BhY2Ugd2hlbiBpdHNcbiAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgdGFnLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGRpcmVjdCBjb21wb25lbnQgb3B0aW9ucyAvIGNvbnN0cnVjdG9yXG4gICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgaWYgKGlzRGVmKG5zKSkgeyBhcHBseU5TKHZub2RlLCBucyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHsgcmVnaXN0ZXJEZWVwQmluZGluZ3MoZGF0YSk7IH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlOUyAodm5vZGUsIG5zLCBmb3JjZSkge1xuICB2bm9kZS5ucyA9IG5zO1xuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcbiAgICBucyA9IHVuZGVmaW5lZDtcbiAgICBmb3JjZSA9IHRydWU7XG4gIH1cbiAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIChcbiAgICAgICAgaXNVbmRlZihjaGlsZC5ucykgfHwgKGlzVHJ1ZShmb3JjZSkgJiYgY2hpbGQudGFnICE9PSAnc3ZnJykpKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zLCBmb3JjZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHJlZiAjNTMxOFxuLy8gbmVjZXNzYXJ5IHRvIGVuc3VyZSBwYXJlbnQgcmUtcmVuZGVyIHdoZW4gZGVlcCBiaW5kaW5ncyBsaWtlIDpzdHlsZSBhbmRcbi8vIDpjbGFzcyBhcmUgdXNlZCBvbiBzbG90IG5vZGVzXG5mdW5jdGlvbiByZWdpc3RlckRlZXBCaW5kaW5ncyAoZGF0YSkge1xuICBpZiAoaXNPYmplY3QoZGF0YS5zdHlsZSkpIHtcbiAgICB0cmF2ZXJzZShkYXRhLnN0eWxlKTtcbiAgfVxuICBpZiAoaXNPYmplY3QoZGF0YS5jbGFzcykpIHtcbiAgICB0cmF2ZXJzZShkYXRhLmNsYXNzKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDsgLy8gdi1vbmNlIGNhY2hlZCB0cmVlc1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICB2YXIgcGFyZW50Vm5vZGUgPSB2bS4kdm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMob3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuXG4gIC8vICRhdHRycyAmICRsaXN0ZW5lcnMgYXJlIGV4cG9zZWQgZm9yIGVhc2llciBIT0MgY3JlYXRpb24uXG4gIC8vIHRoZXkgbmVlZCB0byBiZSByZWFjdGl2ZSBzbyB0aGF0IEhPQ3MgdXNpbmcgdGhlbSBhcmUgYWx3YXlzIHVwZGF0ZWRcbiAgdmFyIHBhcmVudERhdGEgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5kYXRhO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGF0dHJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkbGlzdGVuZXJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gIH1cbn1cblxudmFyIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgLy8gaW5zdGFsbCBydW50aW1lIGNvbnZlbmllbmNlIGhlbHBlcnNcbiAgaW5zdGFsbFJlbmRlckhlbHBlcnMoVnVlLnByb3RvdHlwZSk7XG5cbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgaWYgKF9wYXJlbnRWbm9kZSkge1xuICAgICAgdm0uJHNjb3BlZFNsb3RzID0gbm9ybWFsaXplU2NvcGVkU2xvdHMoXG4gICAgICAgIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzLFxuICAgICAgICB2bS4kc2xvdHMsXG4gICAgICAgIHZtLiRzY29wZWRTbG90c1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gbWFpbnRhaW4gYSBzdGFjayBiZWNhdWVzIGFsbCByZW5kZXIgZm5zIGFyZSBjYWxsZWRcbiAgICAgIC8vIHNlcGFyYXRlbHkgZnJvbSBvbmUgYW5vdGhlci4gTmVzdGVkIGNvbXBvbmVudCdzIHJlbmRlciBmbnMgYXJlIGNhbGxlZFxuICAgICAgLy8gd2hlbiBwYXJlbnQgY29tcG9uZW50IGlzIHBhdGNoZWQuXG4gICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSB2bTtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyXCIpO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmICh2bS4kb3B0aW9ucy5yZW5kZXJFcnJvcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50LCBlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlckVycm9yXCIpO1xuICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcbiAgICB9XG4gICAgLy8gaWYgdGhlIHJldHVybmVkIGFycmF5IGNvbnRhaW5zIG9ubHkgYSBzaW5nbGUgbm9kZSwgYWxsb3cgaXRcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkgJiYgdm5vZGUubGVuZ3RoID09PSAxKSB7XG4gICAgICB2bm9kZSA9IHZub2RlWzBdO1xuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW5zdXJlQ3RvciAoY29tcCwgYmFzZSkge1xuICBpZiAoXG4gICAgY29tcC5fX2VzTW9kdWxlIHx8XG4gICAgKGhhc1N5bWJvbCAmJiBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKVxuICApIHtcbiAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICB9XG4gIHJldHVybiBpc09iamVjdChjb21wKVxuICAgID8gYmFzZS5leHRlbmQoY29tcClcbiAgICA6IGNvbXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXN5bmNQbGFjZWhvbGRlciAoXG4gIGZhY3RvcnksXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICB2YXIgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xuICBub2RlLmFzeW5jTWV0YSA9IHsgZGF0YTogZGF0YSwgY29udGV4dDogY29udGV4dCwgY2hpbGRyZW46IGNoaWxkcmVuLCB0YWc6IHRhZyB9O1xuICByZXR1cm4gbm9kZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvclxuKSB7XG4gIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG5cbiAgdmFyIG93bmVyID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICBpZiAob3duZXIgJiYgaXNEZWYoZmFjdG9yeS5vd25lcnMpICYmIGZhY3Rvcnkub3duZXJzLmluZGV4T2Yob3duZXIpID09PSAtMSkge1xuICAgIC8vIGFscmVhZHkgcGVuZGluZ1xuICAgIGZhY3Rvcnkub3duZXJzLnB1c2gob3duZXIpO1xuICB9XG5cbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgfVxuXG4gIGlmIChvd25lciAmJiAhaXNEZWYoZmFjdG9yeS5vd25lcnMpKSB7XG4gICAgdmFyIG93bmVycyA9IGZhY3Rvcnkub3duZXJzID0gW293bmVyXTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG4gICAgdmFyIHRpbWVyTG9hZGluZyA9IG51bGw7XG4gICAgdmFyIHRpbWVyVGltZW91dCA9IG51bGxcblxuICAgIDsob3duZXIpLiRvbignaG9vazpkZXN0cm95ZWQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZW1vdmUob3duZXJzLCBvd25lcik7IH0pO1xuXG4gICAgdmFyIGZvcmNlUmVuZGVyID0gZnVuY3Rpb24gKHJlbmRlckNvbXBsZXRlZCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvd25lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIChvd25lcnNbaV0pLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgICBpZiAodGltZXJMb2FkaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyTG9hZGluZyk7XG4gICAgICAgICAgdGltZXJMb2FkaW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXJUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyVGltZW91dCk7XG4gICAgICAgICAgdGltZXJUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvd25lcnMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICApO1xuICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIGlmIChpc1Byb21pc2UocmVzKSkge1xuICAgICAgICAvLyAoKSA9PiBQcm9taXNlXG4gICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1Byb21pc2UocmVzLmNvbXBvbmVudCkpIHtcbiAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICBmYWN0b3J5LmVycm9yQ29tcCA9IGVuc3VyZUN0b3IocmVzLmVycm9yLCBiYXNlQ3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgZmFjdG9yeS5sb2FkaW5nQ29tcCA9IGVuc3VyZUN0b3IocmVzLmxvYWRpbmcsIGJhc2VDdG9yKTtcbiAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aW1lckxvYWRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGltZXJMb2FkaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZXMuZGVsYXkgfHwgMjAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLnRpbWVvdXQpKSB7XG4gICAgICAgICAgdGltZXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aW1lclRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIFwidGltZW91dCAoXCIgKyAocmVzLnRpbWVvdXQpICsgXCJtcylcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ1xuICAgICAgPyBmYWN0b3J5LmxvYWRpbmdDb21wXG4gICAgICA6IGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCAmJiBub2RlLmFzeW5jRmFjdG9yeVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiAoaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYykpKSB7XG4gICAgICAgIHJldHVybiBjXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciAoZXZlbnQsIGZuKSB7XG4gIHZhciBfdGFyZ2V0ID0gdGFyZ2V0O1xuICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xuICAgIHZhciByZXMgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIF90YXJnZXQuJG9mZihldmVudCwgb25jZUhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICB2bSxcbiAgbGlzdGVuZXJzLFxuICBvbGRMaXN0ZW5lcnNcbikge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCBjcmVhdGVPbmNlSGFuZGxlciwgdm0pO1xuICB0YXJnZXQgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcbiAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xuICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdm0uJG9uKGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgLy8gb3B0aW1pemUgaG9vazpldmVudCBjb3N0IGJ5IHVzaW5nIGEgYm9vbGVhbiBmbGFnIG1hcmtlZCBhdCByZWdpc3RyYXRpb25cbiAgICAgIC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxuICAgICAgaWYgKGhvb2tSRS50ZXN0KGV2ZW50KSkge1xuICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uICgpIHtcbiAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcbiAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvbi5mbiA9IGZuO1xuICAgIHZtLiRvbihldmVudCwgb24pO1xuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpJDEgPCBsOyBpJDErKykge1xuICAgICAgICB2bS4kb2ZmKGV2ZW50W2kkMV0sIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmICghZm4pIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgdmFyIGNiO1xuICAgIHZhciBpID0gY2JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjYiA9IGNic1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICB2YXIgaW5mbyA9IFwiZXZlbnQgaGFuZGxlciBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCJcIjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjYnNbaV0sIHZtLCBhcmdzLCB2bSwgaW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuZnVuY3Rpb24gc2V0QWN0aXZlSW5zdGFuY2Uodm0pIHtcbiAgdmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICB2YXIgcmVzdG9yZUFjdGl2ZUluc3RhbmNlID0gc2V0QWN0aXZlSW5zdGFuY2Uodm0pO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZWxlYXNlIGNpcmN1bGFyIHJlZmVyZW5jZSAoIzY3NTkpXG4gICAgaWYgKHZtLiR2bm9kZSkge1xuICAgICAgdm0uJHZub2RlLnBhcmVudCA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICB2YXIgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgaWQ7XG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gd2Ugc2V0IHRoaXMgdG8gdm0uX3dhdGNoZXIgaW5zaWRlIHRoZSB3YXRjaGVyJ3MgY29uc3RydWN0b3JcbiAgLy8gc2luY2UgdGhlIHdhdGNoZXIncyBpbml0aWFsIHBhdGNoIG1heSBjYWxsICRmb3JjZVVwZGF0ZSAoZS5nLiBpbnNpZGUgY2hpbGRcbiAgLy8gY29tcG9uZW50J3MgbW91bnRlZCBob29rKSwgd2hpY2ggcmVsaWVzIG9uIHZtLl93YXRjaGVyIGJlaW5nIGFscmVhZHkgZGVmaW5lZFxuICBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wLCB7XG4gICAgYmVmb3JlOiBmdW5jdGlvbiBiZWZvcmUgKCkge1xuICAgICAgaWYgKHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLlxuXG4gIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBkeW5hbWljIHNjb3BlZFNsb3RzIChoYW5kLXdyaXR0ZW4gb3IgY29tcGlsZWQgYnV0IHdpdGhcbiAgLy8gZHluYW1pYyBzbG90IG5hbWVzKS4gU3RhdGljIHNjb3BlZCBzbG90cyBjb21waWxlZCBmcm9tIHRlbXBsYXRlIGhhcyB0aGVcbiAgLy8gXCIkc3RhYmxlXCIgbWFya2VyLlxuICB2YXIgbmV3U2NvcGVkU2xvdHMgPSBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzO1xuICB2YXIgb2xkU2NvcGVkU2xvdHMgPSB2bS4kc2NvcGVkU2xvdHM7XG4gIHZhciBoYXNEeW5hbWljU2NvcGVkU2xvdCA9ICEhKFxuICAgIChuZXdTY29wZWRTbG90cyAmJiAhbmV3U2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcbiAgICAob2xkU2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0ICYmICFvbGRTY29wZWRTbG90cy4kc3RhYmxlKSB8fFxuICAgIChuZXdTY29wZWRTbG90cyAmJiB2bS4kc2NvcGVkU2xvdHMuJGtleSAhPT0gbmV3U2NvcGVkU2xvdHMuJGtleSlcbiAgKTtcblxuICAvLyBBbnkgc3RhdGljIHNsb3QgY2hpbGRyZW4gZnJvbSB0aGUgcGFyZW50IG1heSBoYXZlIGNoYW5nZWQgZHVyaW5nIHBhcmVudCdzXG4gIC8vIHVwZGF0ZS4gRHluYW1pYyBzY29wZWQgc2xvdHMgbWF5IGFsc28gaGF2ZSBjaGFuZ2VkLiBJbiBzdWNoIGNhc2VzLCBhIGZvcmNlZFxuICAvLyB1cGRhdGUgaXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSBjb3JyZWN0bmVzcy5cbiAgdmFyIG5lZWRzRm9yY2VVcGRhdGUgPSAhIShcbiAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xuICAgIGhhc0R5bmFtaWNTY29wZWRTbG90XG4gICk7XG5cbiAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXG5cbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgJGF0dHJzIGFuZCAkbGlzdGVuZXJzIGhhc2hcbiAgLy8gdGhlc2UgYXJlIGFsc28gcmVhY3RpdmUgc28gdGhleSBtYXkgdHJpZ2dlciBjaGlsZCB1cGRhdGUgaWYgdGhlIGNoaWxkXG4gIC8vIHVzZWQgdGhlbSBkdXJpbmcgcmVuZGVyXG4gIHZtLiRhdHRycyA9IHBhcmVudFZub2RlLmRhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3Q7XG4gIHZtLiRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG5cbiAgLy8gdXBkYXRlIHByb3BzXG4gIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgIHZhciBwcm9wcyA9IHZtLl9wcm9wcztcbiAgICB2YXIgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IHByb3BLZXlzW2ldO1xuICAgICAgdmFyIHByb3BPcHRpb25zID0gdm0uJG9wdGlvbnMucHJvcHM7IC8vIHd0ZiBmbG93P1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICB9XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gIH1cblxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gIGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcbiAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuXG4gIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gIGlmIChuZWVkc0ZvcmNlVXBkYXRlKSB7XG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xuICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcbiAgICBpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBsaWZlY3ljbGUgaG9va3NcbiAgcHVzaFRhcmdldCgpO1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgdmFyIGluZm8gPSBob29rICsgXCIgaG9va1wiO1xuICBpZiAoaGFuZGxlcnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoaGFuZGxlcnNbaV0sIHZtLCBudWxsLCB2bSwgaW5mbyk7XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG4gIHBvcFRhcmdldCgpO1xufVxuXG4vKiAgKi9cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAge1xuICAgIGNpcmN1bGFyID0ge307XG4gIH1cbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8vIEFzeW5jIGVkZ2UgY2FzZSAjNjU2NiByZXF1aXJlcyBzYXZpbmcgdGhlIHRpbWVzdGFtcCB3aGVuIGV2ZW50IGxpc3RlbmVycyBhcmVcbi8vIGF0dGFjaGVkLiBIb3dldmVyLCBjYWxsaW5nIHBlcmZvcm1hbmNlLm5vdygpIGhhcyBhIHBlcmYgb3ZlcmhlYWQgZXNwZWNpYWxseVxuLy8gaWYgdGhlIHBhZ2UgaGFzIHRob3VzYW5kcyBvZiBldmVudCBsaXN0ZW5lcnMuIEluc3RlYWQsIHdlIHRha2UgYSB0aW1lc3RhbXBcbi8vIGV2ZXJ5IHRpbWUgdGhlIHNjaGVkdWxlciBmbHVzaGVzIGFuZCB1c2UgdGhhdCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVyc1xuLy8gYXR0YWNoZWQgZHVyaW5nIHRoYXQgZmx1c2guXG52YXIgY3VycmVudEZsdXNoVGltZXN0YW1wID0gMDtcblxuLy8gQXN5bmMgZWRnZSBjYXNlIGZpeCByZXF1aXJlcyBzdG9yaW5nIGFuIGV2ZW50IGxpc3RlbmVyJ3MgYXR0YWNoIHRpbWVzdGFtcC5cbnZhciBnZXROb3cgPSBEYXRlLm5vdztcblxuLy8gRGV0ZXJtaW5lIHdoYXQgZXZlbnQgdGltZXN0YW1wIHRoZSBicm93c2VyIGlzIHVzaW5nLiBBbm5veWluZ2x5LCB0aGVcbi8vIHRpbWVzdGFtcCBjYW4gZWl0aGVyIGJlIGhpLXJlcyAocmVsYXRpdmUgdG8gcGFnZSBsb2FkKSBvciBsb3ctcmVzXG4vLyAocmVsYXRpdmUgdG8gVU5JWCBlcG9jaCksIHNvIGluIG9yZGVyIHRvIGNvbXBhcmUgdGltZSB3ZSBoYXZlIHRvIHVzZSB0aGVcbi8vIHNhbWUgdGltZXN0YW1wIHR5cGUgd2hlbiBzYXZpbmcgdGhlIGZsdXNoIHRpbWVzdGFtcC5cbi8vIEFsbCBJRSB2ZXJzaW9ucyB1c2UgbG93LXJlcyBldmVudCB0aW1lc3RhbXBzLCBhbmQgaGF2ZSBwcm9ibGVtYXRpYyBjbG9ja1xuLy8gaW1wbGVtZW50YXRpb25zICgjOTYzMilcbmlmIChpbkJyb3dzZXIgJiYgIWlzSUUpIHtcbiAgdmFyIHBlcmZvcm1hbmNlID0gd2luZG93LnBlcmZvcm1hbmNlO1xuICBpZiAoXG4gICAgcGVyZm9ybWFuY2UgJiZcbiAgICB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nICYmXG4gICAgZ2V0Tm93KCkgPiBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKS50aW1lU3RhbXBcbiAgKSB7XG4gICAgLy8gaWYgdGhlIGV2ZW50IHRpbWVzdGFtcCwgYWx0aG91Z2ggZXZhbHVhdGVkIEFGVEVSIHRoZSBEYXRlLm5vdygpLCBpc1xuICAgIC8vIHNtYWxsZXIgdGhhbiBpdCwgaXQgbWVhbnMgdGhlIGV2ZW50IGlzIHVzaW5nIGEgaGktcmVzIHRpbWVzdGFtcCxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byB1c2UgdGhlIGhpLXJlcyB2ZXJzaW9uIGZvciBldmVudCBsaXN0ZW5lciB0aW1lc3RhbXBzIGFzXG4gICAgLy8gd2VsbC5cbiAgICBnZXROb3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTsgfTtcbiAgfVxufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgY3VycmVudEZsdXNoVGltZXN0YW1wID0gZ2V0Tm93KCk7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWYgKHdhdGNoZXIuYmVmb3JlKSB7XG4gICAgICB3YXRjaGVyLmJlZm9yZSgpO1xuICAgIH1cbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyAocXVldWUpIHtcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWNvbmZpZy5hc3luYykge1xuICAgICAgICBmbHVzaFNjaGVkdWxlclF1ZXVlKCk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5cblxudmFyIHVpZCQyID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqL1xudmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGNiLFxuICBvcHRpb25zLFxuICBpc1JlbmRlcldhdGNoZXJcbikge1xuICB0aGlzLnZtID0gdm07XG4gIGlmIChpc1JlbmRlcldhdGNoZXIpIHtcbiAgICB2bS5fd2F0Y2hlciA9IHRoaXM7XG4gIH1cbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIC8vIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgICB0aGlzLmJlZm9yZSA9IG9wdGlvbnMuYmVmb3JlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZGVlcCA9IHRoaXMudXNlciA9IHRoaXMubGF6eSA9IHRoaXMuc3luYyA9IGZhbHNlO1xuICB9XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5pZCA9ICsrdWlkJDI7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBbXTtcbiAgdGhpcy5uZXdEZXBzID0gW107XG4gIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLmV4cHJlc3Npb24gPSBleHBPckZuLnRvU3RyaW5nKCk7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBub29wO1xuICAgICAgd2FybihcbiAgICAgICAgXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArXG4gICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXG4gICAgICAgICdGb3IgZnVsbCBjb250cm9sLCB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHRoaXMuZ2V0KCk7XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcbiAgcHVzaFRhcmdldCh0aGlzKTtcbiAgdmFyIHZhbHVlO1xuICB2YXIgdm0gPSB0aGlzLnZtO1xuICB0cnkge1xuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImdldHRlciBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gICAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gICAgaWYgKHRoaXMuZGVlcCkge1xuICAgICAgdHJhdmVyc2UodmFsdWUpO1xuICAgIH1cbiAgICBwb3BUYXJnZXQoKTtcbiAgICB0aGlzLmNsZWFudXBEZXBzKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59O1xuXG4vKipcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIGFkZERlcCAoZGVwKSB7XG4gIHZhciBpZCA9IGRlcC5pZDtcbiAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcbiAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuY2xlYW51cERlcHMgPSBmdW5jdGlvbiBjbGVhbnVwRGVwcyAoKSB7XG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkZXAgPSB0aGlzLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgdG1wID0gdGhpcy5kZXBzO1xuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRoaXMubGF6eSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgIHRoaXMucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgIHRoaXMuZGVlcFxuICAgICkge1xuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIChcImNhbGxiYWNrIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzLmRlcHNbaV0uZGVwZW5kKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZW1vdmUodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufTtcblxuLyogICovXG5cbnZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBub29wLFxuICBzZXQ6IG5vb3Bcbn07XG5cbmZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldXG4gIH07XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucztcbiAgaWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxuICBpZiAob3B0cy5tZXRob2RzKSB7IGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpOyB9XG4gIGlmIChvcHRzLmRhdGEpIHtcbiAgICBpbml0RGF0YSh2bSk7XG4gIH0gZWxzZSB7XG4gICAgb2JzZXJ2ZSh2bS5fZGF0YSA9IHt9LCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xuICB9XG4gIGlmIChvcHRzLmNvbXB1dGVkKSB7IGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7IH1cbiAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcbiAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICB2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bS5fcHJvcHMgPSB7fTtcbiAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcbiAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gIHZhciBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XG4gIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gIGlmICghaXNSb290KSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgfVxuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICB7XG4gICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoaHlwaGVuYXRlZEtleSkgfHxcbiAgICAgICAgICBjb25maWcuaXNSZXNlcnZlZEF0dHIoaHlwaGVuYXRlZEtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJcXFwiXCIgKyBoeXBoZW5hdGVkS2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNSb290ICYmICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAge1xuICAgICAgaWYgKG1ldGhvZHMgJiYgaGFzT3duKG1ldGhvZHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIGRhdGEgcHJvcGVydHkuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBkYXRhIGdldHRlcnNcbiAgcHVzaFRhcmdldCgpO1xuICB0cnkge1xuICAgIHJldHVybiBkYXRhLmNhbGwodm0sIHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgIHJldHVybiB7fVxuICB9IGZpbmFsbHkge1xuICAgIHBvcFRhcmdldCgpO1xuICB9XG59XG5cbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8vIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGp1c3QgZ2V0dGVycyBkdXJpbmcgU1NSXG4gIHZhciBpc1NTUiA9IGlzU2VydmVyUmVuZGVyaW5nKCk7XG5cbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgIHZhciBnZXR0ZXIgPSB0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcbiAgICBpZiAoZ2V0dGVyID09IG51bGwpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIChcIkdldHRlciBpcyBtaXNzaW5nIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzU1NSKSB7XG4gICAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKFxuICAgICAgICB2bSxcbiAgICAgICAgZ2V0dGVyIHx8IG5vb3AsXG4gICAgICAgIG5vb3AsXG4gICAgICAgIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgIC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG4gICAgLy8gYXQgaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5cIiksIHZtKTtcbiAgICAgIH0gZWxzZSBpZiAodm0uJG9wdGlvbnMucHJvcHMgJiYga2V5IGluIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCAoXG4gIHRhcmdldCxcbiAga2V5LFxuICB1c2VyRGVmXG4pIHtcbiAgdmFyIHNob3VsZENhY2hlID0gIWlzU2VydmVyUmVuZGVyaW5nKCk7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBzaG91bGRDYWNoZVxuICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZik7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZi5nZXQpXG4gICAgICA6IG5vb3A7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0IHx8IG5vb3A7XG4gIH1cbiAgaWYgKHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiQ29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdhcyBhc3NpZ25lZCB0byBidXQgaXQgaGFzIG5vIHNldHRlci5cIiksXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlR2V0dGVySW52b2tlcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIHRoaXMpXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyB0eXBlIFxcXCJcIiArICh0eXBlb2YgbWV0aG9kc1trZXldKSArIFwiXFxcIiBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIFwiICtcbiAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoKGtleSBpbiB2bSkgJiYgaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIGFuIGV4aXN0aW5nIFZ1ZSBpbnN0YW5jZSBtZXRob2QuIFwiICtcbiAgICAgICAgICBcIkF2b2lkIGRlZmluaW5nIGNvbXBvbmVudCBtZXRob2RzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdm1ba2V5XSA9IHR5cGVvZiBtZXRob2RzW2tleV0gIT09ICdmdW5jdGlvbicgPyBub29wIDogYmluZChtZXRob2RzW2tleV0sIHZtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0V2F0Y2ggKHZtLCB3YXRjaCkge1xuICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcbiAgICB2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGhhbmRsZXIsXG4gIG9wdGlvbnNcbikge1xuICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgfVxuICByZXR1cm4gdm0uJHdhdGNoKGV4cE9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gIHZhciBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICB7XG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGNiKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZXJyb3IsIHZtLCAoXCJjYWxsYmFjayBmb3IgaW1tZWRpYXRlIHdhdGNoZXIgXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDMgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCQzKys7XG5cbiAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArICh2bS5fdWlkKTtcbiAgICAgIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgfVxuXG4gICAgLy8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcbiAgICB2bS5faXNWdWUgPSB0cnVlO1xuICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuICAgICAgLy8gb3B0aW1pemUgaW50ZXJuYWwgY29tcG9uZW50IGluc3RhbnRpYXRpb25cbiAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuICAgICAgaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnModm0uY29uc3RydWN0b3IpLFxuICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodm0uX25hbWUpICsgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgdmFyIHBhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG5cbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHBhcmVudFZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XG5cbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG1vZGlmaWVkO1xuICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gbGF0ZXN0W2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBWdWUgKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFZ1ZSlcbiAgKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUpO1xuc3RhdGVNaXhpbihWdWUpO1xuZXZlbnRzTWl4aW4oVnVlKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSk7XG5yZW5kZXJNaXhpbihWdWUpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgdmFyIGluc3RhbGxlZFBsdWdpbnMgPSAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyB8fCAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyA9IFtdKSk7XG4gICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcbiAgICByZXR1cm4gU3ViXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICBpZCxcbiAgICAgIGRlZmluaXRpb25cbiAgICApIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50Jykge1xuICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qICAqL1xuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSAob3B0cykge1xuICByZXR1cm4gb3B0cyAmJiAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZylcbn1cblxuZnVuY3Rpb24gbWF0Y2hlcyAocGF0dGVybiwgbmFtZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGUgKGtlZXBBbGl2ZUluc3RhbmNlLCBmaWx0ZXIpIHtcbiAgdmFyIGNhY2hlID0ga2VlcEFsaXZlSW5zdGFuY2UuY2FjaGU7XG4gIHZhciBrZXlzID0ga2VlcEFsaXZlSW5zdGFuY2Uua2V5cztcbiAgdmFyIF92bm9kZSA9IGtlZXBBbGl2ZUluc3RhbmNlLl92bm9kZTtcbiAgZm9yICh2YXIga2V5IGluIGNhY2hlKSB7XG4gICAgdmFyIGNhY2hlZE5vZGUgPSBjYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY2FjaGVkTm9kZS5jb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcbiAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXksIGtleXMsIF92bm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAoXG4gIGNhY2hlLFxuICBrZXksXG4gIGtleXMsXG4gIGN1cnJlbnRcbikge1xuICB2YXIgY2FjaGVkJCQxID0gY2FjaGVba2V5XTtcbiAgaWYgKGNhY2hlZCQkMSAmJiAoIWN1cnJlbnQgfHwgY2FjaGVkJCQxLnRhZyAhPT0gY3VycmVudC50YWcpKSB7XG4gICAgY2FjaGVkJCQxLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbiAgY2FjaGVba2V5XSA9IG51bGw7XG4gIHJlbW92ZShrZXlzLCBrZXkpO1xufVxuXG52YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIG1heDogW1N0cmluZywgTnVtYmVyXVxuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMua2V5cyA9IFtdO1xuICB9LFxuXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5jYWNoZSkge1xuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMuY2FjaGUsIGtleSwgdGhpcy5rZXlzKTtcbiAgICB9XG4gIH0sXG5cbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLiR3YXRjaCgnaW5jbHVkZScsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9KTtcbiAgICB0aGlzLiR3YXRjaCgnZXhjbHVkZScsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIHZhciBzbG90ID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHNsb3QpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgaW5jbHVkZSA9IHJlZi5pbmNsdWRlO1xuICAgICAgdmFyIGV4Y2x1ZGUgPSByZWYuZXhjbHVkZTtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gbm90IGluY2x1ZGVkXG4gICAgICAgIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkpIHx8XG4gICAgICAgIC8vIGV4Y2x1ZGVkXG4gICAgICAgIChleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiQxID0gdGhpcztcbiAgICAgIHZhciBjYWNoZSA9IHJlZiQxLmNhY2hlO1xuICAgICAgdmFyIGtleXMgPSByZWYkMS5rZXlzO1xuICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAvLyBtYWtlIGN1cnJlbnQga2V5IGZyZXNoZXN0XG4gICAgICAgIHJlbW92ZShrZXlzLCBrZXkpO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxuICAgICAgICBpZiAodGhpcy5tYXggJiYga2V5cy5sZW5ndGggPiBwYXJzZUludCh0aGlzLm1heCkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleXNbMF0sIGtleXMsIHRoaXMuX3Zub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZSB8fCAoc2xvdCAmJiBzbG90WzBdKVxuICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8vIGNvbmZpZ1xuICB2YXIgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2Fybjogd2FybixcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcbiAgfTtcblxuICBWdWUuc2V0ID0gc2V0O1xuICBWdWUuZGVsZXRlID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICAvLyAyLjYgZXhwbGljaXQgb2JzZXJ2YWJsZSBBUElcbiAgVnVlLm9ic2VydmFibGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgb2JzZXJ2ZShvYmopO1xuICAgIHJldHVybiBvYmpcbiAgfTtcblxuICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHRcbiAgfVxufSk7XG5cbi8vIGV4cG9zZSBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCBmb3Igc3NyIHJ1bnRpbWUgaGVscGVyIGluc3RhbGxhdGlvblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ0Z1bmN0aW9uYWxSZW5kZXJDb250ZXh0Jywge1xuICB2YWx1ZTogRnVuY3Rpb25hbFJlbmRlckNvbnRleHRcbn0pO1xuXG5WdWUudmVyc2lvbiA9ICcyLjYuMTAnO1xuXG4vKiAgKi9cblxuLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbnZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QscHJvZ3Jlc3MnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG52YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG52YXIgaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlID0gbWFrZU1hcCgnZXZlbnRzLGNhcmV0LHR5cGluZyxwbGFpbnRleHQtb25seScpO1xuXG52YXIgY29udmVydEVudW1lcmF0ZWRWYWx1ZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJ1xuICAgID8gJ2ZhbHNlJ1xuICAgIC8vIGFsbG93IGFyYml0cmFyeSBzdHJpbmcgdmFsdWUgZm9yIGNvbnRlbnRlZGl0YWJsZVxuICAgIDoga2V5ID09PSAnY29udGVudGVkaXRhYmxlJyAmJiBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUodmFsdWUpXG4gICAgICA/IHZhbHVlXG4gICAgICA6ICd0cnVlJ1xufTtcblxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbmRlckNsYXNzKGRhdGEuc3RhdGljQ2xhc3MsIGRhdGEuY2xhc3MpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpXG4gICAgICA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJDbGFzcyAoXG4gIHN0YXRpY0NsYXNzLFxuICBkeW5hbWljQ2xhc3Ncbikge1xuICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgc3RyaW5naWZpZWQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IHN0cmluZ2lmaWVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeU9iamVjdCAodmFsdWUpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAodmFsdWVba2V5XSkge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xuKTtcblxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XG4vLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxudmFyIGlzU1ZHID0gbWFrZU1hcChcbiAgJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG4gIHRydWVcbik7XG5cbnZhciBpc1ByZVRhZyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRhZyA9PT0gJ3ByZSc7IH07XG5cbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxufTtcblxuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcbiAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICByZXR1cm4gJ3N2ZydcbiAgfVxuICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuICBpZiAodGFnID09PSAnbWF0aCcpIHtcbiAgICByZXR1cm4gJ21hdGgnXG4gIH1cbn1cblxudmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICB9XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG4gICAgKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG4gIH1cbn1cblxudmFyIGlzVGV4dElucHV0VHlwZSA9IG1ha2VNYXAoJ3RleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsJyk7XG5cbi8qICAqL1xuXG4vKipcbiAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuICovXG5mdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0U3R5bGVTY29wZSAobm9kZSwgc2NvcGVJZCkge1xuICBub2RlLnNldEF0dHJpYnV0ZShzY29wZUlkLCAnJyk7XG59XG5cbnZhciBub2RlT3BzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG4gIGNyZWF0ZUVsZW1lbnROUzogY3JlYXRlRWxlbWVudE5TLFxuICBjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG4gIGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG4gIGluc2VydEJlZm9yZTogaW5zZXJ0QmVmb3JlLFxuICByZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG4gIGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcbiAgcGFyZW50Tm9kZTogcGFyZW50Tm9kZSxcbiAgbmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuICB0YWdOYW1lOiB0YWdOYW1lLFxuICBzZXRUZXh0Q29udGVudDogc2V0VGV4dENvbnRlbnQsXG4gIHNldFN0eWxlU2NvcGU6IHNldFN0eWxlU2NvcGVcbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiA9IHtcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgIH1cbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG4gIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgaWYgKCFpc0RlZihrZXkpKSB7IHJldHVybiB9XG5cbiAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9IGVsc2UgaWYgKHJlZnNba2V5XS5pbmRleE9mKHJlZikgPCAwKSB7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICpcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICovXG5cbnZhciBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XG5cbnZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xuXG5mdW5jdGlvbiBzYW1lVm5vZGUgKGEsIGIpIHtcbiAgcmV0dXJuIChcbiAgICBhLmtleSA9PT0gYi5rZXkgJiYgKFxuICAgICAgKFxuICAgICAgICBhLnRhZyA9PT0gYi50YWcgJiZcbiAgICAgICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXG4gICAgICAgIGlzRGVmKGEuZGF0YSkgPT09IGlzRGVmKGIuZGF0YSkgJiZcbiAgICAgICAgc2FtZUlucHV0VHlwZShhLCBiKVxuICAgICAgKSB8fCAoXG4gICAgICAgIGlzVHJ1ZShhLmlzQXN5bmNQbGFjZWhvbGRlcikgJiZcbiAgICAgICAgYS5hc3luY0ZhY3RvcnkgPT09IGIuYXN5bmNGYWN0b3J5ICYmXG4gICAgICAgIGlzVW5kZWYoYi5hc3luY0ZhY3RvcnkuZXJyb3IpXG4gICAgICApXG4gICAgKVxuICApXG59XG5cbmZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcbiAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGk7XG4gIHZhciB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHZhciB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHJldHVybiB0eXBlQSA9PT0gdHlwZUIgfHwgaXNUZXh0SW5wdXRUeXBlKHR5cGVBKSAmJiBpc1RleHRJbnB1dFR5cGUodHlwZUIpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICB2YXIgaSwga2V5O1xuICB2YXIgbWFwID0ge307XG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSB7IG1hcFtrZXldID0gaTsgfVxuICB9XG4gIHJldHVybiBtYXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbiAoYmFja2VuZCkge1xuICB2YXIgaSwgajtcbiAgdmFyIGNicyA9IHt9O1xuXG4gIHZhciBtb2R1bGVzID0gYmFja2VuZC5tb2R1bGVzO1xuICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyArK2kpIHtcbiAgICBjYnNbaG9va3NbaV1dID0gW107XG4gICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChpc0RlZihtb2R1bGVzW2pdW2hvb2tzW2ldXSkpIHtcbiAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eU5vZGVBdCAoZWxtKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgIGZ1bmN0aW9uIHJlbW92ZSQkMSAoKSB7XG4gICAgICBpZiAoLS1yZW1vdmUkJDEubGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUkJDEubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHJldHVybiByZW1vdmUkJDFcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIG5vZGVPcHMucmVtb3ZlQ2hpbGQocGFyZW50LCBlbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCQkMSAodm5vZGUsIGluVlByZSkge1xuICAgIHJldHVybiAoXG4gICAgICAhaW5WUHJlICYmXG4gICAgICAhdm5vZGUubnMgJiZcbiAgICAgICEoXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuc29tZShmdW5jdGlvbiAoaWdub3JlKSB7XG4gICAgICAgICAgcmV0dXJuIGlzUmVnRXhwKGlnbm9yZSlcbiAgICAgICAgICAgID8gaWdub3JlLnRlc3Qodm5vZGUudGFnKVxuICAgICAgICAgICAgOiBpZ25vcmUgPT09IHZub2RlLnRhZ1xuICAgICAgICB9KVxuICAgICAgKSAmJlxuICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodm5vZGUudGFnKVxuICAgIClcbiAgfVxuXG4gIHZhciBjcmVhdGluZ0VsbUluVlByZSA9IDA7XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxtIChcbiAgICB2bm9kZSxcbiAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgcGFyZW50RWxtLFxuICAgIHJlZkVsbSxcbiAgICBuZXN0ZWQsXG4gICAgb3duZXJBcnJheSxcbiAgICBpbmRleFxuICApIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgLy8gVGhpcyB2bm9kZSB3YXMgdXNlZCBpbiBhIHByZXZpb3VzIHJlbmRlciFcbiAgICAgIC8vIG5vdyBpdCdzIHVzZWQgYXMgYSBuZXcgbm9kZSwgb3ZlcndyaXRpbmcgaXRzIGVsbSB3b3VsZCBjYXVzZVxuICAgICAgLy8gcG90ZW50aWFsIHBhdGNoIGVycm9ycyBkb3duIHRoZSByb2FkIHdoZW4gaXQncyB1c2VkIGFzIGFuIGluc2VydGlvblxuICAgICAgLy8gcmVmZXJlbmNlIG5vZGUuIEluc3RlYWQsIHdlIGNsb25lIHRoZSBub2RlIG9uLWRlbWFuZCBiZWZvcmUgY3JlYXRpbmdcbiAgICAgIC8vIGFzc29jaWF0ZWQgRE9NIGVsZW1lbnQgZm9yIGl0LlxuICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIH1cblxuICAgIHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7IC8vIGZvciB0cmFuc2l0aW9uIGVudGVyIGNoZWNrXG4gICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgY3JlYXRpbmdFbG1JblZQcmUpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSkge1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xuICAgICAgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cbiAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaTtcbiAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgLy8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgdmFyIGlubmVyTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcbiAgICAvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZiQkMSkge1xuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBpZiAoaXNEZWYocmVmJCQxKSkge1xuICAgICAgICBpZiAobm9kZU9wcy5wYXJlbnROb2RlKHJlZiQkMSkgPT09IHBhcmVudCkge1xuICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYkJDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbiAodm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSwgY2hpbGRyZW4sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKFN0cmluZyh2bm9kZS50ZXh0KSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGF0Y2hhYmxlICh2bm9kZSkge1xuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgfVxuICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSkgeyBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICAvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXG4gIGZ1bmN0aW9uIHNldFNjb3BlICh2bm9kZSkge1xuICAgIHZhciBpO1xuICAgIGlmIChpc0RlZihpID0gdm5vZGUuZm5TY29wZUlkKSkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlO1xuICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgaSAhPT0gdm5vZGUuZm5Db250ZXh0ICYmXG4gICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZClcbiAgICApIHtcbiAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIGZhbHNlLCB2bm9kZXMsIHN0YXJ0SWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAge1xuICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKG5ld0NoKTtcbiAgICB9XG5cbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3RW5kSWR4KTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpXG4gICAgICAgICAgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV1cbiAgICAgICAgICA6IGZpbmRJZHhJbk9sZChuZXdTdGFydFZub2RlLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgIGlmIChzYW1lVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaFZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgdm5vZGVUb01vdmUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVLZXlzIChjaGlsZHJlbikge1xuICAgIHZhciBzZWVuS2V5cyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2bm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgdmFyIGtleSA9IHZub2RlLmtleTtcbiAgICAgIGlmIChpc0RlZihrZXkpKSB7XG4gICAgICAgIGlmIChzZWVuS2V5c1trZXldKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIChcIkR1cGxpY2F0ZSBrZXlzIGRldGVjdGVkOiAnXCIgKyBrZXkgKyBcIicuIFRoaXMgbWF5IGNhdXNlIGFuIHVwZGF0ZSBlcnJvci5cIiksXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWVuS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRJZHhJbk9sZCAobm9kZSwgb2xkQ2gsIHN0YXJ0LCBlbmQpIHtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdmFyIGMgPSBvbGRDaFtpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiBzYW1lVm5vZGUobm9kZSwgYykpIHsgcmV0dXJuIGkgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKFxuICAgIG9sZFZub2RlLFxuICAgIHZub2RlLFxuICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICBvd25lckFycmF5LFxuICAgIGluZGV4LFxuICAgIHJlbW92ZU9ubHlcbiAgKSB7XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIGNsb25lIHJldXNlZCB2bm9kZVxuICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG5cbiAgICBpZiAoaXNUcnVlKG9sZFZub2RlLmlzQXN5bmNQbGFjZWhvbGRlcikpIHtcbiAgICAgIGlmIChpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgIGh5ZHJhdGUob2xkVm5vZGUuZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxuICAgICkge1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGh5ZHJhdGlvbkJhaWxlZCA9IGZhbHNlO1xuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICAvLyBOb3RlOiBzdHlsZSBpcyBleGNsdWRlZCBiZWNhdXNlIGl0IHJlbGllcyBvbiBpbml0aWFsIGNsb25lIGZvciBmdXR1cmVcbiAgLy8gZGVlcCB1cGRhdGVzICgjNzA2MykuXG4gIHZhciBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XG5cbiAgLy8gTm90ZTogdGhpcyBpcyBhIGJyb3dzZXItb25seSBmdW5jdGlvbiBzbyB3ZSBjYW4gYXNzdW1lIGVsbXMgYXJlIERPTSBub2Rlcy5cbiAgZnVuY3Rpb24gaHlkcmF0ZSAoZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpblZQcmUgPSBpblZQcmUgfHwgKGRhdGEgJiYgZGF0YS5wcmUpO1xuICAgIHZub2RlLmVsbSA9IGVsbTtcblxuICAgIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSAmJiBpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkpKSB7XG4gICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gYXNzZXJ0IG5vZGUgbWF0Y2hcbiAgICB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlLCBpblZQcmUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIGNoaWxkIGNvbXBvbmVudC4gaXQgc2hvdWxkIGhhdmUgaHlkcmF0ZWQgaXRzIG93biB0cmVlLlxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKGlzRGVmKGNoaWxkcmVuKSkge1xuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cbiAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHYtaHRtbCBhbmQgZG9tUHJvcHM6IGlubmVySFRNTFxuICAgICAgICAgIGlmIChpc0RlZihpID0gZGF0YSkgJiYgaXNEZWYoaSA9IGkuZG9tUHJvcHMpICYmIGlzRGVmKGkgPSBpLmlubmVySFRNTCkpIHtcbiAgICAgICAgICAgIGlmIChpICE9PSBlbG0uaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBlbG0uY2hpbGROb2RlcywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIHZhciBmdWxsSW52b2tlID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGZ1bGxJbnZva2UgPSB0cnVlO1xuICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZ1bGxJbnZva2UgJiYgZGF0YVsnY2xhc3MnXSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBjb2xsZWN0aW5nIGRlcHMgZm9yIGRlZXAgY2xhc3MgYmluZGluZ3MgZm9yIGZ1dHVyZSB1cGRhdGVzXG4gICAgICAgICAgdHJhdmVyc2UoZGF0YVsnY2xhc3MnXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlLCBpblZQcmUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUudGFnKSkge1xuICAgICAgcmV0dXJuIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHwgKFxuICAgICAgICAhaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgaW5WUHJlKSAmJlxuICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5KSB7XG4gICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG4gICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XG4gICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBudWxsLCBudWxsLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICB2YXIgcGFyZW50RWxtID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBub2RlXG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0sXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgIHZhciBwYXRjaGFibGUgPSBpc1BhdGNoYWJsZSh2bm9kZSk7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5kZXN0cm95W2ldKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGlmIChwYXRjaGFibGUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgYW5jZXN0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vICM2NTEzXG4gICAgICAgICAgICAgIC8vIGludm9rZSBpbnNlcnQgaG9va3MgdGhhdCBtYXkgaGF2ZSBiZWVuIG1lcmdlZCBieSBjcmVhdGUgaG9va3MuXG4gICAgICAgICAgICAgIC8vIGUuZy4gZm9yIGRpcmVjdGl2ZXMgdGhhdCB1c2VzIHRoZSBcImluc2VydGVkXCIgaG9vay5cbiAgICAgICAgICAgICAgdmFyIGluc2VydCA9IGFuY2VzdG9yLmRhdGEuaG9vay5pbnNlcnQ7XG4gICAgICAgICAgICAgIGlmIChpbnNlcnQubWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgYXQgaW5kZXggMSB0byBhdm9pZCByZS1pbnZva2luZyBjb21wb25lbnQgbW91bnRlZCBob29rXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMTsgaSQyIDwgaW5zZXJ0LmZucy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgICAgICAgICAgICBpbnNlcnQuZm5zW2kkMl0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlZ2lzdGVyUmVmKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlc3Ryb3kgb2xkIG5vZGVcbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSkpIHtcbiAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBkaXIub2xkQXJnID0gb2xkRGlyLmFyZztcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzQ3JlYXRlKSB7XG4gICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxuICAgICAgICBjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGVtcHR5TW9kaWZpZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcbiAgZGlycyxcbiAgdm1cbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKCFkaXJzKSB7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgcmV0dXJuIHJlc1xuICB9XG4gIHZhciBpLCBkaXI7XG4gIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBpZiAoIWRpci5tb2RpZmllcnMpIHtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgcmV0dXJuIGRpci5yYXdOYW1lIHx8ICgoZGlyLm5hbWUpICsgXCIuXCIgKyAoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSlcbn1cblxuZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIHRyeSB7XG4gICAgICBmbih2bm9kZS5lbG0sIGRpciwgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW1xuICByZWYsXG4gIGRpcmVjdGl2ZXNcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSkge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xuICAgIH1cbiAgfVxuICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuICAvLyAjNjY2NjogSUUvRWRnZSBmb3JjZXMgcHJvZ3Jlc3MgdmFsdWUgZG93biB0byAxIGJlZm9yZSBzZXR0aW5nIGEgbWF4XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoKGlzSUUgfHwgaXNFZGdlKSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChlbC50YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAvLyBidXQgRmxhc2ggZXhwZWN0cyBhIHZhbHVlIG9mIFwidHJ1ZVwiIHdoZW4gdXNlZCBvbiA8ZW1iZWQ+IHRhZ1xuICAgICAgdmFsdWUgPSBrZXkgPT09ICdhbGxvd2Z1bGxzY3JlZW4nICYmIGVsLnRhZ05hbWUgPT09ICdFTUJFRCdcbiAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgOiBrZXk7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUoa2V5LCB2YWx1ZSkpO1xuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2VTZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyAjNzEzODogSUUxMCAmIDExIGZpcmVzIGlucHV0IGV2ZW50IHdoZW4gc2V0dGluZyBwbGFjZWhvbGRlciBvblxuICAgIC8vIDx0ZXh0YXJlYT4uLi4gYmxvY2sgdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFuZCByZW1vdmUgdGhlIGJsb2NrZXJcbiAgICAvLyBpbW1lZGlhdGVseS5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXG4gICAgICBpc0lFICYmICFpc0lFOSAmJlxuICAgICAgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJlxuICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmIHZhbHVlICE9PSAnJyAmJiAhZWwuX19pZXBoXG4gICAgKSB7XG4gICAgICB2YXIgYmxvY2tlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICB9O1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgZWwuX19pZXBoID0gdHJ1ZTsgLyogSUUgcGxhY2Vob2xkZXIgcGF0Y2hlZCAqL1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgdmFyIGluU2luZ2xlID0gZmFsc2U7XG4gIHZhciBpbkRvdWJsZSA9IGZhbHNlO1xuICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICB2YXIgaW5SZWdleCA9IGZhbHNlO1xuICB2YXIgY3VybHkgPSAwO1xuICB2YXIgc3F1YXJlID0gMDtcbiAgdmFyIHBhcmVuID0gMDtcbiAgdmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSB7IGluRG91YmxlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAhY3VybHkgJiYgIXNxdWFyZSAmJiAhcGFyZW5cbiAgICApIHtcbiAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6IGluU2luZ2xlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyAnXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcbiAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6IHBhcmVuLS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6IGN1cmx5Kys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAweDJmKSB7IC8vIC9cbiAgICAgICAgdmFyIGogPSBpIC0gMTtcbiAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICB9XG5cbiAgaWYgKGZpbHRlcnMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25cbn1cblxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgdmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIChhcmdzICE9PSAnKScgPyAnLCcgKyBhcmdzIDogYXJncykpXG4gIH1cbn1cblxuLyogICovXG5cblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZywgcmFuZ2UpIHtcbiAgY29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcbn1cbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gIG1vZHVsZXMsXG4gIGtleVxuKSB7XG4gIHJldHVybiBtb2R1bGVzXG4gICAgPyBtb2R1bGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbVtrZXldOyB9KS5maWx0ZXIoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH0pXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XG4gIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UsIGR5bmFtaWMpIHtcbiAgdmFyIGF0dHJzID0gZHluYW1pY1xuICAgID8gKGVsLmR5bmFtaWNBdHRycyB8fCAoZWwuZHluYW1pY0F0dHJzID0gW10pKVxuICAgIDogKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSk7XG4gIGF0dHJzLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbi8vIGFkZCBhIHJhdyBhdHRyICh1c2UgdGhpcyBpbiBwcmVUcmFuc2Zvcm1zKVxuZnVuY3Rpb24gYWRkUmF3QXR0ciAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSkge1xuICBlbC5hdHRyc01hcFtuYW1lXSA9IHZhbHVlO1xuICBlbC5hdHRyc0xpc3QucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSwgcmFuZ2UpKTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJhd05hbWUsXG4gIHZhbHVlLFxuICBhcmcsXG4gIGlzRHluYW1pY0FyZyxcbiAgbW9kaWZpZXJzLFxuICByYW5nZVxuKSB7XG4gIChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHJhbmdlU2V0SXRlbSh7XG4gICAgbmFtZTogbmFtZSxcbiAgICByYXdOYW1lOiByYXdOYW1lLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBhcmc6IGFyZyxcbiAgICBpc0R5bmFtaWNBcmc6IGlzRHluYW1pY0FyZyxcbiAgICBtb2RpZmllcnM6IG1vZGlmaWVyc1xuICB9LCByYW5nZSkpO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwcmVwZW5kTW9kaWZpZXJNYXJrZXIgKHN5bWJvbCwgbmFtZSwgZHluYW1pYykge1xuICByZXR1cm4gZHluYW1pY1xuICAgID8gKFwiX3AoXCIgKyBuYW1lICsgXCIsXFxcIlwiICsgc3ltYm9sICsgXCJcXFwiKVwiKVxuICAgIDogc3ltYm9sICsgbmFtZSAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudCxcbiAgd2FybixcbiAgcmFuZ2UsXG4gIGR5bmFtaWNcbikge1xuICBtb2RpZmllcnMgPSBtb2RpZmllcnMgfHwgZW1wdHlPYmplY3Q7XG4gIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHdhcm4gJiZcbiAgICBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZVxuICApIHtcbiAgICB3YXJuKFxuICAgICAgJ3Bhc3NpdmUgYW5kIHByZXZlbnQgY2FuXFwndCBiZSB1c2VkIHRvZ2V0aGVyLiAnICtcbiAgICAgICdQYXNzaXZlIGhhbmRsZXIgY2FuXFwndCBwcmV2ZW50IGRlZmF1bHQgZXZlbnQuJyxcbiAgICAgIHJhbmdlXG4gICAgKTtcbiAgfVxuXG4gIC8vIG5vcm1hbGl6ZSBjbGljay5yaWdodCBhbmQgY2xpY2subWlkZGxlIHNpbmNlIHRoZXkgZG9uJ3QgYWN0dWFsbHkgZmlyZVxuICAvLyB0aGlzIGlzIHRlY2huaWNhbGx5IGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBhdCBsZWFzdCBmb3Igbm93IGJyb3dzZXJzIGFyZVxuICAvLyB0aGUgb25seSB0YXJnZXQgZW52cyB0aGF0IGhhdmUgcmlnaHQvbWlkZGxlIGNsaWNrcy5cbiAgaWYgKG1vZGlmaWVycy5yaWdodCkge1xuICAgIGlmIChkeW5hbWljKSB7XG4gICAgICBuYW1lID0gXCIoXCIgKyBuYW1lICsgXCIpPT09J2NsaWNrJz8nY29udGV4dG1lbnUnOihcIiArIG5hbWUgKyBcIilcIjtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgIG5hbWUgPSAnY29udGV4dG1lbnUnO1xuICAgICAgZGVsZXRlIG1vZGlmaWVycy5yaWdodDtcbiAgICB9XG4gIH0gZWxzZSBpZiAobW9kaWZpZXJzLm1pZGRsZSkge1xuICAgIGlmIChkeW5hbWljKSB7XG4gICAgICBuYW1lID0gXCIoXCIgKyBuYW1lICsgXCIpPT09J2NsaWNrJz8nbW91c2V1cCc6KFwiICsgbmFtZSArIFwiKVwiO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgbmFtZSA9ICdtb3VzZXVwJztcbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayBjYXB0dXJlIG1vZGlmaWVyXG4gIGlmIChtb2RpZmllcnMuY2FwdHVyZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMuY2FwdHVyZTtcbiAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCchJywgbmFtZSwgZHluYW1pYyk7XG4gIH1cbiAgaWYgKG1vZGlmaWVycy5vbmNlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5vbmNlO1xuICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJ34nLCBuYW1lLCBkeW5hbWljKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKG1vZGlmaWVycy5wYXNzaXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5wYXNzaXZlO1xuICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJyYnLCBuYW1lLCBkeW5hbWljKTtcbiAgfVxuXG4gIHZhciBldmVudHM7XG4gIGlmIChtb2RpZmllcnMubmF0aXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XG4gICAgZXZlbnRzID0gZWwubmF0aXZlRXZlbnRzIHx8IChlbC5uYXRpdmVFdmVudHMgPSB7fSk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG4gIH1cblxuICB2YXIgbmV3SGFuZGxlciA9IHJhbmdlU2V0SXRlbSh7IHZhbHVlOiB2YWx1ZS50cmltKCksIGR5bmFtaWM6IGR5bmFtaWMgfSwgcmFuZ2UpO1xuICBpZiAobW9kaWZpZXJzICE9PSBlbXB0eU9iamVjdCkge1xuICAgIG5ld0hhbmRsZXIubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuICB9XG5cbiAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcnMpKSB7XG4gICAgaW1wb3J0YW50ID8gaGFuZGxlcnMudW5zaGlmdChuZXdIYW5kbGVyKSA6IGhhbmRsZXJzLnB1c2gobmV3SGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoaGFuZGxlcnMpIHtcbiAgICBldmVudHNbbmFtZV0gPSBpbXBvcnRhbnQgPyBbbmV3SGFuZGxlciwgaGFuZGxlcnNdIDogW2hhbmRsZXJzLCBuZXdIYW5kbGVyXTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHNbbmFtZV0gPSBuZXdIYW5kbGVyO1xuICB9XG5cbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0UmF3QmluZGluZ0F0dHIgKFxuICBlbCxcbiAgbmFtZVxuKSB7XG4gIHJldHVybiBlbC5yYXdBdHRyc01hcFsnOicgKyBuYW1lXSB8fFxuICAgIGVsLnJhd0F0dHJzTWFwWyd2LWJpbmQ6JyArIG5hbWVdIHx8XG4gICAgZWwucmF3QXR0cnNNYXBbbmFtZV1cbn1cblxuZnVuY3Rpb24gZ2V0QmluZGluZ0F0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgZ2V0U3RhdGljXG4pIHtcbiAgdmFyIGR5bmFtaWNWYWx1ZSA9XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJzonICsgbmFtZSkgfHxcbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1iaW5kOicgKyBuYW1lKTtcbiAgaWYgKGR5bmFtaWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHBhcnNlRmlsdGVycyhkeW5hbWljVmFsdWUpXG4gIH0gZWxzZSBpZiAoZ2V0U3RhdGljICE9PSBmYWxzZSkge1xuICAgIHZhciBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xuICAgIGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RhdGljVmFsdWUpXG4gICAgfVxuICB9XG59XG5cbi8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcbi8vIGRvZXNuJ3QgZ2V0IHByb2Nlc3NlZCBieSBwcm9jZXNzQXR0cnMuXG4vLyBCeSBkZWZhdWx0IGl0IGRvZXMgTk9UIHJlbW92ZSBpdCBmcm9tIHRoZSBtYXAgKGF0dHJzTWFwKSBiZWNhdXNlIHRoZSBtYXAgaXNcbi8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cbmZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHIgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmVtb3ZlRnJvbU1hcFxuKSB7XG4gIHZhciB2YWw7XG4gIGlmICgodmFsID0gZWwuYXR0cnNNYXBbbmFtZV0pICE9IG51bGwpIHtcbiAgICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAobGlzdFtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocmVtb3ZlRnJvbU1hcCkge1xuICAgIGRlbGV0ZSBlbC5hdHRyc01hcFtuYW1lXTtcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbmZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4IChcbiAgZWwsXG4gIG5hbWVcbikge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBhdHRyID0gbGlzdFtpXTtcbiAgICBpZiAobmFtZS50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgcmV0dXJuIGF0dHJcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmFuZ2VTZXRJdGVtIChcbiAgaXRlbSxcbiAgcmFuZ2Vcbikge1xuICBpZiAocmFuZ2UpIHtcbiAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgaXRlbS5zdGFydCA9IHJhbmdlLnN0YXJ0O1xuICAgIH1cbiAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgIGl0ZW0uZW5kID0gcmFuZ2UuZW5kO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXRlbVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cbmZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcblxuICB2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gYmFzZVZhbHVlRXhwcmVzc2lvbjtcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgXCIodHlwZW9mIFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiID09PSAnc3RyaW5nJ1wiICtcbiAgICAgIFwiPyBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIi50cmltKClcIiArXG4gICAgICBcIjogXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuICB2YXIgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuXG4gIGVsLm1vZGVsID0ge1xuICAgIHZhbHVlOiAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSxcbiAgICBleHByZXNzaW9uOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSksXG4gICAgY2FsbGJhY2s6IChcImZ1bmN0aW9uIChcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIikge1wiICsgYXNzaWdubWVudCArIFwifVwiKVxuICB9O1xufVxuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICovXG5mdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAoXG4gIHZhbHVlLFxuICBhc3NpZ25tZW50XG4pIHtcbiAgdmFyIHJlcyA9IHBhcnNlTW9kZWwodmFsdWUpO1xuICBpZiAocmVzLmtleSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAodmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIiRzZXQoXCIgKyAocmVzLmV4cCkgKyBcIiwgXCIgKyAocmVzLmtleSkgKyBcIiwgXCIgKyBhc3NpZ25tZW50ICsgXCIpXCIpXG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIHYtbW9kZWwgZXhwcmVzc2lvbiBpbnRvIGEgYmFzZSBwYXRoIGFuZCBhIGZpbmFsIGtleSBzZWdtZW50LlxuICogSGFuZGxlcyBib3RoIGRvdC1wYXRoIGFuZCBwb3NzaWJsZSBzcXVhcmUgYnJhY2tldHMuXG4gKlxuICogUG9zc2libGUgY2FzZXM6XG4gKlxuICogLSB0ZXN0XG4gKiAtIHRlc3Rba2V5XVxuICogLSB0ZXN0W3Rlc3QxW2tleV1dXG4gKiAtIHRlc3RbXCJhXCJdW2tleV1cbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtrZXldXVxuICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2tleV1dXG4gKlxuICovXG5cbnZhciBsZW4sIHN0ciwgY2hyLCBpbmRleCQxLCBleHByZXNzaW9uUG9zLCBleHByZXNzaW9uRW5kUG9zO1xuXG5cblxuZnVuY3Rpb24gcGFyc2VNb2RlbCAodmFsKSB7XG4gIC8vIEZpeCBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlL3B1bGwvNzczMFxuICAvLyBhbGxvdyB2LW1vZGVsPVwib2JqLnZhbCBcIiAodHJhaWxpbmcgd2hpdGVzcGFjZSlcbiAgdmFsID0gdmFsLnRyaW0oKTtcbiAgbGVuID0gdmFsLmxlbmd0aDtcblxuICBpZiAodmFsLmluZGV4T2YoJ1snKSA8IDAgfHwgdmFsLmxhc3RJbmRleE9mKCddJykgPCBsZW4gLSAxKSB7XG4gICAgaW5kZXgkMSA9IHZhbC5sYXN0SW5kZXhPZignLicpO1xuICAgIGlmIChpbmRleCQxID4gLTEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLnNsaWNlKDAsIGluZGV4JDEpLFxuICAgICAgICBrZXk6ICdcIicgKyB2YWwuc2xpY2UoaW5kZXgkMSArIDEpICsgJ1wiJ1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHA6IHZhbCxcbiAgICAgICAga2V5OiBudWxsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RyID0gdmFsO1xuICBpbmRleCQxID0gZXhwcmVzc2lvblBvcyA9IGV4cHJlc3Npb25FbmRQb3MgPSAwO1xuXG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICB9IGVsc2UgaWYgKGNociA9PT0gMHg1Qikge1xuICAgICAgcGFyc2VCcmFja2V0KGNocik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHA6IHZhbC5zbGljZSgwLCBleHByZXNzaW9uUG9zKSxcbiAgICBrZXk6IHZhbC5zbGljZShleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXh0ICgpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgkMSlcbn1cblxuZnVuY3Rpb24gZW9mICgpIHtcbiAgcmV0dXJuIGluZGV4JDEgPj0gbGVuXG59XG5cbmZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xuICByZXR1cm4gY2hyID09PSAweDIyIHx8IGNociA9PT0gMHgyN1xufVxuXG5mdW5jdGlvbiBwYXJzZUJyYWNrZXQgKGNocikge1xuICB2YXIgaW5CcmFja2V0ID0gMTtcbiAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjaHIgPT09IDB4NUIpIHsgaW5CcmFja2V0Kys7IH1cbiAgICBpZiAoY2hyID09PSAweDVEKSB7IGluQnJhY2tldC0tOyB9XG4gICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xuICAgICAgZXhwcmVzc2lvbkVuZFBvcyA9IGluZGV4JDE7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyAoY2hyKSB7XG4gIHZhciBzdHJpbmdRdW90ZSA9IGNocjtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB3YXJuJDE7XG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG52YXIgUkFOR0VfVE9LRU4gPSAnX19yJztcbnZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG5mdW5jdGlvbiBtb2RlbCAoXG4gIGVsLFxuICBkaXIsXG4gIF93YXJuXG4pIHtcbiAgd2FybiQxID0gX3dhcm47XG4gIHZhciB2YWx1ZSA9IGRpci52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGRpci5tb2RpZmllcnM7XG4gIHZhciB0YWcgPSBlbC50YWc7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICB7XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCIsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2Uge1xuICAgIHdhcm4kMShcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgXCJ2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBlbGVtZW50IHR5cGUuIFwiICtcbiAgICAgICdJZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBjb250ZW50ZWRpdGFibGUsIGl0XFwncyByZWNvbW1lbmRlZCB0byAnICtcbiAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LicsXG4gICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBydW50aW1lIGRpcmVjdGl2ZSBtZXRhZGF0YVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZW5DaGVja2JveE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YXIgdHJ1ZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHJ1ZS12YWx1ZScpIHx8ICd0cnVlJztcbiAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJyxcbiAgICBcIkFycmF5LmlzQXJyYXkoXCIgKyB2YWx1ZSArIFwiKVwiICtcbiAgICBcIj9faShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIik+LTFcIiArIChcbiAgICAgIHRydWVWYWx1ZUJpbmRpbmcgPT09ICd0cnVlJ1xuICAgICAgICA/IChcIjooXCIgKyB2YWx1ZSArIFwiKVwiKVxuICAgICAgICA6IChcIjpfcShcIiArIHZhbHVlICsgXCIsXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpXCIpXG4gICAgKVxuICApO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJyxcbiAgICBcInZhciAkJGE9XCIgKyB2YWx1ZSArIFwiLFwiICtcbiAgICAgICAgJyQkZWw9JGV2ZW50LnRhcmdldCwnICtcbiAgICAgICAgXCIkJGM9JCRlbC5jaGVja2VkPyhcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIik6KFwiICsgZmFsc2VWYWx1ZUJpbmRpbmcgKyBcIik7XCIgK1xuICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xuICAgICAgXCJ2YXIgJCR2PVwiICsgKG51bWJlciA/ICdfbignICsgdmFsdWVCaW5kaW5nICsgJyknIDogdmFsdWVCaW5kaW5nKSArIFwiLFwiICtcbiAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xuICAgICAgXCJpZigkJGVsLmNoZWNrZWQpeyQkaTwwJiYoXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGEuY29uY2F0KFskJHZdKScpKSArIFwiKX1cIiArXG4gICAgICBcImVsc2V7JCRpPi0xJiYoXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGEuc2xpY2UoMCwkJGkpLmNvbmNhdCgkJGEuc2xpY2UoJCRpKzEpKScpKSArIFwiKX1cIiArXG4gICAgXCJ9ZWxzZXtcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYycpKSArIFwifVwiLFxuICAgIG51bGwsIHRydWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2VuUmFkaW9Nb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFsdWVCaW5kaW5nID0gbnVtYmVyID8gKFwiX24oXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikgOiB2YWx1ZUJpbmRpbmc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJywgKFwiX3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUJpbmRpbmcpLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU2VsZWN0IChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciBzZWxlY3RlZFZhbCA9IFwiQXJyYXkucHJvdG90eXBlLmZpbHRlclwiICtcbiAgICBcIi5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pXCIgK1xuICAgIFwiLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXFxcIl92YWx1ZVxcXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZTtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXCJ9KVwiO1xuXG4gIHZhciBhc3NpZ25tZW50ID0gJyRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXSc7XG4gIHZhciBjb2RlID0gXCJ2YXIgJCRzZWxlY3RlZFZhbCA9IFwiICsgc2VsZWN0ZWRWYWwgKyBcIjtcIjtcbiAgY29kZSA9IGNvZGUgKyBcIiBcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkpO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIC8vIHdhcm4gaWYgdi1iaW5kOnZhbHVlIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWxcbiAgLy8gZXhjZXB0IGZvciBpbnB1dHMgd2l0aCB2LWJpbmQ6dHlwZVxuICB7XG4gICAgdmFyIHZhbHVlJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gfHwgZWwuYXR0cnNNYXBbJzp2YWx1ZSddO1xuICAgIHZhciB0eXBlQmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dHlwZSddIHx8IGVsLmF0dHJzTWFwWyc6dHlwZSddO1xuICAgIGlmICh2YWx1ZSQxICYmICF0eXBlQmluZGluZykge1xuICAgICAgdmFyIGJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gPyAndi1iaW5kOnZhbHVlJyA6ICc6dmFsdWUnO1xuICAgICAgd2FybiQxKFxuICAgICAgICBiaW5kaW5nICsgXCI9XFxcIlwiICsgdmFsdWUkMSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCB2LW1vZGVsIG9uIHRoZSBzYW1lIGVsZW1lbnQgXCIgK1xuICAgICAgICAnYmVjYXVzZSB0aGUgbGF0dGVyIGFscmVhZHkgZXhwYW5kcyB0byBhIHZhbHVlIGJpbmRpbmcgaW50ZXJuYWxseScsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwW2JpbmRpbmddXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG4gIHZhciBsYXp5ID0gcmVmLmxhenk7XG4gIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICB2YXIgdHJpbSA9IHJlZi50cmltO1xuICB2YXIgbmVlZENvbXBvc2l0aW9uR3VhcmQgPSAhbGF6eSAmJiB0eXBlICE9PSAncmFuZ2UnO1xuICB2YXIgZXZlbnQgPSBsYXp5XG4gICAgPyAnY2hhbmdlJ1xuICAgIDogdHlwZSA9PT0gJ3JhbmdlJ1xuICAgICAgPyBSQU5HRV9UT0tFTlxuICAgICAgOiAnaW5wdXQnO1xuXG4gIHZhciB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCIkZXZlbnQudGFyZ2V0LnZhbHVlLnRyaW0oKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cblxuICB2YXIgY29kZSA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuICBpZiAobmVlZENvbXBvc2l0aW9uR3VhcmQpIHtcbiAgICBjb2RlID0gXCJpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47XCIgKyBjb2RlO1xuICB9XG5cbiAgYWRkUHJvcChlbCwgJ3ZhbHVlJywgKFwiKFwiICsgdmFsdWUgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCBldmVudCwgY29kZSwgbnVsbCwgdHJ1ZSk7XG4gIGlmICh0cmltIHx8IG51bWJlcikge1xuICAgIGFkZEhhbmRsZXIoZWwsICdibHVyJywgJyRmb3JjZVVwZGF0ZSgpJyk7XG4gIH1cbn1cblxuLyogICovXG5cbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbi8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2Vcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudHMgKG9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICB2YXIgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcbiAgfVxuICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxuICAvLyBhZnRlciAyLjUuIEtlZXBpbmcgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXQgd2l0aCBnZW5lcmF0ZWQgY29kZSBmcm9tIDwgMi40XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgIG9uLmNoYW5nZSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uLmNoYW5nZSB8fCBbXSk7XG4gICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0JDE7XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyJDEgKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKSB7XG4gIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XG4gICAgdmFyIHJlcyA9IGhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICByZW1vdmUkMihldmVudCwgb25jZUhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgIH1cbiAgfVxufVxuXG4vLyAjOTQ0NjogRmlyZWZveCA8PSA1MyAoaW4gcGFydGljdWxhciwgRVNSIDUyKSBoYXMgaW5jb3JyZWN0IEV2ZW50LnRpbWVTdGFtcFxuLy8gaW1wbGVtZW50YXRpb24gYW5kIGRvZXMgbm90IGZpcmUgbWljcm90YXNrcyBpbiBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLCBzb1xuLy8gc2FmZSB0byBleGNsdWRlLlxudmFyIHVzZU1pY3JvdGFza0ZpeCA9IGlzVXNpbmdNaWNyb1Rhc2sgJiYgIShpc0ZGICYmIE51bWJlcihpc0ZGWzFdKSA8PSA1Myk7XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgbmFtZSxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgcGFzc2l2ZVxuKSB7XG4gIC8vIGFzeW5jIGVkZ2UgY2FzZSAjNjU2NjogaW5uZXIgY2xpY2sgZXZlbnQgdHJpZ2dlcnMgcGF0Y2gsIGV2ZW50IGhhbmRsZXJcbiAgLy8gYXR0YWNoZWQgdG8gb3V0ZXIgZWxlbWVudCBkdXJpbmcgcGF0Y2gsIGFuZCB0cmlnZ2VyZWQgYWdhaW4uIFRoaXNcbiAgLy8gaGFwcGVucyBiZWNhdXNlIGJyb3dzZXJzIGZpcmUgbWljcm90YXNrIHRpY2tzIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24uXG4gIC8vIHRoZSBzb2x1dGlvbiBpcyBzaW1wbGU6IHdlIHNhdmUgdGhlIHRpbWVzdGFtcCB3aGVuIGEgaGFuZGxlciBpcyBhdHRhY2hlZCxcbiAgLy8gYW5kIHRoZSBoYW5kbGVyIHdvdWxkIG9ubHkgZmlyZSBpZiB0aGUgZXZlbnQgcGFzc2VkIHRvIGl0IHdhcyBmaXJlZFxuICAvLyBBRlRFUiBpdCB3YXMgYXR0YWNoZWQuXG4gIGlmICh1c2VNaWNyb3Rhc2tGaXgpIHtcbiAgICB2YXIgYXR0YWNoZWRUaW1lc3RhbXAgPSBjdXJyZW50Rmx1c2hUaW1lc3RhbXA7XG4gICAgdmFyIG9yaWdpbmFsID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gb3JpZ2luYWwuX3dyYXBwZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKFxuICAgICAgICAvLyBubyBidWJibGluZywgc2hvdWxkIGFsd2F5cyBmaXJlLlxuICAgICAgICAvLyB0aGlzIGlzIGp1c3QgYSBzYWZldHkgbmV0IGluIGNhc2UgZXZlbnQudGltZVN0YW1wIGlzIHVucmVsaWFibGUgaW5cbiAgICAgICAgLy8gY2VydGFpbiB3ZWlyZCBlbnZpcm9ubWVudHMuLi5cbiAgICAgICAgZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCB8fFxuICAgICAgICAvLyBldmVudCBpcyBmaXJlZCBhZnRlciBoYW5kbGVyIGF0dGFjaG1lbnRcbiAgICAgICAgZS50aW1lU3RhbXAgPj0gYXR0YWNoZWRUaW1lc3RhbXAgfHxcbiAgICAgICAgLy8gYmFpbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgaGF2ZSBidWdneSBldmVudC50aW1lU3RhbXAgaW1wbGVtZW50YXRpb25zXG4gICAgICAgIC8vICM5NDYyIGlPUyA5IGJ1ZzogZXZlbnQudGltZVN0YW1wIGlzIDAgYWZ0ZXIgaGlzdG9yeS5wdXNoU3RhdGVcbiAgICAgICAgLy8gIzk2ODEgUXRXZWJFbmdpbmUgZXZlbnQudGltZVN0YW1wIGlzIG5lZ2F0aXZlIHZhbHVlXG4gICAgICAgIGUudGltZVN0YW1wIDw9IDAgfHxcbiAgICAgICAgLy8gIzk0NDggYmFpbCBpZiBldmVudCBpcyBmaXJlZCBpbiBhbm90aGVyIGRvY3VtZW50IGluIGEgbXVsdGktcGFnZVxuICAgICAgICAvLyBlbGVjdHJvbi9udy5qcyBhcHAsIHNpbmNlIGV2ZW50LnRpbWVTdGFtcCB3aWxsIGJlIHVzaW5nIGEgZGlmZmVyZW50XG4gICAgICAgIC8vIHN0YXJ0aW5nIHJlZmVyZW5jZVxuICAgICAgICBlLnRhcmdldC5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlcixcbiAgICBzdXBwb3J0c1Bhc3NpdmVcbiAgICAgID8geyBjYXB0dXJlOiBjYXB0dXJlLCBwYXNzaXZlOiBwYXNzaXZlIH1cbiAgICAgIDogY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiByZW1vdmUkMiAoXG4gIG5hbWUsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICBuYW1lLFxuICAgIGhhbmRsZXIuX3dyYXBwZXIgfHwgaGFuZGxlcixcbiAgICBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB0YXJnZXQkMSA9IHZub2RlLmVsbTtcbiAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCBjcmVhdGVPbmNlSGFuZGxlciQxLCB2bm9kZS5jb250ZXh0KTtcbiAgdGFyZ2V0JDEgPSB1bmRlZmluZWQ7XG59XG5cbnZhciBldmVudHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICB1cGRhdGU6IHVwZGF0ZURPTUxpc3RlbmVyc1xufTtcblxuLyogICovXG5cbnZhciBzdmdDb250YWluZXI7XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1cjtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihwcm9wcy5fX29iX18pKSB7XG4gICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBvbGRQcm9wcykge1xuICAgIGlmICghKGtleSBpbiBwcm9wcykpIHtcbiAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgfVxuICB9XG5cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICAgIC8vICM2NjAxIHdvcmsgYXJvdW5kIENocm9tZSB2ZXJzaW9uIDw9IDU1IGJ1ZyB3aGVyZSBzaW5nbGUgdGV4dE5vZGVcbiAgICAgIC8vIHJlcGxhY2VkIGJ5IGlubmVySFRNTC90ZXh0Q29udGVudCByZXRhaW5zIGl0cyBwYXJlbnROb2RlIHByb3BlcnR5XG4gICAgICBpZiAoZWxtLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJyAmJiBlbG0udGFnTmFtZSAhPT0gJ1BST0dSRVNTJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIHZhciBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdpbm5lckhUTUwnICYmIGlzU1ZHKGVsbS50YWdOYW1lKSAmJiBpc1VuZGVmKGVsbS5pbm5lckhUTUwpKSB7XG4gICAgICAvLyBJRSBkb2Vzbid0IHN1cHBvcnQgaW5uZXJIVE1MIGZvciBTVkcgZWxlbWVudHNcbiAgICAgIHN2Z0NvbnRhaW5lciA9IHN2Z0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHN2Z0NvbnRhaW5lci5pbm5lckhUTUwgPSBcIjxzdmc+XCIgKyBjdXIgKyBcIjwvc3ZnPlwiO1xuICAgICAgdmFyIHN2ZyA9IHN2Z0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGVsbS5maXJzdENoaWxkKSB7XG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoc3ZnLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxtLmFwcGVuZENoaWxkKHN2Zy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgLy8gc2tpcCB0aGUgdXBkYXRlIGlmIG9sZCBhbmQgbmV3IFZET00gc3RhdGUgaXMgdGhlIHNhbWUuXG4gICAgICAvLyBgdmFsdWVgIGlzIGhhbmRsZWQgc2VwYXJhdGVseSBiZWNhdXNlIHRoZSBET00gdmFsdWUgbWF5IGJlIHRlbXBvcmFyaWx5XG4gICAgICAvLyBvdXQgb2Ygc3luYyB3aXRoIFZET00gc3RhdGUgZHVlIHRvIGZvY3VzLCBjb21wb3NpdGlvbiBhbmQgbW9kaWZpZXJzLlxuICAgICAgLy8gVGhpcyAgIzQ1MjEgYnkgc2tpcHBpbmcgdGhlIHVubmVjZXNhcnJ5IGBjaGVja2VkYCB1cGRhdGUuXG4gICAgICBjdXIgIT09IG9sZFByb3BzW2tleV1cbiAgICApIHtcbiAgICAgIC8vIHNvbWUgcHJvcGVydHkgdXBkYXRlcyBjYW4gdGhyb3dcbiAgICAgIC8vIGUuZy4gYHZhbHVlYCBvbiA8cHJvZ3Jlc3M+IHcvIG5vbi1maW5pdGUgdmFsdWVcbiAgICAgIHRyeSB7XG4gICAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gIH1cbn1cblxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKGVsbSwgY2hlY2tWYWwpIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgZWxtLnRhZ05hbWUgPT09ICdPUFRJT04nIHx8XG4gICAgaXNOb3RJbkZvY3VzQW5kRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICBpc0RpcnR5V2l0aE1vZGlmaWVycyhlbG0sIGNoZWNrVmFsKVxuICApKVxufVxuXG5mdW5jdGlvbiBpc05vdEluRm9jdXNBbmREaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXG4gIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICB2YXIgbm90SW5Gb2N1cyA9IHRydWU7XG4gIC8vICM2MTU3XG4gIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICB0cnkgeyBub3RJbkZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtOyB9IGNhdGNoIChlKSB7fVxuICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzRGlydHlXaXRoTW9kaWZpZXJzIChlbG0sIG5ld1ZhbCkge1xuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSkge1xuICAgIGlmIChtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxufVxuXG52YXIgZG9tUHJvcHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbn07XG5cbi8qICAqL1xuXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XG4gIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB2YXIgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEgKGRhdGEpIHtcbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cbiAgLy8gYW5kIGlzIGFsd2F5cyBhIGZyZXNoIG9iamVjdCwgc28gaXQncyBzYWZlIHRvIG1lcmdlIGludG8gaXRcbiAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcbiAgICA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcbiAgICA6IHN0eWxlXG59XG5cbi8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3RcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICByZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKVxuICB9XG4gIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZVN0eWxlVGV4dChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgcmV0dXJuIGJpbmRpbmdTdHlsZVxufVxuXG4vKipcbiAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBzdHlsZURhdGE7XG5cbiAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChcbiAgICAgICAgY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhICYmXG4gICAgICAgIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKVxuICAgICAgKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgfVxuXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGNzc1ZhclJFID0gL14tLS87XG52YXIgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbnZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShoeXBoZW5hdGUobmFtZSksIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgdmVuZG9yTmFtZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxudmFyIGVtcHR5U3R5bGU7XG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIGVtcHR5U3R5bGUgPSBlbXB0eVN0eWxlIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiBlbXB0eVN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgdmFyIGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuYW1lID0gdmVuZG9yTmFtZXNbaV0gKyBjYXBOYW1lO1xuICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgIHJldHVybiBuYW1lXG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGN1ciwgbmFtZTtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcbiAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xuICAvLyB0byBtdXRhdGUgaXQuXG4gIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxuICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcbiAgICA6IHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59O1xuXG4vKiAgKi9cblxudmFyIHdoaXRlc3BhY2VSRSA9IC9cXHMrLztcblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUpLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUpLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgfVxuICAgIGlmICghZWwuY2xhc3NMaXN0Lmxlbmd0aCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBjdXIgPSBjdXIudHJpbSgpO1xuICAgIGlmIChjdXIpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmJCQxKSB7XG4gIGlmICghZGVmJCQxKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGlmIChkZWYkJDEuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZiQkMSk7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMSlcbiAgfVxufVxuXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICBsZWF2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlXCIpLFxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuICB9XG59KTtcblxudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG52YXIgcmFmID0gaW5Ccm93c2VyXG4gID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgICA6IHNldFRpbWVvdXRcbiAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH07XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIHZhciB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pO1xuICBpZiAodHJhbnNpdGlvbkNsYXNzZXMuaW5kZXhPZihjbHMpIDwgMCkge1xuICAgIHRyYW5zaXRpb25DbGFzc2VzLnB1c2goY2xzKTtcbiAgICBhZGRDbGFzcyhlbCwgY2xzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHJlbW92ZShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyAoXG4gIGVsLFxuICBleHBlY3RlZFR5cGUsXG4gIGNiXG4pIHtcbiAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICB2YXIgdGltZW91dCA9IHJlZi50aW1lb3V0O1xuICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcbiAgaWYgKCF0eXBlKSB7IHJldHVybiBjYigpIH1cbiAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICB2YXIgZW5kZWQgPSAwO1xuICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICBjYigpO1xuICB9O1xuICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgICBlbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbn1cblxudmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgLy8gSlNET00gbWF5IHJldHVybiB1bmRlZmluZWQgZm9yIHRyYW5zaXRpb24gcHJvcGVydGllc1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICB2YXIgdHlwZTtcbiAgdmFyIHRpbWVvdXQgPSAwO1xuICB2YXIgcHJvcENvdW50ID0gMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgOiAwO1xuICB9XG4gIHZhciBoYXNUcmFuc2Zvcm0gPVxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgcHJvcENvdW50OiBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG4vLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlciBudW1iZXJzXG4vLyBpbiBhIGxvY2FsZS1kZXBlbmRlbnQgd2F5LCB1c2luZyBhIGNvbW1hIGluc3RlYWQgb2YgYSBkb3QuXG4vLyBJZiBjb21tYSBpcyBub3QgcmVwbGFjZWQgd2l0aCBhIGRvdCwgdGhlIGlucHV0IHdpbGwgYmUgcm91bmRlZCBkb3duIChpLmUuIGFjdGluZ1xuLy8gYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpLnJlcGxhY2UoJywnLCAnLicpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAoZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgdmFyIGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHZhciBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiXG4gICAgICApIHtcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICB9XG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xuICBpZiAoZXhwZWN0c0NTUykge1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgfVxuXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2VudGVyQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm4gcm0oKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzO1xuICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlO1xuICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcbiAgdmFyIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZDtcbiAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcblxuICB2YXIgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmxlYXZlXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVsodm5vZGUua2V5KV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmIChpc1VuZGVmKGZuKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGRpcmVjdGl2ZSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIC8vICM2OTAzXG4gICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRpcmVjdGl2ZS5jb21wb25lbnRVcGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfVxuICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIHByZXZPcHRpb25zID0gZWwuX3ZPcHRpb25zO1xuICAgICAgdmFyIGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKGZ1bmN0aW9uIChvLCBpKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSk7IH0pKSB7XG4gICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50IGlmXG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXG4gICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGN1ck9wdGlvbnMpOyB9KVxuICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xuICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgIH0sIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjdHVhbGx5U2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcbiAgICAgIFwiZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5ldmVyeShmdW5jdGlvbiAobykgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgdmFsdWUpOyB9KVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuICBpZiAoIWUudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm4gfVxuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgdmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKSB7IHJldHVybiB9XG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIGlmICh0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBkaXJlY3RpdmUsXG4gIHNob3c6IHNob3dcbn07XG5cbi8qICAqL1xuXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgY3NzOiBCb29sZWFuLFxuICBtb2RlOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcblxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAvLyBwcm9wc1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gIH1cbiAgLy8gZXZlbnRzLlxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgaWYgKC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKSkge1xuICAgIHJldHVybiBoKCdrZWVwLWFsaXZlJywge1xuICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uICh2bm9kZSkge1xuICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xuICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZUNoaWxkIChjaGlsZCwgb2xkQ2hpbGQpIHtcbiAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG59XG5cbnZhciBpc05vdFRleHROb2RlID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudGFnIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKTsgfTtcblxudmFyIGlzVlNob3dEaXJlY3RpdmUgPSBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH07XG5cbnZhciBUcmFuc2l0aW9uID0ge1xuICBuYW1lOiAndHJhbnNpdGlvbicsXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoaXNOb3RUZXh0Tm9kZSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAobW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJ1xuICAgICkge1xuICAgICAgd2FybihcbiAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG4gICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICAvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcbiAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgIH1cblxuICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG4gICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICB2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIiArICh0aGlzLl91aWQpICsgXCItXCI7XG4gICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgID8gY2hpbGQuaXNDb21tZW50XG4gICAgICAgID8gaWQgKyAnY29tbWVudCdcbiAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xuICAgICAgOiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG4gICAgICAgID8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG4gICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgdmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcbiAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgLy8gbWFyayB2LXNob3dcbiAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGlzVlNob3dEaXJlY3RpdmUpKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG9sZENoaWxkICYmXG4gICAgICBvbGRDaGlsZC5kYXRhICYmXG4gICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZCkgJiZcbiAgICAgIC8vICM2Njg3IGNvbXBvbmVudCByb290IGlzIGEgY29tbWVudCBub2RlXG4gICAgICAhKG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlICYmIG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZS5pc0NvbW1lbnQpXG4gICAgKSB7XG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgIHZhciBvbGREYXRhID0gb2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKTtcbiAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcbiAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcbiAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMkMS5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgaWYgKGlzQXN5bmNQbGFjZWhvbGRlcihjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gb2xkUmF3Q2hpbGRcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xuICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkgeyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkgeyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd0NoaWxkXG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgcHJvcHMgPSBleHRlbmQoe1xuICB0YWc6IFN0cmluZyxcbiAgbW92ZUNsYXNzOiBTdHJpbmdcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbmRlbGV0ZSBwcm9wcy5tb2RlO1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICBwcm9wczogcHJvcHMsXG5cbiAgYmVmb3JlTW91bnQ6IGZ1bmN0aW9uIGJlZm9yZU1vdW50ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB1cGRhdGUgPSB0aGlzLl91cGRhdGU7XG4gICAgdGhpcy5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICAgIHZhciByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZSh0aGlzJDEpO1xuICAgICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgICAgdGhpcyQxLl9fcGF0Y2hfXyhcbiAgICAgICAgdGhpcyQxLl92bm9kZSxcbiAgICAgICAgdGhpcyQxLmtlcHQsXG4gICAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG4gICAgICApO1xuICAgICAgdGhpcyQxLl92bm9kZSA9IHRoaXMkMS5rZXB0O1xuICAgICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgICB1cGRhdGUuY2FsbCh0aGlzJDEsIHZub2RlLCBoeWRyYXRpbmcpO1xuICAgIH07XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcbiAgICAgIGlmIChjLnRhZykge1xuICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgICAgbWFwW2Mua2V5XSA9IGNcbiAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgLy8gYXNzaWduIHRvIHRoaXMgdG8gYXZvaWQgYmVpbmcgcmVtb3ZlZCBpbiB0cmVlLXNoYWtpbmdcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0aGlzLl9yZWZsb3cgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcblxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgdmFyIGVsID0gYy5lbG07XG4gICAgICAgIHZhciBzID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcbiAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG4gICAgICB9XG4gICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXG4gICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgdmFyIGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xuICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcbiAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCJweCxcIiArIGR5ICsgXCJweClcIjtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gIH1cbn1cblxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcbn07XG5cbi8qICAqL1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xuVnVlLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbmV4dGVuZChWdWUub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xuXG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKGluQnJvd3Nlcikge1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuICAgICkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xuICAgICAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcbiAgICAgICk7XG4gICAgfVxuICB9LCAwKTtcbn1cblxuLyogICovXG5cbnZhciBkZWZhdWx0VGFnUkUgPSAvXFx7XFx7KCg/Oi58XFxyP1xcbikrPylcXH1cXH0vZztcbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcblxudmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcbiAgdmFyIG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICB2YXIgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxufSk7XG5cblxuXG5mdW5jdGlvbiBwYXJzZVRleHQgKFxuICB0ZXh0LFxuICBkZWxpbWl0ZXJzXG4pIHtcbiAgdmFyIHRhZ1JFID0gZGVsaW1pdGVycyA/IGJ1aWxkUmVnZXgoZGVsaW1pdGVycykgOiBkZWZhdWx0VGFnUkU7XG4gIGlmICghdGFnUkUudGVzdCh0ZXh0KSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIHJhd1Rva2VucyA9IFtdO1xuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgdmFyIG1hdGNoLCBpbmRleCwgdG9rZW5WYWx1ZTtcbiAgd2hpbGUgKChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpKSB7XG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAvLyBwdXNoIHRleHQgdG9rZW5cbiAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKTtcbiAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgdmFyIGV4cCA9IHBhcnNlRmlsdGVycyhtYXRjaFsxXS50cmltKCkpO1xuICAgIHRva2Vucy5wdXNoKChcIl9zKFwiICsgZXhwICsgXCIpXCIpKTtcbiAgICByYXdUb2tlbnMucHVzaCh7ICdAYmluZGluZyc6IGV4cCB9KTtcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICByYXdUb2tlbnMucHVzaCh0b2tlblZhbHVlID0gdGV4dC5zbGljZShsYXN0SW5kZXgpKTtcbiAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBleHByZXNzaW9uOiB0b2tlbnMuam9pbignKycpLFxuICAgIHRva2VuczogcmF3VG9rZW5zXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljQ2xhc3MgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnY2xhc3MnKTtcbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgdmFyIHJlcyA9IHBhcnNlVGV4dChzdGF0aWNDbGFzcywgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICBpZiAocmVzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImNsYXNzPVxcXCJcIiArIHN0YXRpY0NsYXNzICsgXCJcXFwiOiBcIiArXG4gICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBjbGFzcz1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmNsYXNzPVwidmFsXCI+LicsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWydjbGFzcyddXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICBlbC5zdGF0aWNDbGFzcyA9IEpTT04uc3RyaW5naWZ5KHN0YXRpY0NsYXNzKTtcbiAgfVxuICB2YXIgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChjbGFzc0JpbmRpbmcpIHtcbiAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY0NsYXNzKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY0NsYXNzOlwiICsgKGVsLnN0YXRpY0NsYXNzKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwiY2xhc3M6XCIgKyAoZWwuY2xhc3NCaW5kaW5nKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBrbGFzcyQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY0NsYXNzJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUsXG4gIGdlbkRhdGE6IGdlbkRhdGFcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlJDEgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcbiAgaWYgKHN0YXRpY1N0eWxlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAge1xuICAgICAgdmFyIHJlcyA9IHBhcnNlVGV4dChzdGF0aWNTdHlsZSwgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcInN0eWxlPVxcXCJcIiArIHN0YXRpY1N0eWxlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBzdHlsZT1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOnN0eWxlPVwidmFsXCI+LicsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3N0eWxlJ11cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWwuc3RhdGljU3R5bGUgPSBKU09OLnN0cmluZ2lmeShwYXJzZVN0eWxlVGV4dChzdGF0aWNTdHlsZSkpO1xuICB9XG5cbiAgdmFyIHN0eWxlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc3R5bGUnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoc3R5bGVCaW5kaW5nKSB7XG4gICAgZWwuc3R5bGVCaW5kaW5nID0gc3R5bGVCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY1N0eWxlOlwiICsgKGVsLnN0YXRpY1N0eWxlKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5zdHlsZUJpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwic3R5bGU6KFwiICsgKGVsLnN0eWxlQmluZGluZykgKyBcIiksXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIHN0eWxlJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljU3R5bGUnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSQxLFxuICBnZW5EYXRhOiBnZW5EYXRhJDFcbn07XG5cbi8qICAqL1xuXG52YXIgZGVjb2RlcjtcblxudmFyIGhlID0ge1xuICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZSAoaHRtbCkge1xuICAgIGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRlY29kZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudFxuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxuICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicidcbik7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbik7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaydcbik7XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG52YXIgYXR0cmlidXRlID0gL15cXHMqKFteXFxzXCInPD5cXC89XSspKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG52YXIgZHluYW1pY0FyZ0F0dHJpYnV0ZSA9IC9eXFxzKigoPzp2LVtcXHctXSs6fEB8OnwjKVxcW1tePV0rXFxdW15cXHNcIic8PlxcLz1dKikoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcbnZhciBuY25hbWUgPSBcIlthLXpBLVpfXVtcXFxcLVxcXFwuMC05X2EtekEtWlwiICsgKHVuaWNvZGVSZWdFeHAuc291cmNlKSArIFwiXSpcIjtcbnZhciBxbmFtZUNhcHR1cmUgPSBcIigoPzpcIiArIG5jbmFtZSArIFwiXFxcXDopP1wiICsgbmNuYW1lICsgXCIpXCI7XG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgoXCJePFwiICsgcW5hbWVDYXB0dXJlKSk7XG52YXIgc3RhcnRUYWdDbG9zZSA9IC9eXFxzKihcXC8/KT4vO1xudmFyIGVuZFRhZyA9IG5ldyBSZWdFeHAoKFwiXjxcXFxcL1wiICsgcW5hbWVDYXB0dXJlICsgXCJbXj5dKj5cIikpO1xudmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcbi8vICM3Mjk4OiBlc2NhcGUgLSB0byBhdm9pZCBiZWluZyBwYXNlZCBhcyBIVE1MIGNvbW1lbnQgd2hlbiBpbmxpbmVkIGluIHBhZ2VcbnZhciBjb21tZW50ID0gL148IVxcLS0vO1xudmFyIGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xuXG4vLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcbnZhciBpc1BsYWluVGV4dEVsZW1lbnQgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciByZUNhY2hlID0ge307XG5cbnZhciBkZWNvZGluZ01hcCA9IHtcbiAgJyZsdDsnOiAnPCcsXG4gICcmZ3Q7JzogJz4nLFxuICAnJnF1b3Q7JzogJ1wiJyxcbiAgJyZhbXA7JzogJyYnLFxuICAnJiMxMDsnOiAnXFxuJyxcbiAgJyYjOTsnOiAnXFx0JyxcbiAgJyYjMzk7JzogXCInXCJcbn07XG52YXIgZW5jb2RlZEF0dHIgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMzOSk7L2c7XG52YXIgZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMzOXwjMTB8IzkpOy9nO1xuXG4vLyAjNTk5MlxudmFyIGlzSWdub3JlTmV3bGluZVRhZyA9IG1ha2VNYXAoJ3ByZSx0ZXh0YXJlYScsIHRydWUpO1xudmFyIHNob3VsZElnbm9yZUZpcnN0TmV3bGluZSA9IGZ1bmN0aW9uICh0YWcsIGh0bWwpIHsgcmV0dXJuIHRhZyAmJiBpc0lnbm9yZU5ld2xpbmVUYWcodGFnKSAmJiBodG1sWzBdID09PSAnXFxuJzsgfTtcblxuZnVuY3Rpb24gZGVjb2RlQXR0ciAodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKSB7XG4gIHZhciByZSA9IHNob3VsZERlY29kZU5ld2xpbmVzID8gZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgOiBlbmNvZGVkQXR0cjtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmUsIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gZGVjb2RpbmdNYXBbbWF0Y2hdOyB9KVxufVxuXG5mdW5jdGlvbiBwYXJzZUhUTUwgKGh0bWwsIG9wdGlvbnMpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBleHBlY3RIVE1MID0gb3B0aW9ucy5leHBlY3RIVE1MO1xuICB2YXIgaXNVbmFyeVRhZyQkMSA9IG9wdGlvbnMuaXNVbmFyeVRhZyB8fCBubztcbiAgdmFyIGNhbkJlTGVmdE9wZW5UYWckJDEgPSBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcgfHwgbm87XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0LCBsYXN0VGFnO1xuICB3aGlsZSAoaHRtbCkge1xuICAgIGxhc3QgPSBodG1sO1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgaW4gYSBwbGFpbnRleHQgY29udGVudCBlbGVtZW50IGxpa2Ugc2NyaXB0L3N0eWxlXG4gICAgaWYgKCFsYXN0VGFnIHx8ICFpc1BsYWluVGV4dEVsZW1lbnQobGFzdFRhZykpIHtcbiAgICAgIHZhciB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XG4gICAgICBpZiAodGV4dEVuZCA9PT0gMCkge1xuICAgICAgICAvLyBDb21tZW50OlxuICAgICAgICBpZiAoY29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbW1lbnRFbmQgPSBodG1sLmluZGV4T2YoJy0tPicpO1xuXG4gICAgICAgICAgaWYgKGNvbW1lbnRFbmQgPj0gMCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkS2VlcENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5jb21tZW50KGh0bWwuc3Vic3RyaW5nKDQsIGNvbW1lbnRFbmQpLCBpbmRleCwgaW5kZXggKyBjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XG4gICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgIHZhciBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcbiAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHRhZzpcbiAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFydFRhZ01hdGNoLnRhZ05hbWUsIGh0bWwpKSB7XG4gICAgICAgICAgICBhZHZhbmNlKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZXh0ID0gKHZvaWQgMCksIHJlc3QgPSAodm9pZCAwKSwgbmV4dCA9ICh2b2lkIDApO1xuICAgICAgaWYgKHRleHRFbmQgPj0gMCkge1xuICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICFlbmRUYWcudGVzdChyZXN0KSAmJlxuICAgICAgICAgICFzdGFydFRhZ09wZW4udGVzdChyZXN0KSAmJlxuICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29uZGl0aW9uYWxDb21tZW50LnRlc3QocmVzdClcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICBuZXh0ID0gcmVzdC5pbmRleE9mKCc8JywgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPCAwKSB7IGJyZWFrIH1cbiAgICAgICAgICB0ZXh0RW5kICs9IG5leHQ7XG4gICAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dEVuZCA8IDApIHtcbiAgICAgICAgdGV4dCA9IGh0bWw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIGFkdmFuY2UodGV4dC5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jaGFycyAmJiB0ZXh0KSB7XG4gICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCwgaW5kZXggLSB0ZXh0Lmxlbmd0aCwgaW5kZXgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZW5kVGFnTGVuZ3RoID0gMDtcbiAgICAgIHZhciBzdGFja2VkVGFnID0gbGFzdFRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8pKDwvJyArIHN0YWNrZWRUYWcgKyAnW14+XSo+KScsICdpJykpO1xuICAgICAgdmFyIHJlc3QkMSA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xuICAgICAgICBlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xuICAgICAgICBpZiAoIWlzUGxhaW5UZXh0RWxlbWVudChzdGFja2VkVGFnKSAmJiBzdGFja2VkVGFnICE9PSAnbm9zY3JpcHQnKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcLS0oW1xcc1xcU10qPyktLT4vZywgJyQxJykgLy8gIzcyOThcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhY2tlZFRhZywgdGV4dCkpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9KTtcbiAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdCQxLmxlbmd0aDtcbiAgICAgIGh0bWwgPSByZXN0JDE7XG4gICAgICBwYXJzZUVuZFRhZyhzdGFja2VkVGFnLCBpbmRleCAtIGVuZFRhZ0xlbmd0aCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGlmIChodG1sID09PSBsYXN0KSB7XG4gICAgICBvcHRpb25zLmNoYXJzICYmIG9wdGlvbnMuY2hhcnMoaHRtbCk7XG4gICAgICBpZiAoIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgb3B0aW9ucy53YXJuKChcIk1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXFxcIlwiICsgaHRtbCArIFwiXFxcIlwiKSwgeyBzdGFydDogaW5kZXggKyBodG1sLmxlbmd0aCB9KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gIHBhcnNlRW5kVGFnKCk7XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSAobikge1xuICAgIGluZGV4ICs9IG47XG4gICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcbiAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgIH07XG4gICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XG4gICAgICB2YXIgZW5kLCBhdHRyO1xuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGR5bmFtaWNBcmdBdHRyaWJ1dGUpIHx8IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYXR0ci5zdGFydCA9IGluZGV4O1xuICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgYXR0ci5lbmQgPSBpbmRleDtcbiAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgbWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcbiAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBtYXRjaFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgIHZhciB0YWdOYW1lID0gbWF0Y2gudGFnTmFtZTtcbiAgICB2YXIgdW5hcnlTbGFzaCA9IG1hdGNoLnVuYXJ5U2xhc2g7XG5cbiAgICBpZiAoZXhwZWN0SFRNTCkge1xuICAgICAgaWYgKGxhc3RUYWcgPT09ICdwJyAmJiBpc05vblBocmFzaW5nVGFnKHRhZ05hbWUpKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKGxhc3RUYWcpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbkJlTGVmdE9wZW5UYWckJDEodGFnTmFtZSkgJiYgbGFzdFRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICBwYXJzZUVuZFRhZyh0YWdOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8ICEhdW5hcnlTbGFzaDtcblxuICAgIHZhciBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgIHZhciBhdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xuICAgICAgdmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gdGFnTmFtZSA9PT0gJ2EnICYmIGFyZ3NbMV0gPT09ICdocmVmJ1xuICAgICAgICA/IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmXG4gICAgICAgIDogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcztcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cih2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpXG4gICAgICB9O1xuICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgYXR0cnNbaV0uc3RhcnQgPSBhcmdzLnN0YXJ0ICsgYXJnc1swXS5tYXRjaCgvXlxccyovKS5sZW5ndGg7XG4gICAgICAgIGF0dHJzW2ldLmVuZCA9IGFyZ3MuZW5kO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdW5hcnkpIHtcbiAgICAgIHN0YWNrLnB1c2goeyB0YWc6IHRhZ05hbWUsIGxvd2VyQ2FzZWRUYWc6IHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgYXR0cnM6IGF0dHJzLCBzdGFydDogbWF0Y2guc3RhcnQsIGVuZDogbWF0Y2guZW5kIH0pO1xuICAgICAgbGFzdFRhZyA9IHRhZ05hbWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgYXR0cnMsIHVuYXJ5LCBtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUVuZFRhZyAodGFnTmFtZSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBwb3MsIGxvd2VyQ2FzZWRUYWdOYW1lO1xuICAgIGlmIChzdGFydCA9PSBudWxsKSB7IHN0YXJ0ID0gaW5kZXg7IH1cbiAgICBpZiAoZW5kID09IG51bGwpIHsgZW5kID0gaW5kZXg7IH1cblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgZm9yIChwb3MgPSBzdGFjay5sZW5ndGggLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcbiAgICAgICAgaWYgKHN0YWNrW3Bvc10ubG93ZXJDYXNlZFRhZyA9PT0gbG93ZXJDYXNlZFRhZ05hbWUpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vIHRhZyBuYW1lIGlzIHByb3ZpZGVkLCBjbGVhbiBzaG9wXG4gICAgICBwb3MgPSAwO1xuICAgIH1cblxuICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcbiAgICAgIGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IHBvczsgaS0tKSB7XG4gICAgICAgIGlmIChpID4gcG9zIHx8ICF0YWdOYW1lICYmXG4gICAgICAgICAgb3B0aW9ucy53YXJuXG4gICAgICAgICkge1xuICAgICAgICAgIG9wdGlvbnMud2FybihcbiAgICAgICAgICAgIChcInRhZyA8XCIgKyAoc3RhY2tbaV0udGFnKSArIFwiPiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5cIiksXG4gICAgICAgICAgICB7IHN0YXJ0OiBzdGFja1tpXS5zdGFydCwgZW5kOiBzdGFja1tpXS5lbmQgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgb3B0aW9ucy5lbmQoc3RhY2tbaV0udGFnLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIG9wZW4gZWxlbWVudHMgZnJvbSB0aGUgc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCA9IHBvcztcbiAgICAgIGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdicicpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIHRydWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdwJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgZmFsc2UsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgIG9wdGlvbnMuZW5kKHRhZ05hbWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG9uUkUgPSAvXkB8XnYtb246LztcbnZhciBkaXJSRSA9IC9edi18XkB8XjovO1xudmFyIGZvckFsaWFzUkUgPSAvKFtcXHNcXFNdKj8pXFxzKyg/OmlufG9mKVxccysoW1xcc1xcU10qKS87XG52YXIgZm9ySXRlcmF0b3JSRSA9IC8sKFteLFxcfVxcXV0qKSg/OiwoW14sXFx9XFxdXSopKT8kLztcbnZhciBzdHJpcFBhcmVuc1JFID0gL15cXCh8XFwpJC9nO1xudmFyIGR5bmFtaWNBcmdSRSA9IC9eXFxbLipcXF0kLztcblxudmFyIGFyZ1JFID0gLzooLiopJC87XG52YXIgYmluZFJFID0gL146fF5cXC58XnYtYmluZDovO1xudmFyIG1vZGlmaWVyUkUgPSAvXFwuW14uXFxdXSsoPz1bXlxcXV0qJCkvZztcblxudmFyIHNsb3RSRSA9IC9edi1zbG90KDp8JCl8XiMvO1xuXG52YXIgbGluZUJyZWFrUkUgPSAvW1xcclxcbl0vO1xudmFyIHdoaXRlc3BhY2VSRSQxID0gL1xccysvZztcblxudmFyIGludmFsaWRBdHRyaWJ1dGVSRSA9IC9bXFxzXCInPD5cXC89XS87XG5cbnZhciBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGhlLmRlY29kZSk7XG5cbnZhciBlbXB0eVNsb3RTY29wZVRva2VuID0gXCJfZW1wdHlfXCI7XG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxudmFyIHdhcm4kMjtcbnZhciBkZWxpbWl0ZXJzO1xudmFyIHRyYW5zZm9ybXM7XG52YXIgcHJlVHJhbnNmb3JtcztcbnZhciBwb3N0VHJhbnNmb3JtcztcbnZhciBwbGF0Zm9ybUlzUHJlVGFnO1xudmFyIHBsYXRmb3JtTXVzdFVzZVByb3A7XG52YXIgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2U7XG52YXIgbWF5YmVDb21wb25lbnQ7XG5cbmZ1bmN0aW9uIGNyZWF0ZUFTVEVsZW1lbnQgKFxuICB0YWcsXG4gIGF0dHJzLFxuICBwYXJlbnRcbikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDEsXG4gICAgdGFnOiB0YWcsXG4gICAgYXR0cnNMaXN0OiBhdHRycyxcbiAgICBhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcbiAgICByYXdBdHRyc01hcDoge30sXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgY2hpbGRyZW46IFtdXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHdhcm4kMiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcblxuICBwbGF0Zm9ybUlzUHJlVGFnID0gb3B0aW9ucy5pc1ByZVRhZyB8fCBubztcbiAgcGxhdGZvcm1NdXN0VXNlUHJvcCA9IG9wdGlvbnMubXVzdFVzZVByb3AgfHwgbm87XG4gIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG4gIHZhciBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICBtYXliZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gISFlbC5jb21wb25lbnQgfHwgIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTsgfTtcblxuICB0cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Ob2RlJyk7XG4gIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcbiAgcG9zdFRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3Bvc3RUcmFuc2Zvcm1Ob2RlJyk7XG5cbiAgZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycztcblxuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgdmFyIHdoaXRlc3BhY2VPcHRpb24gPSBvcHRpb25zLndoaXRlc3BhY2U7XG4gIHZhciByb290O1xuICB2YXIgY3VycmVudFBhcmVudDtcbiAgdmFyIGluVlByZSA9IGZhbHNlO1xuICB2YXIgaW5QcmUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHdhcm5PbmNlIChtc2csIHJhbmdlKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB3YXJuJDIobXNnLCByYW5nZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VFbGVtZW50IChlbGVtZW50KSB7XG4gICAgdHJpbUVuZGluZ1doaXRlc3BhY2UoZWxlbWVudCk7XG4gICAgaWYgKCFpblZQcmUgJiYgIWVsZW1lbnQucHJvY2Vzc2VkKSB7XG4gICAgICBlbGVtZW50ID0gcHJvY2Vzc0VsZW1lbnQoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIHRyZWUgbWFuYWdlbWVudFxuICAgIGlmICghc3RhY2subGVuZ3RoICYmIGVsZW1lbnQgIT09IHJvb3QpIHtcbiAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxuICAgICAgaWYgKHJvb3QuaWYgJiYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkpIHtcbiAgICAgICAge1xuICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcbiAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxuICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgXCJDb21wb25lbnQgdGVtcGxhdGUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50LiBcIiArXG4gICAgICAgICAgXCJJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIFwiICtcbiAgICAgICAgICBcInVzZSB2LWVsc2UtaWYgdG8gY2hhaW4gdGhlbSBpbnN0ZWFkLlwiLFxuICAgICAgICAgIHsgc3RhcnQ6IGVsZW1lbnQuc3RhcnQgfVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcbiAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcbiAgICAgICAgcHJvY2Vzc0lmQ29uZGl0aW9ucyhlbGVtZW50LCBjdXJyZW50UGFyZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbGVtZW50LnNsb3RTY29wZSkge1xuICAgICAgICAgIC8vIHNjb3BlZCBzbG90XG4gICAgICAgICAgLy8ga2VlcCBpdCBpbiB0aGUgY2hpbGRyZW4gbGlzdCBzbyB0aGF0IHYtZWxzZSgtaWYpIGNvbmRpdGlvbnMgY2FuXG4gICAgICAgICAgLy8gZmluZCBpdCBhcyB0aGUgcHJldiBub2RlLlxuICAgICAgICAgIHZhciBuYW1lID0gZWxlbWVudC5zbG90VGFyZ2V0IHx8ICdcImRlZmF1bHRcIidcbiAgICAgICAgICA7KGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgfHwgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgPSB7fSkpW25hbWVdID0gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goZWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnQucGFyZW50ID0gY3VycmVudFBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmaW5hbCBjaGlsZHJlbiBjbGVhbnVwXG4gICAgLy8gZmlsdGVyIG91dCBzY29wZWQgc2xvdHNcbiAgICBlbGVtZW50LmNoaWxkcmVuID0gZWxlbWVudC5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuICEoYykuc2xvdFNjb3BlOyB9KTtcbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBub2RlIGFnYWluXG4gICAgdHJpbUVuZGluZ1doaXRlc3BhY2UoZWxlbWVudCk7XG5cbiAgICAvLyBjaGVjayBwcmUgc3RhdGVcbiAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgIGluVlByZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgIGluUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zdFRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBvc3RUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaW1FbmRpbmdXaGl0ZXNwYWNlIChlbCkge1xuICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG5vZGVcbiAgICBpZiAoIWluUHJlKSB7XG4gICAgICB2YXIgbGFzdE5vZGU7XG4gICAgICB3aGlsZSAoXG4gICAgICAgIChsYXN0Tm9kZSA9IGVsLmNoaWxkcmVuW2VsLmNoaWxkcmVuLmxlbmd0aCAtIDFdKSAmJlxuICAgICAgICBsYXN0Tm9kZS50eXBlID09PSAzICYmXG4gICAgICAgIGxhc3ROb2RlLnRleHQgPT09ICcgJ1xuICAgICAgKSB7XG4gICAgICAgIGVsLmNoaWxkcmVuLnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzIChlbCkge1xuICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHdhcm5PbmNlKFxuICAgICAgICBcIkNhbm5vdCB1c2UgPFwiICsgKGVsLnRhZykgKyBcIj4gYXMgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBcIiArXG4gICAgICAgICdjb250YWluIG11bHRpcGxlIG5vZGVzLicsXG4gICAgICAgIHsgc3RhcnQ6IGVsLnN0YXJ0IH1cbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChlbC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1mb3InKSkge1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgICdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcbiAgICAgICAgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJyxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcGFyc2VIVE1MKHRlbXBsYXRlLCB7XG4gICAgd2Fybjogd2FybiQyLFxuICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcbiAgICBpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXG4gICAgY2FuQmVMZWZ0T3BlblRhZzogb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgc2hvdWxkS2VlcENvbW1lbnQ6IG9wdGlvbnMuY29tbWVudHMsXG4gICAgb3V0cHV0U291cmNlUmFuZ2U6IG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UsXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0ICh0YWcsIGF0dHJzLCB1bmFyeSwgc3RhcnQkMSwgZW5kKSB7XG4gICAgICAvLyBjaGVjayBuYW1lc3BhY2UuXG4gICAgICAvLyBpbmhlcml0IHBhcmVudCBucyBpZiB0aGVyZSBpcyBvbmVcbiAgICAgIHZhciBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cbiAgICAgIC8vIGhhbmRsZSBJRSBzdmcgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xuICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUFTVEVsZW1lbnQodGFnLCBhdHRycywgY3VycmVudFBhcmVudCk7XG4gICAgICBpZiAobnMpIHtcbiAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgZWxlbWVudC5zdGFydCA9IHN0YXJ0JDE7XG4gICAgICAgICAgZWxlbWVudC5lbmQgPSBlbmQ7XG4gICAgICAgICAgZWxlbWVudC5yYXdBdHRyc01hcCA9IGVsZW1lbnQuYXR0cnNMaXN0LnJlZHVjZShmdW5jdGlvbiAoY3VtdWxhdGVkLCBhdHRyKSB7XG4gICAgICAgICAgICBjdW11bGF0ZWRbYXR0ci5uYW1lXSA9IGF0dHI7XG4gICAgICAgICAgICByZXR1cm4gY3VtdWxhdGVkXG4gICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICBpZiAoaW52YWxpZEF0dHJpYnV0ZVJFLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIkludmFsaWQgZHluYW1pYyBhcmd1bWVudCBleHByZXNzaW9uOiBhdHRyaWJ1dGUgbmFtZXMgY2Fubm90IGNvbnRhaW4gXCIgK1xuICAgICAgICAgICAgICBcInNwYWNlcywgcXVvdGVzLCA8LCA+LCAvIG9yID0uXCIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdGFydDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5pbmRleE9mKFwiW1wiKSxcbiAgICAgICAgICAgICAgICBlbmQ6IGF0dHIuc3RhcnQgKyBhdHRyLm5hbWUubGVuZ3RoXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRm9yYmlkZGVuVGFnKGVsZW1lbnQpICYmICFpc1NlcnZlclJlbmRlcmluZygpKSB7XG4gICAgICAgIGVsZW1lbnQuZm9yYmlkZGVuID0gdHJ1ZTtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgICdUZW1wbGF0ZXMgc2hvdWxkIG9ubHkgYmUgcmVzcG9uc2libGUgZm9yIG1hcHBpbmcgdGhlIHN0YXRlIHRvIHRoZSAnICtcbiAgICAgICAgICAnVUkuIEF2b2lkIHBsYWNpbmcgdGFncyB3aXRoIHNpZGUtZWZmZWN0cyBpbiB5b3VyIHRlbXBsYXRlcywgc3VjaCBhcyAnICtcbiAgICAgICAgICBcIjxcIiArIHRhZyArIFwiPlwiICsgJywgYXMgdGhleSB3aWxsIG5vdCBiZSBwYXJzZWQuJyxcbiAgICAgICAgICB7IHN0YXJ0OiBlbGVtZW50LnN0YXJ0IH1cbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGVtZW50ID0gcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICBwcm9jZXNzUHJlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgICBpblZQcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICBwcm9jZXNzUmF3QXR0cnMoZWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKCFlbGVtZW50LnByb2Nlc3NlZCkge1xuICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXNcbiAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0lmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzT25jZShlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJvb3QgPSBlbGVtZW50O1xuICAgICAgICB7XG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMocm9vdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF1bmFyeSkge1xuICAgICAgICBjdXJyZW50UGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZW5kOiBmdW5jdGlvbiBlbmQgKHRhZywgc3RhcnQsIGVuZCQxKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgLy8gcG9wIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgIGVsZW1lbnQuZW5kID0gZW5kJDE7XG4gICAgICB9XG4gICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgfSxcblxuICAgIGNoYXJzOiBmdW5jdGlvbiBjaGFycyAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodGV4dCA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJyxcbiAgICAgICAgICAgICAgeyBzdGFydDogc3RhcnQgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCh0ZXh0ID0gdGV4dC50cmltKCkpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgKFwidGV4dCBcXFwiXCIgKyB0ZXh0ICsgXCJcXFwiIG91dHNpZGUgcm9vdCBlbGVtZW50IHdpbGwgYmUgaWdub3JlZC5cIiksXG4gICAgICAgICAgICAgIHsgc3RhcnQ6IHN0YXJ0IH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHRcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XG4gICAgICBpZiAoaW5QcmUgfHwgdGV4dC50cmltKCkpIHtcbiAgICAgICAgdGV4dCA9IGlzVGV4dFRhZyhjdXJyZW50UGFyZW50KSA/IHRleHQgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpO1xuICAgICAgfSBlbHNlIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgd2hpdGVzcGFjZS1vbmx5IG5vZGUgcmlnaHQgYWZ0ZXIgYW4gb3BlbmluZyB0YWdcbiAgICAgICAgdGV4dCA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh3aGl0ZXNwYWNlT3B0aW9uKSB7XG4gICAgICAgIGlmICh3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgLy8gaW4gY29uZGVuc2UgbW9kZSwgcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlIG5vZGUgaWYgaXQgY29udGFpbnNcbiAgICAgICAgICAvLyBsaW5lIGJyZWFrLCBvdGhlcndpc2UgY29uZGVuc2UgdG8gYSBzaW5nbGUgc3BhY2VcbiAgICAgICAgICB0ZXh0ID0gbGluZUJyZWFrUkUudGVzdCh0ZXh0KSA/ICcnIDogJyAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHQgPSAnICc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQgPSBwcmVzZXJ2ZVdoaXRlc3BhY2UgPyAnICcgOiAnJztcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIGlmICghaW5QcmUgJiYgd2hpdGVzcGFjZU9wdGlvbiA9PT0gJ2NvbmRlbnNlJykge1xuICAgICAgICAgIC8vIGNvbmRlbnNlIGNvbnNlY3V0aXZlIHdoaXRlc3BhY2VzIGludG8gc2luZ2xlIHNwYWNlXG4gICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSh3aGl0ZXNwYWNlUkUkMSwgJyAnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzO1xuICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgIGlmICghaW5WUHJlICYmIHRleHQgIT09ICcgJyAmJiAocmVzID0gcGFyc2VUZXh0KHRleHQsIGRlbGltaXRlcnMpKSkge1xuICAgICAgICAgIGNoaWxkID0ge1xuICAgICAgICAgICAgdHlwZTogMixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHJlcy5leHByZXNzaW9uLFxuICAgICAgICAgICAgdG9rZW5zOiByZXMudG9rZW5zLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodGV4dCAhPT0gJyAnIHx8ICFjaGlsZHJlbi5sZW5ndGggfHwgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgICAgY2hpbGQgPSB7XG4gICAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAgIGNoaWxkLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBjaGlsZC5lbmQgPSBlbmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21tZW50OiBmdW5jdGlvbiBjb21tZW50ICh0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICAvLyBhZGRpbmcgYW55dGluZyBhcyBhIHNpYmxpbmcgdG8gdGhlIHJvb3Qgbm9kZSBpcyBmb3JiaWRkZW5cbiAgICAgIC8vIGNvbW1lbnRzIHNob3VsZCBzdGlsbCBiZSBhbGxvd2VkLCBidXQgaWdub3JlZFxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgdmFyIGNoaWxkID0ge1xuICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBpc0NvbW1lbnQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgIGNoaWxkLmVuZCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb290XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XG4gICAgZWwucHJlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIGlmIChsZW4pIHtcbiAgICB2YXIgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBsaXN0W2ldLm5hbWUsXG4gICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShsaXN0W2ldLnZhbHVlKVxuICAgICAgfTtcbiAgICAgIGlmIChsaXN0W2ldLnN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgYXR0cnNbaV0uc3RhcnQgPSBsaXN0W2ldLnN0YXJ0O1xuICAgICAgICBhdHRyc1tpXS5lbmQgPSBsaXN0W2ldLmVuZDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoIWVsLnByZSkge1xuICAgIC8vIG5vbiByb290IG5vZGUgaW4gcHJlIGJsb2NrcyB3aXRoIG5vIGF0dHJpYnV0ZXNcbiAgICBlbC5wbGFpbiA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0VsZW1lbnQgKFxuICBlbGVtZW50LFxuICBvcHRpb25zXG4pIHtcbiAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuICAvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcbiAgZWxlbWVudC5wbGFpbiA9IChcbiAgICAhZWxlbWVudC5rZXkgJiZcbiAgICAhZWxlbWVudC5zY29wZWRTbG90cyAmJlxuICAgICFlbGVtZW50LmF0dHJzTGlzdC5sZW5ndGhcbiAgKTtcblxuICBwcm9jZXNzUmVmKGVsZW1lbnQpO1xuICBwcm9jZXNzU2xvdENvbnRlbnQoZWxlbWVudCk7XG4gIHByb2Nlc3NTbG90T3V0bGV0KGVsZW1lbnQpO1xuICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICBlbGVtZW50ID0gdHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICB9XG4gIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnRcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG4gIGlmIChleHApIHtcbiAgICB7XG4gICAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcIjx0ZW1wbGF0ZT4gY2Fubm90IGJlIGtleWVkLiBQbGFjZSB0aGUga2V5IG9uIHJlYWwgZWxlbWVudHMgaW5zdGVhZC5cIixcbiAgICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZWwuZm9yKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGVsLml0ZXJhdG9yMiB8fCBlbC5pdGVyYXRvcjE7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgICAgIGlmIChpdGVyYXRvciAmJiBpdGVyYXRvciA9PT0gZXhwICYmIHBhcmVudCAmJiBwYXJlbnQudGFnID09PSAndHJhbnNpdGlvbi1ncm91cCcpIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBcIkRvIG5vdCB1c2Ugdi1mb3IgaW5kZXggYXMga2V5IG9uIDx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiwgXCIgK1xuICAgICAgICAgICAgXCJ0aGlzIGlzIHRoZSBzYW1lIGFzIG5vdCB1c2luZyBrZXlzLlwiLFxuICAgICAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKSxcbiAgICAgICAgICAgIHRydWUgLyogdGlwICovXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbC5rZXkgPSBleHA7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1JlZiAoZWwpIHtcbiAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gIGlmIChyZWYpIHtcbiAgICBlbC5yZWYgPSByZWY7XG4gICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICB2YXIgZXhwO1xuICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xuICAgIHZhciByZXMgPSBwYXJzZUZvcihleHApO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIGV4dGVuZChlbCwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybiQyKFxuICAgICAgICAoXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiICsgZXhwKSxcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cblxuXG5mdW5jdGlvbiBwYXJzZUZvciAoZXhwKSB7XG4gIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICBpZiAoIWluTWF0Y2gpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICByZXMuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gIHZhciBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpLnJlcGxhY2Uoc3RyaXBQYXJlbnNSRSwgJycpO1xuICB2YXIgaXRlcmF0b3JNYXRjaCA9IGFsaWFzLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xuICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgIHJlcy5hbGlhcyA9IGFsaWFzLnJlcGxhY2UoZm9ySXRlcmF0b3JSRSwgJycpLnRyaW0oKTtcbiAgICByZXMuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcbiAgICAgIHJlcy5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXM7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICBpZiAoZXhwKSB7XG4gICAgZWwuaWYgPSBleHA7XG4gICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgIGV4cDogZXhwLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcbiAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgaWYgKHByZXYgJiYgcHJldi5pZikge1xuICAgIGFkZElmQ29uZGl0aW9uKHByZXYsIHtcbiAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgd2FybiQyKFxuICAgICAgXCJ2LVwiICsgKGVsLmVsc2VpZiA/ICgnZWxzZS1pZj1cIicgKyBlbC5lbHNlaWYgKyAnXCInKSA6ICdlbHNlJykgKyBcIiBcIiArXG4gICAgICBcInVzZWQgb24gZWxlbWVudCA8XCIgKyAoZWwudGFnKSArIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIixcbiAgICAgIGVsLnJhd0F0dHJzTWFwW2VsLmVsc2VpZiA/ICd2LWVsc2UtaWYnIDogJ3YtZWxzZSddXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUHJldkVsZW1lbnQgKGNoaWxkcmVuKSB7XG4gIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IDEpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2hpbGRyZW5baV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInRleHQgXFxcIlwiICsgKGNoaWxkcmVuW2ldLnRleHQudHJpbSgpKSArIFwiXFxcIiBiZXR3ZWVuIHYtaWYgYW5kIHYtZWxzZSgtaWYpIFwiICtcbiAgICAgICAgICBcIndpbGwgYmUgaWdub3JlZC5cIixcbiAgICAgICAgICBjaGlsZHJlbltpXVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4ucG9wKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZElmQ29uZGl0aW9uIChlbCwgY29uZGl0aW9uKSB7XG4gIGlmICghZWwuaWZDb25kaXRpb25zKSB7XG4gICAgZWwuaWZDb25kaXRpb25zID0gW107XG4gIH1cbiAgZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc09uY2UgKGVsKSB7XG4gIHZhciBvbmNlJCQxID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Ytb25jZScpO1xuICBpZiAob25jZSQkMSAhPSBudWxsKSB7XG4gICAgZWwub25jZSA9IHRydWU7XG4gIH1cbn1cblxuLy8gaGFuZGxlIGNvbnRlbnQgYmVpbmcgcGFzc2VkIHRvIGEgY29tcG9uZW50IGFzIHNsb3QsXG4vLyBlLmcuIDx0ZW1wbGF0ZSBzbG90PVwieHh4XCI+LCA8ZGl2IHNsb3Qtc2NvcGU9XCJ4eHhcIj5cbmZ1bmN0aW9uIHByb2Nlc3NTbG90Q29udGVudCAoZWwpIHtcbiAgdmFyIHNsb3RTY29wZTtcbiAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgIHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzY29wZScpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChzbG90U2NvcGUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCJ0aGUgXFxcInNjb3BlXFxcIiBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBzbG90cyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBhbmQgXCIgK1xuICAgICAgICBcInJlcGxhY2VkIGJ5IFxcXCJzbG90LXNjb3BlXFxcIiBzaW5jZSAyLjUuIFRoZSBuZXcgXFxcInNsb3Qtc2NvcGVcXFwiIGF0dHJpYnV0ZSBcIiArXG4gICAgICAgIFwiY2FuIGFsc28gYmUgdXNlZCBvbiBwbGFpbiBlbGVtZW50cyBpbiBhZGRpdGlvbiB0byA8dGVtcGxhdGU+IHRvIFwiICtcbiAgICAgICAgXCJkZW5vdGUgc2NvcGVkIHNsb3RzLlwiLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsnc2NvcGUnXSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlIHx8IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJyk7XG4gIH0gZWxzZSBpZiAoKHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJykpKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGVsLmF0dHJzTWFwWyd2LWZvciddKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiQW1iaWd1b3VzIGNvbWJpbmVkIHVzYWdlIG9mIHNsb3Qtc2NvcGUgYW5kIHYtZm9yIG9uIDxcIiArIChlbC50YWcpICsgXCI+IFwiICtcbiAgICAgICAgXCIodi1mb3IgdGFrZXMgaGlnaGVyIHByaW9yaXR5KS4gVXNlIGEgd3JhcHBlciA8dGVtcGxhdGU+IGZvciB0aGUgXCIgK1xuICAgICAgICBcInNjb3BlZCBzbG90IHRvIG1ha2UgaXQgY2xlYXJlci5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXSxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcbiAgICB9XG4gICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlO1xuICB9XG5cbiAgLy8gc2xvdD1cInh4eFwiXG4gIHZhciBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gIGlmIChzbG90VGFyZ2V0KSB7XG4gICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgIGVsLnNsb3RUYXJnZXREeW5hbWljID0gISEoZWwuYXR0cnNNYXBbJzpzbG90J10gfHwgZWwuYXR0cnNNYXBbJ3YtYmluZDpzbG90J10pO1xuICAgIC8vIHByZXNlcnZlIHNsb3QgYXMgYW4gYXR0cmlidXRlIGZvciBuYXRpdmUgc2hhZG93IERPTSBjb21wYXRcbiAgICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzLlxuICAgIGlmIChlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgICAgYWRkQXR0cihlbCwgJ3Nsb3QnLCBzbG90VGFyZ2V0LCBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gMi42IHYtc2xvdCBzeW50YXhcbiAge1xuICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIC8vIHYtc2xvdCBvbiA8dGVtcGxhdGU+XG4gICAgICB2YXIgc2xvdEJpbmRpbmcgPSBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleChlbCwgc2xvdFJFKTtcbiAgICAgIGlmIChzbG90QmluZGluZykge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKGVsLnNsb3RUYXJnZXQgfHwgZWwuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBtaXhlZCB1c2FnZSBvZiBkaWZmZXJlbnQgc2xvdCBzeW50YXhlcy5cIixcbiAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5wYXJlbnQgJiYgIW1heWJlQ29tcG9uZW50KGVsLnBhcmVudCkpIHtcbiAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgXCI8dGVtcGxhdGUgdi1zbG90PiBjYW4gb25seSBhcHBlYXIgYXQgdGhlIHJvb3QgbGV2ZWwgaW5zaWRlIFwiICtcbiAgICAgICAgICAgICAgXCJ0aGUgcmVjZWl2aW5nIHRoZSBjb21wb25lbnRcIixcbiAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciByZWYgPSBnZXRTbG90TmFtZShzbG90QmluZGluZyk7XG4gICAgICAgIHZhciBuYW1lID0gcmVmLm5hbWU7XG4gICAgICAgIHZhciBkeW5hbWljID0gcmVmLmR5bmFtaWM7XG4gICAgICAgIGVsLnNsb3RUYXJnZXQgPSBuYW1lO1xuICAgICAgICBlbC5zbG90VGFyZ2V0RHluYW1pYyA9IGR5bmFtaWM7XG4gICAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nLnZhbHVlIHx8IGVtcHR5U2xvdFNjb3BlVG9rZW47IC8vIGZvcmNlIGl0IGludG8gYSBzY29wZWQgc2xvdCBmb3IgcGVyZlxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB2LXNsb3Qgb24gY29tcG9uZW50LCBkZW5vdGVzIGRlZmF1bHQgc2xvdFxuICAgICAgdmFyIHNsb3RCaW5kaW5nJDEgPSBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleChlbCwgc2xvdFJFKTtcbiAgICAgIGlmIChzbG90QmluZGluZyQxKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIW1heWJlQ29tcG9uZW50KGVsKSkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcInYtc2xvdCBjYW4gb25seSBiZSB1c2VkIG9uIGNvbXBvbmVudHMgb3IgPHRlbXBsYXRlPi5cIixcbiAgICAgICAgICAgICAgc2xvdEJpbmRpbmckMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLnNsb3RTY29wZSB8fCBlbC5zbG90VGFyZ2V0KSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBtaXhlZCB1c2FnZSBvZiBkaWZmZXJlbnQgc2xvdCBzeW50YXhlcy5cIixcbiAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIlRvIGF2b2lkIHNjb3BlIGFtYmlndWl0eSwgdGhlIGRlZmF1bHQgc2xvdCBzaG91bGQgYWxzbyB1c2UgXCIgK1xuICAgICAgICAgICAgICBcIjx0ZW1wbGF0ZT4gc3ludGF4IHdoZW4gdGhlcmUgYXJlIG90aGVyIG5hbWVkIHNsb3RzLlwiLFxuICAgICAgICAgICAgICBzbG90QmluZGluZyQxXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgdGhlIGNvbXBvbmVudCdzIGNoaWxkcmVuIHRvIGl0cyBkZWZhdWx0IHNsb3RcbiAgICAgICAgdmFyIHNsb3RzID0gZWwuc2NvcGVkU2xvdHMgfHwgKGVsLnNjb3BlZFNsb3RzID0ge30pO1xuICAgICAgICB2YXIgcmVmJDEgPSBnZXRTbG90TmFtZShzbG90QmluZGluZyQxKTtcbiAgICAgICAgdmFyIG5hbWUkMSA9IHJlZiQxLm5hbWU7XG4gICAgICAgIHZhciBkeW5hbWljJDEgPSByZWYkMS5keW5hbWljO1xuICAgICAgICB2YXIgc2xvdENvbnRhaW5lciA9IHNsb3RzW25hbWUkMV0gPSBjcmVhdGVBU1RFbGVtZW50KCd0ZW1wbGF0ZScsIFtdLCBlbCk7XG4gICAgICAgIHNsb3RDb250YWluZXIuc2xvdFRhcmdldCA9IG5hbWUkMTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90VGFyZ2V0RHluYW1pYyA9IGR5bmFtaWMkMTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5jaGlsZHJlbiA9IGVsLmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICAgIGlmICghYy5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgIGMucGFyZW50ID0gc2xvdENvbnRhaW5lcjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2xvdENvbnRhaW5lci5zbG90U2NvcGUgPSBzbG90QmluZGluZyQxLnZhbHVlIHx8IGVtcHR5U2xvdFNjb3BlVG9rZW47XG4gICAgICAgIC8vIHJlbW92ZSBjaGlsZHJlbiBhcyB0aGV5IGFyZSByZXR1cm5lZCBmcm9tIHNjb3BlZFNsb3RzIG5vd1xuICAgICAgICBlbC5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAvLyBtYXJrIGVsIG5vbi1wbGFpbiBzbyBkYXRhIGdldHMgZ2VuZXJhdGVkXG4gICAgICAgIGVsLnBsYWluID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNsb3ROYW1lIChiaW5kaW5nKSB7XG4gIHZhciBuYW1lID0gYmluZGluZy5uYW1lLnJlcGxhY2Uoc2xvdFJFLCAnJyk7XG4gIGlmICghbmFtZSkge1xuICAgIGlmIChiaW5kaW5nLm5hbWVbMF0gIT09ICcjJykge1xuICAgICAgbmFtZSA9ICdkZWZhdWx0JztcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcInYtc2xvdCBzaG9ydGhhbmQgc3ludGF4IHJlcXVpcmVzIGEgc2xvdCBuYW1lLlwiLFxuICAgICAgICBiaW5kaW5nXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSlcbiAgICAvLyBkeW5hbWljIFtuYW1lXVxuICAgID8geyBuYW1lOiBuYW1lLnNsaWNlKDEsIC0xKSwgZHluYW1pYzogdHJ1ZSB9XG4gICAgLy8gc3RhdGljIG5hbWVcbiAgICA6IHsgbmFtZTogKFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiKSwgZHluYW1pYzogZmFsc2UgfVxufVxuXG4vLyBoYW5kbGUgPHNsb3QvPiBvdXRsZXRzXG5mdW5jdGlvbiBwcm9jZXNzU2xvdE91dGxldCAoZWwpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcbiAgICBpZiAoZWwua2V5KSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiYGtleWAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBcIiArXG4gICAgICAgIFwiYW5kIGNhbiBwb3NzaWJseSBleHBhbmQgaW50byBtdWx0aXBsZSBlbGVtZW50cy4gXCIgK1xuICAgICAgICBcIlVzZSB0aGUga2V5IG9uIGEgd3JhcHBpbmcgZWxlbWVudCBpbnN0ZWFkLlwiLFxuICAgICAgICBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50IChlbCkge1xuICB2YXIgYmluZGluZztcbiAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgIGVsLmNvbXBvbmVudCA9IGJpbmRpbmc7XG4gIH1cbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NBdHRycyAoZWwpIHtcbiAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gIHZhciBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBzeW5jR2VuLCBpc0R5bmFtaWM7XG4gIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xuICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgLy8gbWFyayBlbGVtZW50IGFzIGR5bmFtaWNcbiAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgIC8vIG1vZGlmaWVyc1xuICAgICAgbW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZS5yZXBsYWNlKGRpclJFLCAnJykpO1xuICAgICAgLy8gc3VwcG9ydCAuZm9vIHNob3J0aGFuZCBzeW50YXggZm9yIHRoZSAucHJvcCBtb2RpZmllclxuICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcbiAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgdmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAoXCJUaGUgdmFsdWUgZm9yIGEgdi1iaW5kIGV4cHJlc3Npb24gY2Fubm90IGJlIGVtcHR5LiBGb3VuZCBpbiBcXFwidi1iaW5kOlwiICsgbmFtZSArIFwiXFxcIlwiKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCAmJiAhaXNEeW5hbWljKSB7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwgJiYgIWlzRHluYW1pYykge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnN5bmMpIHtcbiAgICAgICAgICAgIHN5bmNHZW4gPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgXCIkZXZlbnRcIik7XG4gICAgICAgICAgICBpZiAoIWlzRHluYW1pYykge1xuICAgICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChjYW1lbGl6ZShuYW1lKSkpLFxuICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoaHlwaGVuYXRlKG5hbWUpICE9PSBjYW1lbGl6ZShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAgIChcInVwZGF0ZTpcIiArIChoeXBoZW5hdGUobmFtZSkpKSxcbiAgICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaGFuZGxlciB3LyBkeW5hbWljIGV2ZW50IG5hbWVcbiAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgICAoXCJcXFwidXBkYXRlOlxcXCIrKFwiICsgbmFtZSArIFwiKVwiKSxcbiAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgIGxpc3RbaV0sXG4gICAgICAgICAgICAgICAgdHJ1ZSAvLyBkeW5hbWljXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgobW9kaWZpZXJzICYmIG1vZGlmaWVycy5wcm9wKSB8fCAoXG4gICAgICAgICAgIWVsLmNvbXBvbmVudCAmJiBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSlcbiAgICAgICAgKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcbiAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiQyLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgIHZhciBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcbiAgICAgICAgaXNEeW5hbWljID0gZmFsc2U7XG4gICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XG4gICAgICAgICAgaWYgKGR5bmFtaWNBcmdSRS50ZXN0KGFyZykpIHtcbiAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICBpc0R5bmFtaWMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIGlzRHluYW1pYywgbW9kaWZpZXJzLCBsaXN0W2ldKTtcbiAgICAgICAgaWYgKG5hbWUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsaXRlcmFsIGF0dHJpYnV0ZVxuICAgICAge1xuICAgICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nLFxuICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSwgbGlzdFtpXSk7XG4gICAgICAvLyAjNjg4NyBmaXJlZm94IGRvZXNuJ3QgdXBkYXRlIG11dGVkIHN0YXRlIGlmIHNldCB2aWEgYXR0cmlidXRlXG4gICAgICAvLyBldmVuIGltbWVkaWF0ZWx5IGFmdGVyIGVsZW1lbnQgY3JlYXRpb25cbiAgICAgIGlmICghZWwuY29tcG9uZW50ICYmXG4gICAgICAgICAgbmFtZSA9PT0gJ211dGVkJyAmJlxuICAgICAgICAgIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xuICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCAndHJ1ZScsIGxpc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0luRm9yIChlbCkge1xuICB2YXIgcGFyZW50ID0gZWw7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgbWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXRbbS5zbGljZSgxKV0gPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUF0dHJzTWFwIChhdHRycykge1xuICB2YXIgbWFwID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKFxuICAgICAgbWFwW2F0dHJzW2ldLm5hbWVdICYmICFpc0lFICYmICFpc0VkZ2VcbiAgICApIHtcbiAgICAgIHdhcm4kMignZHVwbGljYXRlIGF0dHJpYnV0ZTogJyArIGF0dHJzW2ldLm5hbWUsIGF0dHJzW2ldKTtcbiAgICB9XG4gICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG4vLyBmb3Igc2NyaXB0IChlLmcuIHR5cGU9XCJ4L3RlbXBsYXRlXCIpIG9yIHN0eWxlLCBkbyBub3QgZGVjb2RlIGNvbnRlbnRcbmZ1bmN0aW9uIGlzVGV4dFRhZyAoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXG59XG5cbmZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnIChlbCkge1xuICByZXR1cm4gKFxuICAgIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxuICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmIChcbiAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xuICAgICkpXG4gIClcbn1cblxudmFyIGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XG52YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBndWFyZElFU1ZHQnVnIChhdHRycykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG4gIHZhciBfZWwgPSBlbDtcbiAgd2hpbGUgKF9lbCkge1xuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICAgIFwiWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIFwiICtcbiAgICAgICAgXCJUaGlzIHdpbGwgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSB2LWZvciBzb3VyY2UgYXJyYXkgYmVjYXVzZSBcIiArXG4gICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xuICAgICAgICBcIkNvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLlwiLFxuICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgICApO1xuICAgIH1cbiAgICBfZWwgPSBfZWwucGFyZW50O1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBwcmVUcmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICBpZiAoZWwudGFnID09PSAnaW5wdXQnKSB7XG4gICAgdmFyIG1hcCA9IGVsLmF0dHJzTWFwO1xuICAgIGlmICghbWFwWyd2LW1vZGVsJ10pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciB0eXBlQmluZGluZztcbiAgICBpZiAobWFwWyc6dHlwZSddIHx8IG1hcFsndi1iaW5kOnR5cGUnXSkge1xuICAgICAgdHlwZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3R5cGUnKTtcbiAgICB9XG4gICAgaWYgKCFtYXAudHlwZSAmJiAhdHlwZUJpbmRpbmcgJiYgbWFwWyd2LWJpbmQnXSkge1xuICAgICAgdHlwZUJpbmRpbmcgPSBcIihcIiArIChtYXBbJ3YtYmluZCddKSArIFwiKS50eXBlXCI7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVCaW5kaW5nKSB7XG4gICAgICB2YXIgaWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicsIHRydWUpO1xuICAgICAgdmFyIGlmQ29uZGl0aW9uRXh0cmEgPSBpZkNvbmRpdGlvbiA/IChcIiYmKFwiICsgaWZDb25kaXRpb24gKyBcIilcIikgOiBcIlwiO1xuICAgICAgdmFyIGhhc0Vsc2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJywgdHJ1ZSkgIT0gbnVsbDtcbiAgICAgIHZhciBlbHNlSWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJywgdHJ1ZSk7XG4gICAgICAvLyAxLiBjaGVja2JveFxuICAgICAgdmFyIGJyYW5jaDAgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgLy8gcHJvY2VzcyBmb3Igb24gdGhlIG1haW4gbm9kZVxuICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMCwgJ3R5cGUnLCAnY2hlY2tib3gnKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDAsIG9wdGlvbnMpO1xuICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxuICAgICAgYnJhbmNoMC5pZiA9IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0nY2hlY2tib3gnXCIgKyBpZkNvbmRpdGlvbkV4dHJhO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGJyYW5jaDAuaWYsXG4gICAgICAgIGJsb2NrOiBicmFuY2gwXG4gICAgICB9KTtcbiAgICAgIC8vIDIuIGFkZCByYWRpbyBlbHNlLWlmIGNvbmRpdGlvblxuICAgICAgdmFyIGJyYW5jaDEgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gxLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMSwgJ3R5cGUnLCAncmFkaW8nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDEsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0ncmFkaW8nXCIgKyBpZkNvbmRpdGlvbkV4dHJhLFxuICAgICAgICBibG9jazogYnJhbmNoMVxuICAgICAgfSk7XG4gICAgICAvLyAzLiBvdGhlclxuICAgICAgdmFyIGJyYW5jaDIgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gyLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMiwgJzp0eXBlJywgdHlwZUJpbmRpbmcpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMiwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogaWZDb25kaXRpb24sXG4gICAgICAgIGJsb2NrOiBicmFuY2gyXG4gICAgICB9KTtcblxuICAgICAgaWYgKGhhc0Vsc2UpIHtcbiAgICAgICAgYnJhbmNoMC5lbHNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZWxzZUlmQ29uZGl0aW9uKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZWlmID0gZWxzZUlmQ29uZGl0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnJhbmNoMFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFTVEVsZW1lbnQgKGVsKSB7XG4gIHJldHVybiBjcmVhdGVBU1RFbGVtZW50KGVsLnRhZywgZWwuYXR0cnNMaXN0LnNsaWNlKCksIGVsLnBhcmVudClcbn1cblxudmFyIG1vZGVsJDEgPSB7XG4gIHByZVRyYW5zZm9ybU5vZGU6IHByZVRyYW5zZm9ybU5vZGVcbn07XG5cbnZhciBtb2R1bGVzJDEgPSBbXG4gIGtsYXNzJDEsXG4gIHN0eWxlJDEsXG4gIG1vZGVsJDFcbl07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0ZXh0IChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAndGV4dENvbnRlbnQnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpLCBkaXIpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSwgZGlyKTtcbiAgfVxufVxuXG52YXIgZGlyZWN0aXZlcyQxID0ge1xuICBtb2RlbDogbW9kZWwsXG4gIHRleHQ6IHRleHQsXG4gIGh0bWw6IGh0bWxcbn07XG5cbi8qICAqL1xuXG52YXIgYmFzZU9wdGlvbnMgPSB7XG4gIGV4cGVjdEhUTUw6IHRydWUsXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyQxLFxuICBpc1ByZVRhZzogaXNQcmVUYWcsXG4gIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXG4gIG11c3RVc2VQcm9wOiBtdXN0VXNlUHJvcCxcbiAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcbiAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcbiAgZ2V0VGFnTmFtZXNwYWNlOiBnZXRUYWdOYW1lc3BhY2UsXG4gIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxufTtcblxuLyogICovXG5cbnZhciBpc1N0YXRpY0tleTtcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XG5cbnZhciBnZW5TdGF0aWNLZXlzQ2FjaGVkID0gY2FjaGVkKGdlblN0YXRpY0tleXMkMSk7XG5cbi8qKlxuICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gKlxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG4gKlxuICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XG4gIGlmICghcm9vdCkgeyByZXR1cm4gfVxuICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICBtYXJrU3RhdGljJDEocm9vdCk7XG4gIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cbiAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XG4gIHJldHVybiBtYWtlTWFwKFxuICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzLHN0YXJ0LGVuZCxyYXdBdHRyc01hcCcgK1xuICAgIChrZXlzID8gJywnICsga2V5cyA6ICcnKVxuICApXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXG4gICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xuICAgIC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcbiAgICBpZiAoXG4gICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgbm9kZS50YWcgIT09ICdzbG90JyAmJlxuICAgICAgbm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICBtYXJrU3RhdGljJDEoY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5zdGF0aWMpIHtcbiAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcbiAgICAgICAgdmFyIGJsb2NrID0gbm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaztcbiAgICAgICAgbWFya1N0YXRpYyQxKGJsb2NrKTtcbiAgICAgICAgaWYgKCFibG9jay5zdGF0aWMpIHtcbiAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUub25jZSkge1xuICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG4gICAgfVxuICAgIC8vIEZvciBhIG5vZGUgdG8gcXVhbGlmeSBhcyBhIHN0YXRpYyByb290LCBpdCBzaG91bGQgaGF2ZSBjaGlsZHJlbiB0aGF0XG4gICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcbiAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG4gICAgaWYgKG5vZGUuc3RhdGljICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmICEoXG4gICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXG4gICAgKSkge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrLCBpc0luRm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdGF0aWMgKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxuICAgICFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcbiAgICAhbm9kZS5pZiAmJiAhbm9kZS5mb3IgJiYgLy8gbm90IHYtaWYgb3Igdi1mb3Igb3Igdi1lbHNlXG4gICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cbiAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGNvbXBvbmVudFxuICAgICFpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSAmJlxuICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciAobm9kZSkge1xuICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbnZhciBmbkV4cFJFID0gL14oW1xcdyRfXSt8XFwoW14pXSo/XFwpKVxccyo9PnxeZnVuY3Rpb25cXHMqKD86W1xcdyRdKyk/XFxzKlxcKC87XG52YXIgZm5JbnZva2VSRSA9IC9cXChbXildKj9cXCk7KiQvO1xudmFyIHNpbXBsZVBhdGhSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnW14nXSo/J118XFxbXCJbXlwiXSo/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqJC87XG5cbi8vIEtleWJvYXJkRXZlbnQua2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gIHVwOiAzOCxcbiAgbGVmdDogMzcsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDAsXG4gICdkZWxldGUnOiBbOCwgNDZdXG59O1xuXG4vLyBLZXlib2FyZEV2ZW50LmtleSBhbGlhc2VzXG52YXIga2V5TmFtZXMgPSB7XG4gIC8vICM3ODgwOiBJRTExIGFuZCBFZGdlIHVzZSBgRXNjYCBmb3IgRXNjYXBlIGtleSBuYW1lLlxuICBlc2M6IFsnRXNjJywgJ0VzY2FwZSddLFxuICB0YWI6ICdUYWInLFxuICBlbnRlcjogJ0VudGVyJyxcbiAgLy8gIzkxMTI6IElFMTEgdXNlcyBgU3BhY2ViYXJgIGZvciBTcGFjZSBrZXkgbmFtZS5cbiAgc3BhY2U6IFsnICcsICdTcGFjZWJhciddLFxuICAvLyAjNzgwNjogSUUxMSB1c2VzIGtleSBuYW1lcyB3aXRob3V0IGBBcnJvd2AgcHJlZml4IGZvciBhcnJvdyBrZXlzLlxuICB1cDogWydVcCcsICdBcnJvd1VwJ10sXG4gIGxlZnQ6IFsnTGVmdCcsICdBcnJvd0xlZnQnXSxcbiAgcmlnaHQ6IFsnUmlnaHQnLCAnQXJyb3dSaWdodCddLFxuICBkb3duOiBbJ0Rvd24nLCAnQXJyb3dEb3duJ10sXG4gIC8vICM5MTEyOiBJRTExIHVzZXMgYERlbGAgZm9yIERlbGV0ZSBrZXkgbmFtZS5cbiAgJ2RlbGV0ZSc6IFsnQmFja3NwYWNlJywgJ0RlbGV0ZScsICdEZWwnXVxufTtcblxuLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbi8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcbi8vIHRoZSBsaXN0ZW5lciBmb3IgLm9uY2VcbnZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIChcImlmKFwiICsgY29uZGl0aW9uICsgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xuXG52YXIgbW9kaWZpZXJDb2RlID0ge1xuICBzdG9wOiAnJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOycsXG4gIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuICBzZWxmOiBnZW5HdWFyZChcIiRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0XCIpLFxuICBjdHJsOiBnZW5HdWFyZChcIiEkZXZlbnQuY3RybEtleVwiKSxcbiAgc2hpZnQ6IGdlbkd1YXJkKFwiISRldmVudC5zaGlmdEtleVwiKSxcbiAgYWx0OiBnZW5HdWFyZChcIiEkZXZlbnQuYWx0S2V5XCIpLFxuICBtZXRhOiBnZW5HdWFyZChcIiEkZXZlbnQubWV0YUtleVwiKSxcbiAgbGVmdDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFwiKSxcbiAgbWlkZGxlOiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxXCIpLFxuICByaWdodDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMlwiKVxufTtcblxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxuICBldmVudHMsXG4gIGlzTmF0aXZlXG4pIHtcbiAgdmFyIHByZWZpeCA9IGlzTmF0aXZlID8gJ25hdGl2ZU9uOicgOiAnb246JztcbiAgdmFyIHN0YXRpY0hhbmRsZXJzID0gXCJcIjtcbiAgdmFyIGR5bmFtaWNIYW5kbGVycyA9IFwiXCI7XG4gIGZvciAodmFyIG5hbWUgaW4gZXZlbnRzKSB7XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gZ2VuSGFuZGxlcihldmVudHNbbmFtZV0pO1xuICAgIGlmIChldmVudHNbbmFtZV0gJiYgZXZlbnRzW25hbWVdLmR5bmFtaWMpIHtcbiAgICAgIGR5bmFtaWNIYW5kbGVycyArPSBuYW1lICsgXCIsXCIgKyBoYW5kbGVyQ29kZSArIFwiLFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0aWNIYW5kbGVycyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyBoYW5kbGVyQ29kZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBzdGF0aWNIYW5kbGVycyA9IFwie1wiICsgKHN0YXRpY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSkgKyBcIn1cIjtcbiAgaWYgKGR5bmFtaWNIYW5kbGVycykge1xuICAgIHJldHVybiBwcmVmaXggKyBcIl9kKFwiICsgc3RhdGljSGFuZGxlcnMgKyBcIixbXCIgKyAoZHluYW1pY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSkgKyBcIl0pXCJcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJlZml4ICsgc3RhdGljSGFuZGxlcnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5IYW5kbGVyIChoYW5kbGVyKSB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiAnZnVuY3Rpb24oKXt9J1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICByZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG4gIH1cblxuICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gIHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgdmFyIGlzRnVuY3Rpb25JbnZvY2F0aW9uID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZS5yZXBsYWNlKGZuSW52b2tlUkUsICcnKSk7XG5cbiAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgIGlmIChpc01ldGhvZFBhdGggfHwgaXNGdW5jdGlvbkV4cHJlc3Npb24pIHtcbiAgICAgIHJldHVybiBoYW5kbGVyLnZhbHVlXG4gICAgfVxuICAgIHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgKGlzRnVuY3Rpb25JbnZvY2F0aW9uID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpKSA6IGhhbmRsZXIudmFsdWUpICsgXCJ9XCIpIC8vIGlubGluZSBzdGF0ZW1lbnRcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29kZSA9ICcnO1xuICAgIHZhciBnZW5Nb2RpZmllckNvZGUgPSAnJztcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgaWYgKG1vZGlmaWVyQ29kZVtrZXldKSB7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcbiAgICAgICAgLy8gbGVmdC9yaWdodFxuICAgICAgICBpZiAoa2V5Q29kZXNba2V5XSkge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2V4YWN0Jykge1xuICAgICAgICB2YXIgbW9kaWZpZXJzID0gKGhhbmRsZXIubW9kaWZpZXJzKTtcbiAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IGdlbkd1YXJkKFxuICAgICAgICAgIFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gIW1vZGlmaWVyc1trZXlNb2RpZmllcl07IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gKFwiJGV2ZW50LlwiICsga2V5TW9kaWZpZXIgKyBcIktleVwiKTsgfSlcbiAgICAgICAgICAgIC5qb2luKCd8fCcpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICBjb2RlICs9IGdlbktleUZpbHRlcihrZXlzKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcbiAgICBpZiAoZ2VuTW9kaWZpZXJDb2RlKSB7XG4gICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcbiAgICB9XG4gICAgdmFyIGhhbmRsZXJDb2RlID0gaXNNZXRob2RQYXRoXG4gICAgICA/IChcInJldHVybiBcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKCRldmVudClcIilcbiAgICAgIDogaXNGdW5jdGlvbkV4cHJlc3Npb25cbiAgICAgICAgPyAoXCJyZXR1cm4gKFwiICsgKGhhbmRsZXIudmFsdWUpICsgXCIpKCRldmVudClcIilcbiAgICAgICAgOiBpc0Z1bmN0aW9uSW52b2NhdGlvblxuICAgICAgICAgID8gKFwicmV0dXJuIFwiICsgKGhhbmRsZXIudmFsdWUpKVxuICAgICAgICAgIDogaGFuZGxlci52YWx1ZTtcbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICByZXR1cm4gKFxuICAgIC8vIG1ha2Ugc3VyZSB0aGUga2V5IGZpbHRlcnMgb25seSBhcHBseSB0byBLZXlib2FyZEV2ZW50c1xuICAgIC8vICM5NDQxOiBjYW4ndCB1c2UgJ2tleUNvZGUnIGluICRldmVudCBiZWNhdXNlIENocm9tZSBhdXRvZmlsbCBmaXJlcyBmYWtlXG4gICAgLy8ga2V5IGV2ZW50cyB0aGF0IGRvIG5vdCBoYXZlIGtleUNvZGUgcHJvcGVydHkuLi5cbiAgICBcImlmKCEkZXZlbnQudHlwZS5pbmRleE9mKCdrZXknKSYmXCIgK1xuICAgIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFwiKXJldHVybiBudWxsO1wiXG4gIClcbn1cblxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgaWYgKGtleVZhbCkge1xuICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuICB9XG4gIHZhciBrZXlDb2RlID0ga2V5Q29kZXNba2V5XTtcbiAgdmFyIGtleU5hbWUgPSBrZXlOYW1lc1trZXldO1xuICByZXR1cm4gKFxuICAgIFwiX2soJGV2ZW50LmtleUNvZGUsXCIgK1xuICAgIChKU09OLnN0cmluZ2lmeShrZXkpKSArIFwiLFwiICtcbiAgICAoSlNPTi5zdHJpbmdpZnkoa2V5Q29kZSkpICsgXCIsXCIgK1xuICAgIFwiJGV2ZW50LmtleSxcIiArXG4gICAgXCJcIiArIChKU09OLnN0cmluZ2lmeShrZXlOYW1lKSkgK1xuICAgIFwiKVwiXG4gIClcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG9uIChlbCwgZGlyKSB7XG4gIGlmIChkaXIubW9kaWZpZXJzKSB7XG4gICAgd2FybihcInYtb24gd2l0aG91dCBhcmd1bWVudCBkb2VzIG5vdCBzdXBwb3J0IG1vZGlmaWVycy5cIik7XG4gIH1cbiAgZWwud3JhcExpc3RlbmVycyA9IGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJfZyhcIiArIGNvZGUgKyBcIixcIiArIChkaXIudmFsdWUpICsgXCIpXCIpOyB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZCQxIChlbCwgZGlyKSB7XG4gIGVsLndyYXBEYXRhID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4gKFwiX2IoXCIgKyBjb2RlICsgXCIsJ1wiICsgKGVsLnRhZykgKyBcIicsXCIgKyAoZGlyLnZhbHVlKSArIFwiLFwiICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5wcm9wID8gJ3RydWUnIDogJ2ZhbHNlJykgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnN5bmMgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgYmFzZURpcmVjdGl2ZXMgPSB7XG4gIG9uOiBvbixcbiAgYmluZDogYmluZCQxLFxuICBjbG9hazogbm9vcFxufTtcblxuLyogICovXG5cblxuXG5cblxudmFyIENvZGVnZW5TdGF0ZSA9IGZ1bmN0aW9uIENvZGVnZW5TdGF0ZSAob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLndhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHRoaXMudHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtQ29kZScpO1xuICB0aGlzLmRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcbiAgdGhpcy5kaXJlY3RpdmVzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmFzZURpcmVjdGl2ZXMpLCBvcHRpb25zLmRpcmVjdGl2ZXMpO1xuICB2YXIgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgdGhpcy5tYXliZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gISFlbC5jb21wb25lbnQgfHwgIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTsgfTtcbiAgdGhpcy5vbmNlSWQgPSAwO1xuICB0aGlzLnN0YXRpY1JlbmRlckZucyA9IFtdO1xuICB0aGlzLnByZSA9IGZhbHNlO1xufTtcblxuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlIChcbiAgYXN0LFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIHN0YXRlID0gbmV3IENvZGVnZW5TdGF0ZShvcHRpb25zKTtcbiAgdmFyIGNvZGUgPSBhc3QgPyBnZW5FbGVtZW50KGFzdCwgc3RhdGUpIDogJ19jKFwiZGl2XCIpJztcbiAgcmV0dXJuIHtcbiAgICByZW5kZXI6IChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgY29kZSArIFwifVwiKSxcbiAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRlLnN0YXRpY1JlbmRlckZuc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkVsZW1lbnQgKGVsLCBzdGF0ZSkge1xuICBpZiAoZWwucGFyZW50KSB7XG4gICAgZWwucHJlID0gZWwucHJlIHx8IGVsLnBhcmVudC5wcmU7XG4gIH1cblxuICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwub25jZSAmJiAhZWwub25jZVByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3IoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnICYmICFlbC5zbG90VGFyZ2V0ICYmICFzdGF0ZS5wcmUpIHtcbiAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndm9pZCAwJ1xuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgcmV0dXJuIGdlblNsb3QoZWwsIHN0YXRlKVxuICB9IGVsc2Uge1xuICAgIC8vIGNvbXBvbmVudCBvciBlbGVtZW50XG4gICAgdmFyIGNvZGU7XG4gICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgY29kZSA9IGdlbkNvbXBvbmVudChlbC5jb21wb25lbnQsIGVsLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkYXRhO1xuICAgICAgaWYgKCFlbC5wbGFpbiB8fCAoZWwucHJlICYmIHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSkpIHtcbiAgICAgICAgZGF0YSA9IGdlbkRhdGEkMihlbCwgc3RhdGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICAgICAgY29kZSA9IFwiX2MoJ1wiICsgKGVsLnRhZykgKyBcIidcIiArIChkYXRhID8gKFwiLFwiICsgZGF0YSkgOiAnJykgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIjtcbiAgICB9XG4gICAgLy8gbW9kdWxlIHRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLnRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS50cmFuc2Zvcm1zW2ldKGVsLCBjb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVcbiAgfVxufVxuXG4vLyBob2lzdCBzdGF0aWMgc3ViLXRyZWVzIG91dFxuZnVuY3Rpb24gZ2VuU3RhdGljIChlbCwgc3RhdGUpIHtcbiAgZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgLy8gU29tZSBlbGVtZW50cyAodGVtcGxhdGVzKSBuZWVkIHRvIGJlaGF2ZSBkaWZmZXJlbnRseSBpbnNpZGUgb2YgYSB2LXByZVxuICAvLyBub2RlLiAgQWxsIHByZSBub2RlcyBhcmUgc3RhdGljIHJvb3RzLCBzbyB3ZSBjYW4gdXNlIHRoaXMgYXMgYSBsb2NhdGlvbiB0b1xuICAvLyB3cmFwIGEgc3RhdGUgY2hhbmdlIGFuZCByZXNldCBpdCB1cG9uIGV4aXRpbmcgdGhlIHByZSBub2RlLlxuICB2YXIgb3JpZ2luYWxQcmVTdGF0ZSA9IHN0YXRlLnByZTtcbiAgaWYgKGVsLnByZSkge1xuICAgIHN0YXRlLnByZSA9IGVsLnByZTtcbiAgfVxuICBzdGF0ZS5zdGF0aWNSZW5kZXJGbnMucHVzaCgoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCIpKTtcbiAgc3RhdGUucHJlID0gb3JpZ2luYWxQcmVTdGF0ZTtcbiAgcmV0dXJuIChcIl9tKFwiICsgKHN0YXRlLnN0YXRpY1JlbmRlckZucy5sZW5ndGggLSAxKSArIChlbC5zdGF0aWNJbkZvciA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbn1cblxuLy8gdi1vbmNlXG5mdW5jdGlvbiBnZW5PbmNlIChlbCwgc3RhdGUpIHtcbiAgZWwub25jZVByb2Nlc3NlZCA9IHRydWU7XG4gIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnN0YXRpY0luRm9yKSB7XG4gICAgdmFyIGtleSA9ICcnO1xuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5mb3IpIHtcbiAgICAgICAga2V5ID0gcGFyZW50LmtleTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIGlmICgha2V5KSB7XG4gICAgICBzdGF0ZS53YXJuKFxuICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Ytb25jZSddXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgIH1cbiAgICByZXR1cm4gKFwiX28oXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwiLFwiICsgKHN0YXRlLm9uY2VJZCsrKSArIFwiLFwiICsga2V5ICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSWYgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gZ2VuSWZDb25kaXRpb25zKGVsLmlmQ29uZGl0aW9ucy5zbGljZSgpLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSlcbn1cblxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChcbiAgY29uZGl0aW9ucyxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsdEVtcHR5IHx8ICdfZSgpJ1xuICB9XG5cbiAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcbiAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiXCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSlcbiAgfVxuXG4gIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcbiAgZnVuY3Rpb24gZ2VuVGVybmFyeUV4cCAoZWwpIHtcbiAgICByZXR1cm4gYWx0R2VuXG4gICAgICA/IGFsdEdlbihlbCwgc3RhdGUpXG4gICAgICA6IGVsLm9uY2VcbiAgICAgICAgPyBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5Gb3IgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0SGVscGVyXG4pIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXG4gIGlmIChzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkgJiZcbiAgICBlbC50YWcgIT09ICdzbG90JyAmJlxuICAgIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICFlbC5rZXlcbiAgKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LWZvcj1cXFwiXCIgKyBhbGlhcyArIFwiIGluIFwiICsgZXhwICsgXCJcXFwiPjogY29tcG9uZW50IGxpc3RzIHJlbmRlcmVkIHdpdGggXCIgK1xuICAgICAgXCJ2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBcIiArXG4gICAgICBcIlNlZSBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9saXN0Lmh0bWwja2V5IGZvciBtb3JlIGluZm8uXCIsXG4gICAgICBlbC5yYXdBdHRyc01hcFsndi1mb3InXSxcbiAgICAgIHRydWUgLyogdGlwICovXG4gICAgKTtcbiAgfVxuXG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gKGFsdEhlbHBlciB8fCAnX2wnKSArIFwiKChcIiArIGV4cCArIFwiKSxcIiArXG4gICAgXCJmdW5jdGlvbihcIiArIGFsaWFzICsgaXRlcmF0b3IxICsgaXRlcmF0b3IyICsgXCIpe1wiICtcbiAgICAgIFwicmV0dXJuIFwiICsgKChhbHRHZW4gfHwgZ2VuRWxlbWVudCkoZWwsIHN0YXRlKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCwgc3RhdGUpIHtcbiAgdmFyIGRhdGEgPSAneyc7XG5cbiAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cbiAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgdmFyIGRpcnMgPSBnZW5EaXJlY3RpdmVzKGVsLCBzdGF0ZSk7XG4gIGlmIChkaXJzKSB7IGRhdGEgKz0gZGlycyArICcsJzsgfVxuXG4gIC8vIGtleVxuICBpZiAoZWwua2V5KSB7XG4gICAgZGF0YSArPSBcImtleTpcIiArIChlbC5rZXkpICsgXCIsXCI7XG4gIH1cbiAgLy8gcmVmXG4gIGlmIChlbC5yZWYpIHtcbiAgICBkYXRhICs9IFwicmVmOlwiICsgKGVsLnJlZikgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwucmVmSW5Gb3IpIHtcbiAgICBkYXRhICs9IFwicmVmSW5Gb3I6dHJ1ZSxcIjtcbiAgfVxuICAvLyBwcmVcbiAgaWYgKGVsLnByZSkge1xuICAgIGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgdGFnIG5hbWUgZm9yIGNvbXBvbmVudHMgdXNpbmcgXCJpc1wiIGF0dHJpYnV0ZVxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZGF0YSArPSBcInRhZzpcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIjtcbiAgfVxuICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmRhdGFHZW5GbnMubGVuZ3RoOyBpKyspIHtcbiAgICBkYXRhICs9IHN0YXRlLmRhdGFHZW5GbnNbaV0oZWwpO1xuICB9XG4gIC8vIGF0dHJpYnV0ZXNcbiAgaWYgKGVsLmF0dHJzKSB7XG4gICAgZGF0YSArPSBcImF0dHJzOlwiICsgKGdlblByb3BzKGVsLmF0dHJzKSkgKyBcIixcIjtcbiAgfVxuICAvLyBET00gcHJvcHNcbiAgaWYgKGVsLnByb3BzKSB7XG4gICAgZGF0YSArPSBcImRvbVByb3BzOlwiICsgKGdlblByb3BzKGVsLnByb3BzKSkgKyBcIixcIjtcbiAgfVxuICAvLyBldmVudCBoYW5kbGVyc1xuICBpZiAoZWwuZXZlbnRzKSB7XG4gICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwuZXZlbnRzLCBmYWxzZSkpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLm5hdGl2ZUV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLm5hdGl2ZUV2ZW50cywgdHJ1ZSkpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2xvdCB0YXJnZXRcbiAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90c1xuICBpZiAoZWwuc2xvdFRhcmdldCAmJiAhZWwuc2xvdFNjb3BlKSB7XG4gICAgZGF0YSArPSBcInNsb3Q6XCIgKyAoZWwuc2xvdFRhcmdldCkgKyBcIixcIjtcbiAgfVxuICAvLyBzY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgZGF0YSArPSAoZ2VuU2NvcGVkU2xvdHMoZWwsIGVsLnNjb3BlZFNsb3RzLCBzdGF0ZSkpICsgXCIsXCI7XG4gIH1cbiAgLy8gY29tcG9uZW50IHYtbW9kZWxcbiAgaWYgKGVsLm1vZGVsKSB7XG4gICAgZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIiArIChlbC5tb2RlbC52YWx1ZSkgKyBcIixjYWxsYmFjazpcIiArIChlbC5tb2RlbC5jYWxsYmFjaykgKyBcIixleHByZXNzaW9uOlwiICsgKGVsLm1vZGVsLmV4cHJlc3Npb24pICsgXCJ9LFwiO1xuICB9XG4gIC8vIGlubGluZS10ZW1wbGF0ZVxuICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcbiAgICB2YXIgaW5saW5lVGVtcGxhdGUgPSBnZW5JbmxpbmVUZW1wbGF0ZShlbCwgc3RhdGUpO1xuICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgZGF0YSArPSBpbmxpbmVUZW1wbGF0ZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgLy8gdi1iaW5kIGR5bmFtaWMgYXJndW1lbnQgd3JhcFxuICAvLyB2LWJpbmQgd2l0aCBkeW5hbWljIGFyZ3VtZW50cyBtdXN0IGJlIGFwcGxpZWQgdXNpbmcgdGhlIHNhbWUgdi1iaW5kIG9iamVjdFxuICAvLyBtZXJnZSBoZWxwZXIgc28gdGhhdCBjbGFzcy9zdHlsZS9tdXN0VXNlUHJvcCBhdHRycyBhcmUgaGFuZGxlZCBjb3JyZWN0bHkuXG4gIGlmIChlbC5keW5hbWljQXR0cnMpIHtcbiAgICBkYXRhID0gXCJfYihcIiArIGRhdGEgKyBcIixcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIiArIChnZW5Qcm9wcyhlbC5keW5hbWljQXR0cnMpKSArIFwiKVwiO1xuICB9XG4gIC8vIHYtYmluZCBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBEYXRhKSB7XG4gICAgZGF0YSA9IGVsLndyYXBEYXRhKGRhdGEpO1xuICB9XG4gIC8vIHYtb24gZGF0YSB3cmFwXG4gIGlmIChlbC53cmFwTGlzdGVuZXJzKSB7XG4gICAgZGF0YSA9IGVsLndyYXBMaXN0ZW5lcnMoZGF0YSk7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuZnVuY3Rpb24gZ2VuRGlyZWN0aXZlcyAoZWwsIHN0YXRlKSB7XG4gIHZhciBkaXJzID0gZWwuZGlyZWN0aXZlcztcbiAgaWYgKCFkaXJzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSAnZGlyZWN0aXZlczpbJztcbiAgdmFyIGhhc1J1bnRpbWUgPSBmYWxzZTtcbiAgdmFyIGksIGwsIGRpciwgbmVlZFJ1bnRpbWU7XG4gIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgbmVlZFJ1bnRpbWUgPSB0cnVlO1xuICAgIHZhciBnZW4gPSBzdGF0ZS5kaXJlY3RpdmVzW2Rpci5uYW1lXTtcbiAgICBpZiAoZ2VuKSB7XG4gICAgICAvLyBjb21waWxlLXRpbWUgZGlyZWN0aXZlIHRoYXQgbWFuaXB1bGF0ZXMgQVNULlxuICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIGl0IGFsc28gbmVlZHMgYSBydW50aW1lIGNvdW50ZXJwYXJ0LlxuICAgICAgbmVlZFJ1bnRpbWUgPSAhIWdlbihlbCwgZGlyLCBzdGF0ZS53YXJuKTtcbiAgICB9XG4gICAgaWYgKG5lZWRSdW50aW1lKSB7XG4gICAgICBoYXNSdW50aW1lID0gdHJ1ZTtcbiAgICAgIHJlcyArPSBcIntuYW1lOlxcXCJcIiArIChkaXIubmFtZSkgKyBcIlxcXCIscmF3TmFtZTpcXFwiXCIgKyAoZGlyLnJhd05hbWUpICsgXCJcXFwiXCIgKyAoZGlyLnZhbHVlID8gKFwiLHZhbHVlOihcIiArIChkaXIudmFsdWUpICsgXCIpLGV4cHJlc3Npb246XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLnZhbHVlKSkpIDogJycpICsgKGRpci5hcmcgPyAoXCIsYXJnOlwiICsgKGRpci5pc0R5bmFtaWNBcmcgPyBkaXIuYXJnIDogKFwiXFxcIlwiICsgKGRpci5hcmcpICsgXCJcXFwiXCIpKSkgOiAnJykgKyAoZGlyLm1vZGlmaWVycyA/IChcIixtb2RpZmllcnM6XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLm1vZGlmaWVycykpKSA6ICcnKSArIFwifSxcIjtcbiAgICB9XG4gIH1cbiAgaWYgKGhhc1J1bnRpbWUpIHtcbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJ1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklubGluZVRlbXBsYXRlIChlbCwgc3RhdGUpIHtcbiAgdmFyIGFzdCA9IGVsLmNoaWxkcmVuWzBdO1xuICBpZiAoZWwuY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8IGFzdC50eXBlICE9PSAxKSB7XG4gICAgc3RhdGUud2FybihcbiAgICAgICdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nLFxuICAgICAgeyBzdGFydDogZWwuc3RhcnQgfVxuICAgICk7XG4gIH1cbiAgaWYgKGFzdCAmJiBhc3QudHlwZSA9PT0gMSkge1xuICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIHN0YXRlLm9wdGlvbnMpO1xuICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKFxuICBlbCxcbiAgc2xvdHMsXG4gIHN0YXRlXG4pIHtcbiAgLy8gYnkgZGVmYXVsdCBzY29wZWQgc2xvdHMgYXJlIGNvbnNpZGVyZWQgXCJzdGFibGVcIiwgdGhpcyBhbGxvd3MgY2hpbGRcbiAgLy8gY29tcG9uZW50cyB3aXRoIG9ubHkgc2NvcGVkIHNsb3RzIHRvIHNraXAgZm9yY2VkIHVwZGF0ZXMgZnJvbSBwYXJlbnQuXG4gIC8vIGJ1dCBpbiBzb21lIGNhc2VzIHdlIGhhdmUgdG8gYmFpbC1vdXQgb2YgdGhpcyBvcHRpbWl6YXRpb25cbiAgLy8gZm9yIGV4YW1wbGUgaWYgdGhlIHNsb3QgY29udGFpbnMgZHluYW1pYyBuYW1lcywgaGFzIHYtaWYgb3Igdi1mb3Igb24gdGhlbS4uLlxuICB2YXIgbmVlZHNGb3JjZVVwZGF0ZSA9IGVsLmZvciB8fCBPYmplY3Qua2V5cyhzbG90cykuc29tZShmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHNsb3QgPSBzbG90c1trZXldO1xuICAgIHJldHVybiAoXG4gICAgICBzbG90LnNsb3RUYXJnZXREeW5hbWljIHx8XG4gICAgICBzbG90LmlmIHx8XG4gICAgICBzbG90LmZvciB8fFxuICAgICAgY29udGFpbnNTbG90Q2hpbGQoc2xvdCkgLy8gaXMgcGFzc2luZyBkb3duIHNsb3QgZnJvbSBwYXJlbnQgd2hpY2ggbWF5IGJlIGR5bmFtaWNcbiAgICApXG4gIH0pO1xuXG4gIC8vICM5NTM0OiBpZiBhIGNvbXBvbmVudCB3aXRoIHNjb3BlZCBzbG90cyBpcyBpbnNpZGUgYSBjb25kaXRpb25hbCBicmFuY2gsXG4gIC8vIGl0J3MgcG9zc2libGUgZm9yIHRoZSBzYW1lIGNvbXBvbmVudCB0byBiZSByZXVzZWQgYnV0IHdpdGggZGlmZmVyZW50XG4gIC8vIGNvbXBpbGVkIHNsb3QgY29udGVudC4gVG8gYXZvaWQgdGhhdCwgd2UgZ2VuZXJhdGUgYSB1bmlxdWUga2V5IGJhc2VkIG9uXG4gIC8vIHRoZSBnZW5lcmF0ZWQgY29kZSBvZiBhbGwgdGhlIHNsb3QgY29udGVudHMuXG4gIHZhciBuZWVkc0tleSA9ICEhZWwuaWY7XG5cbiAgLy8gT1Igd2hlbiBpdCBpcyBpbnNpZGUgYW5vdGhlciBzY29wZWQgc2xvdCBvciB2LWZvciAodGhlIHJlYWN0aXZpdHkgbWF5IGJlXG4gIC8vIGRpc2Nvbm5lY3RlZCBkdWUgdG8gdGhlIGludGVybWVkaWF0ZSBzY29wZSB2YXJpYWJsZSlcbiAgLy8gIzk0MzgsICM5NTA2XG4gIC8vIFRPRE86IHRoaXMgY2FuIGJlIGZ1cnRoZXIgb3B0aW1pemVkIGJ5IHByb3Blcmx5IGFuYWx5emluZyBpbi1zY29wZSBiaW5kaW5nc1xuICAvLyBhbmQgc2tpcCBmb3JjZSB1cGRhdGluZyBvbmVzIHRoYXQgZG8gbm90IGFjdHVhbGx5IHVzZSBzY29wZSB2YXJpYWJsZXMuXG4gIGlmICghbmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKFxuICAgICAgICAocGFyZW50LnNsb3RTY29wZSAmJiBwYXJlbnQuc2xvdFNjb3BlICE9PSBlbXB0eVNsb3RTY29wZVRva2VuKSB8fFxuICAgICAgICBwYXJlbnQuZm9yXG4gICAgICApIHtcbiAgICAgICAgbmVlZHNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAocGFyZW50LmlmKSB7XG4gICAgICAgIG5lZWRzS2V5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIGdlbmVyYXRlZFNsb3RzID0gT2JqZWN0LmtleXMoc2xvdHMpXG4gICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBnZW5TY29wZWRTbG90KHNsb3RzW2tleV0sIHN0YXRlKTsgfSlcbiAgICAuam9pbignLCcpO1xuXG4gIHJldHVybiAoXCJzY29wZWRTbG90czpfdShbXCIgKyBnZW5lcmF0ZWRTbG90cyArIFwiXVwiICsgKG5lZWRzRm9yY2VVcGRhdGUgPyBcIixudWxsLHRydWVcIiA6IFwiXCIpICsgKCFuZWVkc0ZvcmNlVXBkYXRlICYmIG5lZWRzS2V5ID8gKFwiLG51bGwsZmFsc2UsXCIgKyAoaGFzaChnZW5lcmF0ZWRTbG90cykpKSA6IFwiXCIpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gIHZhciBoYXNoID0gNTM4MTtcbiAgdmFyIGkgPSBzdHIubGVuZ3RoO1xuICB3aGlsZShpKSB7XG4gICAgaGFzaCA9IChoYXNoICogMzMpIF4gc3RyLmNoYXJDb2RlQXQoLS1pKTtcbiAgfVxuICByZXR1cm4gaGFzaCA+Pj4gMFxufVxuXG5mdW5jdGlvbiBjb250YWluc1Nsb3RDaGlsZCAoZWwpIHtcbiAgaWYgKGVsLnR5cGUgPT09IDEpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBlbC5jaGlsZHJlbi5zb21lKGNvbnRhaW5zU2xvdENoaWxkKVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90IChcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGlzTGVnYWN5U3ludGF4ID0gZWwuYXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCAmJiAhaXNMZWdhY3lTeW50YXgpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90LCBcIm51bGxcIilcbiAgfVxuICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSwgZ2VuU2NvcGVkU2xvdClcbiAgfVxuICB2YXIgc2xvdFNjb3BlID0gZWwuc2xvdFNjb3BlID09PSBlbXB0eVNsb3RTY29wZVRva2VuXG4gICAgPyBcIlwiXG4gICAgOiBTdHJpbmcoZWwuc2xvdFNjb3BlKTtcbiAgdmFyIGZuID0gXCJmdW5jdGlvbihcIiArIHNsb3RTY29wZSArIFwiKXtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICA/IGVsLmlmICYmIGlzTGVnYWN5U3ludGF4XG4gICAgICAgID8gKFwiKFwiICsgKGVsLmlmKSArIFwiKT9cIiArIChnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnKSArIFwiOnVuZGVmaW5lZFwiKVxuICAgICAgICA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCdcbiAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiO1xuICAvLyByZXZlcnNlIHByb3h5IHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXG4gIHZhciByZXZlcnNlUHJveHkgPSBzbG90U2NvcGUgPyBcIlwiIDogXCIscHJveHk6dHJ1ZVwiO1xuICByZXR1cm4gKFwie2tleTpcIiArIChlbC5zbG90VGFyZ2V0IHx8IFwiXFxcImRlZmF1bHRcXFwiXCIpICsgXCIsZm46XCIgKyBmbiArIHJldmVyc2VQcm94eSArIFwifVwiKVxufVxuXG5mdW5jdGlvbiBnZW5DaGlsZHJlbiAoXG4gIGVsLFxuICBzdGF0ZSxcbiAgY2hlY2tTa2lwLFxuICBhbHRHZW5FbGVtZW50LFxuICBhbHRHZW5Ob2RlXG4pIHtcbiAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xuICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgIGVsJDEuZm9yICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgZWwkMS50YWcgIT09ICdzbG90J1xuICAgICkge1xuICAgICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICAgID8gc3RhdGUubWF5YmVDb21wb25lbnQoZWwkMSkgPyBcIiwxXCIgOiBcIiwwXCJcbiAgICAgICAgOiBcIlwiO1xuICAgICAgcmV0dXJuIChcIlwiICsgKChhbHRHZW5FbGVtZW50IHx8IGdlbkVsZW1lbnQpKGVsJDEsIHN0YXRlKSkgKyBub3JtYWxpemF0aW9uVHlwZSlcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlJDEgPSBjaGVja1NraXBcbiAgICAgID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4sIHN0YXRlLm1heWJlQ29tcG9uZW50KVxuICAgICAgOiAwO1xuICAgIHZhciBnZW4gPSBhbHRHZW5Ob2RlIHx8IGdlbk5vZGU7XG4gICAgcmV0dXJuIChcIltcIiArIChjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGdlbihjLCBzdGF0ZSk7IH0pLmpvaW4oJywnKSkgKyBcIl1cIiArIChub3JtYWxpemF0aW9uVHlwZSQxID8gKFwiLFwiICsgbm9ybWFsaXphdGlvblR5cGUkMSkgOiAnJykpXG4gIH1cbn1cblxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChcbiAgY2hpbGRyZW4sXG4gIG1heWJlQ29tcG9uZW50XG4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbmVlZHNOb3JtYWxpemF0aW9uKGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDI7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBpZiAobWF5YmVDb21wb25lbnQoZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUsIHN0YXRlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDMgJiYgbm9kZS5pc0NvbW1lbnQpIHtcbiAgICByZXR1cm4gZ2VuQ29tbWVudChub2RlKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5UZXh0KG5vZGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuVGV4dCAodGV4dCkge1xuICByZXR1cm4gKFwiX3YoXCIgKyAodGV4dC50eXBlID09PSAyXG4gICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgIDogdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKEpTT04uc3RyaW5naWZ5KHRleHQudGV4dCkpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Db21tZW50IChjb21tZW50KSB7XG4gIHJldHVybiAoXCJfZShcIiArIChKU09OLnN0cmluZ2lmeShjb21tZW50LnRleHQpKSArIFwiKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TbG90IChlbCwgc3RhdGUpIHtcbiAgdmFyIHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1wiZGVmYXVsdFwiJztcbiAgdmFyIGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKTtcbiAgdmFyIHJlcyA9IFwiX3QoXCIgKyBzbG90TmFtZSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKTtcbiAgdmFyIGF0dHJzID0gZWwuYXR0cnMgfHwgZWwuZHluYW1pY0F0dHJzXG4gICAgPyBnZW5Qcm9wcygoZWwuYXR0cnMgfHwgW10pLmNvbmNhdChlbC5keW5hbWljQXR0cnMgfHwgW10pLm1hcChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gKHtcbiAgICAgICAgLy8gc2xvdCBwcm9wcyBhcmUgY2FtZWxpemVkXG4gICAgICAgIG5hbWU6IGNhbWVsaXplKGF0dHIubmFtZSksXG4gICAgICAgIHZhbHVlOiBhdHRyLnZhbHVlLFxuICAgICAgICBkeW5hbWljOiBhdHRyLmR5bmFtaWNcbiAgICAgIH0pOyB9KSlcbiAgICA6IG51bGw7XG4gIHZhciBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgIHJlcyArPSBcIixudWxsXCI7XG4gIH1cbiAgaWYgKGF0dHJzKSB7XG4gICAgcmVzICs9IFwiLFwiICsgYXR0cnM7XG4gIH1cbiAgaWYgKGJpbmQkJDEpIHtcbiAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFwiLFwiICsgYmluZCQkMTtcbiAgfVxuICByZXR1cm4gcmVzICsgJyknXG59XG5cbi8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcbmZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoXG4gIGNvbXBvbmVudE5hbWUsXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gIHJldHVybiAoXCJfYyhcIiArIGNvbXBvbmVudE5hbWUgKyBcIixcIiArIChnZW5EYXRhJDIoZWwsIHN0YXRlKSkgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuUHJvcHMgKHByb3BzKSB7XG4gIHZhciBzdGF0aWNQcm9wcyA9IFwiXCI7XG4gIHZhciBkeW5hbWljUHJvcHMgPSBcIlwiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICB2YXIgdmFsdWUgPSB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMocHJvcC52YWx1ZSk7XG4gICAgaWYgKHByb3AuZHluYW1pYykge1xuICAgICAgZHluYW1pY1Byb3BzICs9IChwcm9wLm5hbWUpICsgXCIsXCIgKyB2YWx1ZSArIFwiLFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0aWNQcm9wcyArPSBcIlxcXCJcIiArIChwcm9wLm5hbWUpICsgXCJcXFwiOlwiICsgdmFsdWUgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgc3RhdGljUHJvcHMgPSBcIntcIiArIChzdGF0aWNQcm9wcy5zbGljZSgwLCAtMSkpICsgXCJ9XCI7XG4gIGlmIChkeW5hbWljUHJvcHMpIHtcbiAgICByZXR1cm4gKFwiX2QoXCIgKyBzdGF0aWNQcm9wcyArIFwiLFtcIiArIChkeW5hbWljUHJvcHMuc2xpY2UoMCwgLTEpKSArIFwiXSlcIilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RhdGljUHJvcHNcbiAgfVxufVxuXG4vLyAjMzg5NSwgIzQyNjhcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyAodGV4dCkge1xuICByZXR1cm4gdGV4dFxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxufVxuXG4vKiAgKi9cblxuXG5cbi8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXG4vLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXG52YXIgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXG4gICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXG4gICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxifFxcXFxiJykgKyAnXFxcXGInKTtcblxuLy8gdGhlc2UgdW5hcnkgb3BlcmF0b3JzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eS9tZXRob2QgbmFtZXNcbnZhciB1bmFyeU9wZXJhdG9yc1JFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZGVsZXRlLHR5cGVvZix2b2lkJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCl8XFxcXGInKSArICdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpJyk7XG5cbi8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcbnZhciBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XG5cbi8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXG5mdW5jdGlvbiBkZXRlY3RFcnJvcnMgKGFzdCwgd2Fybikge1xuICBpZiAoYXN0KSB7XG4gICAgY2hlY2tOb2RlKGFzdCwgd2Fybik7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tOb2RlIChub2RlLCB3YXJuKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByYW5nZSA9IG5vZGUucmF3QXR0cnNNYXBbbmFtZV07XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcbiAgICAgICAgICAgIGNoZWNrRm9yKG5vZGUsIChcInYtZm9yPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIHdhcm4pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBub2RlLnRleHQsIHdhcm4sIG5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgdmFyIHN0aXBwZWQgPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJyk7XG4gIHZhciBrZXl3b3JkTWF0Y2ggPSBzdGlwcGVkLm1hdGNoKHVuYXJ5T3BlcmF0b3JzUkUpO1xuICBpZiAoa2V5d29yZE1hdGNoICYmIHN0aXBwZWQuY2hhckF0KGtleXdvcmRNYXRjaC5pbmRleCAtIDEpICE9PSAnJCcpIHtcbiAgICB3YXJuKFxuICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IHVuYXJ5IG9wZXJhdG9yIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSksXG4gICAgICByYW5nZVxuICAgICk7XG4gIH1cbiAgY2hlY2tFeHByZXNzaW9uKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpO1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZm9yIHx8ICcnLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjIsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIHdhcm4sIHJhbmdlKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyIChcbiAgaWRlbnQsXG4gIHR5cGUsXG4gIHRleHQsXG4gIHdhcm4sXG4gIHJhbmdlXG4pIHtcbiAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgbmV3IEZ1bmN0aW9uKChcInZhciBcIiArIGlkZW50ICsgXCI9X1wiKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybigoXCJpbnZhbGlkIFwiICsgdHlwZSArIFwiIFxcXCJcIiArIGlkZW50ICsgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSksIHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFeHByZXNzaW9uIChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKChcInJldHVybiBcIiArIGV4cCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCJcXG4gIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSksXG4gICAgICAgIHJhbmdlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImludmFsaWQgZXhwcmVzc2lvbjogXCIgKyAoZS5tZXNzYWdlKSArIFwiIGluXFxuXFxuXCIgK1xuICAgICAgICBcIiAgICBcIiArIGV4cCArIFwiXFxuXFxuXCIgK1xuICAgICAgICBcIiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSArIFwiXFxuXCIsXG4gICAgICAgIHJhbmdlXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHJhbmdlID0gMjtcblxuZnVuY3Rpb24gZ2VuZXJhdGVDb2RlRnJhbWUgKFxuICBzb3VyY2UsXG4gIHN0YXJ0LFxuICBlbmRcbikge1xuICBpZiAoIHN0YXJ0ID09PSB2b2lkIDAgKSBzdGFydCA9IDA7XG4gIGlmICggZW5kID09PSB2b2lkIDAgKSBlbmQgPSBzb3VyY2UubGVuZ3RoO1xuXG4gIHZhciBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvXFxyP1xcbi8pO1xuICB2YXIgY291bnQgPSAwO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3VudCArPSBsaW5lc1tpXS5sZW5ndGggKyAxO1xuICAgIGlmIChjb3VudCA+PSBzdGFydCkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xuICAgICAgICBpZiAoaiA8IDAgfHwgaiA+PSBsaW5lcy5sZW5ndGgpIHsgY29udGludWUgfVxuICAgICAgICByZXMucHVzaCgoXCJcIiArIChqICsgMSkgKyAocmVwZWF0JDEoXCIgXCIsIDMgLSBTdHJpbmcoaiArIDEpLmxlbmd0aCkpICsgXCJ8ICBcIiArIChsaW5lc1tqXSkpKTtcbiAgICAgICAgdmFyIGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XG4gICAgICAgIGlmIChqID09PSBpKSB7XG4gICAgICAgICAgLy8gcHVzaCB1bmRlcmxpbmVcbiAgICAgICAgICB2YXIgcGFkID0gc3RhcnQgLSAoY291bnQgLSBsaW5lTGVuZ3RoKSArIDE7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGVuZCA+IGNvdW50ID8gbGluZUxlbmd0aCAtIHBhZCA6IGVuZCAtIHN0YXJ0O1xuICAgICAgICAgIHJlcy5wdXNoKFwiICAgfCAgXCIgKyByZXBlYXQkMShcIiBcIiwgcGFkKSArIHJlcGVhdCQxKFwiXlwiLCBsZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChqID4gaSkge1xuICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCQxID0gTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpO1xuICAgICAgICAgICAgcmVzLnB1c2goXCIgICB8ICBcIiArIHJlcGVhdCQxKFwiXlwiLCBsZW5ndGgkMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy5qb2luKCdcXG4nKVxufVxuXG5mdW5jdGlvbiByZXBlYXQkMSAoc3RyLCBuKSB7XG4gIHZhciByZXN1bHQgPSAnJztcbiAgaWYgKG4gPiAwKSB7XG4gICAgd2hpbGUgKHRydWUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgaWYgKG4gJiAxKSB7IHJlc3VsdCArPSBzdHI7IH1cbiAgICAgIG4gPj4+PSAxO1xuICAgICAgaWYgKG4gPD0gMCkgeyBicmVhayB9XG4gICAgICBzdHIgKz0gc3RyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qICAqL1xuXG5cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4gKGNvbXBpbGUpIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zLFxuICAgIHZtXG4gICkge1xuICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICAgIHZhciB3YXJuJCQxID0gb3B0aW9ucy53YXJuIHx8IHdhcm47XG4gICAgZGVsZXRlIG9wdGlvbnMud2FybjtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIHtcbiAgICAgIC8vIGRldGVjdCBwb3NzaWJsZSBDU1AgcmVzdHJpY3Rpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIDEnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcbiAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgK1xuICAgICAgICAgICAgJ2Vudmlyb25tZW50IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgK1xuICAgICAgICAgICAgJ1RoZSB0ZW1wbGF0ZSBjb21waWxlciBjYW5ub3Qgd29yayBpbiB0aGlzIGVudmlyb25tZW50LiBDb25zaWRlciAnICtcbiAgICAgICAgICAgICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICtcbiAgICAgICAgICAgICd0ZW1wbGF0ZXMgaW50byByZW5kZXIgZnVuY3Rpb25zLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgY2FjaGVcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcbiAgICAgIDogdGVtcGxhdGU7XG4gICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgIHJldHVybiBjYWNoZVtrZXldXG4gICAgfVxuXG4gICAgLy8gY29tcGlsZVxuICAgIHZhciBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgY29tcGlsYXRpb24gZXJyb3JzL3RpcHNcbiAgICB7XG4gICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBjb21waWxlZC5lcnJvcnMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyAoZS5tc2cpICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgICAgIGdlbmVyYXRlQ29kZUZyYW1lKHRlbXBsYXRlLCBlLnN0YXJ0LCBlLmVuZCksXG4gICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIHRlbXBsYXRlICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoXCItIFwiICsgZSk7IH0pLmpvaW4oJ1xcbicpICsgJ1xcbicsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjb21waWxlZC50aXBzICYmIGNvbXBpbGVkLnRpcHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7IHJldHVybiB0aXAoZS5tc2csIHZtKTsgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGZuR2VuRXJyb3JzID0gW107XG4gICAgcmVzLnJlbmRlciA9IGNyZWF0ZUZ1bmN0aW9uKGNvbXBpbGVkLnJlbmRlciwgZm5HZW5FcnJvcnMpO1xuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb24oY29kZSwgZm5HZW5FcnJvcnMpXG4gICAgfSk7XG5cbiAgICAvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cbiAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxuICAgIC8vIG1vc3RseSBmb3IgY29kZWdlbiBkZXZlbG9wbWVudCB1c2VcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICB7XG4gICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgIFwiRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5cIiArXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSByZWYuZXJyO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSByZWYuY29kZTtcblxuICAgICAgICAgICAgcmV0dXJuICgoZXJyLnRvU3RyaW5nKCkpICsgXCIgaW5cXG5cXG5cIiArIGNvZGUgKyBcIlxcblwiKTtcbiAgICAgICAgfSkuam9pbignXFxuJyksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXMpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyQ3JlYXRvciAoYmFzZUNvbXBpbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGNvbXBpbGUgKFxuICAgICAgdGVtcGxhdGUsXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICB2YXIgZmluYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucyk7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB2YXIgdGlwcyA9IFtdO1xuXG4gICAgICB2YXIgd2FybiA9IGZ1bmN0aW9uIChtc2csIHJhbmdlLCB0aXApIHtcbiAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgICAgdmFyIGxlYWRpbmdTcGFjZUxlbmd0aCA9IHRlbXBsYXRlLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcblxuICAgICAgICAgIHdhcm4gPSBmdW5jdGlvbiAobXNnLCByYW5nZSwgdGlwKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHsgbXNnOiBtc2cgfTtcbiAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGEuc3RhcnQgPSByYW5nZS5zdGFydCArIGxlYWRpbmdTcGFjZUxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmVuZCA9IHJhbmdlLmVuZCArIGxlYWRpbmdTcGFjZUxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2goZGF0YSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSBjdXN0b20gbW9kdWxlc1xuICAgICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPVxuICAgICAgICAgICAgKGJhc2VPcHRpb25zLm1vZHVsZXMgfHwgW10pLmNvbmNhdChvcHRpb25zLm1vZHVsZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBkaXJlY3RpdmVzXG4gICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcbiAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMuZGlyZWN0aXZlcyB8fCBudWxsKSxcbiAgICAgICAgICAgIG9wdGlvbnMuZGlyZWN0aXZlc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29weSBvdGhlciBvcHRpb25zXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKGtleSAhPT0gJ21vZHVsZXMnICYmIGtleSAhPT0gJ2RpcmVjdGl2ZXMnKSB7XG4gICAgICAgICAgICBmaW5hbE9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZmluYWxPcHRpb25zLndhcm4gPSB3YXJuO1xuXG4gICAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZS50cmltKCksIGZpbmFsT3B0aW9ucyk7XG4gICAgICB7XG4gICAgICAgIGRldGVjdEVycm9ycyhjb21waWxlZC5hc3QsIHdhcm4pO1xuICAgICAgfVxuICAgICAgY29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgY29tcGlsZWQudGlwcyA9IHRpcHM7XG4gICAgICByZXR1cm4gY29tcGlsZWRcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29tcGlsZTogY29tcGlsZSxcbiAgICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25Gbihjb21waWxlKVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxuLy8gcGFyc2VyL29wdGltaXplci9jb2RlZ2VuLCBlLmcgdGhlIFNTUiBvcHRpbWl6aW5nIGNvbXBpbGVyLlxuLy8gSGVyZSB3ZSBqdXN0IGV4cG9ydCBhIGRlZmF1bHQgY29tcGlsZXIgdXNpbmcgdGhlIGRlZmF1bHQgcGFydHMuXG52YXIgY3JlYXRlQ29tcGlsZXIgPSBjcmVhdGVDb21waWxlckNyZWF0b3IoZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuICBpZiAob3B0aW9ucy5vcHRpbWl6ZSAhPT0gZmFsc2UpIHtcbiAgICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICB9XG4gIHZhciBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBhc3Q6IGFzdCxcbiAgICByZW5kZXI6IGNvZGUucmVuZGVyLFxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmJDEgPSBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucyk7XG52YXIgY29tcGlsZSA9IHJlZiQxLmNvbXBpbGU7XG52YXIgY29tcGlsZVRvRnVuY3Rpb25zID0gcmVmJDEuY29tcGlsZVRvRnVuY3Rpb25zO1xuXG4vKiAgKi9cblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbnZhciBkaXY7XG5mdW5jdGlvbiBnZXRTaG91bGREZWNvZGUgKGhyZWYpIHtcbiAgZGl2ID0gZGl2IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gaHJlZiA/IFwiPGEgaHJlZj1cXFwiXFxuXFxcIi8+XCIgOiBcIjxkaXYgYT1cXFwiXFxuXFxcIi8+XCI7XG4gIHJldHVybiBkaXYuaW5uZXJIVE1MLmluZGV4T2YoJyYjMTA7JykgPiAwXG59XG5cbi8vICMzNjYzOiBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUoZmFsc2UpIDogZmFsc2U7XG4vLyAjNjgyODogY2hyb21lIGVuY29kZXMgY29udGVudCBpbiBhW2hyZWZdXG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKHRydWUpIDogZmFsc2U7XG5cbi8qICAqL1xuXG52YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xuICB2YXIgZWwgPSBxdWVyeShpZCk7XG4gIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUxcbn0pO1xuXG52YXIgbW91bnQgPSBWdWUucHJvdG90eXBlLiRtb3VudDtcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBxdWVyeShlbCk7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgd2FybihcbiAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIChcIlRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiBcIiArIChvcHRpb25zLnRlbXBsYXRlKSksXG4gICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVmID0gY29tcGlsZVRvRnVuY3Rpb25zKHRlbXBsYXRlLCB7XG4gICAgICAgIG91dHB1dFNvdXJjZVJhbmdlOiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyxcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IHNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzLFxuICAgICAgICBjb21tZW50czogb3B0aW9ucy5jb21tZW50c1xuICAgICAgfSwgdGhpcyk7XG4gICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodGhpcy5fbmFtZSkgKyBcIiBjb21waWxlXCIpLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgIHJldHVybiBlbC5vdXRlckhUTUxcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcbiAgfVxufVxuXG5WdWUuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxubW9kdWxlLmV4cG9ydHMgPSBWdWU7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vue/dist/vue.common.dev.js\n");

/***/ }),

/***/ "./node_modules/vue/dist/vue.common.js":
/*!*********************************************!*\
  !*** ./node_modules/vue/dist/vue.common.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("if (false) {} else {\n  module.exports = __webpack_require__(/*! ./vue.common.dev.js */ \"./node_modules/vue/dist/vue.common.dev.js\")\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmNvbW1vbi5qcz81ZWU1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLElBQUksS0FBcUMsRUFBRSxFQUUxQztBQUNELG1CQUFtQixtQkFBTyxDQUFDLHNFQUFxQjtBQUNoRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUuY29tbW9uLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3Z1ZS5jb21tb24ucHJvZC5qcycpXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vdnVlLmNvbW1vbi5kZXYuanMnKVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue/dist/vue.common.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./resources/js/app.js":
/*!*****************************!*\
  !*** ./resources/js/app.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * First we will load all of this project's JavaScript dependencies which\n * includes Vue and other libraries. It is a great starting point when\n * building robust, powerful web applications using Vue and Laravel.\n */\n__webpack_require__(/*! ./common_scripts */ \"./resources/js/common_scripts.js\");\n\n__webpack_require__(/*! ./main */ \"./resources/js/main.js\");\n\n__webpack_require__(/*! ./validate */ \"./resources/js/validate.js\");\n\nwindow.Vue = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.common.js\");\n/**\n * The following block of code may be used to automatically register your\n * Vue components. It will recursively scan this directory for the Vue\n * components and automatically register them with their \"basename\".\n *\n * Eg. ./components/ExampleComponent.vue -> <example-component></example-component>\n */\n// const files = require.context('./', true, /\\.vue$/i);\n// files.keys().map(key => Vue.component(key.split('/').pop().split('.')[0], files(key).default));\n\nVue.component('example-component', __webpack_require__(/*! ./components/ExampleComponent.vue */ \"./resources/js/components/ExampleComponent.vue\")[\"default\"]);\n/**\n * Next, we will create a fresh Vue application instance and attach it to\n * the page. Then, you may begin adding components to this application\n * or customize the JavaScript scaffolding to fit your unique needs.\n */\n\nvar app = new Vue({\n  el: '#app'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvYXBwLmpzPzZkNDAiXSwibmFtZXMiOlsicmVxdWlyZSIsIndpbmRvdyIsIlZ1ZSIsImNvbXBvbmVudCIsImFwcCIsImVsIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7QUFNQUEsbUJBQU8sQ0FBQywwREFBRCxDQUFQOztBQUNBQSxtQkFBTyxDQUFDLHNDQUFELENBQVA7O0FBQ0FBLG1CQUFPLENBQUMsOENBQUQsQ0FBUDs7QUFFQUMsTUFBTSxDQUFDQyxHQUFQLEdBQWFGLG1CQUFPLENBQUMsa0RBQUQsQ0FBcEI7QUFFQTs7Ozs7OztBQVFBO0FBQ0E7O0FBRUFFLEdBQUcsQ0FBQ0MsU0FBSixDQUFjLG1CQUFkLEVBQW1DSCxtQkFBTyxDQUFDLHlGQUFELENBQVAsV0FBbkM7QUFFQTs7Ozs7O0FBTUEsSUFBTUksR0FBRyxHQUFHLElBQUlGLEdBQUosQ0FBUTtBQUNoQkcsSUFBRSxFQUFFO0FBRFksQ0FBUixDQUFaIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL2pzL2FwcC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRmlyc3Qgd2Ugd2lsbCBsb2FkIGFsbCBvZiB0aGlzIHByb2plY3QncyBKYXZhU2NyaXB0IGRlcGVuZGVuY2llcyB3aGljaFxuICogaW5jbHVkZXMgVnVlIGFuZCBvdGhlciBsaWJyYXJpZXMuIEl0IGlzIGEgZ3JlYXQgc3RhcnRpbmcgcG9pbnQgd2hlblxuICogYnVpbGRpbmcgcm9idXN0LCBwb3dlcmZ1bCB3ZWIgYXBwbGljYXRpb25zIHVzaW5nIFZ1ZSBhbmQgTGFyYXZlbC5cbiAqL1xuXG5yZXF1aXJlKCcuL2NvbW1vbl9zY3JpcHRzJyk7XG5yZXF1aXJlKCcuL21haW4nKTtcbnJlcXVpcmUoJy4vdmFsaWRhdGUnKTtcblxud2luZG93LlZ1ZSA9IHJlcXVpcmUoJ3Z1ZScpO1xuXG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgYmxvY2sgb2YgY29kZSBtYXkgYmUgdXNlZCB0byBhdXRvbWF0aWNhbGx5IHJlZ2lzdGVyIHlvdXJcbiAqIFZ1ZSBjb21wb25lbnRzLiBJdCB3aWxsIHJlY3Vyc2l2ZWx5IHNjYW4gdGhpcyBkaXJlY3RvcnkgZm9yIHRoZSBWdWVcbiAqIGNvbXBvbmVudHMgYW5kIGF1dG9tYXRpY2FsbHkgcmVnaXN0ZXIgdGhlbSB3aXRoIHRoZWlyIFwiYmFzZW5hbWVcIi5cbiAqXG4gKiBFZy4gLi9jb21wb25lbnRzL0V4YW1wbGVDb21wb25lbnQudnVlIC0+IDxleGFtcGxlLWNvbXBvbmVudD48L2V4YW1wbGUtY29tcG9uZW50PlxuICovXG5cbi8vIGNvbnN0IGZpbGVzID0gcmVxdWlyZS5jb250ZXh0KCcuLycsIHRydWUsIC9cXC52dWUkL2kpO1xuLy8gZmlsZXMua2V5cygpLm1hcChrZXkgPT4gVnVlLmNvbXBvbmVudChrZXkuc3BsaXQoJy8nKS5wb3AoKS5zcGxpdCgnLicpWzBdLCBmaWxlcyhrZXkpLmRlZmF1bHQpKTtcblxuVnVlLmNvbXBvbmVudCgnZXhhbXBsZS1jb21wb25lbnQnLCByZXF1aXJlKCcuL2NvbXBvbmVudHMvRXhhbXBsZUNvbXBvbmVudC52dWUnKS5kZWZhdWx0KTtcblxuLyoqXG4gKiBOZXh0LCB3ZSB3aWxsIGNyZWF0ZSBhIGZyZXNoIFZ1ZSBhcHBsaWNhdGlvbiBpbnN0YW5jZSBhbmQgYXR0YWNoIGl0IHRvXG4gKiB0aGUgcGFnZS4gVGhlbiwgeW91IG1heSBiZWdpbiBhZGRpbmcgY29tcG9uZW50cyB0byB0aGlzIGFwcGxpY2F0aW9uXG4gKiBvciBjdXN0b21pemUgdGhlIEphdmFTY3JpcHQgc2NhZmZvbGRpbmcgdG8gZml0IHlvdXIgdW5pcXVlIG5lZWRzLlxuICovXG5cbmNvbnN0IGFwcCA9IG5ldyBWdWUoe1xuICAgIGVsOiAnI2FwcCcsXG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/app.js\n");

/***/ }),

/***/ "./resources/js/common_scripts.js":
/*!****************************************!*\
  !*** ./resources/js/common_scripts.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*\nPOPPER.MIN.JS\n Copyright (C) Federico Zivolo 2017\n Distributed under the MIT License (license terms are at http://opensource.org/licenses/MIT).\n */\n(function (e, t) {\n  'object' == ( false ? undefined : _typeof(exports)) && 'undefined' != typeof module ? module.exports = t() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (t),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;\n})(this, function () {\n  'use strict';\n\n  function e(e) {\n    return e && '[object Function]' === {}.toString.call(e);\n  }\n\n  function t(e, t) {\n    if (1 !== e.nodeType) return [];\n    var o = window.getComputedStyle(e, null);\n    return t ? o[t] : o;\n  }\n\n  function o(e) {\n    return 'HTML' === e.nodeName ? e : e.parentNode || e.host;\n  }\n\n  function n(e) {\n    if (!e || -1 !== ['HTML', 'BODY', '#document'].indexOf(e.nodeName)) return window.document.body;\n    var i = t(e),\n        r = i.overflow,\n        p = i.overflowX,\n        s = i.overflowY;\n    return /(auto|scroll)/.test(r + s + p) ? e : n(o(e));\n  }\n\n  function r(e) {\n    var o = e && e.offsetParent,\n        i = o && o.nodeName;\n    return i && 'BODY' !== i && 'HTML' !== i ? -1 !== ['TD', 'TABLE'].indexOf(o.nodeName) && 'static' === t(o, 'position') ? r(o) : o : window.document.documentElement;\n  }\n\n  function p(e) {\n    var t = e.nodeName;\n    return 'BODY' !== t && ('HTML' === t || r(e.firstElementChild) === e);\n  }\n\n  function s(e) {\n    return null === e.parentNode ? e : s(e.parentNode);\n  }\n\n  function d(e, t) {\n    if (!e || !e.nodeType || !t || !t.nodeType) return window.document.documentElement;\n    var o = e.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_FOLLOWING,\n        i = o ? e : t,\n        n = o ? t : e,\n        a = document.createRange();\n    a.setStart(i, 0), a.setEnd(n, 0);\n    var f = a.commonAncestorContainer;\n    if (e !== f && t !== f || i.contains(n)) return p(f) ? f : r(f);\n    var l = s(e);\n    return l.host ? d(l.host, t) : d(e, s(t).host);\n  }\n\n  function a(e) {\n    var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 'top',\n        o = 'top' === t ? 'scrollTop' : 'scrollLeft',\n        i = e.nodeName;\n\n    if ('BODY' === i || 'HTML' === i) {\n      var n = window.document.documentElement,\n          r = window.document.scrollingElement || n;\n      return r[o];\n    }\n\n    return e[o];\n  }\n\n  function f(e, t) {\n    var o = 2 < arguments.length && void 0 !== arguments[2] && arguments[2],\n        i = a(t, 'top'),\n        n = a(t, 'left'),\n        r = o ? -1 : 1;\n    return e.top += i * r, e.bottom += i * r, e.left += n * r, e.right += n * r, e;\n  }\n\n  function l(e, t) {\n    var o = 'x' === t ? 'Left' : 'Top',\n        i = 'Left' == o ? 'Right' : 'Bottom';\n    return +e['border' + o + 'Width'].split('px')[0] + +e['border' + i + 'Width'].split('px')[0];\n  }\n\n  function m(e, t, o, i) {\n    return _(t['offset' + e], o['client' + e], o['offset' + e], ie() ? o['offset' + e] + i['margin' + ('Height' === e ? 'Top' : 'Left')] + i['margin' + ('Height' === e ? 'Bottom' : 'Right')] : 0);\n  }\n\n  function h() {\n    var e = window.document.body,\n        t = window.document.documentElement,\n        o = ie() && window.getComputedStyle(t);\n    return {\n      height: m('Height', e, t, o),\n      width: m('Width', e, t, o)\n    };\n  }\n\n  function c(e) {\n    return se({}, e, {\n      right: e.left + e.width,\n      bottom: e.top + e.height\n    });\n  }\n\n  function g(e) {\n    var o = {};\n    if (ie()) try {\n      o = e.getBoundingClientRect();\n      var i = a(e, 'top'),\n          n = a(e, 'left');\n      o.top += i, o.left += n, o.bottom += i, o.right += n;\n    } catch (e) {} else o = e.getBoundingClientRect();\n    var r = {\n      left: o.left,\n      top: o.top,\n      width: o.right - o.left,\n      height: o.bottom - o.top\n    },\n        p = 'HTML' === e.nodeName ? h() : {},\n        s = p.width || e.clientWidth || r.right - r.left,\n        d = p.height || e.clientHeight || r.bottom - r.top,\n        f = e.offsetWidth - s,\n        m = e.offsetHeight - d;\n\n    if (f || m) {\n      var g = t(e);\n      f -= l(g, 'x'), m -= l(g, 'y'), r.width -= f, r.height -= m;\n    }\n\n    return c(r);\n  }\n\n  function u(e, o) {\n    var i = ie(),\n        r = 'HTML' === o.nodeName,\n        p = g(e),\n        s = g(o),\n        d = n(e),\n        a = t(o),\n        l = +a.borderTopWidth.split('px')[0],\n        m = +a.borderLeftWidth.split('px')[0],\n        h = c({\n      top: p.top - s.top - l,\n      left: p.left - s.left - m,\n      width: p.width,\n      height: p.height\n    });\n\n    if (h.marginTop = 0, h.marginLeft = 0, !i && r) {\n      var u = +a.marginTop.split('px')[0],\n          b = +a.marginLeft.split('px')[0];\n      h.top -= l - u, h.bottom -= l - u, h.left -= m - b, h.right -= m - b, h.marginTop = u, h.marginLeft = b;\n    }\n\n    return (i ? o.contains(d) : o === d && 'BODY' !== d.nodeName) && (h = f(h, o)), h;\n  }\n\n  function b(e) {\n    var t = window.document.documentElement,\n        o = u(e, t),\n        i = _(t.clientWidth, window.innerWidth || 0),\n        n = _(t.clientHeight, window.innerHeight || 0),\n        r = a(t),\n        p = a(t, 'left'),\n        s = {\n      top: r - o.top + o.marginTop,\n      left: p - o.left + o.marginLeft,\n      width: i,\n      height: n\n    };\n\n    return c(s);\n  }\n\n  function y(e) {\n    var i = e.nodeName;\n    return 'BODY' === i || 'HTML' === i ? !1 : 'fixed' === t(e, 'position') || y(o(e));\n  }\n\n  function w(e, t, i, r) {\n    var p = {\n      top: 0,\n      left: 0\n    },\n        s = d(e, t);\n    if ('viewport' === r) p = b(s);else {\n      var a;\n      'scrollParent' === r ? (a = n(o(e)), 'BODY' === a.nodeName && (a = window.document.documentElement)) : 'window' === r ? a = window.document.documentElement : a = r;\n      var f = u(a, s);\n\n      if ('HTML' === a.nodeName && !y(s)) {\n        var l = h(),\n            m = l.height,\n            c = l.width;\n        p.top += f.top - f.marginTop, p.bottom = m + f.top, p.left += f.left - f.marginLeft, p.right = c + f.left;\n      } else p = f;\n    }\n    return p.left += i, p.top += i, p.right -= i, p.bottom -= i, p;\n  }\n\n  function v(e) {\n    var t = e.width,\n        o = e.height;\n    return t * o;\n  }\n\n  function E(e, t, o, i, n) {\n    var r = 5 < arguments.length && void 0 !== arguments[5] ? arguments[5] : 0;\n    if (-1 === e.indexOf('auto')) return e;\n    var p = w(o, i, r, n),\n        s = {\n      top: {\n        width: p.width,\n        height: t.top - p.top\n      },\n      right: {\n        width: p.right - t.right,\n        height: p.height\n      },\n      bottom: {\n        width: p.width,\n        height: p.bottom - t.bottom\n      },\n      left: {\n        width: t.left - p.left,\n        height: p.height\n      }\n    },\n        d = Object.keys(s).map(function (e) {\n      return se({\n        key: e\n      }, s[e], {\n        area: v(s[e])\n      });\n    }).sort(function (e, t) {\n      return t.area - e.area;\n    }),\n        a = d.filter(function (e) {\n      var t = e.width,\n          i = e.height;\n      return t >= o.clientWidth && i >= o.clientHeight;\n    }),\n        f = 0 < a.length ? a[0].key : d[0].key,\n        l = e.split('-')[1];\n    return f + (l ? '-' + l : '');\n  }\n\n  function x(e, t, o) {\n    var i = d(t, o);\n    return u(o, i);\n  }\n\n  function O(e) {\n    var t = window.getComputedStyle(e),\n        o = parseFloat(t.marginTop) + parseFloat(t.marginBottom),\n        i = parseFloat(t.marginLeft) + parseFloat(t.marginRight),\n        n = {\n      width: e.offsetWidth + i,\n      height: e.offsetHeight + o\n    };\n    return n;\n  }\n\n  function L(e) {\n    var t = {\n      left: 'right',\n      right: 'left',\n      bottom: 'top',\n      top: 'bottom'\n    };\n    return e.replace(/left|right|bottom|top/g, function (e) {\n      return t[e];\n    });\n  }\n\n  function S(e, t, o) {\n    o = o.split('-')[0];\n    var i = O(e),\n        n = {\n      width: i.width,\n      height: i.height\n    },\n        r = -1 !== ['right', 'left'].indexOf(o),\n        p = r ? 'top' : 'left',\n        s = r ? 'left' : 'top',\n        d = r ? 'height' : 'width',\n        a = r ? 'width' : 'height';\n    return n[p] = t[p] + t[d] / 2 - i[d] / 2, n[s] = o === s ? t[s] - i[a] : t[L(s)], n;\n  }\n\n  function T(e, t) {\n    return Array.prototype.find ? e.find(t) : e.filter(t)[0];\n  }\n\n  function C(e, t, o) {\n    if (Array.prototype.findIndex) return e.findIndex(function (e) {\n      return e[t] === o;\n    });\n    var i = T(e, function (e) {\n      return e[t] === o;\n    });\n    return e.indexOf(i);\n  }\n\n  function N(t, o, i) {\n    var n = void 0 === i ? t : t.slice(0, C(t, 'name', i));\n    return n.forEach(function (t) {\n      t[\"function\"] && console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n      var i = t[\"function\"] || t.fn;\n      t.enabled && e(i) && (o.offsets.popper = c(o.offsets.popper), o.offsets.reference = c(o.offsets.reference), o = i(o, t));\n    }), o;\n  }\n\n  function k() {\n    if (!this.state.isDestroyed) {\n      var e = {\n        instance: this,\n        styles: {},\n        attributes: {},\n        flipped: !1,\n        offsets: {}\n      };\n      e.offsets.reference = x(this.state, this.popper, this.reference), e.placement = E(this.options.placement, e.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), e.originalPlacement = e.placement, e.offsets.popper = S(this.popper, e.offsets.reference, e.placement), e.offsets.popper.position = 'absolute', e = N(this.modifiers, e), this.state.isCreated ? this.options.onUpdate(e) : (this.state.isCreated = !0, this.options.onCreate(e));\n    }\n  }\n\n  function W(e, t) {\n    return e.some(function (e) {\n      var o = e.name,\n          i = e.enabled;\n      return i && o === t;\n    });\n  }\n\n  function B(e) {\n    for (var t = [!1, 'ms', 'Webkit', 'Moz', 'O'], o = e.charAt(0).toUpperCase() + e.slice(1), n = 0; n < t.length - 1; n++) {\n      var i = t[n],\n          r = i ? '' + i + o : e;\n      if ('undefined' != typeof window.document.body.style[r]) return r;\n    }\n\n    return null;\n  }\n\n  function D() {\n    return this.state.isDestroyed = !0, W(this.modifiers, 'applyStyle') && (this.popper.removeAttribute('x-placement'), this.popper.style.left = '', this.popper.style.position = '', this.popper.style.top = '', this.popper.style[B('transform')] = ''), this.disableEventListeners(), this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper), this;\n  }\n\n  function H(e, t, o, i) {\n    var r = 'BODY' === e.nodeName,\n        p = r ? window : e;\n    p.addEventListener(t, o, {\n      passive: !0\n    }), r || H(n(p.parentNode), t, o, i), i.push(p);\n  }\n\n  function P(e, t, o, i) {\n    o.updateBound = i, window.addEventListener('resize', o.updateBound, {\n      passive: !0\n    });\n    var r = n(e);\n    return H(r, 'scroll', o.updateBound, o.scrollParents), o.scrollElement = r, o.eventsEnabled = !0, o;\n  }\n\n  function A() {\n    this.state.eventsEnabled || (this.state = P(this.reference, this.options, this.state, this.scheduleUpdate));\n  }\n\n  function M(e, t) {\n    return window.removeEventListener('resize', t.updateBound), t.scrollParents.forEach(function (e) {\n      e.removeEventListener('scroll', t.updateBound);\n    }), t.updateBound = null, t.scrollParents = [], t.scrollElement = null, t.eventsEnabled = !1, t;\n  }\n\n  function I() {\n    this.state.eventsEnabled && (window.cancelAnimationFrame(this.scheduleUpdate), this.state = M(this.reference, this.state));\n  }\n\n  function R(e) {\n    return '' !== e && !isNaN(parseFloat(e)) && isFinite(e);\n  }\n\n  function U(e, t) {\n    Object.keys(t).forEach(function (o) {\n      var i = '';\n      -1 !== ['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(o) && R(t[o]) && (i = 'px'), e.style[o] = t[o] + i;\n    });\n  }\n\n  function Y(e, t) {\n    Object.keys(t).forEach(function (o) {\n      var i = t[o];\n      !1 === i ? e.removeAttribute(o) : e.setAttribute(o, t[o]);\n    });\n  }\n\n  function F(e, t, o) {\n    var i = T(e, function (e) {\n      var o = e.name;\n      return o === t;\n    }),\n        n = !!i && e.some(function (e) {\n      return e.name === o && e.enabled && e.order < i.order;\n    });\n\n    if (!n) {\n      var r = '`' + t + '`';\n      console.warn('`' + o + '`' + ' modifier is required by ' + r + ' modifier in order to work, be sure to include it before ' + r + '!');\n    }\n\n    return n;\n  }\n\n  function j(e) {\n    return 'end' === e ? 'start' : 'start' === e ? 'end' : e;\n  }\n\n  function K(e) {\n    var t = 1 < arguments.length && void 0 !== arguments[1] && arguments[1],\n        o = ae.indexOf(e),\n        i = ae.slice(o + 1).concat(ae.slice(0, o));\n    return t ? i.reverse() : i;\n  }\n\n  function q(e, t, o, i) {\n    var n = e.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/),\n        r = +n[1],\n        p = n[2];\n    if (!r) return e;\n\n    if (0 === p.indexOf('%')) {\n      var s;\n\n      switch (p) {\n        case '%p':\n          s = o;\n          break;\n\n        case '%':\n        case '%r':\n        default:\n          s = i;\n      }\n\n      var d = c(s);\n      return d[t] / 100 * r;\n    }\n\n    if ('vh' === p || 'vw' === p) {\n      var a;\n      return a = 'vh' === p ? _(document.documentElement.clientHeight, window.innerHeight || 0) : _(document.documentElement.clientWidth, window.innerWidth || 0), a / 100 * r;\n    }\n\n    return r;\n  }\n\n  function G(e, t, o, i) {\n    var n = [0, 0],\n        r = -1 !== ['right', 'left'].indexOf(i),\n        p = e.split(/(\\+|\\-)/).map(function (e) {\n      return e.trim();\n    }),\n        s = p.indexOf(T(p, function (e) {\n      return -1 !== e.search(/,|\\s/);\n    }));\n    p[s] && -1 === p[s].indexOf(',') && console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');\n    var d = /\\s*,\\s*|\\s+/,\n        a = -1 === s ? [p] : [p.slice(0, s).concat([p[s].split(d)[0]]), [p[s].split(d)[1]].concat(p.slice(s + 1))];\n    return a = a.map(function (e, i) {\n      var n = (1 === i ? !r : r) ? 'height' : 'width',\n          p = !1;\n      return e.reduce(function (e, t) {\n        return '' === e[e.length - 1] && -1 !== ['+', '-'].indexOf(t) ? (e[e.length - 1] = t, p = !0, e) : p ? (e[e.length - 1] += t, p = !1, e) : e.concat(t);\n      }, []).map(function (e) {\n        return q(e, n, t, o);\n      });\n    }), a.forEach(function (e, t) {\n      e.forEach(function (o, i) {\n        R(o) && (n[t] += o * ('-' === e[i - 1] ? -1 : 1));\n      });\n    }), n;\n  }\n\n  for (var z = Math.min, V = Math.floor, _ = Math.max, X = ['native code', '[object MutationObserverConstructor]'], Q = function Q(e) {\n    return X.some(function (t) {\n      return -1 < (e || '').toString().indexOf(t);\n    });\n  }, J = 'undefined' != typeof window, Z = ['Edge', 'Trident', 'Firefox'], $ = 0, ee = 0; ee < Z.length; ee += 1) {\n    if (J && 0 <= navigator.userAgent.indexOf(Z[ee])) {\n      $ = 1;\n      break;\n    }\n  }\n\n  var i,\n      te = J && Q(window.MutationObserver),\n      oe = te ? function (e) {\n    var t = !1,\n        o = 0,\n        i = document.createElement('span'),\n        n = new MutationObserver(function () {\n      e(), t = !1;\n    });\n    return n.observe(i, {\n      attributes: !0\n    }), function () {\n      t || (t = !0, i.setAttribute('x-index', o), ++o);\n    };\n  } : function (e) {\n    var t = !1;\n    return function () {\n      t || (t = !0, setTimeout(function () {\n        t = !1, e();\n      }, $));\n    };\n  },\n      ie = function ie() {\n    return void 0 == i && (i = -1 !== navigator.appVersion.indexOf('MSIE 10')), i;\n  },\n      ne = function ne(e, t) {\n    if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function');\n  },\n      re = function () {\n    function e(e, t) {\n      for (var o, n = 0; n < t.length; n++) {\n        o = t[n], o.enumerable = o.enumerable || !1, o.configurable = !0, 'value' in o && (o.writable = !0), Object.defineProperty(e, o.key, o);\n      }\n    }\n\n    return function (t, o, i) {\n      return o && e(t.prototype, o), i && e(t, i), t;\n    };\n  }(),\n      pe = function pe(e, t, o) {\n    return t in e ? Object.defineProperty(e, t, {\n      value: o,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : e[t] = o, e;\n  },\n      se = Object.assign || function (e) {\n    for (var t, o = 1; o < arguments.length; o++) {\n      for (var i in t = arguments[o], t) {\n        Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);\n      }\n    }\n\n    return e;\n  },\n      de = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'],\n      ae = de.slice(3),\n      fe = {\n    FLIP: 'flip',\n    CLOCKWISE: 'clockwise',\n    COUNTERCLOCKWISE: 'counterclockwise'\n  },\n      le = function () {\n    function t(o, i) {\n      var n = this,\n          r = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {};\n      ne(this, t), this.scheduleUpdate = function () {\n        return requestAnimationFrame(n.update);\n      }, this.update = oe(this.update.bind(this)), this.options = se({}, t.Defaults, r), this.state = {\n        isDestroyed: !1,\n        isCreated: !1,\n        scrollParents: []\n      }, this.reference = o.jquery ? o[0] : o, this.popper = i.jquery ? i[0] : i, this.options.modifiers = {}, Object.keys(se({}, t.Defaults.modifiers, r.modifiers)).forEach(function (e) {\n        n.options.modifiers[e] = se({}, t.Defaults.modifiers[e] || {}, r.modifiers ? r.modifiers[e] : {});\n      }), this.modifiers = Object.keys(this.options.modifiers).map(function (e) {\n        return se({\n          name: e\n        }, n.options.modifiers[e]);\n      }).sort(function (e, t) {\n        return e.order - t.order;\n      }), this.modifiers.forEach(function (t) {\n        t.enabled && e(t.onLoad) && t.onLoad(n.reference, n.popper, n.options, t, n.state);\n      }), this.update();\n      var p = this.options.eventsEnabled;\n      p && this.enableEventListeners(), this.state.eventsEnabled = p;\n    }\n\n    return re(t, [{\n      key: 'update',\n      value: function value() {\n        return k.call(this);\n      }\n    }, {\n      key: 'destroy',\n      value: function value() {\n        return D.call(this);\n      }\n    }, {\n      key: 'enableEventListeners',\n      value: function value() {\n        return A.call(this);\n      }\n    }, {\n      key: 'disableEventListeners',\n      value: function value() {\n        return I.call(this);\n      }\n    }]), t;\n  }();\n\n  return le.Utils = ('undefined' == typeof window ? global : window).PopperUtils, le.placements = de, le.Defaults = {\n    placement: 'bottom',\n    eventsEnabled: !0,\n    removeOnDestroy: !1,\n    onCreate: function onCreate() {},\n    onUpdate: function onUpdate() {},\n    modifiers: {\n      shift: {\n        order: 100,\n        enabled: !0,\n        fn: function fn(e) {\n          var t = e.placement,\n              o = t.split('-')[0],\n              i = t.split('-')[1];\n\n          if (i) {\n            var n = e.offsets,\n                r = n.reference,\n                p = n.popper,\n                s = -1 !== ['bottom', 'top'].indexOf(o),\n                d = s ? 'left' : 'top',\n                a = s ? 'width' : 'height',\n                f = {\n              start: pe({}, d, r[d]),\n              end: pe({}, d, r[d] + r[a] - p[a])\n            };\n            e.offsets.popper = se({}, p, f[i]);\n          }\n\n          return e;\n        }\n      },\n      offset: {\n        order: 200,\n        enabled: !0,\n        fn: function fn(e, t) {\n          var o,\n              i = t.offset,\n              n = e.placement,\n              r = e.offsets,\n              p = r.popper,\n              s = r.reference,\n              d = n.split('-')[0];\n          return o = R(+i) ? [+i, 0] : G(i, p, s, d), 'left' === d ? (p.top += o[0], p.left -= o[1]) : 'right' === d ? (p.top += o[0], p.left += o[1]) : 'top' === d ? (p.left += o[0], p.top -= o[1]) : 'bottom' === d && (p.left += o[0], p.top += o[1]), e.popper = p, e;\n        },\n        offset: 0\n      },\n      preventOverflow: {\n        order: 300,\n        enabled: !0,\n        fn: function fn(e, t) {\n          var o = t.boundariesElement || r(e.instance.popper);\n          e.instance.reference === o && (o = r(o));\n          var i = w(e.instance.popper, e.instance.reference, t.padding, o);\n          t.boundaries = i;\n          var n = t.priority,\n              p = e.offsets.popper,\n              s = {\n            primary: function primary(e) {\n              var o = p[e];\n              return p[e] < i[e] && !t.escapeWithReference && (o = _(p[e], i[e])), pe({}, e, o);\n            },\n            secondary: function secondary(e) {\n              var o = 'right' === e ? 'left' : 'top',\n                  n = p[o];\n              return p[e] > i[e] && !t.escapeWithReference && (n = z(p[o], i[e] - ('right' === e ? p.width : p.height))), pe({}, o, n);\n            }\n          };\n          return n.forEach(function (e) {\n            var t = -1 === ['left', 'top'].indexOf(e) ? 'secondary' : 'primary';\n            p = se({}, p, s[t](e));\n          }), e.offsets.popper = p, e;\n        },\n        priority: ['left', 'right', 'top', 'bottom'],\n        padding: 5,\n        boundariesElement: 'scrollParent'\n      },\n      keepTogether: {\n        order: 400,\n        enabled: !0,\n        fn: function fn(e) {\n          var t = e.offsets,\n              o = t.popper,\n              i = t.reference,\n              n = e.placement.split('-')[0],\n              r = V,\n              p = -1 !== ['top', 'bottom'].indexOf(n),\n              s = p ? 'right' : 'bottom',\n              d = p ? 'left' : 'top',\n              a = p ? 'width' : 'height';\n          return o[s] < r(i[d]) && (e.offsets.popper[d] = r(i[d]) - o[a]), o[d] > r(i[s]) && (e.offsets.popper[d] = r(i[s])), e;\n        }\n      },\n      arrow: {\n        order: 500,\n        enabled: !0,\n        fn: function fn(e, t) {\n          if (!F(e.instance.modifiers, 'arrow', 'keepTogether')) return e;\n          var o = t.element;\n\n          if ('string' == typeof o) {\n            if (o = e.instance.popper.querySelector(o), !o) return e;\n          } else if (!e.instance.popper.contains(o)) return console.warn('WARNING: `arrow.element` must be child of its popper element!'), e;\n\n          var i = e.placement.split('-')[0],\n              n = e.offsets,\n              r = n.popper,\n              p = n.reference,\n              s = -1 !== ['left', 'right'].indexOf(i),\n              d = s ? 'height' : 'width',\n              a = s ? 'top' : 'left',\n              f = s ? 'left' : 'top',\n              l = s ? 'bottom' : 'right',\n              m = O(o)[d];\n          p[l] - m < r[a] && (e.offsets.popper[a] -= r[a] - (p[l] - m)), p[a] + m > r[l] && (e.offsets.popper[a] += p[a] + m - r[l]);\n          var h = p[a] + p[d] / 2 - m / 2,\n              g = h - c(e.offsets.popper)[a];\n          return g = _(z(r[d] - m, g), 0), e.arrowElement = o, e.offsets.arrow = {}, e.offsets.arrow[a] = Math.round(g), e.offsets.arrow[f] = '', e;\n        },\n        element: '[x-arrow]'\n      },\n      flip: {\n        order: 600,\n        enabled: !0,\n        fn: function fn(e, t) {\n          if (W(e.instance.modifiers, 'inner')) return e;\n          if (e.flipped && e.placement === e.originalPlacement) return e;\n          var o = w(e.instance.popper, e.instance.reference, t.padding, t.boundariesElement),\n              i = e.placement.split('-')[0],\n              n = L(i),\n              r = e.placement.split('-')[1] || '',\n              p = [];\n\n          switch (t.behavior) {\n            case fe.FLIP:\n              p = [i, n];\n              break;\n\n            case fe.CLOCKWISE:\n              p = K(i);\n              break;\n\n            case fe.COUNTERCLOCKWISE:\n              p = K(i, !0);\n              break;\n\n            default:\n              p = t.behavior;\n          }\n\n          return p.forEach(function (s, d) {\n            if (i !== s || p.length === d + 1) return e;\n            i = e.placement.split('-')[0], n = L(i);\n            var a = e.offsets.popper,\n                f = e.offsets.reference,\n                l = V,\n                m = 'left' === i && l(a.right) > l(f.left) || 'right' === i && l(a.left) < l(f.right) || 'top' === i && l(a.bottom) > l(f.top) || 'bottom' === i && l(a.top) < l(f.bottom),\n                h = l(a.left) < l(o.left),\n                c = l(a.right) > l(o.right),\n                g = l(a.top) < l(o.top),\n                u = l(a.bottom) > l(o.bottom),\n                b = 'left' === i && h || 'right' === i && c || 'top' === i && g || 'bottom' === i && u,\n                y = -1 !== ['top', 'bottom'].indexOf(i),\n                w = !!t.flipVariations && (y && 'start' === r && h || y && 'end' === r && c || !y && 'start' === r && g || !y && 'end' === r && u);\n            (m || b || w) && (e.flipped = !0, (m || b) && (i = p[d + 1]), w && (r = j(r)), e.placement = i + (r ? '-' + r : ''), e.offsets.popper = se({}, e.offsets.popper, S(e.instance.popper, e.offsets.reference, e.placement)), e = N(e.instance.modifiers, e, 'flip'));\n          }), e;\n        },\n        behavior: 'flip',\n        padding: 5,\n        boundariesElement: 'viewport'\n      },\n      inner: {\n        order: 700,\n        enabled: !1,\n        fn: function fn(e) {\n          var t = e.placement,\n              o = t.split('-')[0],\n              i = e.offsets,\n              n = i.popper,\n              r = i.reference,\n              p = -1 !== ['left', 'right'].indexOf(o),\n              s = -1 === ['top', 'left'].indexOf(o);\n          return n[p ? 'left' : 'top'] = r[t] - (s ? n[p ? 'width' : 'height'] : 0), e.placement = L(t), e.offsets.popper = c(n), e;\n        }\n      },\n      hide: {\n        order: 800,\n        enabled: !0,\n        fn: function fn(e) {\n          if (!F(e.instance.modifiers, 'hide', 'preventOverflow')) return e;\n          var t = e.offsets.reference,\n              o = T(e.instance.modifiers, function (e) {\n            return 'preventOverflow' === e.name;\n          }).boundaries;\n\n          if (t.bottom < o.top || t.left > o.right || t.top > o.bottom || t.right < o.left) {\n            if (!0 === e.hide) return e;\n            e.hide = !0, e.attributes['x-out-of-boundaries'] = '';\n          } else {\n            if (!1 === e.hide) return e;\n            e.hide = !1, e.attributes['x-out-of-boundaries'] = !1;\n          }\n\n          return e;\n        }\n      },\n      computeStyle: {\n        order: 850,\n        enabled: !0,\n        fn: function fn(e, t) {\n          var o = t.x,\n              i = t.y,\n              n = e.offsets.popper,\n              p = T(e.instance.modifiers, function (e) {\n            return 'applyStyle' === e.name;\n          }).gpuAcceleration;\n          void 0 !== p && console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');\n          var s,\n              d,\n              a = void 0 === p ? t.gpuAcceleration : p,\n              f = r(e.instance.popper),\n              l = g(f),\n              m = {\n            position: n.position\n          },\n              h = {\n            left: V(n.left),\n            top: V(n.top),\n            bottom: V(n.bottom),\n            right: V(n.right)\n          },\n              c = 'bottom' === o ? 'top' : 'bottom',\n              u = 'right' === i ? 'left' : 'right',\n              b = B('transform');\n          if (d = 'bottom' == c ? -l.height + h.bottom : h.top, s = 'right' == u ? -l.width + h.right : h.left, a && b) m[b] = 'translate3d(' + s + 'px, ' + d + 'px, 0)', m[c] = 0, m[u] = 0, m.willChange = 'transform';else {\n            var y = 'bottom' == c ? -1 : 1,\n                w = 'right' == u ? -1 : 1;\n            m[c] = d * y, m[u] = s * w, m.willChange = c + ', ' + u;\n          }\n          var v = {\n            \"x-placement\": e.placement\n          };\n          return e.attributes = se({}, v, e.attributes), e.styles = se({}, m, e.styles), e;\n        },\n        gpuAcceleration: !0,\n        x: 'bottom',\n        y: 'right'\n      },\n      applyStyle: {\n        order: 900,\n        enabled: !0,\n        fn: function fn(e) {\n          return U(e.instance.popper, e.styles), Y(e.instance.popper, e.attributes), e.offsets.arrow && U(e.arrowElement, e.offsets.arrow), e;\n        },\n        onLoad: function onLoad(e, t, o, i, n) {\n          var r = x(n, t, e),\n              p = E(o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding);\n          return t.setAttribute('x-placement', p), U(t, {\n            position: 'absolute'\n          }), o;\n        },\n        gpuAcceleration: void 0\n      }\n    }\n  }, le;\n});\n/*!\n * Bootstrap v4.0.0-beta (https://getbootstrap.com)\n * Copyright 2011-2017 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n */\n\n\nif (\"undefined\" == typeof jQuery) throw new Error(\"Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript.\");\n!function (t) {\n  var e = jQuery.fn.jquery.split(\" \")[0].split(\".\");\n  if (e[0] < 2 && e[1] < 9 || 1 == e[0] && 9 == e[1] && e[2] < 1 || e[0] >= 4) throw new Error(\"Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0\");\n}(), function () {\n  function t(t, e) {\n    if (!t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return !e || \"object\" != _typeof(e) && \"function\" != typeof e ? t : e;\n  }\n\n  function e(t, e) {\n    if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(e));\n    t.prototype = Object.create(e && e.prototype, {\n      constructor: {\n        value: t,\n        enumerable: !1,\n        writable: !0,\n        configurable: !0\n      }\n    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);\n  }\n\n  function n(t, e) {\n    if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n\n  var i = \"function\" == typeof Symbol && \"symbol\" == _typeof(Symbol.iterator) ? function (t) {\n    return _typeof(t);\n  } : function (t) {\n    return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : _typeof(t);\n  },\n      o = function () {\n    function t(t, e) {\n      for (var n = 0; n < e.length; n++) {\n        var i = e[n];\n        i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n      }\n    }\n\n    return function (e, n, i) {\n      return n && t(e.prototype, n), i && t(e, i), e;\n    };\n  }(),\n      r = function (t) {\n    function e(t) {\n      return {}.toString.call(t).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();\n    }\n\n    function n(t) {\n      return (t[0] || t).nodeType;\n    }\n\n    function i() {\n      return {\n        bindType: s.end,\n        delegateType: s.end,\n        handle: function handle(e) {\n          if (t(e.target).is(this)) return e.handleObj.handler.apply(this, arguments);\n        }\n      };\n    }\n\n    function o() {\n      if (window.QUnit) return !1;\n      var t = document.createElement(\"bootstrap\");\n\n      for (var e in a) {\n        if (void 0 !== t.style[e]) return {\n          end: a[e]\n        };\n      }\n\n      return !1;\n    }\n\n    function r(e) {\n      var n = this,\n          i = !1;\n      return t(this).one(l.TRANSITION_END, function () {\n        i = !0;\n      }), setTimeout(function () {\n        i || l.triggerTransitionEnd(n);\n      }, e), this;\n    }\n\n    var s = !1,\n        a = {\n      WebkitTransition: \"webkitTransitionEnd\",\n      MozTransition: \"transitionend\",\n      OTransition: \"oTransitionEnd otransitionend\",\n      transition: \"transitionend\"\n    },\n        l = {\n      TRANSITION_END: \"bsTransitionEnd\",\n      getUID: function getUID(t) {\n        do {\n          t += ~~(1e6 * Math.random());\n        } while (document.getElementById(t));\n\n        return t;\n      },\n      getSelectorFromElement: function getSelectorFromElement(e) {\n        var n = e.getAttribute(\"data-target\");\n        n && \"#\" !== n || (n = e.getAttribute(\"href\") || \"\");\n\n        try {\n          return t(n).length > 0 ? n : null;\n        } catch (t) {\n          return null;\n        }\n      },\n      reflow: function reflow(t) {\n        return t.offsetHeight;\n      },\n      triggerTransitionEnd: function triggerTransitionEnd(e) {\n        t(e).trigger(s.end);\n      },\n      supportsTransitionEnd: function supportsTransitionEnd() {\n        return Boolean(s);\n      },\n      typeCheckConfig: function typeCheckConfig(t, i, o) {\n        for (var r in o) {\n          if (o.hasOwnProperty(r)) {\n            var s = o[r],\n                a = i[r],\n                l = a && n(a) ? \"element\" : e(a);\n            if (!new RegExp(s).test(l)) throw new Error(t.toUpperCase() + ': Option \"' + r + '\" provided type \"' + l + '\" but expected type \"' + s + '\".');\n          }\n        }\n      }\n    };\n    return s = o(), t.fn.emulateTransitionEnd = r, l.supportsTransitionEnd() && (t.event.special[l.TRANSITION_END] = i()), l;\n  }(jQuery),\n      s = (function (t) {\n    var e = \"alert\",\n        i = t.fn[e],\n        s = {\n      DISMISS: '[data-dismiss=\"alert\"]'\n    },\n        a = {\n      CLOSE: \"close.bs.alert\",\n      CLOSED: \"closed.bs.alert\",\n      CLICK_DATA_API: \"click.bs.alert.data-api\"\n    },\n        l = {\n      ALERT: \"alert\",\n      FADE: \"fade\",\n      SHOW: \"show\"\n    },\n        h = function () {\n      function e(t) {\n        n(this, e), this._element = t;\n      }\n\n      return e.prototype.close = function (t) {\n        t = t || this._element;\n\n        var e = this._getRootElement(t);\n\n        this._triggerCloseEvent(e).isDefaultPrevented() || this._removeElement(e);\n      }, e.prototype.dispose = function () {\n        t.removeData(this._element, \"bs.alert\"), this._element = null;\n      }, e.prototype._getRootElement = function (e) {\n        var n = r.getSelectorFromElement(e),\n            i = !1;\n        return n && (i = t(n)[0]), i || (i = t(e).closest(\".\" + l.ALERT)[0]), i;\n      }, e.prototype._triggerCloseEvent = function (e) {\n        var n = t.Event(a.CLOSE);\n        return t(e).trigger(n), n;\n      }, e.prototype._removeElement = function (e) {\n        var n = this;\n        t(e).removeClass(l.SHOW), r.supportsTransitionEnd() && t(e).hasClass(l.FADE) ? t(e).one(r.TRANSITION_END, function (t) {\n          return n._destroyElement(e, t);\n        }).emulateTransitionEnd(150) : this._destroyElement(e);\n      }, e.prototype._destroyElement = function (e) {\n        t(e).detach().trigger(a.CLOSED).remove();\n      }, e._jQueryInterface = function (n) {\n        return this.each(function () {\n          var i = t(this),\n              o = i.data(\"bs.alert\");\n          o || (o = new e(this), i.data(\"bs.alert\", o)), \"close\" === n && o[n](this);\n        });\n      }, e._handleDismiss = function (t) {\n        return function (e) {\n          e && e.preventDefault(), t.close(this);\n        };\n      }, o(e, null, [{\n        key: \"VERSION\",\n        get: function get() {\n          return \"4.0.0-beta\";\n        }\n      }]), e;\n    }();\n\n    t(document).on(a.CLICK_DATA_API, s.DISMISS, h._handleDismiss(new h())), t.fn[e] = h._jQueryInterface, t.fn[e].Constructor = h, t.fn[e].noConflict = function () {\n      return t.fn[e] = i, h._jQueryInterface;\n    };\n  }(jQuery), function (t) {\n    var e = \"button\",\n        i = t.fn[e],\n        r = {\n      ACTIVE: \"active\",\n      BUTTON: \"btn\",\n      FOCUS: \"focus\"\n    },\n        s = {\n      DATA_TOGGLE_CARROT: '[data-toggle^=\"button\"]',\n      DATA_TOGGLE: '[data-toggle=\"buttons\"]',\n      INPUT: \"input\",\n      ACTIVE: \".active\",\n      BUTTON: \".btn\"\n    },\n        a = {\n      CLICK_DATA_API: \"click.bs.button.data-api\",\n      FOCUS_BLUR_DATA_API: \"focus.bs.button.data-api blur.bs.button.data-api\"\n    },\n        l = function () {\n      function e(t) {\n        n(this, e), this._element = t;\n      }\n\n      return e.prototype.toggle = function () {\n        var e = !0,\n            n = !0,\n            i = t(this._element).closest(s.DATA_TOGGLE)[0];\n\n        if (i) {\n          var o = t(this._element).find(s.INPUT)[0];\n\n          if (o) {\n            if (\"radio\" === o.type) if (o.checked && t(this._element).hasClass(r.ACTIVE)) e = !1;else {\n              var a = t(i).find(s.ACTIVE)[0];\n              a && t(a).removeClass(r.ACTIVE);\n            }\n\n            if (e) {\n              if (o.hasAttribute(\"disabled\") || i.hasAttribute(\"disabled\") || o.classList.contains(\"disabled\") || i.classList.contains(\"disabled\")) return;\n              o.checked = !t(this._element).hasClass(r.ACTIVE), t(o).trigger(\"change\");\n            }\n\n            o.focus(), n = !1;\n          }\n        }\n\n        n && this._element.setAttribute(\"aria-pressed\", !t(this._element).hasClass(r.ACTIVE)), e && t(this._element).toggleClass(r.ACTIVE);\n      }, e.prototype.dispose = function () {\n        t.removeData(this._element, \"bs.button\"), this._element = null;\n      }, e._jQueryInterface = function (n) {\n        return this.each(function () {\n          var i = t(this).data(\"bs.button\");\n          i || (i = new e(this), t(this).data(\"bs.button\", i)), \"toggle\" === n && i[n]();\n        });\n      }, o(e, null, [{\n        key: \"VERSION\",\n        get: function get() {\n          return \"4.0.0-beta\";\n        }\n      }]), e;\n    }();\n\n    t(document).on(a.CLICK_DATA_API, s.DATA_TOGGLE_CARROT, function (e) {\n      e.preventDefault();\n      var n = e.target;\n      t(n).hasClass(r.BUTTON) || (n = t(n).closest(s.BUTTON)), l._jQueryInterface.call(t(n), \"toggle\");\n    }).on(a.FOCUS_BLUR_DATA_API, s.DATA_TOGGLE_CARROT, function (e) {\n      var n = t(e.target).closest(s.BUTTON)[0];\n      t(n).toggleClass(r.FOCUS, /^focus(in)?$/.test(e.type));\n    }), t.fn[e] = l._jQueryInterface, t.fn[e].Constructor = l, t.fn[e].noConflict = function () {\n      return t.fn[e] = i, l._jQueryInterface;\n    };\n  }(jQuery), function (t) {\n    var e = \"carousel\",\n        s = \"bs.carousel\",\n        a = \".\" + s,\n        l = t.fn[e],\n        h = {\n      interval: 5e3,\n      keyboard: !0,\n      slide: !1,\n      pause: \"hover\",\n      wrap: !0\n    },\n        c = {\n      interval: \"(number|boolean)\",\n      keyboard: \"boolean\",\n      slide: \"(boolean|string)\",\n      pause: \"(string|boolean)\",\n      wrap: \"boolean\"\n    },\n        u = {\n      NEXT: \"next\",\n      PREV: \"prev\",\n      LEFT: \"left\",\n      RIGHT: \"right\"\n    },\n        d = {\n      SLIDE: \"slide\" + a,\n      SLID: \"slid\" + a,\n      KEYDOWN: \"keydown\" + a,\n      MOUSEENTER: \"mouseenter\" + a,\n      MOUSELEAVE: \"mouseleave\" + a,\n      TOUCHEND: \"touchend\" + a,\n      LOAD_DATA_API: \"load.bs.carousel.data-api\",\n      CLICK_DATA_API: \"click.bs.carousel.data-api\"\n    },\n        f = {\n      CAROUSEL: \"carousel\",\n      ACTIVE: \"active\",\n      SLIDE: \"slide\",\n      RIGHT: \"carousel-item-right\",\n      LEFT: \"carousel-item-left\",\n      NEXT: \"carousel-item-next\",\n      PREV: \"carousel-item-prev\",\n      ITEM: \"carousel-item\"\n    },\n        p = {\n      ACTIVE: \".active\",\n      ACTIVE_ITEM: \".active.carousel-item\",\n      ITEM: \".carousel-item\",\n      NEXT_PREV: \".carousel-item-next, .carousel-item-prev\",\n      INDICATORS: \".carousel-indicators\",\n      DATA_SLIDE: \"[data-slide], [data-slide-to]\",\n      DATA_RIDE: '[data-ride=\"carousel\"]'\n    },\n        _ = function () {\n      function l(e, i) {\n        n(this, l), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this._config = this._getConfig(i), this._element = t(e)[0], this._indicatorsElement = t(this._element).find(p.INDICATORS)[0], this._addEventListeners();\n      }\n\n      return l.prototype.next = function () {\n        this._isSliding || this._slide(u.NEXT);\n      }, l.prototype.nextWhenVisible = function () {\n        document.hidden || this.next();\n      }, l.prototype.prev = function () {\n        this._isSliding || this._slide(u.PREV);\n      }, l.prototype.pause = function (e) {\n        e || (this._isPaused = !0), t(this._element).find(p.NEXT_PREV)[0] && r.supportsTransitionEnd() && (r.triggerTransitionEnd(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null;\n      }, l.prototype.cycle = function (t) {\n        t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config.interval && !this._isPaused && (this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval));\n      }, l.prototype.to = function (e) {\n        var n = this;\n        this._activeElement = t(this._element).find(p.ACTIVE_ITEM)[0];\n\n        var i = this._getItemIndex(this._activeElement);\n\n        if (!(e > this._items.length - 1 || e < 0)) if (this._isSliding) t(this._element).one(d.SLID, function () {\n          return n.to(e);\n        });else {\n          if (i === e) return this.pause(), void this.cycle();\n          var o = e > i ? u.NEXT : u.PREV;\n\n          this._slide(o, this._items[e]);\n        }\n      }, l.prototype.dispose = function () {\n        t(this._element).off(a), t.removeData(this._element, s), this._items = null, this._config = null, this._element = null, this._interval = null, this._isPaused = null, this._isSliding = null, this._activeElement = null, this._indicatorsElement = null;\n      }, l.prototype._getConfig = function (n) {\n        return n = t.extend({}, h, n), r.typeCheckConfig(e, n, c), n;\n      }, l.prototype._addEventListeners = function () {\n        var e = this;\n        this._config.keyboard && t(this._element).on(d.KEYDOWN, function (t) {\n          return e._keydown(t);\n        }), \"hover\" === this._config.pause && (t(this._element).on(d.MOUSEENTER, function (t) {\n          return e.pause(t);\n        }).on(d.MOUSELEAVE, function (t) {\n          return e.cycle(t);\n        }), \"ontouchstart\" in document.documentElement && t(this._element).on(d.TOUCHEND, function () {\n          e.pause(), e.touchTimeout && clearTimeout(e.touchTimeout), e.touchTimeout = setTimeout(function (t) {\n            return e.cycle(t);\n          }, 500 + e._config.interval);\n        }));\n      }, l.prototype._keydown = function (t) {\n        if (!/input|textarea/i.test(t.target.tagName)) switch (t.which) {\n          case 37:\n            t.preventDefault(), this.prev();\n            break;\n\n          case 39:\n            t.preventDefault(), this.next();\n            break;\n\n          default:\n            return;\n        }\n      }, l.prototype._getItemIndex = function (e) {\n        return this._items = t.makeArray(t(e).parent().find(p.ITEM)), this._items.indexOf(e);\n      }, l.prototype._getItemByDirection = function (t, e) {\n        var n = t === u.NEXT,\n            i = t === u.PREV,\n            o = this._getItemIndex(e),\n            r = this._items.length - 1;\n\n        if ((i && 0 === o || n && o === r) && !this._config.wrap) return e;\n        var s = (o + (t === u.PREV ? -1 : 1)) % this._items.length;\n        return -1 === s ? this._items[this._items.length - 1] : this._items[s];\n      }, l.prototype._triggerSlideEvent = function (e, n) {\n        var i = this._getItemIndex(e),\n            o = this._getItemIndex(t(this._element).find(p.ACTIVE_ITEM)[0]),\n            r = t.Event(d.SLIDE, {\n          relatedTarget: e,\n          direction: n,\n          from: o,\n          to: i\n        });\n\n        return t(this._element).trigger(r), r;\n      }, l.prototype._setActiveIndicatorElement = function (e) {\n        if (this._indicatorsElement) {\n          t(this._indicatorsElement).find(p.ACTIVE).removeClass(f.ACTIVE);\n\n          var n = this._indicatorsElement.children[this._getItemIndex(e)];\n\n          n && t(n).addClass(f.ACTIVE);\n        }\n      }, l.prototype._slide = function (e, n) {\n        var i = this,\n            o = t(this._element).find(p.ACTIVE_ITEM)[0],\n            s = this._getItemIndex(o),\n            a = n || o && this._getItemByDirection(e, o),\n            l = this._getItemIndex(a),\n            h = Boolean(this._interval),\n            c = void 0,\n            _ = void 0,\n            g = void 0;\n\n        if (e === u.NEXT ? (c = f.LEFT, _ = f.NEXT, g = u.LEFT) : (c = f.RIGHT, _ = f.PREV, g = u.RIGHT), a && t(a).hasClass(f.ACTIVE)) this._isSliding = !1;else if (!this._triggerSlideEvent(a, g).isDefaultPrevented() && o && a) {\n          this._isSliding = !0, h && this.pause(), this._setActiveIndicatorElement(a);\n          var m = t.Event(d.SLID, {\n            relatedTarget: a,\n            direction: g,\n            from: s,\n            to: l\n          });\n          r.supportsTransitionEnd() && t(this._element).hasClass(f.SLIDE) ? (t(a).addClass(_), r.reflow(a), t(o).addClass(c), t(a).addClass(c), t(o).one(r.TRANSITION_END, function () {\n            t(a).removeClass(c + \" \" + _).addClass(f.ACTIVE), t(o).removeClass(f.ACTIVE + \" \" + _ + \" \" + c), i._isSliding = !1, setTimeout(function () {\n              return t(i._element).trigger(m);\n            }, 0);\n          }).emulateTransitionEnd(600)) : (t(o).removeClass(f.ACTIVE), t(a).addClass(f.ACTIVE), this._isSliding = !1, t(this._element).trigger(m)), h && this.cycle();\n        }\n      }, l._jQueryInterface = function (e) {\n        return this.each(function () {\n          var n = t(this).data(s),\n              o = t.extend({}, h, t(this).data());\n          \"object\" === (void 0 === e ? \"undefined\" : i(e)) && t.extend(o, e);\n          var r = \"string\" == typeof e ? e : o.slide;\n          if (n || (n = new l(this, o), t(this).data(s, n)), \"number\" == typeof e) n.to(e);else if (\"string\" == typeof r) {\n            if (void 0 === n[r]) throw new Error('No method named \"' + r + '\"');\n            n[r]();\n          } else o.interval && (n.pause(), n.cycle());\n        });\n      }, l._dataApiClickHandler = function (e) {\n        var n = r.getSelectorFromElement(this);\n\n        if (n) {\n          var i = t(n)[0];\n\n          if (i && t(i).hasClass(f.CAROUSEL)) {\n            var o = t.extend({}, t(i).data(), t(this).data()),\n                a = this.getAttribute(\"data-slide-to\");\n            a && (o.interval = !1), l._jQueryInterface.call(t(i), o), a && t(i).data(s).to(a), e.preventDefault();\n          }\n        }\n      }, o(l, null, [{\n        key: \"VERSION\",\n        get: function get() {\n          return \"4.0.0-beta\";\n        }\n      }, {\n        key: \"Default\",\n        get: function get() {\n          return h;\n        }\n      }]), l;\n    }();\n\n    t(document).on(d.CLICK_DATA_API, p.DATA_SLIDE, _._dataApiClickHandler), t(window).on(d.LOAD_DATA_API, function () {\n      t(p.DATA_RIDE).each(function () {\n        var e = t(this);\n\n        _._jQueryInterface.call(e, e.data());\n      });\n    }), t.fn[e] = _._jQueryInterface, t.fn[e].Constructor = _, t.fn[e].noConflict = function () {\n      return t.fn[e] = l, _._jQueryInterface;\n    };\n  }(jQuery), function (t) {\n    var e = \"collapse\",\n        s = \"bs.collapse\",\n        a = t.fn[e],\n        l = {\n      toggle: !0,\n      parent: \"\"\n    },\n        h = {\n      toggle: \"boolean\",\n      parent: \"string\"\n    },\n        c = {\n      SHOW: \"show.bs.collapse\",\n      SHOWN: \"shown.bs.collapse\",\n      HIDE: \"hide.bs.collapse\",\n      HIDDEN: \"hidden.bs.collapse\",\n      CLICK_DATA_API: \"click.bs.collapse.data-api\"\n    },\n        u = {\n      SHOW: \"show\",\n      COLLAPSE: \"collapse\",\n      COLLAPSING: \"collapsing\",\n      COLLAPSED: \"collapsed\"\n    },\n        d = {\n      WIDTH: \"width\",\n      HEIGHT: \"height\"\n    },\n        f = {\n      ACTIVES: \".show, .collapsing\",\n      DATA_TOGGLE: '[data-toggle=\"collapse\"]'\n    },\n        p = function () {\n      function a(e, i) {\n        n(this, a), this._isTransitioning = !1, this._element = e, this._config = this._getConfig(i), this._triggerArray = t.makeArray(t('[data-toggle=\"collapse\"][href=\"#' + e.id + '\"],[data-toggle=\"collapse\"][data-target=\"#' + e.id + '\"]'));\n\n        for (var o = t(f.DATA_TOGGLE), s = 0; s < o.length; s++) {\n          var l = o[s],\n              h = r.getSelectorFromElement(l);\n          null !== h && t(h).filter(e).length > 0 && this._triggerArray.push(l);\n        }\n\n        this._parent = this._config.parent ? this._getParent() : null, this._config.parent || this._addAriaAndCollapsedClass(this._element, this._triggerArray), this._config.toggle && this.toggle();\n      }\n\n      return a.prototype.toggle = function () {\n        t(this._element).hasClass(u.SHOW) ? this.hide() : this.show();\n      }, a.prototype.show = function () {\n        var e = this;\n\n        if (!this._isTransitioning && !t(this._element).hasClass(u.SHOW)) {\n          var n = void 0,\n              i = void 0;\n\n          if (this._parent && ((n = t.makeArray(t(this._parent).children().children(f.ACTIVES))).length || (n = null)), !(n && (i = t(n).data(s)) && i._isTransitioning)) {\n            var o = t.Event(c.SHOW);\n\n            if (t(this._element).trigger(o), !o.isDefaultPrevented()) {\n              n && (a._jQueryInterface.call(t(n), \"hide\"), i || t(n).data(s, null));\n\n              var l = this._getDimension();\n\n              t(this._element).removeClass(u.COLLAPSE).addClass(u.COLLAPSING), this._element.style[l] = 0, this._triggerArray.length && t(this._triggerArray).removeClass(u.COLLAPSED).attr(\"aria-expanded\", !0), this.setTransitioning(!0);\n\n              var h = function h() {\n                t(e._element).removeClass(u.COLLAPSING).addClass(u.COLLAPSE).addClass(u.SHOW), e._element.style[l] = \"\", e.setTransitioning(!1), t(e._element).trigger(c.SHOWN);\n              };\n\n              if (r.supportsTransitionEnd()) {\n                var d = \"scroll\" + (l[0].toUpperCase() + l.slice(1));\n                t(this._element).one(r.TRANSITION_END, h).emulateTransitionEnd(600), this._element.style[l] = this._element[d] + \"px\";\n              } else h();\n            }\n          }\n        }\n      }, a.prototype.hide = function () {\n        var e = this;\n\n        if (!this._isTransitioning && t(this._element).hasClass(u.SHOW)) {\n          var n = t.Event(c.HIDE);\n\n          if (t(this._element).trigger(n), !n.isDefaultPrevented()) {\n            var i = this._getDimension();\n\n            if (this._element.style[i] = this._element.getBoundingClientRect()[i] + \"px\", r.reflow(this._element), t(this._element).addClass(u.COLLAPSING).removeClass(u.COLLAPSE).removeClass(u.SHOW), this._triggerArray.length) for (var o = 0; o < this._triggerArray.length; o++) {\n              var s = this._triggerArray[o],\n                  a = r.getSelectorFromElement(s);\n              null !== a && (t(a).hasClass(u.SHOW) || t(s).addClass(u.COLLAPSED).attr(\"aria-expanded\", !1));\n            }\n            this.setTransitioning(!0);\n\n            var l = function l() {\n              e.setTransitioning(!1), t(e._element).removeClass(u.COLLAPSING).addClass(u.COLLAPSE).trigger(c.HIDDEN);\n            };\n\n            this._element.style[i] = \"\", r.supportsTransitionEnd() ? t(this._element).one(r.TRANSITION_END, l).emulateTransitionEnd(600) : l();\n          }\n        }\n      }, a.prototype.setTransitioning = function (t) {\n        this._isTransitioning = t;\n      }, a.prototype.dispose = function () {\n        t.removeData(this._element, s), this._config = null, this._parent = null, this._element = null, this._triggerArray = null, this._isTransitioning = null;\n      }, a.prototype._getConfig = function (n) {\n        return n = t.extend({}, l, n), n.toggle = Boolean(n.toggle), r.typeCheckConfig(e, n, h), n;\n      }, a.prototype._getDimension = function () {\n        return t(this._element).hasClass(d.WIDTH) ? d.WIDTH : d.HEIGHT;\n      }, a.prototype._getParent = function () {\n        var e = this,\n            n = t(this._config.parent)[0],\n            i = '[data-toggle=\"collapse\"][data-parent=\"' + this._config.parent + '\"]';\n        return t(n).find(i).each(function (t, n) {\n          e._addAriaAndCollapsedClass(a._getTargetFromElement(n), [n]);\n        }), n;\n      }, a.prototype._addAriaAndCollapsedClass = function (e, n) {\n        if (e) {\n          var i = t(e).hasClass(u.SHOW);\n          n.length && t(n).toggleClass(u.COLLAPSED, !i).attr(\"aria-expanded\", i);\n        }\n      }, a._getTargetFromElement = function (e) {\n        var n = r.getSelectorFromElement(e);\n        return n ? t(n)[0] : null;\n      }, a._jQueryInterface = function (e) {\n        return this.each(function () {\n          var n = t(this),\n              o = n.data(s),\n              r = t.extend({}, l, n.data(), \"object\" === (void 0 === e ? \"undefined\" : i(e)) && e);\n\n          if (!o && r.toggle && /show|hide/.test(e) && (r.toggle = !1), o || (o = new a(this, r), n.data(s, o)), \"string\" == typeof e) {\n            if (void 0 === o[e]) throw new Error('No method named \"' + e + '\"');\n            o[e]();\n          }\n        });\n      }, o(a, null, [{\n        key: \"VERSION\",\n        get: function get() {\n          return \"4.0.0-beta\";\n        }\n      }, {\n        key: \"Default\",\n        get: function get() {\n          return l;\n        }\n      }]), a;\n    }();\n\n    t(document).on(c.CLICK_DATA_API, f.DATA_TOGGLE, function (e) {\n      /input|textarea/i.test(e.target.tagName) || e.preventDefault();\n      var n = t(this),\n          i = r.getSelectorFromElement(this);\n      t(i).each(function () {\n        var e = t(this),\n            i = e.data(s) ? \"toggle\" : n.data();\n\n        p._jQueryInterface.call(e, i);\n      });\n    }), t.fn[e] = p._jQueryInterface, t.fn[e].Constructor = p, t.fn[e].noConflict = function () {\n      return t.fn[e] = a, p._jQueryInterface;\n    };\n  }(jQuery), function (t) {\n    if (\"undefined\" == typeof Popper) throw new Error(\"Bootstrap dropdown require Popper.js (https://popper.js.org)\");\n\n    var e = \"dropdown\",\n        s = \"bs.dropdown\",\n        a = \".\" + s,\n        l = t.fn[e],\n        h = new RegExp(\"38|40|27\"),\n        c = {\n      HIDE: \"hide\" + a,\n      HIDDEN: \"hidden\" + a,\n      SHOW: \"show\" + a,\n      SHOWN: \"shown\" + a,\n      CLICK: \"click\" + a,\n      CLICK_DATA_API: \"click.bs.dropdown.data-api\",\n      KEYDOWN_DATA_API: \"keydown.bs.dropdown.data-api\",\n      KEYUP_DATA_API: \"keyup.bs.dropdown.data-api\"\n    },\n        u = {\n      DISABLED: \"disabled\",\n      SHOW: \"show\",\n      DROPUP: \"dropup\",\n      MENURIGHT: \"dropdown-menu-right\",\n      MENULEFT: \"dropdown-menu-left\"\n    },\n        d = {\n      DATA_TOGGLE: '[data-toggle=\"dropdown\"]',\n      FORM_CHILD: \".dropdown form\",\n      MENU: \".dropdown-menu\",\n      NAVBAR_NAV: \".navbar-nav\",\n      VISIBLE_ITEMS: \".dropdown-menu .dropdown-item:not(.disabled)\"\n    },\n        f = {\n      TOP: \"top-start\",\n      TOPEND: \"top-end\",\n      BOTTOM: \"bottom-start\",\n      BOTTOMEND: \"bottom-end\"\n    },\n        p = {\n      placement: f.BOTTOM,\n      offset: 0,\n      flip: !0\n    },\n        _ = {\n      placement: \"string\",\n      offset: \"(number|string)\",\n      flip: \"boolean\"\n    },\n        g = function () {\n      function l(t, e) {\n        n(this, l), this._element = t, this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._addEventListeners();\n      }\n\n      return l.prototype.toggle = function () {\n        if (!this._element.disabled && !t(this._element).hasClass(u.DISABLED)) {\n          var e = l._getParentFromElement(this._element),\n              n = t(this._menu).hasClass(u.SHOW);\n\n          if (l._clearMenus(), !n) {\n            var i = {\n              relatedTarget: this._element\n            },\n                o = t.Event(c.SHOW, i);\n\n            if (t(e).trigger(o), !o.isDefaultPrevented()) {\n              var r = this._element;\n              t(e).hasClass(u.DROPUP) && (t(this._menu).hasClass(u.MENULEFT) || t(this._menu).hasClass(u.MENURIGHT)) && (r = e), this._popper = new Popper(r, this._menu, this._getPopperConfig()), \"ontouchstart\" in document.documentElement && !t(e).closest(d.NAVBAR_NAV).length && t(\"body\").children().on(\"mouseover\", null, t.noop), this._element.focus(), this._element.setAttribute(\"aria-expanded\", !0), t(this._menu).toggleClass(u.SHOW), t(e).toggleClass(u.SHOW).trigger(t.Event(c.SHOWN, i));\n            }\n          }\n        }\n      }, l.prototype.dispose = function () {\n        t.removeData(this._element, s), t(this._element).off(a), this._element = null, this._menu = null, null !== this._popper && this._popper.destroy(), this._popper = null;\n      }, l.prototype.update = function () {\n        this._inNavbar = this._detectNavbar(), null !== this._popper && this._popper.scheduleUpdate();\n      }, l.prototype._addEventListeners = function () {\n        var e = this;\n        t(this._element).on(c.CLICK, function (t) {\n          t.preventDefault(), t.stopPropagation(), e.toggle();\n        });\n      }, l.prototype._getConfig = function (n) {\n        var i = t(this._element).data();\n        return void 0 !== i.placement && (i.placement = f[i.placement.toUpperCase()]), n = t.extend({}, this.constructor.Default, t(this._element).data(), n), r.typeCheckConfig(e, n, this.constructor.DefaultType), n;\n      }, l.prototype._getMenuElement = function () {\n        if (!this._menu) {\n          var e = l._getParentFromElement(this._element);\n\n          this._menu = t(e).find(d.MENU)[0];\n        }\n\n        return this._menu;\n      }, l.prototype._getPlacement = function () {\n        var e = t(this._element).parent(),\n            n = this._config.placement;\n        return e.hasClass(u.DROPUP) || this._config.placement === f.TOP ? (n = f.TOP, t(this._menu).hasClass(u.MENURIGHT) && (n = f.TOPEND)) : t(this._menu).hasClass(u.MENURIGHT) && (n = f.BOTTOMEND), n;\n      }, l.prototype._detectNavbar = function () {\n        return t(this._element).closest(\".navbar\").length > 0;\n      }, l.prototype._getPopperConfig = function () {\n        var t = {\n          placement: this._getPlacement(),\n          modifiers: {\n            offset: {\n              offset: this._config.offset\n            },\n            flip: {\n              enabled: this._config.flip\n            }\n          }\n        };\n        return this._inNavbar && (t.modifiers.applyStyle = {\n          enabled: !this._inNavbar\n        }), t;\n      }, l._jQueryInterface = function (e) {\n        return this.each(function () {\n          var n = t(this).data(s),\n              o = \"object\" === (void 0 === e ? \"undefined\" : i(e)) ? e : null;\n\n          if (n || (n = new l(this, o), t(this).data(s, n)), \"string\" == typeof e) {\n            if (void 0 === n[e]) throw new Error('No method named \"' + e + '\"');\n            n[e]();\n          }\n        });\n      }, l._clearMenus = function (e) {\n        if (!e || 3 !== e.which && (\"keyup\" !== e.type || 9 === e.which)) for (var n = t.makeArray(t(d.DATA_TOGGLE)), i = 0; i < n.length; i++) {\n          var o = l._getParentFromElement(n[i]),\n              r = t(n[i]).data(s),\n              a = {\n            relatedTarget: n[i]\n          };\n\n          if (r) {\n            var h = r._menu;\n\n            if (t(o).hasClass(u.SHOW) && !(e && (\"click\" === e.type && /input|textarea/i.test(e.target.tagName) || \"keyup\" === e.type && 9 === e.which) && t.contains(o, e.target))) {\n              var f = t.Event(c.HIDE, a);\n              t(o).trigger(f), f.isDefaultPrevented() || (\"ontouchstart\" in document.documentElement && t(\"body\").children().off(\"mouseover\", null, t.noop), n[i].setAttribute(\"aria-expanded\", \"false\"), t(h).removeClass(u.SHOW), t(o).removeClass(u.SHOW).trigger(t.Event(c.HIDDEN, a)));\n            }\n          }\n        }\n      }, l._getParentFromElement = function (e) {\n        var n = void 0,\n            i = r.getSelectorFromElement(e);\n        return i && (n = t(i)[0]), n || e.parentNode;\n      }, l._dataApiKeydownHandler = function (e) {\n        if (!(!h.test(e.which) || /button/i.test(e.target.tagName) && 32 === e.which || /input|textarea/i.test(e.target.tagName) || (e.preventDefault(), e.stopPropagation(), this.disabled || t(this).hasClass(u.DISABLED)))) {\n          var n = l._getParentFromElement(this),\n              i = t(n).hasClass(u.SHOW);\n\n          if ((i || 27 === e.which && 32 === e.which) && (!i || 27 !== e.which && 32 !== e.which)) {\n            var o = t(n).find(d.VISIBLE_ITEMS).get();\n\n            if (o.length) {\n              var r = o.indexOf(e.target);\n              38 === e.which && r > 0 && r--, 40 === e.which && r < o.length - 1 && r++, r < 0 && (r = 0), o[r].focus();\n            }\n          } else {\n            if (27 === e.which) {\n              var s = t(n).find(d.DATA_TOGGLE)[0];\n              t(s).trigger(\"focus\");\n            }\n\n            t(this).trigger(\"click\");\n          }\n        }\n      }, o(l, null, [{\n        key: \"VERSION\",\n        get: function get() {\n          return \"4.0.0-beta\";\n        }\n      }, {\n        key: \"Default\",\n        get: function get() {\n          return p;\n        }\n      }, {\n        key: \"DefaultType\",\n        get: function get() {\n          return _;\n        }\n      }]), l;\n    }();\n\n    t(document).on(c.KEYDOWN_DATA_API, d.DATA_TOGGLE, g._dataApiKeydownHandler).on(c.KEYDOWN_DATA_API, d.MENU, g._dataApiKeydownHandler).on(c.CLICK_DATA_API + \" \" + c.KEYUP_DATA_API, g._clearMenus).on(c.CLICK_DATA_API, d.DATA_TOGGLE, function (e) {\n      e.preventDefault(), e.stopPropagation(), g._jQueryInterface.call(t(this), \"toggle\");\n    }).on(c.CLICK_DATA_API, d.FORM_CHILD, function (t) {\n      t.stopPropagation();\n    }), t.fn[e] = g._jQueryInterface, t.fn[e].Constructor = g, t.fn[e].noConflict = function () {\n      return t.fn[e] = l, g._jQueryInterface;\n    };\n  }(jQuery), function (t) {\n    var e = \"modal\",\n        s = \".bs.modal\",\n        a = t.fn[e],\n        l = {\n      backdrop: !0,\n      keyboard: !0,\n      focus: !0,\n      show: !0\n    },\n        h = {\n      backdrop: \"(boolean|string)\",\n      keyboard: \"boolean\",\n      focus: \"boolean\",\n      show: \"boolean\"\n    },\n        c = {\n      HIDE: \"hide.bs.modal\",\n      HIDDEN: \"hidden.bs.modal\",\n      SHOW: \"show.bs.modal\",\n      SHOWN: \"shown.bs.modal\",\n      FOCUSIN: \"focusin.bs.modal\",\n      RESIZE: \"resize.bs.modal\",\n      CLICK_DISMISS: \"click.dismiss.bs.modal\",\n      KEYDOWN_DISMISS: \"keydown.dismiss.bs.modal\",\n      MOUSEUP_DISMISS: \"mouseup.dismiss.bs.modal\",\n      MOUSEDOWN_DISMISS: \"mousedown.dismiss.bs.modal\",\n      CLICK_DATA_API: \"click.bs.modal.data-api\"\n    },\n        u = {\n      SCROLLBAR_MEASURER: \"modal-scrollbar-measure\",\n      BACKDROP: \"modal-backdrop\",\n      OPEN: \"modal-open\",\n      FADE: \"fade\",\n      SHOW: \"show\"\n    },\n        d = {\n      DIALOG: \".modal-dialog\",\n      DATA_TOGGLE: '[data-toggle=\"modal\"]',\n      DATA_DISMISS: '[data-dismiss=\"modal\"]',\n      FIXED_CONTENT: \".fixed-top, .fixed-bottom, .is-fixed, .sticky-top\",\n      NAVBAR_TOGGLER: \".navbar-toggler\"\n    },\n        f = function () {\n      function a(e, i) {\n        n(this, a), this._config = this._getConfig(i), this._element = e, this._dialog = t(e).find(d.DIALOG)[0], this._backdrop = null, this._isShown = !1, this._isBodyOverflowing = !1, this._ignoreBackdropClick = !1, this._originalBodyPadding = 0, this._scrollbarWidth = 0;\n      }\n\n      return a.prototype.toggle = function (t) {\n        return this._isShown ? this.hide() : this.show(t);\n      }, a.prototype.show = function (e) {\n        var n = this;\n\n        if (!this._isTransitioning) {\n          r.supportsTransitionEnd() && t(this._element).hasClass(u.FADE) && (this._isTransitioning = !0);\n          var i = t.Event(c.SHOW, {\n            relatedTarget: e\n          });\n          t(this._element).trigger(i), this._isShown || i.isDefaultPrevented() || (this._isShown = !0, this._checkScrollbar(), this._setScrollbar(), t(document.body).addClass(u.OPEN), this._setEscapeEvent(), this._setResizeEvent(), t(this._element).on(c.CLICK_DISMISS, d.DATA_DISMISS, function (t) {\n            return n.hide(t);\n          }), t(this._dialog).on(c.MOUSEDOWN_DISMISS, function () {\n            t(n._element).one(c.MOUSEUP_DISMISS, function (e) {\n              t(e.target).is(n._element) && (n._ignoreBackdropClick = !0);\n            });\n          }), this._showBackdrop(function () {\n            return n._showElement(e);\n          }));\n        }\n      }, a.prototype.hide = function (e) {\n        var n = this;\n\n        if (e && e.preventDefault(), !this._isTransitioning && this._isShown) {\n          var i = r.supportsTransitionEnd() && t(this._element).hasClass(u.FADE);\n          i && (this._isTransitioning = !0);\n          var o = t.Event(c.HIDE);\n          t(this._element).trigger(o), this._isShown && !o.isDefaultPrevented() && (this._isShown = !1, this._setEscapeEvent(), this._setResizeEvent(), t(document).off(c.FOCUSIN), t(this._element).removeClass(u.SHOW), t(this._element).off(c.CLICK_DISMISS), t(this._dialog).off(c.MOUSEDOWN_DISMISS), i ? t(this._element).one(r.TRANSITION_END, function (t) {\n            return n._hideModal(t);\n          }).emulateTransitionEnd(300) : this._hideModal());\n        }\n      }, a.prototype.dispose = function () {\n        t.removeData(this._element, \"bs.modal\"), t(window, document, this._element, this._backdrop).off(s), this._config = null, this._element = null, this._dialog = null, this._backdrop = null, this._isShown = null, this._isBodyOverflowing = null, this._ignoreBackdropClick = null, this._scrollbarWidth = null;\n      }, a.prototype.handleUpdate = function () {\n        this._adjustDialog();\n      }, a.prototype._getConfig = function (n) {\n        return n = t.extend({}, l, n), r.typeCheckConfig(e, n, h), n;\n      }, a.prototype._showElement = function (e) {\n        var n = this,\n            i = r.supportsTransitionEnd() && t(this._element).hasClass(u.FADE);\n        this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = \"block\", this._element.removeAttribute(\"aria-hidden\"), this._element.scrollTop = 0, i && r.reflow(this._element), t(this._element).addClass(u.SHOW), this._config.focus && this._enforceFocus();\n\n        var o = t.Event(c.SHOWN, {\n          relatedTarget: e\n        }),\n            s = function s() {\n          n._config.focus && n._element.focus(), n._isTransitioning = !1, t(n._element).trigger(o);\n        };\n\n        i ? t(this._dialog).one(r.TRANSITION_END, s).emulateTransitionEnd(300) : s();\n      }, a.prototype._enforceFocus = function () {\n        var e = this;\n        t(document).off(c.FOCUSIN).on(c.FOCUSIN, function (n) {\n          document === n.target || e._element === n.target || t(e._element).has(n.target).length || e._element.focus();\n        });\n      }, a.prototype._setEscapeEvent = function () {\n        var e = this;\n        this._isShown && this._config.keyboard ? t(this._element).on(c.KEYDOWN_DISMISS, function (t) {\n          27 === t.which && (t.preventDefault(), e.hide());\n        }) : this._isShown || t(this._element).off(c.KEYDOWN_DISMISS);\n      }, a.prototype._setResizeEvent = function () {\n        var e = this;\n        this._isShown ? t(window).on(c.RESIZE, function (t) {\n          return e.handleUpdate(t);\n        }) : t(window).off(c.RESIZE);\n      }, a.prototype._hideModal = function () {\n        var e = this;\n        this._element.style.display = \"none\", this._element.setAttribute(\"aria-hidden\", !0), this._isTransitioning = !1, this._showBackdrop(function () {\n          t(document.body).removeClass(u.OPEN), e._resetAdjustments(), e._resetScrollbar(), t(e._element).trigger(c.HIDDEN);\n        });\n      }, a.prototype._removeBackdrop = function () {\n        this._backdrop && (t(this._backdrop).remove(), this._backdrop = null);\n      }, a.prototype._showBackdrop = function (e) {\n        var n = this,\n            i = t(this._element).hasClass(u.FADE) ? u.FADE : \"\";\n\n        if (this._isShown && this._config.backdrop) {\n          var o = r.supportsTransitionEnd() && i;\n          if (this._backdrop = document.createElement(\"div\"), this._backdrop.className = u.BACKDROP, i && t(this._backdrop).addClass(i), t(this._backdrop).appendTo(document.body), t(this._element).on(c.CLICK_DISMISS, function (t) {\n            n._ignoreBackdropClick ? n._ignoreBackdropClick = !1 : t.target === t.currentTarget && (\"static\" === n._config.backdrop ? n._element.focus() : n.hide());\n          }), o && r.reflow(this._backdrop), t(this._backdrop).addClass(u.SHOW), !e) return;\n          if (!o) return void e();\n          t(this._backdrop).one(r.TRANSITION_END, e).emulateTransitionEnd(150);\n        } else if (!this._isShown && this._backdrop) {\n          t(this._backdrop).removeClass(u.SHOW);\n\n          var s = function s() {\n            n._removeBackdrop(), e && e();\n          };\n\n          r.supportsTransitionEnd() && t(this._element).hasClass(u.FADE) ? t(this._backdrop).one(r.TRANSITION_END, s).emulateTransitionEnd(150) : s();\n        } else e && e();\n      }, a.prototype._adjustDialog = function () {\n        var t = this._element.scrollHeight > document.documentElement.clientHeight;\n        !this._isBodyOverflowing && t && (this._element.style.paddingLeft = this._scrollbarWidth + \"px\"), this._isBodyOverflowing && !t && (this._element.style.paddingRight = this._scrollbarWidth + \"px\");\n      }, a.prototype._resetAdjustments = function () {\n        this._element.style.paddingLeft = \"\", this._element.style.paddingRight = \"\";\n      }, a.prototype._checkScrollbar = function () {\n        this._isBodyOverflowing = document.body.clientWidth < window.innerWidth, this._scrollbarWidth = this._getScrollbarWidth();\n      }, a.prototype._setScrollbar = function () {\n        var e = this;\n\n        if (this._isBodyOverflowing) {\n          t(d.FIXED_CONTENT).each(function (n, i) {\n            var o = t(i)[0].style.paddingRight,\n                r = t(i).css(\"padding-right\");\n            t(i).data(\"padding-right\", o).css(\"padding-right\", parseFloat(r) + e._scrollbarWidth + \"px\");\n          }), t(d.NAVBAR_TOGGLER).each(function (n, i) {\n            var o = t(i)[0].style.marginRight,\n                r = t(i).css(\"margin-right\");\n            t(i).data(\"margin-right\", o).css(\"margin-right\", parseFloat(r) + e._scrollbarWidth + \"px\");\n          });\n          var n = document.body.style.paddingRight,\n              i = t(\"body\").css(\"padding-right\");\n          t(\"body\").data(\"padding-right\", n).css(\"padding-right\", parseFloat(i) + this._scrollbarWidth + \"px\");\n        }\n      }, a.prototype._resetScrollbar = function () {\n        t(d.FIXED_CONTENT).each(function (e, n) {\n          var i = t(n).data(\"padding-right\");\n          void 0 !== i && t(n).css(\"padding-right\", i).removeData(\"padding-right\");\n        }), t(d.NAVBAR_TOGGLER).each(function (e, n) {\n          var i = t(n).data(\"margin-right\");\n          void 0 !== i && t(n).css(\"margin-right\", i).removeData(\"margin-right\");\n        });\n        var e = t(\"body\").data(\"padding-right\");\n        void 0 !== e && t(\"body\").css(\"padding-right\", e).removeData(\"padding-right\");\n      }, a.prototype._getScrollbarWidth = function () {\n        var t = document.createElement(\"div\");\n        t.className = u.SCROLLBAR_MEASURER, document.body.appendChild(t);\n        var e = t.getBoundingClientRect().width - t.clientWidth;\n        return document.body.removeChild(t), e;\n      }, a._jQueryInterface = function (e, n) {\n        return this.each(function () {\n          var o = t(this).data(\"bs.modal\"),\n              r = t.extend({}, a.Default, t(this).data(), \"object\" === (void 0 === e ? \"undefined\" : i(e)) && e);\n\n          if (o || (o = new a(this, r), t(this).data(\"bs.modal\", o)), \"string\" == typeof e) {\n            if (void 0 === o[e]) throw new Error('No method named \"' + e + '\"');\n            o[e](n);\n          } else r.show && o.show(n);\n        });\n      }, o(a, null, [{\n        key: \"VERSION\",\n        get: function get() {\n          return \"4.0.0-beta\";\n        }\n      }, {\n        key: \"Default\",\n        get: function get() {\n          return l;\n        }\n      }]), a;\n    }();\n\n    t(document).on(c.CLICK_DATA_API, d.DATA_TOGGLE, function (e) {\n      var n = this,\n          i = void 0,\n          o = r.getSelectorFromElement(this);\n      o && (i = t(o)[0]);\n      var s = t(i).data(\"bs.modal\") ? \"toggle\" : t.extend({}, t(i).data(), t(this).data());\n      \"A\" !== this.tagName && \"AREA\" !== this.tagName || e.preventDefault();\n      var a = t(i).one(c.SHOW, function (e) {\n        e.isDefaultPrevented() || a.one(c.HIDDEN, function () {\n          t(n).is(\":visible\") && n.focus();\n        });\n      });\n\n      f._jQueryInterface.call(t(i), s, this);\n    }), t.fn[e] = f._jQueryInterface, t.fn[e].Constructor = f, t.fn[e].noConflict = function () {\n      return t.fn[e] = a, f._jQueryInterface;\n    };\n  }(jQuery), function (t) {\n    var e = \"scrollspy\",\n        s = t.fn[e],\n        a = {\n      offset: 10,\n      method: \"auto\",\n      target: \"\"\n    },\n        l = {\n      offset: \"number\",\n      method: \"string\",\n      target: \"(string|element)\"\n    },\n        h = {\n      ACTIVATE: \"activate.bs.scrollspy\",\n      SCROLL: \"scroll.bs.scrollspy\",\n      LOAD_DATA_API: \"load.bs.scrollspy.data-api\"\n    },\n        c = {\n      DROPDOWN_ITEM: \"dropdown-item\",\n      DROPDOWN_MENU: \"dropdown-menu\",\n      ACTIVE: \"active\"\n    },\n        u = {\n      DATA_SPY: '[data-spy=\"scroll\"]',\n      ACTIVE: \".active\",\n      NAV_LIST_GROUP: \".nav, .list-group\",\n      NAV_LINKS: \".nav-link\",\n      LIST_ITEMS: \".list-group-item\",\n      DROPDOWN: \".dropdown\",\n      DROPDOWN_ITEMS: \".dropdown-item\",\n      DROPDOWN_TOGGLE: \".dropdown-toggle\"\n    },\n        d = {\n      OFFSET: \"offset\",\n      POSITION: \"position\"\n    },\n        f = function () {\n      function s(e, i) {\n        var o = this;\n        n(this, s), this._element = e, this._scrollElement = \"BODY\" === e.tagName ? window : e, this._config = this._getConfig(i), this._selector = this._config.target + \" \" + u.NAV_LINKS + \",\" + this._config.target + \" \" + u.LIST_ITEMS + \",\" + this._config.target + \" \" + u.DROPDOWN_ITEMS, this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, t(this._scrollElement).on(h.SCROLL, function (t) {\n          return o._process(t);\n        }), this.refresh(), this._process();\n      }\n\n      return s.prototype.refresh = function () {\n        var e = this,\n            n = this._scrollElement !== this._scrollElement.window ? d.POSITION : d.OFFSET,\n            i = \"auto\" === this._config.method ? n : this._config.method,\n            o = i === d.POSITION ? this._getScrollTop() : 0;\n        this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), t.makeArray(t(this._selector)).map(function (e) {\n          var n = void 0,\n              s = r.getSelectorFromElement(e);\n\n          if (s && (n = t(s)[0]), n) {\n            var a = n.getBoundingClientRect();\n            if (a.width || a.height) return [t(n)[i]().top + o, s];\n          }\n\n          return null;\n        }).filter(function (t) {\n          return t;\n        }).sort(function (t, e) {\n          return t[0] - e[0];\n        }).forEach(function (t) {\n          e._offsets.push(t[0]), e._targets.push(t[1]);\n        });\n      }, s.prototype.dispose = function () {\n        t.removeData(this._element, \"bs.scrollspy\"), t(this._scrollElement).off(\".bs.scrollspy\"), this._element = null, this._scrollElement = null, this._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null;\n      }, s.prototype._getConfig = function (n) {\n        if (\"string\" != typeof (n = t.extend({}, a, n)).target) {\n          var i = t(n.target).attr(\"id\");\n          i || (i = r.getUID(e), t(n.target).attr(\"id\", i)), n.target = \"#\" + i;\n        }\n\n        return r.typeCheckConfig(e, n, l), n;\n      }, s.prototype._getScrollTop = function () {\n        return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;\n      }, s.prototype._getScrollHeight = function () {\n        return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n      }, s.prototype._getOffsetHeight = function () {\n        return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;\n      }, s.prototype._process = function () {\n        var t = this._getScrollTop() + this._config.offset,\n            e = this._getScrollHeight(),\n            n = this._config.offset + e - this._getOffsetHeight();\n\n        if (this._scrollHeight !== e && this.refresh(), t >= n) {\n          var i = this._targets[this._targets.length - 1];\n          this._activeTarget !== i && this._activate(i);\n        } else {\n          if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear();\n\n          for (var o = this._offsets.length; o--;) {\n            this._activeTarget !== this._targets[o] && t >= this._offsets[o] && (void 0 === this._offsets[o + 1] || t < this._offsets[o + 1]) && this._activate(this._targets[o]);\n          }\n        }\n      }, s.prototype._activate = function (e) {\n        this._activeTarget = e, this._clear();\n\n        var n = this._selector.split(\",\");\n\n        n = n.map(function (t) {\n          return t + '[data-target=\"' + e + '\"],' + t + '[href=\"' + e + '\"]';\n        });\n        var i = t(n.join(\",\"));\n        i.hasClass(c.DROPDOWN_ITEM) ? (i.closest(u.DROPDOWN).find(u.DROPDOWN_TOGGLE).addClass(c.ACTIVE), i.addClass(c.ACTIVE)) : (i.addClass(c.ACTIVE), i.parents(u.NAV_LIST_GROUP).prev(u.NAV_LINKS + \", \" + u.LIST_ITEMS).addClass(c.ACTIVE)), t(this._scrollElement).trigger(h.ACTIVATE, {\n          relatedTarget: e\n        });\n      }, s.prototype._clear = function () {\n        t(this._selector).filter(u.ACTIVE).removeClass(c.ACTIVE);\n      }, s._jQueryInterface = function (e) {\n        return this.each(function () {\n          var n = t(this).data(\"bs.scrollspy\"),\n              o = \"object\" === (void 0 === e ? \"undefined\" : i(e)) && e;\n\n          if (n || (n = new s(this, o), t(this).data(\"bs.scrollspy\", n)), \"string\" == typeof e) {\n            if (void 0 === n[e]) throw new Error('No method named \"' + e + '\"');\n            n[e]();\n          }\n        });\n      }, o(s, null, [{\n        key: \"VERSION\",\n        get: function get() {\n          return \"4.0.0-beta\";\n        }\n      }, {\n        key: \"Default\",\n        get: function get() {\n          return a;\n        }\n      }]), s;\n    }();\n\n    t(window).on(h.LOAD_DATA_API, function () {\n      for (var e = t.makeArray(t(u.DATA_SPY)), n = e.length; n--;) {\n        var i = t(e[n]);\n\n        f._jQueryInterface.call(i, i.data());\n      }\n    }), t.fn[e] = f._jQueryInterface, t.fn[e].Constructor = f, t.fn[e].noConflict = function () {\n      return t.fn[e] = s, f._jQueryInterface;\n    };\n  }(jQuery), function (t) {\n    var e = t.fn.tab,\n        i = {\n      HIDE: \"hide.bs.tab\",\n      HIDDEN: \"hidden.bs.tab\",\n      SHOW: \"show.bs.tab\",\n      SHOWN: \"shown.bs.tab\",\n      CLICK_DATA_API: \"click.bs.tab.data-api\"\n    },\n        s = {\n      DROPDOWN_MENU: \"dropdown-menu\",\n      ACTIVE: \"active\",\n      DISABLED: \"disabled\",\n      FADE: \"fade\",\n      SHOW: \"show\"\n    },\n        a = {\n      DROPDOWN: \".dropdown\",\n      NAV_LIST_GROUP: \".nav, .list-group\",\n      ACTIVE: \".active\",\n      DATA_TOGGLE: '[data-toggle=\"tab\"], [data-toggle=\"pill\"], [data-toggle=\"list\"]',\n      DROPDOWN_TOGGLE: \".dropdown-toggle\",\n      DROPDOWN_ACTIVE_CHILD: \"> .dropdown-menu .active\"\n    },\n        l = function () {\n      function e(t) {\n        n(this, e), this._element = t;\n      }\n\n      return e.prototype.show = function () {\n        var e = this;\n\n        if (!(this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && t(this._element).hasClass(s.ACTIVE) || t(this._element).hasClass(s.DISABLED))) {\n          var n = void 0,\n              o = void 0,\n              l = t(this._element).closest(a.NAV_LIST_GROUP)[0],\n              h = r.getSelectorFromElement(this._element);\n          l && (o = t.makeArray(t(l).find(a.ACTIVE)), o = o[o.length - 1]);\n          var c = t.Event(i.HIDE, {\n            relatedTarget: this._element\n          }),\n              u = t.Event(i.SHOW, {\n            relatedTarget: o\n          });\n\n          if (o && t(o).trigger(c), t(this._element).trigger(u), !u.isDefaultPrevented() && !c.isDefaultPrevented()) {\n            h && (n = t(h)[0]), this._activate(this._element, l);\n\n            var d = function d() {\n              var n = t.Event(i.HIDDEN, {\n                relatedTarget: e._element\n              }),\n                  r = t.Event(i.SHOWN, {\n                relatedTarget: o\n              });\n              t(o).trigger(n), t(e._element).trigger(r);\n            };\n\n            n ? this._activate(n, n.parentNode, d) : d();\n          }\n        }\n      }, e.prototype.dispose = function () {\n        t.removeData(this._element, \"bs.tab\"), this._element = null;\n      }, e.prototype._activate = function (e, n, i) {\n        var o = this,\n            l = t(n).find(a.ACTIVE)[0],\n            h = i && r.supportsTransitionEnd() && l && t(l).hasClass(s.FADE),\n            c = function c() {\n          return o._transitionComplete(e, l, h, i);\n        };\n\n        l && h ? t(l).one(r.TRANSITION_END, c).emulateTransitionEnd(150) : c(), l && t(l).removeClass(s.SHOW);\n      }, e.prototype._transitionComplete = function (e, n, i, o) {\n        if (n) {\n          t(n).removeClass(s.ACTIVE);\n          var l = t(n.parentNode).find(a.DROPDOWN_ACTIVE_CHILD)[0];\n          l && t(l).removeClass(s.ACTIVE), n.setAttribute(\"aria-expanded\", !1);\n        }\n\n        if (t(e).addClass(s.ACTIVE), e.setAttribute(\"aria-expanded\", !0), i ? (r.reflow(e), t(e).addClass(s.SHOW)) : t(e).removeClass(s.FADE), e.parentNode && t(e.parentNode).hasClass(s.DROPDOWN_MENU)) {\n          var h = t(e).closest(a.DROPDOWN)[0];\n          h && t(h).find(a.DROPDOWN_TOGGLE).addClass(s.ACTIVE), e.setAttribute(\"aria-expanded\", !0);\n        }\n\n        o && o();\n      }, e._jQueryInterface = function (n) {\n        return this.each(function () {\n          var i = t(this),\n              o = i.data(\"bs.tab\");\n\n          if (o || (o = new e(this), i.data(\"bs.tab\", o)), \"string\" == typeof n) {\n            if (void 0 === o[n]) throw new Error('No method named \"' + n + '\"');\n            o[n]();\n          }\n        });\n      }, o(e, null, [{\n        key: \"VERSION\",\n        get: function get() {\n          return \"4.0.0-beta\";\n        }\n      }]), e;\n    }();\n\n    t(document).on(i.CLICK_DATA_API, a.DATA_TOGGLE, function (e) {\n      e.preventDefault(), l._jQueryInterface.call(t(this), \"show\");\n    }), t.fn.tab = l._jQueryInterface, t.fn.tab.Constructor = l, t.fn.tab.noConflict = function () {\n      return t.fn.tab = e, l._jQueryInterface;\n    };\n  }(jQuery), function (t) {\n    if (\"undefined\" == typeof Popper) throw new Error(\"Bootstrap tooltips require Popper.js (https://popper.js.org)\");\n\n    var e = \"tooltip\",\n        s = \".bs.tooltip\",\n        a = t.fn[e],\n        l = new RegExp(\"(^|\\\\s)bs-tooltip\\\\S+\", \"g\"),\n        h = {\n      animation: \"boolean\",\n      template: \"string\",\n      title: \"(string|element|function)\",\n      trigger: \"string\",\n      delay: \"(number|object)\",\n      html: \"boolean\",\n      selector: \"(string|boolean)\",\n      placement: \"(string|function)\",\n      offset: \"(number|string)\",\n      container: \"(string|element|boolean)\",\n      fallbackPlacement: \"(string|array)\"\n    },\n        c = {\n      AUTO: \"auto\",\n      TOP: \"top\",\n      RIGHT: \"right\",\n      BOTTOM: \"bottom\",\n      LEFT: \"left\"\n    },\n        u = {\n      animation: !0,\n      template: '<div class=\"tooltip\" role=\"tooltip\"><div class=\"arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n      trigger: \"hover focus\",\n      title: \"\",\n      delay: 0,\n      html: !1,\n      selector: !1,\n      placement: \"top\",\n      offset: 0,\n      container: !1,\n      fallbackPlacement: \"flip\"\n    },\n        d = {\n      SHOW: \"show\",\n      OUT: \"out\"\n    },\n        f = {\n      HIDE: \"hide\" + s,\n      HIDDEN: \"hidden\" + s,\n      SHOW: \"show\" + s,\n      SHOWN: \"shown\" + s,\n      INSERTED: \"inserted\" + s,\n      CLICK: \"click\" + s,\n      FOCUSIN: \"focusin\" + s,\n      FOCUSOUT: \"focusout\" + s,\n      MOUSEENTER: \"mouseenter\" + s,\n      MOUSELEAVE: \"mouseleave\" + s\n    },\n        p = {\n      FADE: \"fade\",\n      SHOW: \"show\"\n    },\n        _ = {\n      TOOLTIP: \".tooltip\",\n      TOOLTIP_INNER: \".tooltip-inner\",\n      ARROW: \".arrow\"\n    },\n        g = {\n      HOVER: \"hover\",\n      FOCUS: \"focus\",\n      CLICK: \"click\",\n      MANUAL: \"manual\"\n    },\n        m = function () {\n      function a(t, e) {\n        n(this, a), this._isEnabled = !0, this._timeout = 0, this._hoverState = \"\", this._activeTrigger = {}, this._popper = null, this.element = t, this.config = this._getConfig(e), this.tip = null, this._setListeners();\n      }\n\n      return a.prototype.enable = function () {\n        this._isEnabled = !0;\n      }, a.prototype.disable = function () {\n        this._isEnabled = !1;\n      }, a.prototype.toggleEnabled = function () {\n        this._isEnabled = !this._isEnabled;\n      }, a.prototype.toggle = function (e) {\n        if (e) {\n          var n = this.constructor.DATA_KEY,\n              i = t(e.currentTarget).data(n);\n          i || (i = new this.constructor(e.currentTarget, this._getDelegateConfig()), t(e.currentTarget).data(n, i)), i._activeTrigger.click = !i._activeTrigger.click, i._isWithActiveTrigger() ? i._enter(null, i) : i._leave(null, i);\n        } else {\n          if (t(this.getTipElement()).hasClass(p.SHOW)) return void this._leave(null, this);\n\n          this._enter(null, this);\n        }\n      }, a.prototype.dispose = function () {\n        clearTimeout(this._timeout), t.removeData(this.element, this.constructor.DATA_KEY), t(this.element).off(this.constructor.EVENT_KEY), t(this.element).closest(\".modal\").off(\"hide.bs.modal\"), this.tip && t(this.tip).remove(), this._isEnabled = null, this._timeout = null, this._hoverState = null, this._activeTrigger = null, null !== this._popper && this._popper.destroy(), this._popper = null, this.element = null, this.config = null, this.tip = null;\n      }, a.prototype.show = function () {\n        var e = this;\n        if (\"none\" === t(this.element).css(\"display\")) throw new Error(\"Please use show on visible elements\");\n        var n = t.Event(this.constructor.Event.SHOW);\n\n        if (this.isWithContent() && this._isEnabled) {\n          t(this.element).trigger(n);\n          var i = t.contains(this.element.ownerDocument.documentElement, this.element);\n          if (n.isDefaultPrevented() || !i) return;\n          var o = this.getTipElement(),\n              s = r.getUID(this.constructor.NAME);\n          o.setAttribute(\"id\", s), this.element.setAttribute(\"aria-describedby\", s), this.setContent(), this.config.animation && t(o).addClass(p.FADE);\n\n          var l = \"function\" == typeof this.config.placement ? this.config.placement.call(this, o, this.element) : this.config.placement,\n              h = this._getAttachment(l);\n\n          this.addAttachmentClass(h);\n          var c = !1 === this.config.container ? document.body : t(this.config.container);\n          t(o).data(this.constructor.DATA_KEY, this), t.contains(this.element.ownerDocument.documentElement, this.tip) || t(o).appendTo(c), t(this.element).trigger(this.constructor.Event.INSERTED), this._popper = new Popper(this.element, o, {\n            placement: h,\n            modifiers: {\n              offset: {\n                offset: this.config.offset\n              },\n              flip: {\n                behavior: this.config.fallbackPlacement\n              },\n              arrow: {\n                element: _.ARROW\n              }\n            },\n            onCreate: function onCreate(t) {\n              t.originalPlacement !== t.placement && e._handlePopperPlacementChange(t);\n            },\n            onUpdate: function onUpdate(t) {\n              e._handlePopperPlacementChange(t);\n            }\n          }), t(o).addClass(p.SHOW), \"ontouchstart\" in document.documentElement && t(\"body\").children().on(\"mouseover\", null, t.noop);\n\n          var u = function u() {\n            e.config.animation && e._fixTransition();\n            var n = e._hoverState;\n            e._hoverState = null, t(e.element).trigger(e.constructor.Event.SHOWN), n === d.OUT && e._leave(null, e);\n          };\n\n          r.supportsTransitionEnd() && t(this.tip).hasClass(p.FADE) ? t(this.tip).one(r.TRANSITION_END, u).emulateTransitionEnd(a._TRANSITION_DURATION) : u();\n        }\n      }, a.prototype.hide = function (e) {\n        var n = this,\n            i = this.getTipElement(),\n            o = t.Event(this.constructor.Event.HIDE),\n            s = function s() {\n          n._hoverState !== d.SHOW && i.parentNode && i.parentNode.removeChild(i), n._cleanTipClass(), n.element.removeAttribute(\"aria-describedby\"), t(n.element).trigger(n.constructor.Event.HIDDEN), null !== n._popper && n._popper.destroy(), e && e();\n        };\n\n        t(this.element).trigger(o), o.isDefaultPrevented() || (t(i).removeClass(p.SHOW), \"ontouchstart\" in document.documentElement && t(\"body\").children().off(\"mouseover\", null, t.noop), this._activeTrigger[g.CLICK] = !1, this._activeTrigger[g.FOCUS] = !1, this._activeTrigger[g.HOVER] = !1, r.supportsTransitionEnd() && t(this.tip).hasClass(p.FADE) ? t(i).one(r.TRANSITION_END, s).emulateTransitionEnd(150) : s(), this._hoverState = \"\");\n      }, a.prototype.update = function () {\n        null !== this._popper && this._popper.scheduleUpdate();\n      }, a.prototype.isWithContent = function () {\n        return Boolean(this.getTitle());\n      }, a.prototype.addAttachmentClass = function (e) {\n        t(this.getTipElement()).addClass(\"bs-tooltip-\" + e);\n      }, a.prototype.getTipElement = function () {\n        return this.tip = this.tip || t(this.config.template)[0];\n      }, a.prototype.setContent = function () {\n        var e = t(this.getTipElement());\n        this.setElementContent(e.find(_.TOOLTIP_INNER), this.getTitle()), e.removeClass(p.FADE + \" \" + p.SHOW);\n      }, a.prototype.setElementContent = function (e, n) {\n        var o = this.config.html;\n        \"object\" === (void 0 === n ? \"undefined\" : i(n)) && (n.nodeType || n.jquery) ? o ? t(n).parent().is(e) || e.empty().append(n) : e.text(t(n).text()) : e[o ? \"html\" : \"text\"](n);\n      }, a.prototype.getTitle = function () {\n        var t = this.element.getAttribute(\"data-original-title\");\n        return t || (t = \"function\" == typeof this.config.title ? this.config.title.call(this.element) : this.config.title), t;\n      }, a.prototype._getAttachment = function (t) {\n        return c[t.toUpperCase()];\n      }, a.prototype._setListeners = function () {\n        var e = this;\n        this.config.trigger.split(\" \").forEach(function (n) {\n          if (\"click\" === n) t(e.element).on(e.constructor.Event.CLICK, e.config.selector, function (t) {\n            return e.toggle(t);\n          });else if (n !== g.MANUAL) {\n            var i = n === g.HOVER ? e.constructor.Event.MOUSEENTER : e.constructor.Event.FOCUSIN,\n                o = n === g.HOVER ? e.constructor.Event.MOUSELEAVE : e.constructor.Event.FOCUSOUT;\n            t(e.element).on(i, e.config.selector, function (t) {\n              return e._enter(t);\n            }).on(o, e.config.selector, function (t) {\n              return e._leave(t);\n            });\n          }\n          t(e.element).closest(\".modal\").on(\"hide.bs.modal\", function () {\n            return e.hide();\n          });\n        }), this.config.selector ? this.config = t.extend({}, this.config, {\n          trigger: \"manual\",\n          selector: \"\"\n        }) : this._fixTitle();\n      }, a.prototype._fixTitle = function () {\n        var t = i(this.element.getAttribute(\"data-original-title\"));\n        (this.element.getAttribute(\"title\") || \"string\" !== t) && (this.element.setAttribute(\"data-original-title\", this.element.getAttribute(\"title\") || \"\"), this.element.setAttribute(\"title\", \"\"));\n      }, a.prototype._enter = function (e, n) {\n        var i = this.constructor.DATA_KEY;\n        (n = n || t(e.currentTarget).data(i)) || (n = new this.constructor(e.currentTarget, this._getDelegateConfig()), t(e.currentTarget).data(i, n)), e && (n._activeTrigger[\"focusin\" === e.type ? g.FOCUS : g.HOVER] = !0), t(n.getTipElement()).hasClass(p.SHOW) || n._hoverState === d.SHOW ? n._hoverState = d.SHOW : (clearTimeout(n._timeout), n._hoverState = d.SHOW, n.config.delay && n.config.delay.show ? n._timeout = setTimeout(function () {\n          n._hoverState === d.SHOW && n.show();\n        }, n.config.delay.show) : n.show());\n      }, a.prototype._leave = function (e, n) {\n        var i = this.constructor.DATA_KEY;\n        (n = n || t(e.currentTarget).data(i)) || (n = new this.constructor(e.currentTarget, this._getDelegateConfig()), t(e.currentTarget).data(i, n)), e && (n._activeTrigger[\"focusout\" === e.type ? g.FOCUS : g.HOVER] = !1), n._isWithActiveTrigger() || (clearTimeout(n._timeout), n._hoverState = d.OUT, n.config.delay && n.config.delay.hide ? n._timeout = setTimeout(function () {\n          n._hoverState === d.OUT && n.hide();\n        }, n.config.delay.hide) : n.hide());\n      }, a.prototype._isWithActiveTrigger = function () {\n        for (var t in this._activeTrigger) {\n          if (this._activeTrigger[t]) return !0;\n        }\n\n        return !1;\n      }, a.prototype._getConfig = function (n) {\n        return (n = t.extend({}, this.constructor.Default, t(this.element).data(), n)).delay && \"number\" == typeof n.delay && (n.delay = {\n          show: n.delay,\n          hide: n.delay\n        }), n.title && \"number\" == typeof n.title && (n.title = n.title.toString()), n.content && \"number\" == typeof n.content && (n.content = n.content.toString()), r.typeCheckConfig(e, n, this.constructor.DefaultType), n;\n      }, a.prototype._getDelegateConfig = function () {\n        var t = {};\n        if (this.config) for (var e in this.config) {\n          this.constructor.Default[e] !== this.config[e] && (t[e] = this.config[e]);\n        }\n        return t;\n      }, a.prototype._cleanTipClass = function () {\n        var e = t(this.getTipElement()),\n            n = e.attr(\"class\").match(l);\n        null !== n && n.length > 0 && e.removeClass(n.join(\"\"));\n      }, a.prototype._handlePopperPlacementChange = function (t) {\n        this._cleanTipClass(), this.addAttachmentClass(this._getAttachment(t.placement));\n      }, a.prototype._fixTransition = function () {\n        var e = this.getTipElement(),\n            n = this.config.animation;\n        null === e.getAttribute(\"x-placement\") && (t(e).removeClass(p.FADE), this.config.animation = !1, this.hide(), this.show(), this.config.animation = n);\n      }, a._jQueryInterface = function (e) {\n        return this.each(function () {\n          var n = t(this).data(\"bs.tooltip\"),\n              o = \"object\" === (void 0 === e ? \"undefined\" : i(e)) && e;\n\n          if ((n || !/dispose|hide/.test(e)) && (n || (n = new a(this, o), t(this).data(\"bs.tooltip\", n)), \"string\" == typeof e)) {\n            if (void 0 === n[e]) throw new Error('No method named \"' + e + '\"');\n            n[e]();\n          }\n        });\n      }, o(a, null, [{\n        key: \"VERSION\",\n        get: function get() {\n          return \"4.0.0-beta\";\n        }\n      }, {\n        key: \"Default\",\n        get: function get() {\n          return u;\n        }\n      }, {\n        key: \"NAME\",\n        get: function get() {\n          return e;\n        }\n      }, {\n        key: \"DATA_KEY\",\n        get: function get() {\n          return \"bs.tooltip\";\n        }\n      }, {\n        key: \"Event\",\n        get: function get() {\n          return f;\n        }\n      }, {\n        key: \"EVENT_KEY\",\n        get: function get() {\n          return s;\n        }\n      }, {\n        key: \"DefaultType\",\n        get: function get() {\n          return h;\n        }\n      }]), a;\n    }();\n\n    return t.fn[e] = m._jQueryInterface, t.fn[e].Constructor = m, t.fn[e].noConflict = function () {\n      return t.fn[e] = a, m._jQueryInterface;\n    }, m;\n  }(jQuery));\n\n  !function (r) {\n    var a = \"popover\",\n        l = \".bs.popover\",\n        h = r.fn[a],\n        c = new RegExp(\"(^|\\\\s)bs-popover\\\\S+\", \"g\"),\n        u = r.extend({}, s.Default, {\n      placement: \"right\",\n      trigger: \"click\",\n      content: \"\",\n      template: '<div class=\"popover\" role=\"tooltip\"><div class=\"arrow\"></div><h3 class=\"popover-header\"></h3><div class=\"popover-body\"></div></div>'\n    }),\n        d = r.extend({}, s.DefaultType, {\n      content: \"(string|element|function)\"\n    }),\n        f = {\n      FADE: \"fade\",\n      SHOW: \"show\"\n    },\n        p = {\n      TITLE: \".popover-header\",\n      CONTENT: \".popover-body\"\n    },\n        _ = {\n      HIDE: \"hide\" + l,\n      HIDDEN: \"hidden\" + l,\n      SHOW: \"show\" + l,\n      SHOWN: \"shown\" + l,\n      INSERTED: \"inserted\" + l,\n      CLICK: \"click\" + l,\n      FOCUSIN: \"focusin\" + l,\n      FOCUSOUT: \"focusout\" + l,\n      MOUSEENTER: \"mouseenter\" + l,\n      MOUSELEAVE: \"mouseleave\" + l\n    },\n        g = function (s) {\n      function h() {\n        return n(this, h), t(this, s.apply(this, arguments));\n      }\n\n      return e(h, s), h.prototype.isWithContent = function () {\n        return this.getTitle() || this._getContent();\n      }, h.prototype.addAttachmentClass = function (t) {\n        r(this.getTipElement()).addClass(\"bs-popover-\" + t);\n      }, h.prototype.getTipElement = function () {\n        return this.tip = this.tip || r(this.config.template)[0];\n      }, h.prototype.setContent = function () {\n        var t = r(this.getTipElement());\n        this.setElementContent(t.find(p.TITLE), this.getTitle()), this.setElementContent(t.find(p.CONTENT), this._getContent()), t.removeClass(f.FADE + \" \" + f.SHOW);\n      }, h.prototype._getContent = function () {\n        return this.element.getAttribute(\"data-content\") || (\"function\" == typeof this.config.content ? this.config.content.call(this.element) : this.config.content);\n      }, h.prototype._cleanTipClass = function () {\n        var t = r(this.getTipElement()),\n            e = t.attr(\"class\").match(c);\n        null !== e && e.length > 0 && t.removeClass(e.join(\"\"));\n      }, h._jQueryInterface = function (t) {\n        return this.each(function () {\n          var e = r(this).data(\"bs.popover\"),\n              n = \"object\" === (void 0 === t ? \"undefined\" : i(t)) ? t : null;\n\n          if ((e || !/destroy|hide/.test(t)) && (e || (e = new h(this, n), r(this).data(\"bs.popover\", e)), \"string\" == typeof t)) {\n            if (void 0 === e[t]) throw new Error('No method named \"' + t + '\"');\n            e[t]();\n          }\n        });\n      }, o(h, null, [{\n        key: \"VERSION\",\n        get: function get() {\n          return \"4.0.0-beta\";\n        }\n      }, {\n        key: \"Default\",\n        get: function get() {\n          return u;\n        }\n      }, {\n        key: \"NAME\",\n        get: function get() {\n          return a;\n        }\n      }, {\n        key: \"DATA_KEY\",\n        get: function get() {\n          return \"bs.popover\";\n        }\n      }, {\n        key: \"Event\",\n        get: function get() {\n          return _;\n        }\n      }, {\n        key: \"EVENT_KEY\",\n        get: function get() {\n          return l;\n        }\n      }, {\n        key: \"DefaultType\",\n        get: function get() {\n          return d;\n        }\n      }]), h;\n    }(s);\n\n    r.fn[a] = g._jQueryInterface, r.fn[a].Constructor = g, r.fn[a].noConflict = function () {\n      return r.fn[a] = h, g._jQueryInterface;\n    };\n  }(jQuery);\n}();\n/*! WOW - v1.1.3 - 2016-05-06\n* Copyright (c) 2016 Matthieu Aussaguel;*/\n\n(function () {\n  var a,\n      b,\n      c,\n      d,\n      e,\n      f = function f(a, b) {\n    return function () {\n      return a.apply(b, arguments);\n    };\n  },\n      g = [].indexOf || function (a) {\n    for (var b = 0, c = this.length; c > b; b++) {\n      if (b in this && this[b] === a) return b;\n    }\n\n    return -1;\n  };\n\n  b = function () {\n    function a() {}\n\n    return a.prototype.extend = function (a, b) {\n      var c, d;\n\n      for (c in b) {\n        d = b[c], null == a[c] && (a[c] = d);\n      }\n\n      return a;\n    }, a.prototype.isMobile = function (a) {\n      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(a);\n    }, a.prototype.createEvent = function (a, b, c, d) {\n      var e;\n      return null == b && (b = !1), null == c && (c = !1), null == d && (d = null), null != document.createEvent ? (e = document.createEvent(\"CustomEvent\"), e.initCustomEvent(a, b, c, d)) : null != document.createEventObject ? (e = document.createEventObject(), e.eventType = a) : e.eventName = a, e;\n    }, a.prototype.emitEvent = function (a, b) {\n      return null != a.dispatchEvent ? a.dispatchEvent(b) : b in (null != a) ? a[b]() : \"on\" + b in (null != a) ? a[\"on\" + b]() : void 0;\n    }, a.prototype.addEvent = function (a, b, c) {\n      return null != a.addEventListener ? a.addEventListener(b, c, !1) : null != a.attachEvent ? a.attachEvent(\"on\" + b, c) : a[b] = c;\n    }, a.prototype.removeEvent = function (a, b, c) {\n      return null != a.removeEventListener ? a.removeEventListener(b, c, !1) : null != a.detachEvent ? a.detachEvent(\"on\" + b, c) : delete a[b];\n    }, a.prototype.innerHeight = function () {\n      return \"innerHeight\" in window ? window.innerHeight : document.documentElement.clientHeight;\n    }, a;\n  }(), c = this.WeakMap || this.MozWeakMap || (c = function () {\n    function a() {\n      this.keys = [], this.values = [];\n    }\n\n    return a.prototype.get = function (a) {\n      var b, c, d, e, f;\n\n      for (f = this.keys, b = d = 0, e = f.length; e > d; b = ++d) {\n        if (c = f[b], c === a) return this.values[b];\n      }\n    }, a.prototype.set = function (a, b) {\n      var c, d, e, f, g;\n\n      for (g = this.keys, c = e = 0, f = g.length; f > e; c = ++e) {\n        if (d = g[c], d === a) return void (this.values[c] = b);\n      }\n\n      return this.keys.push(a), this.values.push(b);\n    }, a;\n  }()), a = this.MutationObserver || this.WebkitMutationObserver || this.MozMutationObserver || (a = function () {\n    function a() {\n      \"undefined\" != typeof console && null !== console && console.warn(\"MutationObserver is not supported by your browser.\"), \"undefined\" != typeof console && null !== console && console.warn(\"WOW.js cannot detect dom mutations, please call .sync() after loading new content.\");\n    }\n\n    return a.notSupported = !0, a.prototype.observe = function () {}, a;\n  }()), d = this.getComputedStyle || function (a, b) {\n    return this.getPropertyValue = function (b) {\n      var c;\n      return \"float\" === b && (b = \"styleFloat\"), e.test(b) && b.replace(e, function (a, b) {\n        return b.toUpperCase();\n      }), (null != (c = a.currentStyle) ? c[b] : void 0) || null;\n    }, this;\n  }, e = /(\\-([a-z]){1})/g, this.WOW = function () {\n    function e(a) {\n      null == a && (a = {}), this.scrollCallback = f(this.scrollCallback, this), this.scrollHandler = f(this.scrollHandler, this), this.resetAnimation = f(this.resetAnimation, this), this.start = f(this.start, this), this.scrolled = !0, this.config = this.util().extend(a, this.defaults), null != a.scrollContainer && (this.config.scrollContainer = document.querySelector(a.scrollContainer)), this.animationNameCache = new c(), this.wowEvent = this.util().createEvent(this.config.boxClass);\n    }\n\n    return e.prototype.defaults = {\n      boxClass: \"wow\",\n      animateClass: \"animated\",\n      offset: 0,\n      mobile: !0,\n      live: !0,\n      callback: null,\n      scrollContainer: null\n    }, e.prototype.init = function () {\n      var a;\n      return this.element = window.document.documentElement, \"interactive\" === (a = document.readyState) || \"complete\" === a ? this.start() : this.util().addEvent(document, \"DOMContentLoaded\", this.start), this.finished = [];\n    }, e.prototype.start = function () {\n      var b, c, d, e;\n      if (this.stopped = !1, this.boxes = function () {\n        var a, c, d, e;\n\n        for (d = this.element.querySelectorAll(\".\" + this.config.boxClass), e = [], a = 0, c = d.length; c > a; a++) {\n          b = d[a], e.push(b);\n        }\n\n        return e;\n      }.call(this), this.all = function () {\n        var a, c, d, e;\n\n        for (d = this.boxes, e = [], a = 0, c = d.length; c > a; a++) {\n          b = d[a], e.push(b);\n        }\n\n        return e;\n      }.call(this), this.boxes.length) if (this.disabled()) this.resetStyle();else for (e = this.boxes, c = 0, d = e.length; d > c; c++) {\n        b = e[c], this.applyStyle(b, !0);\n      }\n      return this.disabled() || (this.util().addEvent(this.config.scrollContainer || window, \"scroll\", this.scrollHandler), this.util().addEvent(window, \"resize\", this.scrollHandler), this.interval = setInterval(this.scrollCallback, 50)), this.config.live ? new a(function (a) {\n        return function (b) {\n          var c, d, e, f, g;\n\n          for (g = [], c = 0, d = b.length; d > c; c++) {\n            f = b[c], g.push(function () {\n              var a, b, c, d;\n\n              for (c = f.addedNodes || [], d = [], a = 0, b = c.length; b > a; a++) {\n                e = c[a], d.push(this.doSync(e));\n              }\n\n              return d;\n            }.call(a));\n          }\n\n          return g;\n        };\n      }(this)).observe(document.body, {\n        childList: !0,\n        subtree: !0\n      }) : void 0;\n    }, e.prototype.stop = function () {\n      return this.stopped = !0, this.util().removeEvent(this.config.scrollContainer || window, \"scroll\", this.scrollHandler), this.util().removeEvent(window, \"resize\", this.scrollHandler), null != this.interval ? clearInterval(this.interval) : void 0;\n    }, e.prototype.sync = function (b) {\n      return a.notSupported ? this.doSync(this.element) : void 0;\n    }, e.prototype.doSync = function (a) {\n      var b, c, d, e, f;\n\n      if (null == a && (a = this.element), 1 === a.nodeType) {\n        for (a = a.parentNode || a, e = a.querySelectorAll(\".\" + this.config.boxClass), f = [], c = 0, d = e.length; d > c; c++) {\n          b = e[c], g.call(this.all, b) < 0 ? (this.boxes.push(b), this.all.push(b), this.stopped || this.disabled() ? this.resetStyle() : this.applyStyle(b, !0), f.push(this.scrolled = !0)) : f.push(void 0);\n        }\n\n        return f;\n      }\n    }, e.prototype.show = function (a) {\n      return this.applyStyle(a), a.className = a.className + \" \" + this.config.animateClass, null != this.config.callback && this.config.callback(a), this.util().emitEvent(a, this.wowEvent), this.util().addEvent(a, \"animationend\", this.resetAnimation), this.util().addEvent(a, \"oanimationend\", this.resetAnimation), this.util().addEvent(a, \"webkitAnimationEnd\", this.resetAnimation), this.util().addEvent(a, \"MSAnimationEnd\", this.resetAnimation), a;\n    }, e.prototype.applyStyle = function (a, b) {\n      var c, d, e;\n      return d = a.getAttribute(\"data-wow-duration\"), c = a.getAttribute(\"data-wow-delay\"), e = a.getAttribute(\"data-wow-iteration\"), this.animate(function (f) {\n        return function () {\n          return f.customStyle(a, b, d, c, e);\n        };\n      }(this));\n    }, e.prototype.animate = function () {\n      return \"requestAnimationFrame\" in window ? function (a) {\n        return window.requestAnimationFrame(a);\n      } : function (a) {\n        return a();\n      };\n    }(), e.prototype.resetStyle = function () {\n      var a, b, c, d, e;\n\n      for (d = this.boxes, e = [], b = 0, c = d.length; c > b; b++) {\n        a = d[b], e.push(a.style.visibility = \"visible\");\n      }\n\n      return e;\n    }, e.prototype.resetAnimation = function (a) {\n      var b;\n      return a.type.toLowerCase().indexOf(\"animationend\") >= 0 ? (b = a.target || a.srcElement, b.className = b.className.replace(this.config.animateClass, \"\").trim()) : void 0;\n    }, e.prototype.customStyle = function (a, b, c, d, e) {\n      return b && this.cacheAnimationName(a), a.style.visibility = b ? \"hidden\" : \"visible\", c && this.vendorSet(a.style, {\n        animationDuration: c\n      }), d && this.vendorSet(a.style, {\n        animationDelay: d\n      }), e && this.vendorSet(a.style, {\n        animationIterationCount: e\n      }), this.vendorSet(a.style, {\n        animationName: b ? \"none\" : this.cachedAnimationName(a)\n      }), a;\n    }, e.prototype.vendors = [\"moz\", \"webkit\"], e.prototype.vendorSet = function (a, b) {\n      var c, d, e, f;\n      d = [];\n\n      for (c in b) {\n        e = b[c], a[\"\" + c] = e, d.push(function () {\n          var b, d, g, h;\n\n          for (g = this.vendors, h = [], b = 0, d = g.length; d > b; b++) {\n            f = g[b], h.push(a[\"\" + f + c.charAt(0).toUpperCase() + c.substr(1)] = e);\n          }\n\n          return h;\n        }.call(this));\n      }\n\n      return d;\n    }, e.prototype.vendorCSS = function (a, b) {\n      var c, e, f, g, h, i;\n\n      for (h = d(a), g = h.getPropertyCSSValue(b), f = this.vendors, c = 0, e = f.length; e > c; c++) {\n        i = f[c], g = g || h.getPropertyCSSValue(\"-\" + i + \"-\" + b);\n      }\n\n      return g;\n    }, e.prototype.animationName = function (a) {\n      var b;\n\n      try {\n        b = this.vendorCSS(a, \"animation-name\").cssText;\n      } catch (c) {\n        b = d(a).getPropertyValue(\"animation-name\");\n      }\n\n      return \"none\" === b ? \"\" : b;\n    }, e.prototype.cacheAnimationName = function (a) {\n      return this.animationNameCache.set(a, this.animationName(a));\n    }, e.prototype.cachedAnimationName = function (a) {\n      return this.animationNameCache.get(a);\n    }, e.prototype.scrollHandler = function () {\n      return this.scrolled = !0;\n    }, e.prototype.scrollCallback = function () {\n      var a;\n      return !this.scrolled || (this.scrolled = !1, this.boxes = function () {\n        var b, c, d, e;\n\n        for (d = this.boxes, e = [], b = 0, c = d.length; c > b; b++) {\n          a = d[b], a && (this.isVisible(a) ? this.show(a) : e.push(a));\n        }\n\n        return e;\n      }.call(this), this.boxes.length || this.config.live) ? void 0 : this.stop();\n    }, e.prototype.offsetTop = function (a) {\n      for (var b; void 0 === a.offsetTop;) {\n        a = a.parentNode;\n      }\n\n      for (b = a.offsetTop; a = a.offsetParent;) {\n        b += a.offsetTop;\n      }\n\n      return b;\n    }, e.prototype.isVisible = function (a) {\n      var b, c, d, e, f;\n      return c = a.getAttribute(\"data-wow-offset\") || this.config.offset, f = this.config.scrollContainer && this.config.scrollContainer.scrollTop || window.pageYOffset, e = f + Math.min(this.element.clientHeight, this.util().innerHeight()) - c, d = this.offsetTop(a), b = d + a.clientHeight, e >= d && b >= f;\n    }, e.prototype.util = function () {\n      return null != this._util ? this._util : this._util = new b();\n    }, e.prototype.disabled = function () {\n      return !this.config.mobile && this.util().isMobile(navigator.userAgent);\n    }, e;\n  }();\n}).call(this);\n/* ============================================================\n * retina-replace.min.js v1.0\n * http://github.com/leonsmith/retina-replace-js\n * ============================================================\n * Author: Leon Smith\n * Twitter: @nullUK\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ============================================================ */\n\n(function (a) {\n  var e = function e(d, c) {\n    this.options = c;\n    var b = a(d),\n        g = b.is(\"img\"),\n        f = g ? b.attr(\"src\") : b.backgroundImageUrl(),\n        f = this.options.generateUrl(b, f);\n    a(\"<img/>\").attr(\"src\", f).on('load', function () {\n      g ? b.attr(\"src\", a(this).attr(\"src\")) : (b.backgroundImageUrl(a(this).attr(\"src\")), b.backgroundSize(a(this)[0].width, a(this)[0].height));\n      b.attr(\"data-retina\", \"complete\");\n    });\n  };\n\n  e.prototype = {\n    constructor: e\n  };\n\n  a.fn.retinaReplace = function (d) {\n    var c;\n    c = void 0 === window.devicePixelRatio ? 1 : window.devicePixelRatio;\n    return 1 >= c ? this : this.each(function () {\n      var b = a(this),\n          c = b.data(\"retinaReplace\"),\n          f = a.extend({}, a.fn.retinaReplace.defaults, b.data(), \"object\" == _typeof(d) && d);\n      c || b.data(\"retinaReplace\", c = new e(this, f));\n      if (\"string\" == typeof d) c[d]();\n    });\n  };\n\n  a.fn.retinaReplace.defaults = {\n    suffix: \"_2x\",\n    generateUrl: function generateUrl(a, c) {\n      var b = c.lastIndexOf(\".\"),\n          e = c.substr(b + 1);\n      return c.substr(0, b) + this.suffix + \".\" + e;\n    }\n  };\n  a.fn.retinaReplace.Constructor = e;\n\n  a.fn.backgroundImageUrl = function (d) {\n    return d ? this.each(function () {\n      a(this).css(\"background-image\", 'url(\"' + d + '\")');\n    }) : a(this).css(\"background-image\").replace(/url\\(|\\)|\"|'/g, \"\");\n  };\n\n  a.fn.backgroundSize = function (d, c) {\n    var b = Math.floor(d / 2) + \"px \" + Math.floor(c / 2) + \"px\";\n    a(this).css(\"background-size\", b);\n    a(this).css(\"-webkit-background-size\", b);\n  };\n\n  a(function () {\n    a(\"[data-retina='true']\").retinaReplace();\n  });\n})(window.jQuery);\n/**\n * Owl Carousel v2.2.1\n * Copyright 2013-2017 David Deutsch\n * Licensed under  ()\n */\n\n\n!function (a, b, c, d) {\n  function e(b, c) {\n    this.settings = null, this.options = a.extend({}, e.Defaults, c), this.$element = a(b), this._handlers = {}, this._plugins = {}, this._supress = {}, this._current = null, this._speed = null, this._coordinates = [], this._breakpoint = null, this._width = null, this._items = [], this._clones = [], this._mergers = [], this._widths = [], this._invalidated = {}, this._pipe = [], this._drag = {\n      time: null,\n      target: null,\n      pointer: null,\n      stage: {\n        start: null,\n        current: null\n      },\n      direction: null\n    }, this._states = {\n      current: {},\n      tags: {\n        initializing: [\"busy\"],\n        animating: [\"busy\"],\n        dragging: [\"interacting\"]\n      }\n    }, a.each([\"onResize\", \"onThrottledResize\"], a.proxy(function (b, c) {\n      this._handlers[c] = a.proxy(this[c], this);\n    }, this)), a.each(e.Plugins, a.proxy(function (a, b) {\n      this._plugins[a.charAt(0).toLowerCase() + a.slice(1)] = new b(this);\n    }, this)), a.each(e.Workers, a.proxy(function (b, c) {\n      this._pipe.push({\n        filter: c.filter,\n        run: a.proxy(c.run, this)\n      });\n    }, this)), this.setup(), this.initialize();\n  }\n\n  e.Defaults = {\n    items: 3,\n    loop: !1,\n    center: !1,\n    rewind: !1,\n    mouseDrag: !0,\n    touchDrag: !0,\n    pullDrag: !0,\n    freeDrag: !1,\n    margin: 0,\n    stagePadding: 0,\n    merge: !1,\n    mergeFit: !0,\n    autoWidth: !1,\n    startPosition: 0,\n    rtl: !1,\n    smartSpeed: 250,\n    fluidSpeed: !1,\n    dragEndSpeed: !1,\n    responsive: {},\n    responsiveRefreshRate: 200,\n    responsiveBaseElement: b,\n    fallbackEasing: \"swing\",\n    info: !1,\n    nestedItemSelector: !1,\n    itemElement: \"div\",\n    stageElement: \"div\",\n    refreshClass: \"owl-refresh\",\n    loadedClass: \"owl-loaded\",\n    loadingClass: \"owl-loading\",\n    rtlClass: \"owl-rtl\",\n    responsiveClass: \"owl-responsive\",\n    dragClass: \"owl-drag\",\n    itemClass: \"owl-item\",\n    stageClass: \"owl-stage\",\n    stageOuterClass: \"owl-stage-outer\",\n    grabClass: \"owl-grab\"\n  }, e.Width = {\n    Default: \"default\",\n    Inner: \"inner\",\n    Outer: \"outer\"\n  }, e.Type = {\n    Event: \"event\",\n    State: \"state\"\n  }, e.Plugins = {}, e.Workers = [{\n    filter: [\"width\", \"settings\"],\n    run: function run() {\n      this._width = this.$element.width();\n    }\n  }, {\n    filter: [\"width\", \"items\", \"settings\"],\n    run: function run(a) {\n      a.current = this._items && this._items[this.relative(this._current)];\n    }\n  }, {\n    filter: [\"items\", \"settings\"],\n    run: function run() {\n      this.$stage.children(\".cloned\").remove();\n    }\n  }, {\n    filter: [\"width\", \"items\", \"settings\"],\n    run: function run(a) {\n      var b = this.settings.margin || \"\",\n          c = !this.settings.autoWidth,\n          d = this.settings.rtl,\n          e = {\n        width: \"auto\",\n        \"margin-left\": d ? b : \"\",\n        \"margin-right\": d ? \"\" : b\n      };\n      !c && this.$stage.children().css(e), a.css = e;\n    }\n  }, {\n    filter: [\"width\", \"items\", \"settings\"],\n    run: function run(a) {\n      var b = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,\n          c = null,\n          d = this._items.length,\n          e = !this.settings.autoWidth,\n          f = [];\n\n      for (a.items = {\n        merge: !1,\n        width: b\n      }; d--;) {\n        c = this._mergers[d], c = this.settings.mergeFit && Math.min(c, this.settings.items) || c, a.items.merge = c > 1 || a.items.merge, f[d] = e ? b * c : this._items[d].width();\n      }\n\n      this._widths = f;\n    }\n  }, {\n    filter: [\"items\", \"settings\"],\n    run: function run() {\n      var b = [],\n          c = this._items,\n          d = this.settings,\n          e = Math.max(2 * d.items, 4),\n          f = 2 * Math.ceil(c.length / 2),\n          g = d.loop && c.length ? d.rewind ? e : Math.max(e, f) : 0,\n          h = \"\",\n          i = \"\";\n\n      for (g /= 2; g--;) {\n        b.push(this.normalize(b.length / 2, !0)), h += c[b[b.length - 1]][0].outerHTML, b.push(this.normalize(c.length - 1 - (b.length - 1) / 2, !0)), i = c[b[b.length - 1]][0].outerHTML + i;\n      }\n\n      this._clones = b, a(h).addClass(\"cloned\").appendTo(this.$stage), a(i).addClass(\"cloned\").prependTo(this.$stage);\n    }\n  }, {\n    filter: [\"width\", \"items\", \"settings\"],\n    run: function run() {\n      for (var a = this.settings.rtl ? 1 : -1, b = this._clones.length + this._items.length, c = -1, d = 0, e = 0, f = []; ++c < b;) {\n        d = f[c - 1] || 0, e = this._widths[this.relative(c)] + this.settings.margin, f.push(d + e * a);\n      }\n\n      this._coordinates = f;\n    }\n  }, {\n    filter: [\"width\", \"items\", \"settings\"],\n    run: function run() {\n      var a = this.settings.stagePadding,\n          b = this._coordinates,\n          c = {\n        width: Math.ceil(Math.abs(b[b.length - 1])) + 2 * a,\n        \"padding-left\": a || \"\",\n        \"padding-right\": a || \"\"\n      };\n      this.$stage.css(c);\n    }\n  }, {\n    filter: [\"width\", \"items\", \"settings\"],\n    run: function run(a) {\n      var b = this._coordinates.length,\n          c = !this.settings.autoWidth,\n          d = this.$stage.children();\n      if (c && a.items.merge) for (; b--;) {\n        a.css.width = this._widths[this.relative(b)], d.eq(b).css(a.css);\n      } else c && (a.css.width = a.items.width, d.css(a.css));\n    }\n  }, {\n    filter: [\"items\"],\n    run: function run() {\n      this._coordinates.length < 1 && this.$stage.removeAttr(\"style\");\n    }\n  }, {\n    filter: [\"width\", \"items\", \"settings\"],\n    run: function run(a) {\n      a.current = a.current ? this.$stage.children().index(a.current) : 0, a.current = Math.max(this.minimum(), Math.min(this.maximum(), a.current)), this.reset(a.current);\n    }\n  }, {\n    filter: [\"position\"],\n    run: function run() {\n      this.animate(this.coordinates(this._current));\n    }\n  }, {\n    filter: [\"width\", \"position\", \"items\", \"settings\"],\n    run: function run() {\n      var a,\n          b,\n          c,\n          d,\n          e = this.settings.rtl ? 1 : -1,\n          f = 2 * this.settings.stagePadding,\n          g = this.coordinates(this.current()) + f,\n          h = g + this.width() * e,\n          i = [];\n\n      for (c = 0, d = this._coordinates.length; c < d; c++) {\n        a = this._coordinates[c - 1] || 0, b = Math.abs(this._coordinates[c]) + f * e, (this.op(a, \"<=\", g) && this.op(a, \">\", h) || this.op(b, \"<\", g) && this.op(b, \">\", h)) && i.push(c);\n      }\n\n      this.$stage.children(\".active\").removeClass(\"active\"), this.$stage.children(\":eq(\" + i.join(\"), :eq(\") + \")\").addClass(\"active\"), this.settings.center && (this.$stage.children(\".center\").removeClass(\"center\"), this.$stage.children().eq(this.current()).addClass(\"center\"));\n    }\n  }], e.prototype.initialize = function () {\n    if (this.enter(\"initializing\"), this.trigger(\"initialize\"), this.$element.toggleClass(this.settings.rtlClass, this.settings.rtl), this.settings.autoWidth && !this.is(\"pre-loading\")) {\n      var b, c, e;\n      b = this.$element.find(\"img\"), c = this.settings.nestedItemSelector ? \".\" + this.settings.nestedItemSelector : d, e = this.$element.children(c).width(), b.length && e <= 0 && this.preloadAutoWidthImages(b);\n    }\n\n    this.$element.addClass(this.options.loadingClass), this.$stage = a(\"<\" + this.settings.stageElement + ' class=\"' + this.settings.stageClass + '\"/>').wrap('<div class=\"' + this.settings.stageOuterClass + '\"/>'), this.$element.append(this.$stage.parent()), this.replace(this.$element.children().not(this.$stage.parent())), this.$element.is(\":visible\") ? this.refresh() : this.invalidate(\"width\"), this.$element.removeClass(this.options.loadingClass).addClass(this.options.loadedClass), this.registerEventHandlers(), this.leave(\"initializing\"), this.trigger(\"initialized\");\n  }, e.prototype.setup = function () {\n    var b = this.viewport(),\n        c = this.options.responsive,\n        d = -1,\n        e = null;\n    c ? (a.each(c, function (a) {\n      a <= b && a > d && (d = Number(a));\n    }), e = a.extend({}, this.options, c[d]), \"function\" == typeof e.stagePadding && (e.stagePadding = e.stagePadding()), delete e.responsive, e.responsiveClass && this.$element.attr(\"class\", this.$element.attr(\"class\").replace(new RegExp(\"(\" + this.options.responsiveClass + \"-)\\\\S+\\\\s\", \"g\"), \"$1\" + d))) : e = a.extend({}, this.options), this.trigger(\"change\", {\n      property: {\n        name: \"settings\",\n        value: e\n      }\n    }), this._breakpoint = d, this.settings = e, this.invalidate(\"settings\"), this.trigger(\"changed\", {\n      property: {\n        name: \"settings\",\n        value: this.settings\n      }\n    });\n  }, e.prototype.optionsLogic = function () {\n    this.settings.autoWidth && (this.settings.stagePadding = !1, this.settings.merge = !1);\n  }, e.prototype.prepare = function (b) {\n    var c = this.trigger(\"prepare\", {\n      content: b\n    });\n    return c.data || (c.data = a(\"<\" + this.settings.itemElement + \"/>\").addClass(this.options.itemClass).append(b)), this.trigger(\"prepared\", {\n      content: c.data\n    }), c.data;\n  }, e.prototype.update = function () {\n    for (var b = 0, c = this._pipe.length, d = a.proxy(function (a) {\n      return this[a];\n    }, this._invalidated), e = {}; b < c;) {\n      (this._invalidated.all || a.grep(this._pipe[b].filter, d).length > 0) && this._pipe[b].run(e), b++;\n    }\n\n    this._invalidated = {}, !this.is(\"valid\") && this.enter(\"valid\");\n  }, e.prototype.width = function (a) {\n    switch (a = a || e.Width.Default) {\n      case e.Width.Inner:\n      case e.Width.Outer:\n        return this._width;\n\n      default:\n        return this._width - 2 * this.settings.stagePadding + this.settings.margin;\n    }\n  }, e.prototype.refresh = function () {\n    this.enter(\"refreshing\"), this.trigger(\"refresh\"), this.setup(), this.optionsLogic(), this.$element.addClass(this.options.refreshClass), this.update(), this.$element.removeClass(this.options.refreshClass), this.leave(\"refreshing\"), this.trigger(\"refreshed\");\n  }, e.prototype.onThrottledResize = function () {\n    b.clearTimeout(this.resizeTimer), this.resizeTimer = b.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);\n  }, e.prototype.onResize = function () {\n    return !!this._items.length && this._width !== this.$element.width() && !!this.$element.is(\":visible\") && (this.enter(\"resizing\"), this.trigger(\"resize\").isDefaultPrevented() ? (this.leave(\"resizing\"), !1) : (this.invalidate(\"width\"), this.refresh(), this.leave(\"resizing\"), void this.trigger(\"resized\")));\n  }, e.prototype.registerEventHandlers = function () {\n    a.support.transition && this.$stage.on(a.support.transition.end + \".owl.core\", a.proxy(this.onTransitionEnd, this)), this.settings.responsive !== !1 && this.on(b, \"resize\", this._handlers.onThrottledResize), this.settings.mouseDrag && (this.$element.addClass(this.options.dragClass), this.$stage.on(\"mousedown.owl.core\", a.proxy(this.onDragStart, this)), this.$stage.on(\"dragstart.owl.core selectstart.owl.core\", function () {\n      return !1;\n    })), this.settings.touchDrag && (this.$stage.on(\"touchstart.owl.core\", a.proxy(this.onDragStart, this)), this.$stage.on(\"touchcancel.owl.core\", a.proxy(this.onDragEnd, this)));\n  }, e.prototype.onDragStart = function (b) {\n    var d = null;\n    3 !== b.which && (a.support.transform ? (d = this.$stage.css(\"transform\").replace(/.*\\(|\\)| /g, \"\").split(\",\"), d = {\n      x: d[16 === d.length ? 12 : 4],\n      y: d[16 === d.length ? 13 : 5]\n    }) : (d = this.$stage.position(), d = {\n      x: this.settings.rtl ? d.left + this.$stage.width() - this.width() + this.settings.margin : d.left,\n      y: d.top\n    }), this.is(\"animating\") && (a.support.transform ? this.animate(d.x) : this.$stage.stop(), this.invalidate(\"position\")), this.$element.toggleClass(this.options.grabClass, \"mousedown\" === b.type), this.speed(0), this._drag.time = new Date().getTime(), this._drag.target = a(b.target), this._drag.stage.start = d, this._drag.stage.current = d, this._drag.pointer = this.pointer(b), a(c).on(\"mouseup.owl.core touchend.owl.core\", a.proxy(this.onDragEnd, this)), a(c).one(\"mousemove.owl.core touchmove.owl.core\", a.proxy(function (b) {\n      var d = this.difference(this._drag.pointer, this.pointer(b));\n      a(c).on(\"mousemove.owl.core touchmove.owl.core\", a.proxy(this.onDragMove, this)), Math.abs(d.x) < Math.abs(d.y) && this.is(\"valid\") || (b.preventDefault(), this.enter(\"dragging\"), this.trigger(\"drag\"));\n    }, this)));\n  }, e.prototype.onDragMove = function (a) {\n    var b = null,\n        c = null,\n        d = null,\n        e = this.difference(this._drag.pointer, this.pointer(a)),\n        f = this.difference(this._drag.stage.start, e);\n    this.is(\"dragging\") && (a.preventDefault(), this.settings.loop ? (b = this.coordinates(this.minimum()), c = this.coordinates(this.maximum() + 1) - b, f.x = ((f.x - b) % c + c) % c + b) : (b = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum()), c = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum()), d = this.settings.pullDrag ? -1 * e.x / 5 : 0, f.x = Math.max(Math.min(f.x, b + d), c + d)), this._drag.stage.current = f, this.animate(f.x));\n  }, e.prototype.onDragEnd = function (b) {\n    var d = this.difference(this._drag.pointer, this.pointer(b)),\n        e = this._drag.stage.current,\n        f = d.x > 0 ^ this.settings.rtl ? \"left\" : \"right\";\n    a(c).off(\".owl.core\"), this.$element.removeClass(this.options.grabClass), (0 !== d.x && this.is(\"dragging\") || !this.is(\"valid\")) && (this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed), this.current(this.closest(e.x, 0 !== d.x ? f : this._drag.direction)), this.invalidate(\"position\"), this.update(), this._drag.direction = f, (Math.abs(d.x) > 3 || new Date().getTime() - this._drag.time > 300) && this._drag.target.one(\"click.owl.core\", function () {\n      return !1;\n    })), this.is(\"dragging\") && (this.leave(\"dragging\"), this.trigger(\"dragged\"));\n  }, e.prototype.closest = function (b, c) {\n    var d = -1,\n        e = 30,\n        f = this.width(),\n        g = this.coordinates();\n    return this.settings.freeDrag || a.each(g, a.proxy(function (a, h) {\n      return \"left\" === c && b > h - e && b < h + e ? d = a : \"right\" === c && b > h - f - e && b < h - f + e ? d = a + 1 : this.op(b, \"<\", h) && this.op(b, \">\", g[a + 1] || h - f) && (d = \"left\" === c ? a + 1 : a), d === -1;\n    }, this)), this.settings.loop || (this.op(b, \">\", g[this.minimum()]) ? d = b = this.minimum() : this.op(b, \"<\", g[this.maximum()]) && (d = b = this.maximum())), d;\n  }, e.prototype.animate = function (b) {\n    var c = this.speed() > 0;\n    this.is(\"animating\") && this.onTransitionEnd(), c && (this.enter(\"animating\"), this.trigger(\"translate\")), a.support.transform3d && a.support.transition ? this.$stage.css({\n      transform: \"translate3d(\" + b + \"px,0px,0px)\",\n      transition: this.speed() / 1e3 + \"s\"\n    }) : c ? this.$stage.animate({\n      left: b + \"px\"\n    }, this.speed(), this.settings.fallbackEasing, a.proxy(this.onTransitionEnd, this)) : this.$stage.css({\n      left: b + \"px\"\n    });\n  }, e.prototype.is = function (a) {\n    return this._states.current[a] && this._states.current[a] > 0;\n  }, e.prototype.current = function (a) {\n    if (a === d) return this._current;\n    if (0 === this._items.length) return d;\n\n    if (a = this.normalize(a), this._current !== a) {\n      var b = this.trigger(\"change\", {\n        property: {\n          name: \"position\",\n          value: a\n        }\n      });\n      b.data !== d && (a = this.normalize(b.data)), this._current = a, this.invalidate(\"position\"), this.trigger(\"changed\", {\n        property: {\n          name: \"position\",\n          value: this._current\n        }\n      });\n    }\n\n    return this._current;\n  }, e.prototype.invalidate = function (b) {\n    return \"string\" === a.type(b) && (this._invalidated[b] = !0, this.is(\"valid\") && this.leave(\"valid\")), a.map(this._invalidated, function (a, b) {\n      return b;\n    });\n  }, e.prototype.reset = function (a) {\n    a = this.normalize(a), a !== d && (this._speed = 0, this._current = a, this.suppress([\"translate\", \"translated\"]), this.animate(this.coordinates(a)), this.release([\"translate\", \"translated\"]));\n  }, e.prototype.normalize = function (a, b) {\n    var c = this._items.length,\n        e = b ? 0 : this._clones.length;\n    return !this.isNumeric(a) || c < 1 ? a = d : (a < 0 || a >= c + e) && (a = ((a - e / 2) % c + c) % c + e / 2), a;\n  }, e.prototype.relative = function (a) {\n    return a -= this._clones.length / 2, this.normalize(a, !0);\n  }, e.prototype.maximum = function (a) {\n    var b,\n        c,\n        d,\n        e = this.settings,\n        f = this._coordinates.length;\n    if (e.loop) f = this._clones.length / 2 + this._items.length - 1;else if (e.autoWidth || e.merge) {\n      for (b = this._items.length, c = this._items[--b].width(), d = this.$element.width(); b-- && (c += this._items[b].width() + this.settings.margin, !(c > d));) {\n        ;\n      }\n\n      f = b + 1;\n    } else f = e.center ? this._items.length - 1 : this._items.length - e.items;\n    return a && (f -= this._clones.length / 2), Math.max(f, 0);\n  }, e.prototype.minimum = function (a) {\n    return a ? 0 : this._clones.length / 2;\n  }, e.prototype.items = function (a) {\n    return a === d ? this._items.slice() : (a = this.normalize(a, !0), this._items[a]);\n  }, e.prototype.mergers = function (a) {\n    return a === d ? this._mergers.slice() : (a = this.normalize(a, !0), this._mergers[a]);\n  }, e.prototype.clones = function (b) {\n    var c = this._clones.length / 2,\n        e = c + this._items.length,\n        f = function f(a) {\n      return a % 2 === 0 ? e + a / 2 : c - (a + 1) / 2;\n    };\n\n    return b === d ? a.map(this._clones, function (a, b) {\n      return f(b);\n    }) : a.map(this._clones, function (a, c) {\n      return a === b ? f(c) : null;\n    });\n  }, e.prototype.speed = function (a) {\n    return a !== d && (this._speed = a), this._speed;\n  }, e.prototype.coordinates = function (b) {\n    var c,\n        e = 1,\n        f = b - 1;\n    return b === d ? a.map(this._coordinates, a.proxy(function (a, b) {\n      return this.coordinates(b);\n    }, this)) : (this.settings.center ? (this.settings.rtl && (e = -1, f = b + 1), c = this._coordinates[b], c += (this.width() - c + (this._coordinates[f] || 0)) / 2 * e) : c = this._coordinates[f] || 0, c = Math.ceil(c));\n  }, e.prototype.duration = function (a, b, c) {\n    return 0 === c ? 0 : Math.min(Math.max(Math.abs(b - a), 1), 6) * Math.abs(c || this.settings.smartSpeed);\n  }, e.prototype.to = function (a, b) {\n    var c = this.current(),\n        d = null,\n        e = a - this.relative(c),\n        f = (e > 0) - (e < 0),\n        g = this._items.length,\n        h = this.minimum(),\n        i = this.maximum();\n    this.settings.loop ? (!this.settings.rewind && Math.abs(e) > g / 2 && (e += f * -1 * g), a = c + e, d = ((a - h) % g + g) % g + h, d !== a && d - e <= i && d - e > 0 && (c = d - e, a = d, this.reset(c))) : this.settings.rewind ? (i += 1, a = (a % i + i) % i) : a = Math.max(h, Math.min(i, a)), this.speed(this.duration(c, a, b)), this.current(a), this.$element.is(\":visible\") && this.update();\n  }, e.prototype.next = function (a) {\n    a = a || !1, this.to(this.relative(this.current()) + 1, a);\n  }, e.prototype.prev = function (a) {\n    a = a || !1, this.to(this.relative(this.current()) - 1, a);\n  }, e.prototype.onTransitionEnd = function (a) {\n    if (a !== d && (a.stopPropagation(), (a.target || a.srcElement || a.originalTarget) !== this.$stage.get(0))) return !1;\n    this.leave(\"animating\"), this.trigger(\"translated\");\n  }, e.prototype.viewport = function () {\n    var d;\n    return this.options.responsiveBaseElement !== b ? d = a(this.options.responsiveBaseElement).width() : b.innerWidth ? d = b.innerWidth : c.documentElement && c.documentElement.clientWidth ? d = c.documentElement.clientWidth : console.warn(\"Can not detect viewport width.\"), d;\n  }, e.prototype.replace = function (b) {\n    this.$stage.empty(), this._items = [], b && (b = b instanceof jQuery ? b : a(b)), this.settings.nestedItemSelector && (b = b.find(\".\" + this.settings.nestedItemSelector)), b.filter(function () {\n      return 1 === this.nodeType;\n    }).each(a.proxy(function (a, b) {\n      b = this.prepare(b), this.$stage.append(b), this._items.push(b), this._mergers.push(1 * b.find(\"[data-merge]\").addBack(\"[data-merge]\").attr(\"data-merge\") || 1);\n    }, this)), this.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0), this.invalidate(\"items\");\n  }, e.prototype.add = function (b, c) {\n    var e = this.relative(this._current);\n    c = c === d ? this._items.length : this.normalize(c, !0), b = b instanceof jQuery ? b : a(b), this.trigger(\"add\", {\n      content: b,\n      position: c\n    }), b = this.prepare(b), 0 === this._items.length || c === this._items.length ? (0 === this._items.length && this.$stage.append(b), 0 !== this._items.length && this._items[c - 1].after(b), this._items.push(b), this._mergers.push(1 * b.find(\"[data-merge]\").addBack(\"[data-merge]\").attr(\"data-merge\") || 1)) : (this._items[c].before(b), this._items.splice(c, 0, b), this._mergers.splice(c, 0, 1 * b.find(\"[data-merge]\").addBack(\"[data-merge]\").attr(\"data-merge\") || 1)), this._items[e] && this.reset(this._items[e].index()), this.invalidate(\"items\"), this.trigger(\"added\", {\n      content: b,\n      position: c\n    });\n  }, e.prototype.remove = function (a) {\n    a = this.normalize(a, !0), a !== d && (this.trigger(\"remove\", {\n      content: this._items[a],\n      position: a\n    }), this._items[a].remove(), this._items.splice(a, 1), this._mergers.splice(a, 1), this.invalidate(\"items\"), this.trigger(\"removed\", {\n      content: null,\n      position: a\n    }));\n  }, e.prototype.preloadAutoWidthImages = function (b) {\n    b.each(a.proxy(function (b, c) {\n      this.enter(\"pre-loading\"), c = a(c), a(new Image()).one(\"load\", a.proxy(function (a) {\n        c.attr(\"src\", a.target.src), c.css(\"opacity\", 1), this.leave(\"pre-loading\"), !this.is(\"pre-loading\") && !this.is(\"initializing\") && this.refresh();\n      }, this)).attr(\"src\", c.attr(\"src\") || c.attr(\"data-src\") || c.attr(\"data-src-retina\"));\n    }, this));\n  }, e.prototype.destroy = function () {\n    this.$element.off(\".owl.core\"), this.$stage.off(\".owl.core\"), a(c).off(\".owl.core\"), this.settings.responsive !== !1 && (b.clearTimeout(this.resizeTimer), this.off(b, \"resize\", this._handlers.onThrottledResize));\n\n    for (var d in this._plugins) {\n      this._plugins[d].destroy();\n    }\n\n    this.$stage.children(\".cloned\").remove(), this.$stage.unwrap(), this.$stage.children().contents().unwrap(), this.$stage.children().unwrap(), this.$element.removeClass(this.options.refreshClass).removeClass(this.options.loadingClass).removeClass(this.options.loadedClass).removeClass(this.options.rtlClass).removeClass(this.options.dragClass).removeClass(this.options.grabClass).attr(\"class\", this.$element.attr(\"class\").replace(new RegExp(this.options.responsiveClass + \"-\\\\S+\\\\s\", \"g\"), \"\")).removeData(\"owl.carousel\");\n  }, e.prototype.op = function (a, b, c) {\n    var d = this.settings.rtl;\n\n    switch (b) {\n      case \"<\":\n        return d ? a > c : a < c;\n\n      case \">\":\n        return d ? a < c : a > c;\n\n      case \">=\":\n        return d ? a <= c : a >= c;\n\n      case \"<=\":\n        return d ? a >= c : a <= c;\n    }\n  }, e.prototype.on = function (a, b, c, d) {\n    a.addEventListener ? a.addEventListener(b, c, d) : a.attachEvent && a.attachEvent(\"on\" + b, c);\n  }, e.prototype.off = function (a, b, c, d) {\n    a.removeEventListener ? a.removeEventListener(b, c, d) : a.detachEvent && a.detachEvent(\"on\" + b, c);\n  }, e.prototype.trigger = function (b, c, d, f, g) {\n    var h = {\n      item: {\n        count: this._items.length,\n        index: this.current()\n      }\n    },\n        i = a.camelCase(a.grep([\"on\", b, d], function (a) {\n      return a;\n    }).join(\"-\").toLowerCase()),\n        j = a.Event([b, \"owl\", d || \"carousel\"].join(\".\").toLowerCase(), a.extend({\n      relatedTarget: this\n    }, h, c));\n    return this._supress[b] || (a.each(this._plugins, function (a, b) {\n      b.onTrigger && b.onTrigger(j);\n    }), this.register({\n      type: e.Type.Event,\n      name: b\n    }), this.$element.trigger(j), this.settings && \"function\" == typeof this.settings[i] && this.settings[i].call(this, j)), j;\n  }, e.prototype.enter = function (b) {\n    a.each([b].concat(this._states.tags[b] || []), a.proxy(function (a, b) {\n      this._states.current[b] === d && (this._states.current[b] = 0), this._states.current[b]++;\n    }, this));\n  }, e.prototype.leave = function (b) {\n    a.each([b].concat(this._states.tags[b] || []), a.proxy(function (a, b) {\n      this._states.current[b]--;\n    }, this));\n  }, e.prototype.register = function (b) {\n    if (b.type === e.Type.Event) {\n      if (a.event.special[b.name] || (a.event.special[b.name] = {}), !a.event.special[b.name].owl) {\n        var c = a.event.special[b.name]._default;\n        a.event.special[b.name]._default = function (a) {\n          return !c || !c.apply || a.namespace && a.namespace.indexOf(\"owl\") !== -1 ? a.namespace && a.namespace.indexOf(\"owl\") > -1 : c.apply(this, arguments);\n        }, a.event.special[b.name].owl = !0;\n      }\n    } else b.type === e.Type.State && (this._states.tags[b.name] ? this._states.tags[b.name] = this._states.tags[b.name].concat(b.tags) : this._states.tags[b.name] = b.tags, this._states.tags[b.name] = a.grep(this._states.tags[b.name], a.proxy(function (c, d) {\n      return a.inArray(c, this._states.tags[b.name]) === d;\n    }, this)));\n  }, e.prototype.suppress = function (b) {\n    a.each(b, a.proxy(function (a, b) {\n      this._supress[b] = !0;\n    }, this));\n  }, e.prototype.release = function (b) {\n    a.each(b, a.proxy(function (a, b) {\n      delete this._supress[b];\n    }, this));\n  }, e.prototype.pointer = function (a) {\n    var c = {\n      x: null,\n      y: null\n    };\n    return a = a.originalEvent || a || b.event, a = a.touches && a.touches.length ? a.touches[0] : a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : a, a.pageX ? (c.x = a.pageX, c.y = a.pageY) : (c.x = a.clientX, c.y = a.clientY), c;\n  }, e.prototype.isNumeric = function (a) {\n    return !isNaN(parseFloat(a));\n  }, e.prototype.difference = function (a, b) {\n    return {\n      x: a.x - b.x,\n      y: a.y - b.y\n    };\n  }, a.fn.owlCarousel = function (b) {\n    var c = Array.prototype.slice.call(arguments, 1);\n    return this.each(function () {\n      var d = a(this),\n          f = d.data(\"owl.carousel\");\n      f || (f = new e(this, \"object\" == _typeof(b) && b), d.data(\"owl.carousel\", f), a.each([\"next\", \"prev\", \"to\", \"destroy\", \"refresh\", \"replace\", \"add\", \"remove\"], function (b, c) {\n        f.register({\n          type: e.Type.Event,\n          name: c\n        }), f.$element.on(c + \".owl.carousel.core\", a.proxy(function (a) {\n          a.namespace && a.relatedTarget !== this && (this.suppress([c]), f[c].apply(this, [].slice.call(arguments, 1)), this.release([c]));\n        }, f));\n      })), \"string\" == typeof b && \"_\" !== b.charAt(0) && f[b].apply(f, c);\n    });\n  }, a.fn.owlCarousel.Constructor = e;\n}(window.Zepto || window.jQuery, window, document), function (a, b, c, d) {\n  var e = function e(b) {\n    this._core = b, this._interval = null, this._visible = null, this._handlers = {\n      \"initialized.owl.carousel\": a.proxy(function (a) {\n        a.namespace && this._core.settings.autoRefresh && this.watch();\n      }, this)\n    }, this._core.options = a.extend({}, e.Defaults, this._core.options), this._core.$element.on(this._handlers);\n  };\n\n  e.Defaults = {\n    autoRefresh: !0,\n    autoRefreshInterval: 500\n  }, e.prototype.watch = function () {\n    this._interval || (this._visible = this._core.$element.is(\":visible\"), this._interval = b.setInterval(a.proxy(this.refresh, this), this._core.settings.autoRefreshInterval));\n  }, e.prototype.refresh = function () {\n    this._core.$element.is(\":visible\") !== this._visible && (this._visible = !this._visible, this._core.$element.toggleClass(\"owl-hidden\", !this._visible), this._visible && this._core.invalidate(\"width\") && this._core.refresh());\n  }, e.prototype.destroy = function () {\n    var a, c;\n    b.clearInterval(this._interval);\n\n    for (a in this._handlers) {\n      this._core.$element.off(a, this._handlers[a]);\n    }\n\n    for (c in Object.getOwnPropertyNames(this)) {\n      \"function\" != typeof this[c] && (this[c] = null);\n    }\n  }, a.fn.owlCarousel.Constructor.Plugins.AutoRefresh = e;\n}(window.Zepto || window.jQuery, window, document), function (a, b, c, d) {\n  var e = function e(b) {\n    this._core = b, this._loaded = [], this._handlers = {\n      \"initialized.owl.carousel change.owl.carousel resized.owl.carousel\": a.proxy(function (b) {\n        if (b.namespace && this._core.settings && this._core.settings.lazyLoad && (b.property && \"position\" == b.property.name || \"initialized\" == b.type)) for (var c = this._core.settings, e = c.center && Math.ceil(c.items / 2) || c.items, f = c.center && e * -1 || 0, g = (b.property && b.property.value !== d ? b.property.value : this._core.current()) + f, h = this._core.clones().length, i = a.proxy(function (a, b) {\n          this.load(b);\n        }, this); f++ < e;) {\n          this.load(h / 2 + this._core.relative(g)), h && a.each(this._core.clones(this._core.relative(g)), i), g++;\n        }\n      }, this)\n    }, this._core.options = a.extend({}, e.Defaults, this._core.options), this._core.$element.on(this._handlers);\n  };\n\n  e.Defaults = {\n    lazyLoad: !1\n  }, e.prototype.load = function (c) {\n    var d = this._core.$stage.children().eq(c),\n        e = d && d.find(\".owl-lazy\");\n\n    !e || a.inArray(d.get(0), this._loaded) > -1 || (e.each(a.proxy(function (c, d) {\n      var e,\n          f = a(d),\n          g = b.devicePixelRatio > 1 && f.attr(\"data-src-retina\") || f.attr(\"data-src\");\n      this._core.trigger(\"load\", {\n        element: f,\n        url: g\n      }, \"lazy\"), f.is(\"img\") ? f.one(\"load.owl.lazy\", a.proxy(function () {\n        f.css(\"opacity\", 1), this._core.trigger(\"loaded\", {\n          element: f,\n          url: g\n        }, \"lazy\");\n      }, this)).attr(\"src\", g) : (e = new Image(), e.onload = a.proxy(function () {\n        f.css({\n          \"background-image\": 'url(\"' + g + '\")',\n          opacity: \"1\"\n        }), this._core.trigger(\"loaded\", {\n          element: f,\n          url: g\n        }, \"lazy\");\n      }, this), e.src = g);\n    }, this)), this._loaded.push(d.get(0)));\n  }, e.prototype.destroy = function () {\n    var a, b;\n\n    for (a in this.handlers) {\n      this._core.$element.off(a, this.handlers[a]);\n    }\n\n    for (b in Object.getOwnPropertyNames(this)) {\n      \"function\" != typeof this[b] && (this[b] = null);\n    }\n  }, a.fn.owlCarousel.Constructor.Plugins.Lazy = e;\n}(window.Zepto || window.jQuery, window, document), function (a, b, c, d) {\n  var e = function e(b) {\n    this._core = b, this._handlers = {\n      \"initialized.owl.carousel refreshed.owl.carousel\": a.proxy(function (a) {\n        a.namespace && this._core.settings.autoHeight && this.update();\n      }, this),\n      \"changed.owl.carousel\": a.proxy(function (a) {\n        a.namespace && this._core.settings.autoHeight && \"position\" == a.property.name && this.update();\n      }, this),\n      \"loaded.owl.lazy\": a.proxy(function (a) {\n        a.namespace && this._core.settings.autoHeight && a.element.closest(\".\" + this._core.settings.itemClass).index() === this._core.current() && this.update();\n      }, this)\n    }, this._core.options = a.extend({}, e.Defaults, this._core.options), this._core.$element.on(this._handlers);\n  };\n\n  e.Defaults = {\n    autoHeight: !1,\n    autoHeightClass: \"owl-height\"\n  }, e.prototype.update = function () {\n    var b = this._core._current,\n        c = b + this._core.settings.items,\n        d = this._core.$stage.children().toArray().slice(b, c),\n        e = [],\n        f = 0;\n\n    a.each(d, function (b, c) {\n      e.push(a(c).height());\n    }), f = Math.max.apply(null, e), this._core.$stage.parent().height(f).addClass(this._core.settings.autoHeightClass);\n  }, e.prototype.destroy = function () {\n    var a, b;\n\n    for (a in this._handlers) {\n      this._core.$element.off(a, this._handlers[a]);\n    }\n\n    for (b in Object.getOwnPropertyNames(this)) {\n      \"function\" != typeof this[b] && (this[b] = null);\n    }\n  }, a.fn.owlCarousel.Constructor.Plugins.AutoHeight = e;\n}(window.Zepto || window.jQuery, window, document), function (a, b, c, d) {\n  var e = function e(b) {\n    this._core = b, this._videos = {}, this._playing = null, this._handlers = {\n      \"initialized.owl.carousel\": a.proxy(function (a) {\n        a.namespace && this._core.register({\n          type: \"state\",\n          name: \"playing\",\n          tags: [\"interacting\"]\n        });\n      }, this),\n      \"resize.owl.carousel\": a.proxy(function (a) {\n        a.namespace && this._core.settings.video && this.isInFullScreen() && a.preventDefault();\n      }, this),\n      \"refreshed.owl.carousel\": a.proxy(function (a) {\n        a.namespace && this._core.is(\"resizing\") && this._core.$stage.find(\".cloned .owl-video-frame\").remove();\n      }, this),\n      \"changed.owl.carousel\": a.proxy(function (a) {\n        a.namespace && \"position\" === a.property.name && this._playing && this.stop();\n      }, this),\n      \"prepared.owl.carousel\": a.proxy(function (b) {\n        if (b.namespace) {\n          var c = a(b.content).find(\".owl-video\");\n          c.length && (c.css(\"display\", \"none\"), this.fetch(c, a(b.content)));\n        }\n      }, this)\n    }, this._core.options = a.extend({}, e.Defaults, this._core.options), this._core.$element.on(this._handlers), this._core.$element.on(\"click.owl.video\", \".owl-video-play-icon\", a.proxy(function (a) {\n      this.play(a);\n    }, this));\n  };\n\n  e.Defaults = {\n    video: !1,\n    videoHeight: !1,\n    videoWidth: !1\n  }, e.prototype.fetch = function (a, b) {\n    var c = function () {\n      return a.attr(\"data-vimeo-id\") ? \"vimeo\" : a.attr(\"data-vzaar-id\") ? \"vzaar\" : \"youtube\";\n    }(),\n        d = a.attr(\"data-vimeo-id\") || a.attr(\"data-youtube-id\") || a.attr(\"data-vzaar-id\"),\n        e = a.attr(\"data-width\") || this._core.settings.videoWidth,\n        f = a.attr(\"data-height\") || this._core.settings.videoHeight,\n        g = a.attr(\"href\");\n\n    if (!g) throw new Error(\"Missing video URL.\");\n    if (d = g.match(/(http:|https:|)\\/\\/(player.|www.|app.)?(vimeo\\.com|youtu(be\\.com|\\.be|be\\.googleapis\\.com)|vzaar\\.com)\\/(video\\/|videos\\/|embed\\/|channels\\/.+\\/|groups\\/.+\\/|watch\\?v=|v\\/)?([A-Za-z0-9._%-]*)(\\&\\S+)?/), d[3].indexOf(\"youtu\") > -1) c = \"youtube\";else if (d[3].indexOf(\"vimeo\") > -1) c = \"vimeo\";else {\n      if (!(d[3].indexOf(\"vzaar\") > -1)) throw new Error(\"Video URL not supported.\");\n      c = \"vzaar\";\n    }\n    d = d[6], this._videos[g] = {\n      type: c,\n      id: d,\n      width: e,\n      height: f\n    }, b.attr(\"data-video\", g), this.thumbnail(a, this._videos[g]);\n  }, e.prototype.thumbnail = function (b, c) {\n    var d,\n        e,\n        f,\n        g = c.width && c.height ? 'style=\"width:' + c.width + \"px;height:\" + c.height + 'px;\"' : \"\",\n        h = b.find(\"img\"),\n        i = \"src\",\n        j = \"\",\n        k = this._core.settings,\n        l = function l(a) {\n      e = '<div class=\"owl-video-play-icon\"></div>', d = k.lazyLoad ? '<div class=\"owl-video-tn ' + j + '\" ' + i + '=\"' + a + '\"></div>' : '<div class=\"owl-video-tn\" style=\"opacity:1;background-image:url(' + a + ')\"></div>', b.after(d), b.after(e);\n    };\n\n    if (b.wrap('<div class=\"owl-video-wrapper\"' + g + \"></div>\"), this._core.settings.lazyLoad && (i = \"data-src\", j = \"owl-lazy\"), h.length) return l(h.attr(i)), h.remove(), !1;\n    \"youtube\" === c.type ? (f = \"//img.youtube.com/vi/\" + c.id + \"/hqdefault.jpg\", l(f)) : \"vimeo\" === c.type ? a.ajax({\n      type: \"GET\",\n      url: \"//vimeo.com/api/v2/video/\" + c.id + \".json\",\n      jsonp: \"callback\",\n      dataType: \"jsonp\",\n      success: function success(a) {\n        f = a[0].thumbnail_large, l(f);\n      }\n    }) : \"vzaar\" === c.type && a.ajax({\n      type: \"GET\",\n      url: \"//vzaar.com/api/videos/\" + c.id + \".json\",\n      jsonp: \"callback\",\n      dataType: \"jsonp\",\n      success: function success(a) {\n        f = a.framegrab_url, l(f);\n      }\n    });\n  }, e.prototype.stop = function () {\n    this._core.trigger(\"stop\", null, \"video\"), this._playing.find(\".owl-video-frame\").remove(), this._playing.removeClass(\"owl-video-playing\"), this._playing = null, this._core.leave(\"playing\"), this._core.trigger(\"stopped\", null, \"video\");\n  }, e.prototype.play = function (b) {\n    var c,\n        d = a(b.target),\n        e = d.closest(\".\" + this._core.settings.itemClass),\n        f = this._videos[e.attr(\"data-video\")],\n        g = f.width || \"100%\",\n        h = f.height || this._core.$stage.height();\n\n    this._playing || (this._core.enter(\"playing\"), this._core.trigger(\"play\", null, \"video\"), e = this._core.items(this._core.relative(e.index())), this._core.reset(e.index()), \"youtube\" === f.type ? c = '<iframe width=\"' + g + '\" height=\"' + h + '\" src=\"//www.youtube.com/embed/' + f.id + \"?autoplay=1&rel=0&v=\" + f.id + '\" frameborder=\"0\" allowfullscreen></iframe>' : \"vimeo\" === f.type ? c = '<iframe src=\"//player.vimeo.com/video/' + f.id + '?autoplay=1\" width=\"' + g + '\" height=\"' + h + '\" frameborder=\"0\" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>' : \"vzaar\" === f.type && (c = '<iframe frameborder=\"0\"height=\"' + h + '\"width=\"' + g + '\" allowfullscreen mozallowfullscreen webkitAllowFullScreen src=\"//view.vzaar.com/' + f.id + '/player?autoplay=true\"></iframe>'), a('<div class=\"owl-video-frame\">' + c + \"</div>\").insertAfter(e.find(\".owl-video\")), this._playing = e.addClass(\"owl-video-playing\"));\n  }, e.prototype.isInFullScreen = function () {\n    var b = c.fullscreenElement || c.mozFullScreenElement || c.webkitFullscreenElement;\n    return b && a(b).parent().hasClass(\"owl-video-frame\");\n  }, e.prototype.destroy = function () {\n    var a, b;\n\n    this._core.$element.off(\"click.owl.video\");\n\n    for (a in this._handlers) {\n      this._core.$element.off(a, this._handlers[a]);\n    }\n\n    for (b in Object.getOwnPropertyNames(this)) {\n      \"function\" != typeof this[b] && (this[b] = null);\n    }\n  }, a.fn.owlCarousel.Constructor.Plugins.Video = e;\n}(window.Zepto || window.jQuery, window, document), function (a, b, c, d) {\n  var e = function e(b) {\n    this.core = b, this.core.options = a.extend({}, e.Defaults, this.core.options), this.swapping = !0, this.previous = d, this.next = d, this.handlers = {\n      \"change.owl.carousel\": a.proxy(function (a) {\n        a.namespace && \"position\" == a.property.name && (this.previous = this.core.current(), this.next = a.property.value);\n      }, this),\n      \"drag.owl.carousel dragged.owl.carousel translated.owl.carousel\": a.proxy(function (a) {\n        a.namespace && (this.swapping = \"translated\" == a.type);\n      }, this),\n      \"translate.owl.carousel\": a.proxy(function (a) {\n        a.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn) && this.swap();\n      }, this)\n    }, this.core.$element.on(this.handlers);\n  };\n\n  e.Defaults = {\n    animateOut: !1,\n    animateIn: !1\n  }, e.prototype.swap = function () {\n    if (1 === this.core.settings.items && a.support.animation && a.support.transition) {\n      this.core.speed(0);\n      var b,\n          c = a.proxy(this.clear, this),\n          d = this.core.$stage.children().eq(this.previous),\n          e = this.core.$stage.children().eq(this.next),\n          f = this.core.settings.animateIn,\n          g = this.core.settings.animateOut;\n      this.core.current() !== this.previous && (g && (b = this.core.coordinates(this.previous) - this.core.coordinates(this.next), d.one(a.support.animation.end, c).css({\n        left: b + \"px\"\n      }).addClass(\"animated owl-animated-out\").addClass(g)), f && e.one(a.support.animation.end, c).addClass(\"animated owl-animated-in\").addClass(f));\n    }\n  }, e.prototype.clear = function (b) {\n    a(b.target).css({\n      left: \"\"\n    }).removeClass(\"animated owl-animated-out owl-animated-in\").removeClass(this.core.settings.animateIn).removeClass(this.core.settings.animateOut), this.core.onTransitionEnd();\n  }, e.prototype.destroy = function () {\n    var a, b;\n\n    for (a in this.handlers) {\n      this.core.$element.off(a, this.handlers[a]);\n    }\n\n    for (b in Object.getOwnPropertyNames(this)) {\n      \"function\" != typeof this[b] && (this[b] = null);\n    }\n  }, a.fn.owlCarousel.Constructor.Plugins.Animate = e;\n}(window.Zepto || window.jQuery, window, document), function (a, b, c, d) {\n  var e = function e(b) {\n    this._core = b, this._timeout = null, this._paused = !1, this._handlers = {\n      \"changed.owl.carousel\": a.proxy(function (a) {\n        a.namespace && \"settings\" === a.property.name ? this._core.settings.autoplay ? this.play() : this.stop() : a.namespace && \"position\" === a.property.name && this._core.settings.autoplay && this._setAutoPlayInterval();\n      }, this),\n      \"initialized.owl.carousel\": a.proxy(function (a) {\n        a.namespace && this._core.settings.autoplay && this.play();\n      }, this),\n      \"play.owl.autoplay\": a.proxy(function (a, b, c) {\n        a.namespace && this.play(b, c);\n      }, this),\n      \"stop.owl.autoplay\": a.proxy(function (a) {\n        a.namespace && this.stop();\n      }, this),\n      \"mouseover.owl.autoplay\": a.proxy(function () {\n        this._core.settings.autoplayHoverPause && this._core.is(\"rotating\") && this.pause();\n      }, this),\n      \"mouseleave.owl.autoplay\": a.proxy(function () {\n        this._core.settings.autoplayHoverPause && this._core.is(\"rotating\") && this.play();\n      }, this),\n      \"touchstart.owl.core\": a.proxy(function () {\n        this._core.settings.autoplayHoverPause && this._core.is(\"rotating\") && this.pause();\n      }, this),\n      \"touchend.owl.core\": a.proxy(function () {\n        this._core.settings.autoplayHoverPause && this.play();\n      }, this)\n    }, this._core.$element.on(this._handlers), this._core.options = a.extend({}, e.Defaults, this._core.options);\n  };\n\n  e.Defaults = {\n    autoplay: !1,\n    autoplayTimeout: 5e3,\n    autoplayHoverPause: !1,\n    autoplaySpeed: !1\n  }, e.prototype.play = function (a, b) {\n    this._paused = !1, this._core.is(\"rotating\") || (this._core.enter(\"rotating\"), this._setAutoPlayInterval());\n  }, e.prototype._getNextTimeout = function (d, e) {\n    return this._timeout && b.clearTimeout(this._timeout), b.setTimeout(a.proxy(function () {\n      this._paused || this._core.is(\"busy\") || this._core.is(\"interacting\") || c.hidden || this._core.next(e || this._core.settings.autoplaySpeed);\n    }, this), d || this._core.settings.autoplayTimeout);\n  }, e.prototype._setAutoPlayInterval = function () {\n    this._timeout = this._getNextTimeout();\n  }, e.prototype.stop = function () {\n    this._core.is(\"rotating\") && (b.clearTimeout(this._timeout), this._core.leave(\"rotating\"));\n  }, e.prototype.pause = function () {\n    this._core.is(\"rotating\") && (this._paused = !0);\n  }, e.prototype.destroy = function () {\n    var a, b;\n    this.stop();\n\n    for (a in this._handlers) {\n      this._core.$element.off(a, this._handlers[a]);\n    }\n\n    for (b in Object.getOwnPropertyNames(this)) {\n      \"function\" != typeof this[b] && (this[b] = null);\n    }\n  }, a.fn.owlCarousel.Constructor.Plugins.autoplay = e;\n}(window.Zepto || window.jQuery, window, document), function (a, b, c, d) {\n  \"use strict\";\n\n  var e = function e(b) {\n    this._core = b, this._initialized = !1, this._pages = [], this._controls = {}, this._templates = [], this.$element = this._core.$element, this._overrides = {\n      next: this._core.next,\n      prev: this._core.prev,\n      to: this._core.to\n    }, this._handlers = {\n      \"prepared.owl.carousel\": a.proxy(function (b) {\n        b.namespace && this._core.settings.dotsData && this._templates.push('<div class=\"' + this._core.settings.dotClass + '\">' + a(b.content).find(\"[data-dot]\").addBack(\"[data-dot]\").attr(\"data-dot\") + \"</div>\");\n      }, this),\n      \"added.owl.carousel\": a.proxy(function (a) {\n        a.namespace && this._core.settings.dotsData && this._templates.splice(a.position, 0, this._templates.pop());\n      }, this),\n      \"remove.owl.carousel\": a.proxy(function (a) {\n        a.namespace && this._core.settings.dotsData && this._templates.splice(a.position, 1);\n      }, this),\n      \"changed.owl.carousel\": a.proxy(function (a) {\n        a.namespace && \"position\" == a.property.name && this.draw();\n      }, this),\n      \"initialized.owl.carousel\": a.proxy(function (a) {\n        a.namespace && !this._initialized && (this._core.trigger(\"initialize\", null, \"navigation\"), this.initialize(), this.update(), this.draw(), this._initialized = !0, this._core.trigger(\"initialized\", null, \"navigation\"));\n      }, this),\n      \"refreshed.owl.carousel\": a.proxy(function (a) {\n        a.namespace && this._initialized && (this._core.trigger(\"refresh\", null, \"navigation\"), this.update(), this.draw(), this._core.trigger(\"refreshed\", null, \"navigation\"));\n      }, this)\n    }, this._core.options = a.extend({}, e.Defaults, this._core.options), this.$element.on(this._handlers);\n  };\n\n  e.Defaults = {\n    nav: !1,\n    navText: [\"prev\", \"next\"],\n    navSpeed: !1,\n    navElement: \"div\",\n    navContainer: !1,\n    navContainerClass: \"owl-nav\",\n    navClass: [\"owl-prev\", \"owl-next\"],\n    slideBy: 1,\n    dotClass: \"owl-dot\",\n    dotsClass: \"owl-dots\",\n    dots: !0,\n    dotsEach: !1,\n    dotsData: !1,\n    dotsSpeed: !1,\n    dotsContainer: !1\n  }, e.prototype.initialize = function () {\n    var b,\n        c = this._core.settings;\n    this._controls.$relative = (c.navContainer ? a(c.navContainer) : a(\"<div>\").addClass(c.navContainerClass).appendTo(this.$element)).addClass(\"disabled\"), this._controls.$previous = a(\"<\" + c.navElement + \">\").addClass(c.navClass[0]).html(c.navText[0]).prependTo(this._controls.$relative).on(\"click\", a.proxy(function (a) {\n      this.prev(c.navSpeed);\n    }, this)), this._controls.$next = a(\"<\" + c.navElement + \">\").addClass(c.navClass[1]).html(c.navText[1]).appendTo(this._controls.$relative).on(\"click\", a.proxy(function (a) {\n      this.next(c.navSpeed);\n    }, this)), c.dotsData || (this._templates = [a(\"<div>\").addClass(c.dotClass).append(a(\"<span>\")).prop(\"outerHTML\")]), this._controls.$absolute = (c.dotsContainer ? a(c.dotsContainer) : a(\"<div>\").addClass(c.dotsClass).appendTo(this.$element)).addClass(\"disabled\"), this._controls.$absolute.on(\"click\", \"div\", a.proxy(function (b) {\n      var d = a(b.target).parent().is(this._controls.$absolute) ? a(b.target).index() : a(b.target).parent().index();\n      b.preventDefault(), this.to(d, c.dotsSpeed);\n    }, this));\n\n    for (b in this._overrides) {\n      this._core[b] = a.proxy(this[b], this);\n    }\n  }, e.prototype.destroy = function () {\n    var a, b, c, d;\n\n    for (a in this._handlers) {\n      this.$element.off(a, this._handlers[a]);\n    }\n\n    for (b in this._controls) {\n      this._controls[b].remove();\n    }\n\n    for (d in this.overides) {\n      this._core[d] = this._overrides[d];\n    }\n\n    for (c in Object.getOwnPropertyNames(this)) {\n      \"function\" != typeof this[c] && (this[c] = null);\n    }\n  }, e.prototype.update = function () {\n    var a,\n        b,\n        c,\n        d = this._core.clones().length / 2,\n        e = d + this._core.items().length,\n        f = this._core.maximum(!0),\n        g = this._core.settings,\n        h = g.center || g.autoWidth || g.dotsData ? 1 : g.dotsEach || g.items;\n\n    if (\"page\" !== g.slideBy && (g.slideBy = Math.min(g.slideBy, g.items)), g.dots || \"page\" == g.slideBy) for (this._pages = [], a = d, b = 0, c = 0; a < e; a++) {\n      if (b >= h || 0 === b) {\n        if (this._pages.push({\n          start: Math.min(f, a - d),\n          end: a - d + h - 1\n        }), Math.min(f, a - d) === f) break;\n        b = 0, ++c;\n      }\n\n      b += this._core.mergers(this._core.relative(a));\n    }\n  }, e.prototype.draw = function () {\n    var b,\n        c = this._core.settings,\n        d = this._core.items().length <= c.items,\n        e = this._core.relative(this._core.current()),\n        f = c.loop || c.rewind;\n\n    this._controls.$relative.toggleClass(\"disabled\", !c.nav || d), c.nav && (this._controls.$previous.toggleClass(\"disabled\", !f && e <= this._core.minimum(!0)), this._controls.$next.toggleClass(\"disabled\", !f && e >= this._core.maximum(!0))), this._controls.$absolute.toggleClass(\"disabled\", !c.dots || d), c.dots && (b = this._pages.length - this._controls.$absolute.children().length, c.dotsData && 0 !== b ? this._controls.$absolute.html(this._templates.join(\"\")) : b > 0 ? this._controls.$absolute.append(new Array(b + 1).join(this._templates[0])) : b < 0 && this._controls.$absolute.children().slice(b).remove(), this._controls.$absolute.find(\".active\").removeClass(\"active\"), this._controls.$absolute.children().eq(a.inArray(this.current(), this._pages)).addClass(\"active\"));\n  }, e.prototype.onTrigger = function (b) {\n    var c = this._core.settings;\n    b.page = {\n      index: a.inArray(this.current(), this._pages),\n      count: this._pages.length,\n      size: c && (c.center || c.autoWidth || c.dotsData ? 1 : c.dotsEach || c.items)\n    };\n  }, e.prototype.current = function () {\n    var b = this._core.relative(this._core.current());\n\n    return a.grep(this._pages, a.proxy(function (a, c) {\n      return a.start <= b && a.end >= b;\n    }, this)).pop();\n  }, e.prototype.getPosition = function (b) {\n    var c,\n        d,\n        e = this._core.settings;\n    return \"page\" == e.slideBy ? (c = a.inArray(this.current(), this._pages), d = this._pages.length, b ? ++c : --c, c = this._pages[(c % d + d) % d].start) : (c = this._core.relative(this._core.current()), d = this._core.items().length, b ? c += e.slideBy : c -= e.slideBy), c;\n  }, e.prototype.next = function (b) {\n    a.proxy(this._overrides.to, this._core)(this.getPosition(!0), b);\n  }, e.prototype.prev = function (b) {\n    a.proxy(this._overrides.to, this._core)(this.getPosition(!1), b);\n  }, e.prototype.to = function (b, c, d) {\n    var e;\n    !d && this._pages.length ? (e = this._pages.length, a.proxy(this._overrides.to, this._core)(this._pages[(b % e + e) % e].start, c)) : a.proxy(this._overrides.to, this._core)(b, c);\n  }, a.fn.owlCarousel.Constructor.Plugins.Navigation = e;\n}(window.Zepto || window.jQuery, window, document), function (a, b, c, d) {\n  \"use strict\";\n\n  var e = function e(c) {\n    this._core = c, this._hashes = {}, this.$element = this._core.$element, this._handlers = {\n      \"initialized.owl.carousel\": a.proxy(function (c) {\n        c.namespace && \"URLHash\" === this._core.settings.startPosition && a(b).trigger(\"hashchange.owl.navigation\");\n      }, this),\n      \"prepared.owl.carousel\": a.proxy(function (b) {\n        if (b.namespace) {\n          var c = a(b.content).find(\"[data-hash]\").addBack(\"[data-hash]\").attr(\"data-hash\");\n          if (!c) return;\n          this._hashes[c] = b.content;\n        }\n      }, this),\n      \"changed.owl.carousel\": a.proxy(function (c) {\n        if (c.namespace && \"position\" === c.property.name) {\n          var d = this._core.items(this._core.relative(this._core.current())),\n              e = a.map(this._hashes, function (a, b) {\n            return a === d ? b : null;\n          }).join();\n\n          if (!e || b.location.hash.slice(1) === e) return;\n          b.location.hash = e;\n        }\n      }, this)\n    }, this._core.options = a.extend({}, e.Defaults, this._core.options), this.$element.on(this._handlers), a(b).on(\"hashchange.owl.navigation\", a.proxy(function (a) {\n      var c = b.location.hash.substring(1),\n          e = this._core.$stage.children(),\n          f = this._hashes[c] && e.index(this._hashes[c]);\n\n      f !== d && f !== this._core.current() && this._core.to(this._core.relative(f), !1, !0);\n    }, this));\n  };\n\n  e.Defaults = {\n    URLhashListener: !1\n  }, e.prototype.destroy = function () {\n    var c, d;\n    a(b).off(\"hashchange.owl.navigation\");\n\n    for (c in this._handlers) {\n      this._core.$element.off(c, this._handlers[c]);\n    }\n\n    for (d in Object.getOwnPropertyNames(this)) {\n      \"function\" != typeof this[d] && (this[d] = null);\n    }\n  }, a.fn.owlCarousel.Constructor.Plugins.Hash = e;\n}(window.Zepto || window.jQuery, window, document), function (a, b, c, d) {\n  function e(b, c) {\n    var e = !1,\n        f = b.charAt(0).toUpperCase() + b.slice(1);\n    return a.each((b + \" \" + h.join(f + \" \") + f).split(\" \"), function (a, b) {\n      if (g[b] !== d) return e = !c || b, !1;\n    }), e;\n  }\n\n  function f(a) {\n    return e(a, !0);\n  }\n\n  var g = a(\"<support>\").get(0).style,\n      h = \"Webkit Moz O ms\".split(\" \"),\n      i = {\n    transition: {\n      end: {\n        WebkitTransition: \"webkitTransitionEnd\",\n        MozTransition: \"transitionend\",\n        OTransition: \"oTransitionEnd\",\n        transition: \"transitionend\"\n      }\n    },\n    animation: {\n      end: {\n        WebkitAnimation: \"webkitAnimationEnd\",\n        MozAnimation: \"animationend\",\n        OAnimation: \"oAnimationEnd\",\n        animation: \"animationend\"\n      }\n    }\n  },\n      j = {\n    csstransforms: function csstransforms() {\n      return !!e(\"transform\");\n    },\n    csstransforms3d: function csstransforms3d() {\n      return !!e(\"perspective\");\n    },\n    csstransitions: function csstransitions() {\n      return !!e(\"transition\");\n    },\n    cssanimations: function cssanimations() {\n      return !!e(\"animation\");\n    }\n  };\n  j.csstransitions() && (a.support.transition = new String(f(\"transition\")), a.support.transition.end = i.transition.end[a.support.transition]), j.cssanimations() && (a.support.animation = new String(f(\"animation\")), a.support.animation.end = i.animation.end[a.support.animation]), j.csstransforms() && (a.support.transform = new String(f(\"transform\")), a.support.transform3d = j.csstransforms3d());\n}(window.Zepto || window.jQuery, window, document);\n/*!\n * classie - class helper functions\n * from bonzo https://github.com/ded/bonzo\n * \n * classie.has( elem, 'my-class' ) -> true/false\n * classie.add( elem, 'my-new-class' )\n * classie.remove( elem, 'my-unwanted-class' )\n * classie.toggle( elem, 'my-class' )\n */\n\n/*jshint browser: true, strict: true, undef: true */\n\n/*global define: false */\n\n!function (s) {\n  \"use strict\";\n\n  function e(s) {\n    return new RegExp(\"(^|\\\\s+)\" + s + \"(\\\\s+|$)\");\n  }\n\n  function n(s, e) {\n    (a(s, e) ? c : t)(s, e);\n  }\n\n  var a, t, c;\n  \"classList\" in document.documentElement ? (a = function a(s, e) {\n    return s.classList.contains(e);\n  }, t = function t(s, e) {\n    s.classList.add(e);\n  }, c = function c(s, e) {\n    s.classList.remove(e);\n  }) : (a = function a(s, n) {\n    return e(n).test(s.className);\n  }, t = function t(s, e) {\n    a(s, e) || (s.className = s.className + \" \" + e);\n  }, c = function c(s, n) {\n    s.className = s.className.replace(e(n), \" \");\n  });\n  var i = {\n    hasClass: a,\n    addClass: t,\n    removeClass: c,\n    toggleClass: n,\n    has: a,\n    add: t,\n    remove: c,\n    toggle: n\n  };\n   true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (i),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;\n}(window);\n/*! Magnific Popup - v1.1.0 - 2016-02-20\n* http://dimsemenov.com/plugins/magnific-popup/\n* Copyright (c) 2016 Dmitry Semenov; */\n\n!function (a) {\n   true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (a),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;\n}(function (a) {\n  var b,\n      c,\n      d,\n      e,\n      f,\n      g,\n      h = \"Close\",\n      i = \"BeforeClose\",\n      j = \"AfterClose\",\n      k = \"BeforeAppend\",\n      l = \"MarkupParse\",\n      m = \"Open\",\n      n = \"Change\",\n      o = \"mfp\",\n      p = \".\" + o,\n      q = \"mfp-ready\",\n      r = \"mfp-removing\",\n      s = \"mfp-prevent-close\",\n      t = function t() {},\n      u = !!window.jQuery,\n      v = a(window),\n      w = function w(a, c) {\n    b.ev.on(o + a + p, c);\n  },\n      x = function x(b, c, d, e) {\n    var f = document.createElement(\"div\");\n    return f.className = \"mfp-\" + b, d && (f.innerHTML = d), e ? c && c.appendChild(f) : (f = a(f), c && f.appendTo(c)), f;\n  },\n      y = function y(c, d) {\n    b.ev.triggerHandler(o + c, d), b.st.callbacks && (c = c.charAt(0).toLowerCase() + c.slice(1), b.st.callbacks[c] && b.st.callbacks[c].apply(b, a.isArray(d) ? d : [d]));\n  },\n      z = function z(c) {\n    return c === g && b.currTemplate.closeBtn || (b.currTemplate.closeBtn = a(b.st.closeMarkup.replace(\"%title%\", b.st.tClose)), g = c), b.currTemplate.closeBtn;\n  },\n      A = function A() {\n    a.magnificPopup.instance || (b = new t(), b.init(), a.magnificPopup.instance = b);\n  },\n      B = function B() {\n    var a = document.createElement(\"p\").style,\n        b = [\"ms\", \"O\", \"Moz\", \"Webkit\"];\n    if (void 0 !== a.transition) return !0;\n\n    for (; b.length;) {\n      if (b.pop() + \"Transition\" in a) return !0;\n    }\n\n    return !1;\n  };\n\n  t.prototype = {\n    constructor: t,\n    init: function init() {\n      var c = navigator.appVersion;\n      b.isLowIE = b.isIE8 = document.all && !document.addEventListener, b.isAndroid = /android/gi.test(c), b.isIOS = /iphone|ipad|ipod/gi.test(c), b.supportsTransition = B(), b.probablyMobile = b.isAndroid || b.isIOS || /(Opera Mini)|Kindle|webOS|BlackBerry|(Opera Mobi)|(Windows Phone)|IEMobile/i.test(navigator.userAgent), d = a(document), b.popupsCache = {};\n    },\n    open: function open(c) {\n      var e;\n\n      if (c.isObj === !1) {\n        b.items = c.items.toArray(), b.index = 0;\n        var g,\n            h = c.items;\n\n        for (e = 0; e < h.length; e++) {\n          if (g = h[e], g.parsed && (g = g.el[0]), g === c.el[0]) {\n            b.index = e;\n            break;\n          }\n        }\n      } else b.items = a.isArray(c.items) ? c.items : [c.items], b.index = c.index || 0;\n\n      if (b.isOpen) return void b.updateItemHTML();\n      b.types = [], f = \"\", c.mainEl && c.mainEl.length ? b.ev = c.mainEl.eq(0) : b.ev = d, c.key ? (b.popupsCache[c.key] || (b.popupsCache[c.key] = {}), b.currTemplate = b.popupsCache[c.key]) : b.currTemplate = {}, b.st = a.extend(!0, {}, a.magnificPopup.defaults, c), b.fixedContentPos = \"auto\" === b.st.fixedContentPos ? !b.probablyMobile : b.st.fixedContentPos, b.st.modal && (b.st.closeOnContentClick = !1, b.st.closeOnBgClick = !1, b.st.showCloseBtn = !1, b.st.enableEscapeKey = !1), b.bgOverlay || (b.bgOverlay = x(\"bg\").on(\"click\" + p, function () {\n        b.close();\n      }), b.wrap = x(\"wrap\").attr(\"tabindex\", -1).on(\"click\" + p, function (a) {\n        b._checkIfClose(a.target) && b.close();\n      }), b.container = x(\"container\", b.wrap)), b.contentContainer = x(\"content\"), b.st.preloader && (b.preloader = x(\"preloader\", b.container, b.st.tLoading));\n      var i = a.magnificPopup.modules;\n\n      for (e = 0; e < i.length; e++) {\n        var j = i[e];\n        j = j.charAt(0).toUpperCase() + j.slice(1), b[\"init\" + j].call(b);\n      }\n\n      y(\"BeforeOpen\"), b.st.showCloseBtn && (b.st.closeBtnInside ? (w(l, function (a, b, c, d) {\n        c.close_replaceWith = z(d.type);\n      }), f += \" mfp-close-btn-in\") : b.wrap.append(z())), b.st.alignTop && (f += \" mfp-align-top\"), b.fixedContentPos ? b.wrap.css({\n        overflow: b.st.overflowY,\n        overflowX: \"hidden\",\n        overflowY: b.st.overflowY\n      }) : b.wrap.css({\n        top: v.scrollTop(),\n        position: \"absolute\"\n      }), (b.st.fixedBgPos === !1 || \"auto\" === b.st.fixedBgPos && !b.fixedContentPos) && b.bgOverlay.css({\n        height: d.height(),\n        position: \"absolute\"\n      }), b.st.enableEscapeKey && d.on(\"keyup\" + p, function (a) {\n        27 === a.keyCode && b.close();\n      }), v.on(\"resize\" + p, function () {\n        b.updateSize();\n      }), b.st.closeOnContentClick || (f += \" mfp-auto-cursor\"), f && b.wrap.addClass(f);\n      var k = b.wH = v.height(),\n          n = {};\n\n      if (b.fixedContentPos && b._hasScrollBar(k)) {\n        var o = b._getScrollbarSize();\n\n        o && (n.marginRight = o);\n      }\n\n      b.fixedContentPos && (b.isIE7 ? a(\"body, html\").css(\"overflow\", \"hidden\") : n.overflow = \"hidden\");\n      var r = b.st.mainClass;\n      return b.isIE7 && (r += \" mfp-ie7\"), r && b._addClassToMFP(r), b.updateItemHTML(), y(\"BuildControls\"), a(\"html\").css(n), b.bgOverlay.add(b.wrap).prependTo(b.st.prependTo || a(document.body)), b._lastFocusedEl = document.activeElement, setTimeout(function () {\n        b.content ? (b._addClassToMFP(q), b._setFocus()) : b.bgOverlay.addClass(q), d.on(\"focusin\" + p, b._onFocusIn);\n      }, 16), b.isOpen = !0, b.updateSize(k), y(m), c;\n    },\n    close: function close() {\n      b.isOpen && (y(i), b.isOpen = !1, b.st.removalDelay && !b.isLowIE && b.supportsTransition ? (b._addClassToMFP(r), setTimeout(function () {\n        b._close();\n      }, b.st.removalDelay)) : b._close());\n    },\n    _close: function _close() {\n      y(h);\n      var c = r + \" \" + q + \" \";\n\n      if (b.bgOverlay.detach(), b.wrap.detach(), b.container.empty(), b.st.mainClass && (c += b.st.mainClass + \" \"), b._removeClassFromMFP(c), b.fixedContentPos) {\n        var e = {\n          marginRight: \"\"\n        };\n        b.isIE7 ? a(\"body, html\").css(\"overflow\", \"\") : e.overflow = \"\", a(\"html\").css(e);\n      }\n\n      d.off(\"keyup\" + p + \" focusin\" + p), b.ev.off(p), b.wrap.attr(\"class\", \"mfp-wrap\").removeAttr(\"style\"), b.bgOverlay.attr(\"class\", \"mfp-bg\"), b.container.attr(\"class\", \"mfp-container\"), !b.st.showCloseBtn || b.st.closeBtnInside && b.currTemplate[b.currItem.type] !== !0 || b.currTemplate.closeBtn && b.currTemplate.closeBtn.detach(), b.st.autoFocusLast && b._lastFocusedEl && a(b._lastFocusedEl).focus(), b.currItem = null, b.content = null, b.currTemplate = null, b.prevHeight = 0, y(j);\n    },\n    updateSize: function updateSize(a) {\n      if (b.isIOS) {\n        var c = document.documentElement.clientWidth / window.innerWidth,\n            d = window.innerHeight * c;\n        b.wrap.css(\"height\", d), b.wH = d;\n      } else b.wH = a || v.height();\n\n      b.fixedContentPos || b.wrap.css(\"height\", b.wH), y(\"Resize\");\n    },\n    updateItemHTML: function updateItemHTML() {\n      var c = b.items[b.index];\n      b.contentContainer.detach(), b.content && b.content.detach(), c.parsed || (c = b.parseEl(b.index));\n      var d = c.type;\n\n      if (y(\"BeforeChange\", [b.currItem ? b.currItem.type : \"\", d]), b.currItem = c, !b.currTemplate[d]) {\n        var f = b.st[d] ? b.st[d].markup : !1;\n        y(\"FirstMarkupParse\", f), f ? b.currTemplate[d] = a(f) : b.currTemplate[d] = !0;\n      }\n\n      e && e !== c.type && b.container.removeClass(\"mfp-\" + e + \"-holder\");\n      var g = b[\"get\" + d.charAt(0).toUpperCase() + d.slice(1)](c, b.currTemplate[d]);\n      b.appendContent(g, d), c.preloaded = !0, y(n, c), e = c.type, b.container.prepend(b.contentContainer), y(\"AfterChange\");\n    },\n    appendContent: function appendContent(a, c) {\n      b.content = a, a ? b.st.showCloseBtn && b.st.closeBtnInside && b.currTemplate[c] === !0 ? b.content.find(\".mfp-close\").length || b.content.append(z()) : b.content = a : b.content = \"\", y(k), b.container.addClass(\"mfp-\" + c + \"-holder\"), b.contentContainer.append(b.content);\n    },\n    parseEl: function parseEl(c) {\n      var d,\n          e = b.items[c];\n\n      if (e.tagName ? e = {\n        el: a(e)\n      } : (d = e.type, e = {\n        data: e,\n        src: e.src\n      }), e.el) {\n        for (var f = b.types, g = 0; g < f.length; g++) {\n          if (e.el.hasClass(\"mfp-\" + f[g])) {\n            d = f[g];\n            break;\n          }\n        }\n\n        e.src = e.el.attr(\"data-mfp-src\"), e.src || (e.src = e.el.attr(\"href\"));\n      }\n\n      return e.type = d || b.st.type || \"inline\", e.index = c, e.parsed = !0, b.items[c] = e, y(\"ElementParse\", e), b.items[c];\n    },\n    addGroup: function addGroup(a, c) {\n      var d = function d(_d) {\n        _d.mfpEl = this, b._openClick(_d, a, c);\n      };\n\n      c || (c = {});\n      var e = \"click.magnificPopup\";\n      c.mainEl = a, c.items ? (c.isObj = !0, a.off(e).on(e, d)) : (c.isObj = !1, c.delegate ? a.off(e).on(e, c.delegate, d) : (c.items = a, a.off(e).on(e, d)));\n    },\n    _openClick: function _openClick(c, d, e) {\n      var f = void 0 !== e.midClick ? e.midClick : a.magnificPopup.defaults.midClick;\n\n      if (f || !(2 === c.which || c.ctrlKey || c.metaKey || c.altKey || c.shiftKey)) {\n        var g = void 0 !== e.disableOn ? e.disableOn : a.magnificPopup.defaults.disableOn;\n        if (g) if (a.isFunction(g)) {\n          if (!g.call(b)) return !0;\n        } else if (v.width() < g) return !0;\n        c.type && (c.preventDefault(), b.isOpen && c.stopPropagation()), e.el = a(c.mfpEl), e.delegate && (e.items = d.find(e.delegate)), b.open(e);\n      }\n    },\n    updateStatus: function updateStatus(a, d) {\n      if (b.preloader) {\n        c !== a && b.container.removeClass(\"mfp-s-\" + c), d || \"loading\" !== a || (d = b.st.tLoading);\n        var e = {\n          status: a,\n          text: d\n        };\n        y(\"UpdateStatus\", e), a = e.status, d = e.text, b.preloader.html(d), b.preloader.find(\"a\").on(\"click\", function (a) {\n          a.stopImmediatePropagation();\n        }), b.container.addClass(\"mfp-s-\" + a), c = a;\n      }\n    },\n    _checkIfClose: function _checkIfClose(c) {\n      if (!a(c).hasClass(s)) {\n        var d = b.st.closeOnContentClick,\n            e = b.st.closeOnBgClick;\n        if (d && e) return !0;\n        if (!b.content || a(c).hasClass(\"mfp-close\") || b.preloader && c === b.preloader[0]) return !0;\n\n        if (c === b.content[0] || a.contains(b.content[0], c)) {\n          if (d) return !0;\n        } else if (e && a.contains(document, c)) return !0;\n\n        return !1;\n      }\n    },\n    _addClassToMFP: function _addClassToMFP(a) {\n      b.bgOverlay.addClass(a), b.wrap.addClass(a);\n    },\n    _removeClassFromMFP: function _removeClassFromMFP(a) {\n      this.bgOverlay.removeClass(a), b.wrap.removeClass(a);\n    },\n    _hasScrollBar: function _hasScrollBar(a) {\n      return (b.isIE7 ? d.height() : document.body.scrollHeight) > (a || v.height());\n    },\n    _setFocus: function _setFocus() {\n      (b.st.focus ? b.content.find(b.st.focus).eq(0) : b.wrap).focus();\n    },\n    _onFocusIn: function _onFocusIn(c) {\n      return c.target === b.wrap[0] || a.contains(b.wrap[0], c.target) ? void 0 : (b._setFocus(), !1);\n    },\n    _parseMarkup: function _parseMarkup(b, c, d) {\n      var e;\n      d.data && (c = a.extend(d.data, c)), y(l, [b, c, d]), a.each(c, function (c, d) {\n        if (void 0 === d || d === !1) return !0;\n\n        if (e = c.split(\"_\"), e.length > 1) {\n          var f = b.find(p + \"-\" + e[0]);\n\n          if (f.length > 0) {\n            var g = e[1];\n            \"replaceWith\" === g ? f[0] !== d[0] && f.replaceWith(d) : \"img\" === g ? f.is(\"img\") ? f.attr(\"src\", d) : f.replaceWith(a(\"<img>\").attr(\"src\", d).attr(\"class\", f.attr(\"class\"))) : f.attr(e[1], d);\n          }\n        } else b.find(p + \"-\" + c).html(d);\n      });\n    },\n    _getScrollbarSize: function _getScrollbarSize() {\n      if (void 0 === b.scrollbarSize) {\n        var a = document.createElement(\"div\");\n        a.style.cssText = \"width: 99px; height: 99px; overflow: scroll; position: absolute; top: -9999px;\", document.body.appendChild(a), b.scrollbarSize = a.offsetWidth - a.clientWidth, document.body.removeChild(a);\n      }\n\n      return b.scrollbarSize;\n    }\n  }, a.magnificPopup = {\n    instance: null,\n    proto: t.prototype,\n    modules: [],\n    open: function open(b, c) {\n      return A(), b = b ? a.extend(!0, {}, b) : {}, b.isObj = !0, b.index = c || 0, this.instance.open(b);\n    },\n    close: function close() {\n      return a.magnificPopup.instance && a.magnificPopup.instance.close();\n    },\n    registerModule: function registerModule(b, c) {\n      c.options && (a.magnificPopup.defaults[b] = c.options), a.extend(this.proto, c.proto), this.modules.push(b);\n    },\n    defaults: {\n      disableOn: 0,\n      key: null,\n      midClick: !1,\n      mainClass: \"\",\n      preloader: !0,\n      focus: \"\",\n      closeOnContentClick: !1,\n      closeOnBgClick: !0,\n      closeBtnInside: !0,\n      showCloseBtn: !0,\n      enableEscapeKey: !0,\n      modal: !1,\n      alignTop: !1,\n      removalDelay: 0,\n      prependTo: null,\n      fixedContentPos: \"auto\",\n      fixedBgPos: \"auto\",\n      overflowY: \"auto\",\n      closeMarkup: '<button title=\"%title%\" type=\"button\" class=\"mfp-close\">&#215;</button>',\n      tClose: \"Close (Esc)\",\n      tLoading: \"Loading...\",\n      autoFocusLast: !0\n    }\n  }, a.fn.magnificPopup = function (c) {\n    A();\n    var d = a(this);\n    if (\"string\" == typeof c) {\n      if (\"open\" === c) {\n        var e,\n            f = u ? d.data(\"magnificPopup\") : d[0].magnificPopup,\n            g = parseInt(arguments[1], 10) || 0;\n        f.items ? e = f.items[g] : (e = d, f.delegate && (e = e.find(f.delegate)), e = e.eq(g)), b._openClick({\n          mfpEl: e\n        }, d, f);\n      } else b.isOpen && b[c].apply(b, Array.prototype.slice.call(arguments, 1));\n    } else c = a.extend(!0, {}, c), u ? d.data(\"magnificPopup\", c) : d[0].magnificPopup = c, b.addGroup(d, c);\n    return d;\n  };\n\n  var C,\n      D,\n      E,\n      F = \"inline\",\n      G = function G() {\n    E && (D.after(E.addClass(C)).detach(), E = null);\n  };\n\n  a.magnificPopup.registerModule(F, {\n    options: {\n      hiddenClass: \"hide\",\n      markup: \"\",\n      tNotFound: \"Content not found\"\n    },\n    proto: {\n      initInline: function initInline() {\n        b.types.push(F), w(h + \".\" + F, function () {\n          G();\n        });\n      },\n      getInline: function getInline(c, d) {\n        if (G(), c.src) {\n          var e = b.st.inline,\n              f = a(c.src);\n\n          if (f.length) {\n            var g = f[0].parentNode;\n            g && g.tagName && (D || (C = e.hiddenClass, D = x(C), C = \"mfp-\" + C), E = f.after(D).detach().removeClass(C)), b.updateStatus(\"ready\");\n          } else b.updateStatus(\"error\", e.tNotFound), f = a(\"<div>\");\n\n          return c.inlineElement = f, f;\n        }\n\n        return b.updateStatus(\"ready\"), b._parseMarkup(d, {}, c), d;\n      }\n    }\n  });\n\n  var H,\n      I = \"ajax\",\n      J = function J() {\n    H && a(document.body).removeClass(H);\n  },\n      K = function K() {\n    J(), b.req && b.req.abort();\n  };\n\n  a.magnificPopup.registerModule(I, {\n    options: {\n      settings: null,\n      cursor: \"mfp-ajax-cur\",\n      tError: '<a href=\"%url%\">The content</a> could not be loaded.'\n    },\n    proto: {\n      initAjax: function initAjax() {\n        b.types.push(I), H = b.st.ajax.cursor, w(h + \".\" + I, K), w(\"BeforeChange.\" + I, K);\n      },\n      getAjax: function getAjax(c) {\n        H && a(document.body).addClass(H), b.updateStatus(\"loading\");\n        var d = a.extend({\n          url: c.src,\n          success: function success(d, e, f) {\n            var g = {\n              data: d,\n              xhr: f\n            };\n            y(\"ParseAjax\", g), b.appendContent(a(g.data), I), c.finished = !0, J(), b._setFocus(), setTimeout(function () {\n              b.wrap.addClass(q);\n            }, 16), b.updateStatus(\"ready\"), y(\"AjaxContentAdded\");\n          },\n          error: function error() {\n            J(), c.finished = c.loadError = !0, b.updateStatus(\"error\", b.st.ajax.tError.replace(\"%url%\", c.src));\n          }\n        }, b.st.ajax.settings);\n        return b.req = a.ajax(d), \"\";\n      }\n    }\n  });\n\n  var L,\n      M = function M(c) {\n    if (c.data && void 0 !== c.data.title) return c.data.title;\n    var d = b.st.image.titleSrc;\n\n    if (d) {\n      if (a.isFunction(d)) return d.call(b, c);\n      if (c.el) return c.el.attr(d) || \"\";\n    }\n\n    return \"\";\n  };\n\n  a.magnificPopup.registerModule(\"image\", {\n    options: {\n      markup: '<div class=\"mfp-figure\"><div class=\"mfp-close\"></div><figure><div class=\"mfp-img\"></div><figcaption><div class=\"mfp-bottom-bar\"><div class=\"mfp-title\"></div><div class=\"mfp-counter\"></div></div></figcaption></figure></div>',\n      cursor: \"mfp-zoom-out-cur\",\n      titleSrc: \"title\",\n      verticalFit: !0,\n      tError: '<a href=\"%url%\">The image</a> could not be loaded.'\n    },\n    proto: {\n      initImage: function initImage() {\n        var c = b.st.image,\n            d = \".image\";\n        b.types.push(\"image\"), w(m + d, function () {\n          \"image\" === b.currItem.type && c.cursor && a(document.body).addClass(c.cursor);\n        }), w(h + d, function () {\n          c.cursor && a(document.body).removeClass(c.cursor), v.off(\"resize\" + p);\n        }), w(\"Resize\" + d, b.resizeImage), b.isLowIE && w(\"AfterChange\", b.resizeImage);\n      },\n      resizeImage: function resizeImage() {\n        var a = b.currItem;\n\n        if (a && a.img && b.st.image.verticalFit) {\n          var c = 0;\n          b.isLowIE && (c = parseInt(a.img.css(\"padding-top\"), 10) + parseInt(a.img.css(\"padding-bottom\"), 10)), a.img.css(\"max-height\", b.wH - c);\n        }\n      },\n      _onImageHasSize: function _onImageHasSize(a) {\n        a.img && (a.hasSize = !0, L && clearInterval(L), a.isCheckingImgSize = !1, y(\"ImageHasSize\", a), a.imgHidden && (b.content && b.content.removeClass(\"mfp-loading\"), a.imgHidden = !1));\n      },\n      findImageSize: function findImageSize(a) {\n        var c = 0,\n            d = a.img[0],\n            e = function e(f) {\n          L && clearInterval(L), L = setInterval(function () {\n            return d.naturalWidth > 0 ? void b._onImageHasSize(a) : (c > 200 && clearInterval(L), c++, void (3 === c ? e(10) : 40 === c ? e(50) : 100 === c && e(500)));\n          }, f);\n        };\n\n        e(1);\n      },\n      getImage: function getImage(c, d) {\n        var e = 0,\n            f = function f() {\n          c && (c.img[0].complete ? (c.img.off(\".mfploader\"), c === b.currItem && (b._onImageHasSize(c), b.updateStatus(\"ready\")), c.hasSize = !0, c.loaded = !0, y(\"ImageLoadComplete\")) : (e++, 200 > e ? setTimeout(f, 100) : g()));\n        },\n            g = function g() {\n          c && (c.img.off(\".mfploader\"), c === b.currItem && (b._onImageHasSize(c), b.updateStatus(\"error\", h.tError.replace(\"%url%\", c.src))), c.hasSize = !0, c.loaded = !0, c.loadError = !0);\n        },\n            h = b.st.image,\n            i = d.find(\".mfp-img\");\n\n        if (i.length) {\n          var j = document.createElement(\"img\");\n          j.className = \"mfp-img\", c.el && c.el.find(\"img\").length && (j.alt = c.el.find(\"img\").attr(\"alt\")), c.img = a(j).on(\"load.mfploader\", f).on(\"error.mfploader\", g), j.src = c.src, i.is(\"img\") && (c.img = c.img.clone()), j = c.img[0], j.naturalWidth > 0 ? c.hasSize = !0 : j.width || (c.hasSize = !1);\n        }\n\n        return b._parseMarkup(d, {\n          title: M(c),\n          img_replaceWith: c.img\n        }, c), b.resizeImage(), c.hasSize ? (L && clearInterval(L), c.loadError ? (d.addClass(\"mfp-loading\"), b.updateStatus(\"error\", h.tError.replace(\"%url%\", c.src))) : (d.removeClass(\"mfp-loading\"), b.updateStatus(\"ready\")), d) : (b.updateStatus(\"loading\"), c.loading = !0, c.hasSize || (c.imgHidden = !0, d.addClass(\"mfp-loading\"), b.findImageSize(c)), d);\n      }\n    }\n  });\n\n  var N,\n      O = function O() {\n    return void 0 === N && (N = void 0 !== document.createElement(\"p\").style.MozTransform), N;\n  };\n\n  a.magnificPopup.registerModule(\"zoom\", {\n    options: {\n      enabled: !1,\n      easing: \"ease-in-out\",\n      duration: 300,\n      opener: function opener(a) {\n        return a.is(\"img\") ? a : a.find(\"img\");\n      }\n    },\n    proto: {\n      initZoom: function initZoom() {\n        var a,\n            c = b.st.zoom,\n            d = \".zoom\";\n\n        if (c.enabled && b.supportsTransition) {\n          var e,\n              f,\n              g = c.duration,\n              j = function j(a) {\n            var b = a.clone().removeAttr(\"style\").removeAttr(\"class\").addClass(\"mfp-animated-image\"),\n                d = \"all \" + c.duration / 1e3 + \"s \" + c.easing,\n                e = {\n              position: \"fixed\",\n              zIndex: 9999,\n              left: 0,\n              top: 0,\n              \"-webkit-backface-visibility\": \"hidden\"\n            },\n                f = \"transition\";\n            return e[\"-webkit-\" + f] = e[\"-moz-\" + f] = e[\"-o-\" + f] = e[f] = d, b.css(e), b;\n          },\n              k = function k() {\n            b.content.css(\"visibility\", \"visible\");\n          };\n\n          w(\"BuildControls\" + d, function () {\n            if (b._allowZoom()) {\n              if (clearTimeout(e), b.content.css(\"visibility\", \"hidden\"), a = b._getItemToZoom(), !a) return void k();\n              f = j(a), f.css(b._getOffset()), b.wrap.append(f), e = setTimeout(function () {\n                f.css(b._getOffset(!0)), e = setTimeout(function () {\n                  k(), setTimeout(function () {\n                    f.remove(), a = f = null, y(\"ZoomAnimationEnded\");\n                  }, 16);\n                }, g);\n              }, 16);\n            }\n          }), w(i + d, function () {\n            if (b._allowZoom()) {\n              if (clearTimeout(e), b.st.removalDelay = g, !a) {\n                if (a = b._getItemToZoom(), !a) return;\n                f = j(a);\n              }\n\n              f.css(b._getOffset(!0)), b.wrap.append(f), b.content.css(\"visibility\", \"hidden\"), setTimeout(function () {\n                f.css(b._getOffset());\n              }, 16);\n            }\n          }), w(h + d, function () {\n            b._allowZoom() && (k(), f && f.remove(), a = null);\n          });\n        }\n      },\n      _allowZoom: function _allowZoom() {\n        return \"image\" === b.currItem.type;\n      },\n      _getItemToZoom: function _getItemToZoom() {\n        return b.currItem.hasSize ? b.currItem.img : !1;\n      },\n      _getOffset: function _getOffset(c) {\n        var d;\n        d = c ? b.currItem.img : b.st.zoom.opener(b.currItem.el || b.currItem);\n        var e = d.offset(),\n            f = parseInt(d.css(\"padding-top\"), 10),\n            g = parseInt(d.css(\"padding-bottom\"), 10);\n        e.top -= a(window).scrollTop() - f;\n        var h = {\n          width: d.width(),\n          height: (u ? d.innerHeight() : d[0].offsetHeight) - g - f\n        };\n        return O() ? h[\"-moz-transform\"] = h.transform = \"translate(\" + e.left + \"px,\" + e.top + \"px)\" : (h.left = e.left, h.top = e.top), h;\n      }\n    }\n  });\n\n  var P = \"iframe\",\n      Q = \"//about:blank\",\n      R = function R(a) {\n    if (b.currTemplate[P]) {\n      var c = b.currTemplate[P].find(\"iframe\");\n      c.length && (a || (c[0].src = Q), b.isIE8 && c.css(\"display\", a ? \"block\" : \"none\"));\n    }\n  };\n\n  a.magnificPopup.registerModule(P, {\n    options: {\n      markup: '<div class=\"mfp-iframe-scaler\"><div class=\"mfp-close\"></div><iframe class=\"mfp-iframe\" src=\"//about:blank\" frameborder=\"0\" allowfullscreen></iframe></div>',\n      srcAction: \"iframe_src\",\n      patterns: {\n        youtube: {\n          index: \"youtube.com\",\n          id: \"v=\",\n          src: \"//www.youtube.com/embed/%id%?autoplay=1\"\n        },\n        vimeo: {\n          index: \"vimeo.com/\",\n          id: \"/\",\n          src: \"//player.vimeo.com/video/%id%?autoplay=1\"\n        },\n        gmaps: {\n          index: \"//maps.google.\",\n          src: \"%id%&output=embed\"\n        }\n      }\n    },\n    proto: {\n      initIframe: function initIframe() {\n        b.types.push(P), w(\"BeforeChange\", function (a, b, c) {\n          b !== c && (b === P ? R() : c === P && R(!0));\n        }), w(h + \".\" + P, function () {\n          R();\n        });\n      },\n      getIframe: function getIframe(c, d) {\n        var e = c.src,\n            f = b.st.iframe;\n        a.each(f.patterns, function () {\n          return e.indexOf(this.index) > -1 ? (this.id && (e = \"string\" == typeof this.id ? e.substr(e.lastIndexOf(this.id) + this.id.length, e.length) : this.id.call(this, e)), e = this.src.replace(\"%id%\", e), !1) : void 0;\n        });\n        var g = {};\n        return f.srcAction && (g[f.srcAction] = e), b._parseMarkup(d, g, c), b.updateStatus(\"ready\"), d;\n      }\n    }\n  });\n\n  var S = function S(a) {\n    var c = b.items.length;\n    return a > c - 1 ? a - c : 0 > a ? c + a : a;\n  },\n      T = function T(a, b, c) {\n    return a.replace(/%curr%/gi, b + 1).replace(/%total%/gi, c);\n  };\n\n  a.magnificPopup.registerModule(\"gallery\", {\n    options: {\n      enabled: !1,\n      arrowMarkup: '<button title=\"%title%\" type=\"button\" class=\"mfp-arrow mfp-arrow-%dir%\"></button>',\n      preload: [0, 2],\n      navigateByImgClick: !0,\n      arrows: !0,\n      tPrev: \"Previous (Left arrow key)\",\n      tNext: \"Next (Right arrow key)\",\n      tCounter: \"%curr% of %total%\"\n    },\n    proto: {\n      initGallery: function initGallery() {\n        var c = b.st.gallery,\n            e = \".mfp-gallery\";\n        return b.direction = !0, c && c.enabled ? (f += \" mfp-gallery\", w(m + e, function () {\n          c.navigateByImgClick && b.wrap.on(\"click\" + e, \".mfp-img\", function () {\n            return b.items.length > 1 ? (b.next(), !1) : void 0;\n          }), d.on(\"keydown\" + e, function (a) {\n            37 === a.keyCode ? b.prev() : 39 === a.keyCode && b.next();\n          });\n        }), w(\"UpdateStatus\" + e, function (a, c) {\n          c.text && (c.text = T(c.text, b.currItem.index, b.items.length));\n        }), w(l + e, function (a, d, e, f) {\n          var g = b.items.length;\n          e.counter = g > 1 ? T(c.tCounter, f.index, g) : \"\";\n        }), w(\"BuildControls\" + e, function () {\n          if (b.items.length > 1 && c.arrows && !b.arrowLeft) {\n            var d = c.arrowMarkup,\n                e = b.arrowLeft = a(d.replace(/%title%/gi, c.tPrev).replace(/%dir%/gi, \"left\")).addClass(s),\n                f = b.arrowRight = a(d.replace(/%title%/gi, c.tNext).replace(/%dir%/gi, \"right\")).addClass(s);\n            e.click(function () {\n              b.prev();\n            }), f.click(function () {\n              b.next();\n            }), b.container.append(e.add(f));\n          }\n        }), w(n + e, function () {\n          b._preloadTimeout && clearTimeout(b._preloadTimeout), b._preloadTimeout = setTimeout(function () {\n            b.preloadNearbyImages(), b._preloadTimeout = null;\n          }, 16);\n        }), void w(h + e, function () {\n          d.off(e), b.wrap.off(\"click\" + e), b.arrowRight = b.arrowLeft = null;\n        })) : !1;\n      },\n      next: function next() {\n        b.direction = !0, b.index = S(b.index + 1), b.updateItemHTML();\n      },\n      prev: function prev() {\n        b.direction = !1, b.index = S(b.index - 1), b.updateItemHTML();\n      },\n      goTo: function goTo(a) {\n        b.direction = a >= b.index, b.index = a, b.updateItemHTML();\n      },\n      preloadNearbyImages: function preloadNearbyImages() {\n        var a,\n            c = b.st.gallery.preload,\n            d = Math.min(c[0], b.items.length),\n            e = Math.min(c[1], b.items.length);\n\n        for (a = 1; a <= (b.direction ? e : d); a++) {\n          b._preloadItem(b.index + a);\n        }\n\n        for (a = 1; a <= (b.direction ? d : e); a++) {\n          b._preloadItem(b.index - a);\n        }\n      },\n      _preloadItem: function _preloadItem(c) {\n        if (c = S(c), !b.items[c].preloaded) {\n          var d = b.items[c];\n          d.parsed || (d = b.parseEl(c)), y(\"LazyLoad\", d), \"image\" === d.type && (d.img = a('<img class=\"mfp-img\" />').on(\"load.mfploader\", function () {\n            d.hasSize = !0;\n          }).on(\"error.mfploader\", function () {\n            d.hasSize = !0, d.loadError = !0, y(\"LazyLoadError\", d);\n          }).attr(\"src\", d.src)), d.preloaded = !0;\n        }\n      }\n    }\n  });\n  var U = \"retina\";\n  a.magnificPopup.registerModule(U, {\n    options: {\n      replaceSrc: function replaceSrc(a) {\n        return a.src.replace(/\\.\\w+$/, function (a) {\n          return \"@2x\" + a;\n        });\n      },\n      ratio: 1\n    },\n    proto: {\n      initRetina: function initRetina() {\n        if (window.devicePixelRatio > 1) {\n          var a = b.st.retina,\n              c = a.ratio;\n          c = isNaN(c) ? c() : c, c > 1 && (w(\"ImageHasSize.\" + U, function (a, b) {\n            b.img.css({\n              \"max-width\": b.img[0].naturalWidth / c,\n              width: \"100%\"\n            });\n          }), w(\"ElementParse.\" + U, function (b, d) {\n            d.src = a.replaceSrc(d, c);\n          }));\n        }\n      }\n    }\n  }), A();\n});\n/**\nRESIZESENSOR.JS\n * Copyright Marc J. Schmidt. See the LICENSE file at the top-level\n * directory of this distribution and at\n * https://github.com/marcj/css-element-queries/blob/master/LICENSE.\n */\n\n!function () {\n  var e = function e(t, i) {\n    function s() {\n      this.q = [], this.add = function (e) {\n        this.q.push(e);\n      };\n      var e, t;\n\n      this.call = function () {\n        for (e = 0, t = this.q.length; e < t; e++) {\n          this.q[e].call();\n        }\n      };\n    }\n\n    function o(e, t) {\n      return e.currentStyle ? e.currentStyle[t] : window.getComputedStyle ? window.getComputedStyle(e, null).getPropertyValue(t) : e.style[t];\n    }\n\n    function n(e, t) {\n      if (e.resizedAttached) {\n        if (e.resizedAttached) return void e.resizedAttached.add(t);\n      } else e.resizedAttached = new s(), e.resizedAttached.add(t);\n\n      e.resizeSensor = document.createElement(\"div\"), e.resizeSensor.className = \"resize-sensor\";\n      var i = \"position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;\",\n          n = \"position: absolute; left: 0; top: 0; transition: 0s;\";\n      e.resizeSensor.style.cssText = i, e.resizeSensor.innerHTML = '<div class=\"resize-sensor-expand\" style=\"' + i + '\"><div style=\"' + n + '\"></div></div><div class=\"resize-sensor-shrink\" style=\"' + i + '\"><div style=\"' + n + ' width: 200%; height: 200%\"></div></div>', e.appendChild(e.resizeSensor), {\n        fixed: 1,\n        absolute: 1\n      }[o(e, \"position\")] || (e.style.position = \"relative\");\n      var d,\n          r,\n          l = e.resizeSensor.childNodes[0],\n          c = l.childNodes[0],\n          h = e.resizeSensor.childNodes[1],\n          a = (h.childNodes[0], function () {\n        c.style.width = l.offsetWidth + 10 + \"px\", c.style.height = l.offsetHeight + 10 + \"px\", l.scrollLeft = l.scrollWidth, l.scrollTop = l.scrollHeight, h.scrollLeft = h.scrollWidth, h.scrollTop = h.scrollHeight, d = e.offsetWidth, r = e.offsetHeight;\n      });\n      a();\n\n      var f = function f() {\n        e.resizedAttached && e.resizedAttached.call();\n      },\n          u = function u(e, t, i) {\n        e.attachEvent ? e.attachEvent(\"on\" + t, i) : e.addEventListener(t, i);\n      },\n          p = function p() {\n        e.offsetWidth == d && e.offsetHeight == r || f(), a();\n      };\n\n      u(l, \"scroll\", p), u(h, \"scroll\", p);\n    }\n\n    var d = Object.prototype.toString.call(t),\n        r = \"[object Array]\" === d || \"[object NodeList]\" === d || \"[object HTMLCollection]\" === d || \"undefined\" != typeof jQuery && t instanceof jQuery || \"undefined\" != typeof Elements && t instanceof Elements;\n    if (r) for (var l = 0, c = t.length; l < c; l++) {\n      n(t[l], i);\n    } else n(t, i);\n\n    this.detach = function () {\n      if (r) for (var i = 0, s = t.length; i < s; i++) {\n        e.detach(t[i]);\n      } else e.detach(t);\n    };\n  };\n\n  e.detach = function (e) {\n    e.resizeSensor && (e.removeChild(e.resizeSensor), delete e.resizeSensor, delete e.resizedAttached);\n  },  true && \"undefined\" != typeof module.exports ? module.exports = e : window.ResizeSensor = e;\n}();\n/*!\n * Theia Sticky Sidebar v1.7.0\n * https://github.com/WeCodePixels/theia-sticky-sidebar\n *\n * Glues your website's sidebars, making them permanently visible while scrolling.\n *\n * Copyright 2013-2016 WeCodePixels and other contributors\n * Released under the MIT license\n */\n\n/*!\n * Theia Sticky Sidebar v1.7.0\n * https://github.com/WeCodePixels/theia-sticky-sidebar\n *\n * Glues your website's sidebars, making them permanently visible while scrolling.\n *\n * Copyright 2013-2016 WeCodePixels and other contributors\n * Released under the MIT license\n */\n\n!function (i) {\n  i.fn.theiaStickySidebar = function (t) {\n    function e(t, e) {\n      return !0 === t.initialized || !(i(\"body\").width() < t.minWidth) && (o(t, e), !0);\n    }\n\n    function o(t, e) {\n      t.initialized = !0, 0 === i(\"#theia-sticky-sidebar-stylesheet-\" + t.namespace).length && i(\"head\").append(i('<style id=\"theia-sticky-sidebar-stylesheet-' + t.namespace + '\">.theiaStickySidebar:after {content: \"\"; display: table; clear: both;}</style>')), e.each(function () {\n        function e() {\n          n.fixedScrollTop = 0, n.sidebar.css({\n            \"min-height\": \"1px\"\n          }), n.stickySidebar.css({\n            position: \"static\",\n            width: \"\",\n            transform: \"none\"\n          });\n        }\n\n        function o(t) {\n          var e = t.height();\n          return t.children().each(function () {\n            e = Math.max(e, i(this).height());\n          }), e;\n        }\n\n        var n = {};\n\n        if (n.sidebar = i(this), n.options = t || {}, n.container = i(n.options.containerSelector), 0 == n.container.length && (n.container = n.sidebar.parent()), n.sidebar.parents(\":not(.theia-exception)\").css(\"-webkit-transform\", \"none\"), n.sidebar.css({\n          position: n.options.defaultPosition,\n          overflow: \"visible\",\n          \"-webkit-box-sizing\": \"border-box\",\n          \"-moz-box-sizing\": \"border-box\",\n          \"box-sizing\": \"border-box\"\n        }), n.stickySidebar = n.sidebar.find(\".theiaStickySidebar\"), 0 == n.stickySidebar.length) {\n          var s = /(?:text|application)\\/(?:x-)?(?:javascript|ecmascript)/i;\n          n.sidebar.find(\"script\").filter(function (i, t) {\n            return 0 === t.type.length || t.type.match(s);\n          }).remove(), n.stickySidebar = i(\"<div>\").addClass(\"theiaStickySidebar\").append(n.sidebar.children()), n.sidebar.append(n.stickySidebar);\n        }\n\n        n.marginBottom = parseInt(n.sidebar.css(\"margin-bottom\")), n.paddingTop = parseInt(n.sidebar.css(\"padding-top\")), n.paddingBottom = parseInt(n.sidebar.css(\"padding-bottom\"));\n        var d = n.stickySidebar.offset().top,\n            r = n.stickySidebar.outerHeight();\n        n.stickySidebar.css(\"padding-top\", 1), n.stickySidebar.css(\"padding-bottom\", 1), d -= n.stickySidebar.offset().top, r = n.stickySidebar.outerHeight() - r - d, 0 == d ? (n.stickySidebar.css(\"padding-top\", 0), n.stickySidebarPaddingTop = 0) : n.stickySidebarPaddingTop = 1, 0 == r ? (n.stickySidebar.css(\"padding-bottom\", 0), n.stickySidebarPaddingBottom = 0) : n.stickySidebarPaddingBottom = 1, n.previousScrollTop = null, n.fixedScrollTop = 0, e(), n.onScroll = function (n) {\n          if (n.stickySidebar.is(\":visible\")) if (i(\"body\").width() < n.options.minWidth) e();else if (n.options.disableOnResponsiveLayouts && n.sidebar.outerWidth(\"none\" == n.sidebar.css(\"float\")) + 50 > n.container.width()) e();else {\n            var s = i(document).scrollTop(),\n                d = \"static\";\n\n            if (s >= n.sidebar.offset().top + (n.paddingTop - n.options.additionalMarginTop)) {\n              var r,\n                  c = n.paddingTop + t.additionalMarginTop,\n                  p = n.paddingBottom + n.marginBottom + t.additionalMarginBottom,\n                  b = n.sidebar.offset().top,\n                  l = n.sidebar.offset().top + o(n.container),\n                  f = 0 + t.additionalMarginTop;\n              r = n.stickySidebar.outerHeight() + c + p < i(window).height() ? f + n.stickySidebar.outerHeight() : i(window).height() - n.marginBottom - n.paddingBottom - t.additionalMarginBottom;\n              var h = b - s + n.paddingTop,\n                  g = l - s - n.paddingBottom - n.marginBottom,\n                  u = n.stickySidebar.offset().top - s,\n                  S = n.previousScrollTop - s;\n              \"fixed\" == n.stickySidebar.css(\"position\") && \"modern\" == n.options.sidebarBehavior && (u += S), \"stick-to-top\" == n.options.sidebarBehavior && (u = t.additionalMarginTop), \"stick-to-bottom\" == n.options.sidebarBehavior && (u = r - n.stickySidebar.outerHeight()), u = S > 0 ? Math.min(u, f) : Math.max(u, r - n.stickySidebar.outerHeight()), u = Math.max(u, h), u = Math.min(u, g - n.stickySidebar.outerHeight());\n              var m = n.container.height() == n.stickySidebar.outerHeight();\n              d = (m || u != f) && (m || u != r - n.stickySidebar.outerHeight()) ? s + u - n.sidebar.offset().top - n.paddingTop <= t.additionalMarginTop ? \"static\" : \"absolute\" : \"fixed\";\n            }\n\n            if (\"fixed\" == d) {\n              var y = i(document).scrollLeft();\n              n.stickySidebar.css({\n                position: \"fixed\",\n                width: a(n.stickySidebar) + \"px\",\n                transform: \"translateY(\" + u + \"px)\",\n                left: n.sidebar.offset().left + parseInt(n.sidebar.css(\"padding-left\")) - y + \"px\",\n                top: \"0px\"\n              });\n            } else if (\"absolute\" == d) {\n              var k = {};\n              \"absolute\" != n.stickySidebar.css(\"position\") && (k.position = \"absolute\", k.transform = \"translateY(\" + (s + u - n.sidebar.offset().top - n.stickySidebarPaddingTop - n.stickySidebarPaddingBottom) + \"px)\", k.top = \"0px\"), k.width = a(n.stickySidebar) + \"px\", k.left = \"\", n.stickySidebar.css(k);\n            } else \"static\" == d && e();\n\n            \"static\" != d && 1 == n.options.updateSidebarHeight && n.sidebar.css({\n              \"min-height\": n.stickySidebar.outerHeight() + n.stickySidebar.offset().top - n.sidebar.offset().top + n.paddingBottom\n            }), n.previousScrollTop = s;\n          }\n        }, n.onScroll(n), i(document).on(\"scroll.\" + n.options.namespace, function (i) {\n          return function () {\n            i.onScroll(i);\n          };\n        }(n)), i(window).on(\"resize.\" + n.options.namespace, function (i) {\n          return function () {\n            i.stickySidebar.css({\n              position: \"static\"\n            }), i.onScroll(i);\n          };\n        }(n)), \"undefined\" != typeof ResizeSensor && new ResizeSensor(n.stickySidebar[0], function (i) {\n          return function () {\n            i.onScroll(i);\n          };\n        }(n));\n      });\n    }\n\n    function a(i) {\n      var t;\n\n      try {\n        t = i[0].getBoundingClientRect().width;\n      } catch (i) {}\n\n      return void 0 === t && (t = i.width()), t;\n    }\n\n    var n = {\n      containerSelector: \"\",\n      additionalMarginTop: 0,\n      additionalMarginBottom: 0,\n      updateSidebarHeight: !0,\n      minWidth: 0,\n      disableOnResponsiveLayouts: !0,\n      sidebarBehavior: \"modern\",\n      defaultPosition: \"relative\",\n      namespace: \"TSS\"\n    };\n    return t = i.extend(n, t), t.additionalMarginTop = parseInt(t.additionalMarginTop) || 0, t.additionalMarginBottom = parseInt(t.additionalMarginBottom) || 0, function (t, o) {\n      e(t, o) || (console.log(\"TSS: Body width smaller than options.minWidth. Init is delayed.\"), i(document).on(\"scroll.\" + t.namespace, function (t, o) {\n        return function (a) {\n          e(t, o) && i(this).unbind(a);\n        };\n      }(t, o)), i(window).on(\"resize.\" + t.namespace, function (t, o) {\n        return function (a) {\n          e(t, o) && i(this).unbind(a);\n        };\n      }(t, o)));\n    }(t, this), this;\n  };\n}(jQuery);\n/*!\n * jQuery Selectbox plugin 0.2\n *\n * Copyright 2011-2012, Dimitar Ivanov (http://www.bulgaria-web-developers.com/projects/javascript/selectbox/)\n * Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.\n *\n * Date: Tue Jul 17 19:58:36 2012 +0300\n */\n\n!function (e, s) {\n  function t() {\n    this._state = [], this._defaults = {\n      classHolder: \"sbHolder\",\n      classHolderDisabled: \"sbHolderDisabled\",\n      classSelector: \"sbSelector\",\n      classOptions: \"sbOptions\",\n      classGroup: \"sbGroup\",\n      classSub: \"sbSub\",\n      classDisabled: \"sbDisabled\",\n      classToggleOpen: \"sbToggleOpen\",\n      classToggle: \"sbToggle\",\n      classFocus: \"sbFocus\",\n      speed: 200,\n      effect: \"slide\",\n      onChange: null,\n      onOpen: null,\n      onClose: null\n    };\n  }\n\n  var i = !0;\n  e.extend(t.prototype, {\n    _isOpenSelectbox: function _isOpenSelectbox(e) {\n      return !!e && this._getInst(e).isOpen;\n    },\n    _isDisabledSelectbox: function _isDisabledSelectbox(e) {\n      return !!e && this._getInst(e).isDisabled;\n    },\n    _attachSelectbox: function _attachSelectbox(s, t) {\n      function a() {\n        var s,\n            t,\n            i = this.attr(\"id\").split(\"_\")[1];\n\n        for (s in u._state) {\n          s !== i && u._state.hasOwnProperty(s) && (t = e(\"select[sb='\" + s + \"']\")[0]) && u._closeSelectbox(t);\n        }\n      }\n\n      function n() {\n        var t = !(!arguments[1] || !arguments[1].sub),\n            a = !(!arguments[1] || !arguments[1].disabled);\n        arguments[0].each(function (n) {\n          var l,\n              r = e(this),\n              g = e(\"<li>\");\n          r.is(\":selected\") && (o.text(r.text()), p = i), n === f - 1 && g.addClass(\"last\"), r.is(\":disabled\") || a ? (l = e(\"<span>\", {\n            text: r.text()\n          }).addClass(b.settings.classDisabled), t && l.addClass(b.settings.classSub), l.appendTo(g)) : (l = e(\"<a>\", {\n            href: \"#\" + r.val(),\n            rel: r.val()\n          }).text(r.text()).bind(\"click.sb\", function (t) {\n            t && t.preventDefault && t.preventDefault();\n            var i = c,\n                a = e(this);\n            i.attr(\"id\").split(\"_\")[1];\n            u._changeSelectbox(s, a.attr(\"rel\"), a.text()), u._closeSelectbox(s);\n          }).bind(\"mouseover.sb\", function () {\n            var s = e(this);\n            s.parent().siblings().find(\"a\").removeClass(b.settings.classFocus), s.addClass(b.settings.classFocus);\n          }).bind(\"mouseout.sb\", function () {\n            e(this).removeClass(b.settings.classFocus);\n          }), t && l.addClass(b.settings.classSub), r.is(\":selected\") && l.addClass(b.settings.classFocus), l.appendTo(g)), g.appendTo(d);\n        });\n      }\n\n      if (this._getInst(s)) return !1;\n\n      var l,\n          o,\n          c,\n          d,\n          r = e(s),\n          u = this,\n          b = u._newInst(r),\n          p = !1,\n          g = (r.find(\"optgroup\"), r.find(\"option\")),\n          f = g.length;\n\n      r.attr(\"sb\", b.uid), e.extend(b.settings, u._defaults, t), u._state[b.uid] = !1, r.hide(), l = e(\"<div>\", {\n        id: \"sbHolder_\" + b.uid,\n        \"class\": b.settings.classHolder,\n        tabindex: r.attr(\"tabindex\")\n      }), o = e(\"<a>\", {\n        id: \"sbSelector_\" + b.uid,\n        href: \"#\",\n        \"class\": b.settings.classSelector,\n        click: function click(t) {\n          t.preventDefault(), a.apply(e(this), []);\n          var i = e(this).attr(\"id\").split(\"_\")[1];\n          u._state[i] ? u._closeSelectbox(s) : u._openSelectbox(s);\n        }\n      }), (c = e(\"<a>\", {\n        id: \"sbToggle_\" + b.uid,\n        href: \"#\",\n        \"class\": b.settings.classToggle,\n        click: function click(t) {\n          t.preventDefault(), a.apply(e(this), []);\n          var i = e(this).attr(\"id\").split(\"_\")[1];\n          u._state[i] ? u._closeSelectbox(s) : u._openSelectbox(s);\n        }\n      })).appendTo(l), d = e(\"<ul>\", {\n        id: \"sbOptions_\" + b.uid,\n        \"class\": b.settings.classOptions,\n        css: {\n          display: \"none\"\n        }\n      }), r.children().each(function (s) {\n        var t,\n            i = e(this),\n            a = {};\n        i.is(\"option\") ? n(i) : i.is(\"optgroup\") && (t = e(\"<li>\"), e(\"<span>\", {\n          text: i.attr(\"label\")\n        }).addClass(b.settings.classGroup).appendTo(t), t.appendTo(d), i.is(\":disabled\") && (a.disabled = !0), a.sub = !0, n(i.find(\"option\"), a));\n      }), p || o.text(g.first().text()), e.data(s, \"selectbox\", b), l.data(\"uid\", b.uid).bind(\"keydown.sb\", function (s) {\n        var t = s.charCode ? s.charCode : s.keyCode ? s.keyCode : 0,\n            i = e(this),\n            a = i.data(\"uid\"),\n            n = i.siblings(\"select[sb='\" + a + \"']\").data(\"selectbox\"),\n            l = i.siblings([\"select[sb='\", a, \"']\"].join(\"\")).get(0),\n            o = i.find(\"ul\").find(\"a.\" + n.settings.classFocus);\n\n        switch (t) {\n          case 37:\n          case 38:\n            if (o.length > 0) {\n              e(\"a\", i).removeClass(n.settings.classFocus), (c = o.parent().prevAll(\"li:has(a)\").eq(0).find(\"a\")).length > 0 && (c.addClass(n.settings.classFocus).focus(), e(\"#sbSelector_\" + a).text(c.text()));\n            }\n\n            break;\n\n          case 39:\n          case 40:\n            var c;\n            e(\"a\", i).removeClass(n.settings.classFocus), (c = o.length > 0 ? o.parent().nextAll(\"li:has(a)\").eq(0).find(\"a\") : i.find(\"ul\").find(\"a\").eq(0)).length > 0 && (c.addClass(n.settings.classFocus).focus(), e(\"#sbSelector_\" + a).text(c.text()));\n            break;\n\n          case 13:\n            o.length > 0 && u._changeSelectbox(l, o.attr(\"rel\"), o.text()), u._closeSelectbox(l);\n            break;\n\n          case 9:\n            l && (n = u._getInst(l)) && (o.length > 0 && u._changeSelectbox(l, o.attr(\"rel\"), o.text()), u._closeSelectbox(l));\n            var d = parseInt(i.attr(\"tabindex\"), 10);\n            s.shiftKey ? d-- : d++, e(\"*[tabindex='\" + d + \"']\").focus();\n            break;\n\n          case 27:\n            u._closeSelectbox(l);\n\n        }\n\n        return s.stopPropagation(), !1;\n      }).delegate(\"a\", \"mouseover\", function (s) {\n        e(this).addClass(b.settings.classFocus);\n      }).delegate(\"a\", \"mouseout\", function (s) {\n        e(this).removeClass(b.settings.classFocus);\n      }), o.appendTo(l), d.appendTo(l), l.insertAfter(r), e([\".\", b.settings.classHolder, \", .\", b.settings.classSelector].join(\"\")).mousedown(function (e) {\n        e.stopPropagation();\n      });\n    },\n    _detachSelectbox: function _detachSelectbox(s) {\n      var t = this._getInst(s);\n\n      if (!t) return !1;\n      e(\"#sbHolder_\" + t.uid).remove(), e.data(s, \"selectbox\", null), e(s).show();\n    },\n    _changeSelectbox: function _changeSelectbox(s, t, a) {\n      var n,\n          l = this._getInst(s);\n\n      l && (n = this._get(l, \"onChange\"), e(\"#sbSelector_\" + l.uid).text(a)), t = t.replace(/\\'/g, \"\\\\'\"), e(s).find(\"option[value='\" + t + \"']\").attr(\"selected\", i), l && n ? n.apply(l.input ? l.input[0] : null, [t, l]) : l && l.input && l.input.trigger(\"change\");\n    },\n    _enableSelectbox: function _enableSelectbox(s) {\n      var t = this._getInst(s);\n\n      if (!t || !t.isDisabled) return !1;\n      e(\"#sbHolder_\" + t.uid).removeClass(t.settings.classHolderDisabled), t.isDisabled = !1, e.data(s, \"selectbox\", t);\n    },\n    _disableSelectbox: function _disableSelectbox(s) {\n      var t = this._getInst(s);\n\n      if (!t || t.isDisabled) return !1;\n      e(\"#sbHolder_\" + t.uid).addClass(t.settings.classHolderDisabled), t.isDisabled = i, e.data(s, \"selectbox\", t);\n    },\n    _optionSelectbox: function _optionSelectbox(s, t, i) {\n      var a = this._getInst(s);\n\n      if (!a) return !1;\n      a[t] = i, e.data(s, \"selectbox\", a);\n    },\n    _openSelectbox: function _openSelectbox(s) {\n      var t = this._getInst(s);\n\n      if (t && !t.isOpen && !t.isDisabled) {\n        var a = e(\"#sbOptions_\" + t.uid),\n            n = parseInt(e(window).height(), 10),\n            l = e(\"#sbHolder_\" + t.uid).offset(),\n            o = e(window).scrollTop(),\n            c = a.prev().height(),\n            d = n - (l.top - o) - c / 2,\n            r = this._get(t, \"onOpen\");\n\n        a.css({\n          top: c + \"px\",\n          maxHeight: d - c + \"px\"\n        }), \"fade\" === t.settings.effect ? a.fadeIn(t.settings.speed) : a.slideDown(t.settings.speed), e(\"#sbToggle_\" + t.uid).addClass(t.settings.classToggleOpen), this._state[t.uid] = i, t.isOpen = i, r && r.apply(t.input ? t.input[0] : null, [t]), e.data(s, \"selectbox\", t);\n      }\n    },\n    _closeSelectbox: function _closeSelectbox(s) {\n      var t = this._getInst(s);\n\n      if (t && t.isOpen) {\n        var i = this._get(t, \"onClose\");\n\n        \"fade\" === t.settings.effect ? e(\"#sbOptions_\" + t.uid).fadeOut(t.settings.speed) : e(\"#sbOptions_\" + t.uid).slideUp(t.settings.speed), e(\"#sbToggle_\" + t.uid).removeClass(t.settings.classToggleOpen), this._state[t.uid] = !1, t.isOpen = !1, i && i.apply(t.input ? t.input[0] : null, [t]), e.data(s, \"selectbox\", t);\n      }\n    },\n    _newInst: function _newInst(e) {\n      return {\n        id: e[0].id.replace(/([^A-Za-z0-9_-])/g, \"\\\\\\\\$1\"),\n        input: e,\n        uid: Math.floor(99999999 * Math.random()),\n        isOpen: !1,\n        isDisabled: !1,\n        settings: {}\n      };\n    },\n    _getInst: function _getInst(s) {\n      try {\n        return e.data(s, \"selectbox\");\n      } catch (e) {\n        throw \"Missing instance data for this selectbox\";\n      }\n    },\n    _get: function _get(e, s) {\n      return void 0 !== e.settings[s] ? e.settings[s] : this._defaults[s];\n    }\n  }), e.fn.selectbox = function (s) {\n    var t = Array.prototype.slice.call(arguments, 1);\n    return \"string\" == typeof s && \"isDisabled\" == s ? e.selectbox[\"_\" + s + \"Selectbox\"].apply(e.selectbox, [this[0]].concat(t)) : \"option\" == s && 2 == arguments.length && \"string\" == typeof arguments[1] ? e.selectbox[\"_\" + s + \"Selectbox\"].apply(e.selectbox, [this[0]].concat(t)) : this.each(function () {\n      \"string\" == typeof s ? e.selectbox[\"_\" + s + \"Selectbox\"].apply(e.selectbox, [this].concat(t)) : e.selectbox._attachSelectbox(this, s);\n    });\n  }, e.selectbox = new t(), e.selectbox.version = \"0.2\";\n}(jQuery);\n/*\n Sticky-kit v1.1.3 | MIT | Leaf Corcoran 2015 | http://leafo.net\n*/\n\n(function () {\n  var c, f;\n  c = window.jQuery;\n  f = c(window);\n\n  c.fn.stick_in_parent = function (b) {\n    var A, w, J, n, B, K, p, q, L, k, E, t;\n    null == b && (b = {});\n    t = b.sticky_class;\n    B = b.inner_scrolling;\n    E = b.recalc_every;\n    k = b.parent;\n    q = b.offset_top;\n    p = b.spacer;\n    w = b.bottoming;\n    null == q && (q = 0);\n    null == k && (k = void 0);\n    null == B && (B = !0);\n    null == t && (t = \"is_stuck\");\n    A = c(document);\n    null == w && (w = !0);\n\n    L = function L(a) {\n      var b;\n      return window.getComputedStyle ? (a = window.getComputedStyle(a[0]), b = parseFloat(a.getPropertyValue(\"width\")) + parseFloat(a.getPropertyValue(\"margin-left\")) + parseFloat(a.getPropertyValue(\"margin-right\")), \"border-box\" !== a.getPropertyValue(\"box-sizing\") && (b += parseFloat(a.getPropertyValue(\"border-left-width\")) + parseFloat(a.getPropertyValue(\"border-right-width\")) + parseFloat(a.getPropertyValue(\"padding-left\")) + parseFloat(a.getPropertyValue(\"padding-right\"))), b) : a.outerWidth(!0);\n    };\n\n    J = function J(a, b, n, C, F, u, r, G) {\n      var v, _H, m, D, I, d, g, x, y, z, h, l;\n\n      if (!a.data(\"sticky_kit\")) {\n        a.data(\"sticky_kit\", !0);\n        I = A.height();\n        g = a.parent();\n        null != k && (g = g.closest(k));\n        if (!g.length) throw \"failed to find stick parent\";\n        v = m = !1;\n        (h = null != p ? p && a.closest(p) : c(\"<div />\")) && h.css(\"position\", a.css(\"position\"));\n\n        x = function x() {\n          var d, f, e;\n          if (!G && (I = A.height(), d = parseInt(g.css(\"border-top-width\"), 10), f = parseInt(g.css(\"padding-top\"), 10), b = parseInt(g.css(\"padding-bottom\"), 10), n = g.offset().top + d + f, C = g.height(), m && (v = m = !1, null == p && (a.insertAfter(h), h.detach()), a.css({\n            position: \"\",\n            top: \"\",\n            width: \"\",\n            bottom: \"\"\n          }).removeClass(t), e = !0), F = a.offset().top - (parseInt(a.css(\"margin-top\"), 10) || 0) - q, u = a.outerHeight(!0), r = a.css(\"float\"), h && h.css({\n            width: L(a),\n            height: u,\n            display: a.css(\"display\"),\n            \"vertical-align\": a.css(\"vertical-align\"),\n            \"float\": r\n          }), e)) return l();\n        };\n\n        x();\n        if (u !== C) return D = void 0, d = q, z = E, l = function l() {\n          var c, l, e, k;\n          if (!G && (e = !1, null != z && (--z, 0 >= z && (z = E, x(), e = !0)), e || A.height() === I || x(), e = f.scrollTop(), null != D && (l = e - D), D = e, m ? (w && (k = e + u + d > C + n, v && !k && (v = !1, a.css({\n            position: \"fixed\",\n            bottom: \"\",\n            top: d\n          }).trigger(\"sticky_kit:unbottom\"))), e < F && (m = !1, d = q, null == p && (\"left\" !== r && \"right\" !== r || a.insertAfter(h), h.detach()), c = {\n            position: \"\",\n            width: \"\",\n            top: \"\"\n          }, a.css(c).removeClass(t).trigger(\"sticky_kit:unstick\")), B && (c = f.height(), u + q > c && !v && (d -= l, d = Math.max(c - u, d), d = Math.min(q, d), m && a.css({\n            top: d + \"px\"\n          })))) : e > F && (m = !0, c = {\n            position: \"fixed\",\n            top: d\n          }, c.width = \"border-box\" === a.css(\"box-sizing\") ? a.outerWidth() + \"px\" : a.width() + \"px\", a.css(c).addClass(t), null == p && (a.after(h), \"left\" !== r && \"right\" !== r || h.append(a)), a.trigger(\"sticky_kit:stick\")), m && w && (null == k && (k = e + u + d > C + n), !v && k))) return v = !0, \"static\" === g.css(\"position\") && g.css({\n            position: \"relative\"\n          }), a.css({\n            position: \"absolute\",\n            bottom: b,\n            top: \"auto\"\n          }).trigger(\"sticky_kit:bottom\");\n        }, y = function y() {\n          x();\n          return l();\n        }, _H = function H() {\n          G = !0;\n          f.off(\"touchmove\", l);\n          f.off(\"scroll\", l);\n          f.off(\"resize\", y);\n          c(document.body).off(\"sticky_kit:recalc\", y);\n          a.off(\"sticky_kit:detach\", _H);\n          a.removeData(\"sticky_kit\");\n          a.css({\n            position: \"\",\n            bottom: \"\",\n            top: \"\",\n            width: \"\"\n          });\n          g.position(\"position\", \"\");\n          if (m) return null == p && (\"left\" !== r && \"right\" !== r || a.insertAfter(h), h.remove()), a.removeClass(t);\n        }, f.on(\"touchmove\", l), f.on(\"scroll\", l), f.on(\"resize\", y), c(document.body).on(\"sticky_kit:recalc\", y), a.on(\"sticky_kit:detach\", _H), setTimeout(l, 0);\n      }\n    };\n\n    n = 0;\n\n    for (K = this.length; n < K; n++) {\n      b = this[n], J(c(b));\n    }\n\n    return this;\n  };\n}).call(this);\n/*! iCheck v1.0.2 by Damir Sultanov, http://git.io/arlzeA, MIT Licensed */\n\n(function (f) {\n  function A(a, b, d) {\n    var c = a[0],\n        g = /er/.test(d) ? _indeterminate : /bl/.test(d) ? n : k,\n        e = d == _update ? {\n      checked: c[k],\n      disabled: c[n],\n      indeterminate: \"true\" == a.attr(_indeterminate) || \"false\" == a.attr(_determinate)\n    } : c[g];\n    if (/^(ch|di|in)/.test(d) && !e) x(a, g);else if (/^(un|en|de)/.test(d) && e) q(a, g);else if (d == _update) for (var f in e) {\n      e[f] ? x(a, f, !0) : q(a, f, !0);\n    } else if (!b || \"toggle\" == d) {\n      if (!b) a[_callback](\"ifClicked\");\n      e ? c[_type] !== r && q(a, g) : x(a, g);\n    }\n  }\n\n  function x(a, b, d) {\n    var c = a[0],\n        g = a.parent(),\n        e = b == k,\n        u = b == _indeterminate,\n        v = b == n,\n        s = u ? _determinate : e ? y : \"enabled\",\n        F = l(a, s + t(c[_type])),\n        B = l(a, b + t(c[_type]));\n\n    if (!0 !== c[b]) {\n      if (!d && b == k && c[_type] == r && c.name) {\n        var w = a.closest(\"form\"),\n            p = 'input[name=\"' + c.name + '\"]',\n            p = w.length ? w.find(p) : f(p);\n        p.each(function () {\n          this !== c && f(this).data(m) && q(f(this), b);\n        });\n      }\n\n      u ? (c[b] = !0, c[k] && q(a, k, \"force\")) : (d || (c[b] = !0), e && c[_indeterminate] && q(a, _indeterminate, !1));\n      D(a, e, b, d);\n    }\n\n    c[n] && l(a, _cursor, !0) && g.find(\".\" + C).css(_cursor, \"default\");\n\n    g[_add](B || l(a, b) || \"\");\n\n    g.attr(\"role\") && !u && g.attr(\"aria-\" + (v ? n : k), \"true\");\n\n    g[_remove](F || l(a, s) || \"\");\n  }\n\n  function q(a, b, d) {\n    var c = a[0],\n        g = a.parent(),\n        e = b == k,\n        f = b == _indeterminate,\n        m = b == n,\n        s = f ? _determinate : e ? y : \"enabled\",\n        q = l(a, s + t(c[_type])),\n        r = l(a, b + t(c[_type]));\n\n    if (!1 !== c[b]) {\n      if (f || !d || \"force\" == d) c[b] = !1;\n      D(a, e, s, d);\n    }\n\n    !c[n] && l(a, _cursor, !0) && g.find(\".\" + C).css(_cursor, \"pointer\");\n\n    g[_remove](r || l(a, b) || \"\");\n\n    g.attr(\"role\") && !f && g.attr(\"aria-\" + (m ? n : k), \"false\");\n\n    g[_add](q || l(a, s) || \"\");\n  }\n\n  function E(a, b) {\n    if (a.data(m)) {\n      a.parent().html(a.attr(\"style\", a.data(m).s || \"\"));\n      if (b) a[_callback](b);\n      a.off(\".i\").unwrap();\n      f(_label + '[for=\"' + a[0].id + '\"]').add(a.closest(_label)).off(\".i\");\n    }\n  }\n\n  function l(a, b, f) {\n    if (a.data(m)) return a.data(m).o[b + (f ? \"\" : \"Class\")];\n  }\n\n  function t(a) {\n    return a.charAt(0).toUpperCase() + a.slice(1);\n  }\n\n  function D(a, b, f, c) {\n    if (!c) {\n      if (b) a[_callback](\"ifToggled\");\n\n      a[_callback](\"ifChanged\")[_callback](\"if\" + t(f));\n    }\n  }\n\n  var m = \"iCheck\",\n      C = m + \"-helper\",\n      r = \"radio\",\n      k = \"checked\",\n      y = \"un\" + k,\n      n = \"disabled\";\n  _determinate = \"determinate\";\n  _indeterminate = \"in\" + _determinate;\n  _update = \"update\";\n  _type = \"type\";\n  _click = \"click\";\n  _touch = \"touchbegin.i touchend.i\";\n  _add = \"addClass\";\n  _remove = \"removeClass\";\n  _callback = \"trigger\";\n  _label = \"label\";\n  _cursor = \"cursor\";\n  _mobile = /ipad|iphone|ipod|android|blackberry|windows phone|opera mini|silk/i.test(navigator.userAgent);\n\n  f.fn[m] = function (a, b) {\n    var d = 'input[type=\"checkbox\"], input[type=\"' + r + '\"]',\n        c = f(),\n        g = function g(a) {\n      a.each(function () {\n        var a = f(this);\n        c = a.is(d) ? c.add(a) : c.add(a.find(d));\n      });\n    };\n\n    if (/^(check|uncheck|toggle|indeterminate|determinate|disable|enable|update|destroy)$/i.test(a)) return a = a.toLowerCase(), g(this), c.each(function () {\n      var c = f(this);\n      \"destroy\" == a ? E(c, \"ifDestroyed\") : A(c, !0, a);\n      f.isFunction(b) && b();\n    });\n    if (\"object\" != _typeof(a) && a) return this;\n    var e = f.extend({\n      checkedClass: k,\n      disabledClass: n,\n      indeterminateClass: _indeterminate,\n      labelHover: !0\n    }, a),\n        l = e.handle,\n        v = e.hoverClass || \"hover\",\n        s = e.focusClass || \"focus\",\n        t = e.activeClass || \"active\",\n        B = !!e.labelHover,\n        w = e.labelHoverClass || \"hover\",\n        p = (\"\" + e.increaseArea).replace(\"%\", \"\") | 0;\n    if (\"checkbox\" == l || l == r) d = 'input[type=\"' + l + '\"]';\n    -50 > p && (p = -50);\n    g(this);\n    return c.each(function () {\n      var a = f(this);\n      E(a);\n      var c = this,\n          b = c.id,\n          g = -p + \"%\",\n          d = 100 + 2 * p + \"%\",\n          d = {\n        position: \"absolute\",\n        top: g,\n        left: g,\n        display: \"block\",\n        width: d,\n        height: d,\n        margin: 0,\n        padding: 0,\n        background: \"#fff\",\n        border: 0,\n        opacity: 0\n      },\n          g = _mobile ? {\n        position: \"absolute\",\n        visibility: \"hidden\"\n      } : p ? d : {\n        position: \"absolute\",\n        opacity: 0\n      },\n          l = \"checkbox\" == c[_type] ? e.checkboxClass || \"icheckbox\" : e.radioClass || \"i\" + r,\n          z = f(_label + '[for=\"' + b + '\"]').add(a.closest(_label)),\n          u = !!e.aria,\n          y = m + \"-\" + Math.random().toString(36).substr(2, 6),\n          h = '<div class=\"' + l + '\" ' + (u ? 'role=\"' + c[_type] + '\" ' : \"\");\n      u && z.each(function () {\n        h += 'aria-labelledby=\"';\n        this.id ? h += this.id : (this.id = y, h += y);\n        h += '\"';\n      });\n      h = a.wrap(h + \"/>\")[_callback](\"ifCreated\").parent().append(e.insert);\n      d = f('<ins class=\"' + C + '\"/>').css(d).appendTo(h);\n      a.data(m, {\n        o: e,\n        s: a.attr(\"style\")\n      }).css(g);\n      e.inheritClass && h[_add](c.className || \"\");\n      e.inheritID && b && h.attr(\"id\", m + \"-\" + b);\n      \"static\" == h.css(\"position\") && h.css(\"position\", \"relative\");\n      A(a, !0, _update);\n      if (z.length) z.on(_click + \".i mouseover.i mouseout.i \" + _touch, function (b) {\n        var d = b[_type],\n            e = f(this);\n\n        if (!c[n]) {\n          if (d == _click) {\n            if (f(b.target).is(\"a\")) return;\n            A(a, !1, !0);\n          } else B && (/ut|nd/.test(d) ? (h[_remove](v), e[_remove](w)) : (h[_add](v), e[_add](w)));\n\n          if (_mobile) b.stopPropagation();else return !1;\n        }\n      });\n      a.on(_click + \".i focus.i blur.i keyup.i keydown.i keypress.i\", function (b) {\n        var d = b[_type];\n        b = b.keyCode;\n        if (d == _click) return !1;\n        if (\"keydown\" == d && 32 == b) return c[_type] == r && c[k] || (c[k] ? q(a, k) : x(a, k)), !1;\n        if (\"keyup\" == d && c[_type] == r) !c[k] && x(a, k);else if (/us|ur/.test(d)) h[\"blur\" == d ? _remove : _add](s);\n      });\n      d.on(_click + \" mousedown mouseup mouseover mouseout \" + _touch, function (b) {\n        var d = b[_type],\n            e = /wn|up/.test(d) ? t : v;\n\n        if (!c[n]) {\n          if (d == _click) A(a, !1, !0);else {\n            if (/wn|er|in/.test(d)) h[_add](e);else h[_remove](e + \" \" + t);\n            if (z.length && B && e == v) z[/ut|nd/.test(d) ? _remove : _add](w);\n          }\n          if (_mobile) b.stopPropagation();else return !1;\n        }\n      });\n    });\n  };\n})(window.jQuery || window.Zepto);\n/*\n Search overlay\n*/\n\n\n$(\".search-overlay-menu-btn\").on(\"click\", function (a) {\n  $(\".search-overlay-menu\").addClass(\"open\"), $('.search-overlay-menu > form > input[type=\"search\"]').focus();\n}), $(\".search-overlay-close\").on(\"click\", function (a) {\n  $(\".search-overlay-menu\").removeClass(\"open\");\n}), $(\".search-overlay-menu, .search-overlay-menu .search-overlay-close\").on(\"click keyup\", function (a) {\n  (a.target == this || \"search-overlay-close\" == a.target.className || 27 == a.keyCode) && $(this).removeClass(\"open\");\n});\n/*\n * jQuery mmenu v6.1.8\n * @requires jQuery 1.7.0 or later\n *\n * mmenu.frebsite.nl\n *\n * Copyright (c) Fred Heusschen\n * www.frebsite.nl\n *\n * License: CC-BY-NC-4.0\n * http://creativecommons.org/licenses/by-nc/4.0/\n */\n\n;\n\n(function (root, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this, function (jQuery) {\n  !function (e) {\n    function t() {\n      e[n].glbl || (r = {\n        $wndw: e(window),\n        $docu: e(document),\n        $html: e(\"html\"),\n        $body: e(\"body\")\n      }, s = {}, a = {}, o = {}, e.each([s, a, o], function (e, t) {\n        t.add = function (e) {\n          e = e.split(\" \");\n\n          for (var n = 0, i = e.length; n < i; n++) {\n            t[e[n]] = t.mm(e[n]);\n          }\n        };\n      }), s.mm = function (e) {\n        return \"mm-\" + e;\n      }, s.add(\"wrapper menu panels panel nopanel highest opened subopened navbar hasnavbar title btn prev next listview nolistview inset vertical selected divider spacer hidden fullsubopen noanimation\"), s.umm = function (e) {\n        return \"mm-\" == e.slice(0, 3) && (e = e.slice(3)), e;\n      }, a.mm = function (e) {\n        return \"mm-\" + e;\n      }, a.add(\"parent child\"), o.mm = function (e) {\n        return e + \".mm\";\n      }, o.add(\"transitionend webkitTransitionEnd click scroll resize keydown mousedown mouseup touchstart touchmove touchend orientationchange\"), e[n]._c = s, e[n]._d = a, e[n]._e = o, e[n].glbl = r);\n    }\n\n    var n = \"mmenu\",\n        i = \"6.1.8\";\n\n    if (!(e[n] && e[n].version > i)) {\n      e[n] = function (e, t, n) {\n        return this.$menu = e, this._api = [\"bind\", \"getInstance\", \"initPanels\", \"openPanel\", \"closePanel\", \"closeAllPanels\", \"setSelected\"], this.opts = t, this.conf = n, this.vars = {}, this.cbck = {}, this.mtch = {}, \"function\" == typeof this.___deprecated && this.___deprecated(), this._initAddons(), this._initExtensions(), this._initMenu(), this._initPanels(), this._initOpened(), this._initAnchors(), this._initMatchMedia(), \"function\" == typeof this.___debug && this.___debug(), this;\n      }, e[n].version = i, e[n].addons = {}, e[n].uniqueId = 0, e[n].defaults = {\n        extensions: [],\n        initMenu: function initMenu() {},\n        initPanels: function initPanels() {},\n        navbar: {\n          add: !0,\n          title: \"Menu\",\n          titleLink: \"parent\"\n        },\n        onClick: {\n          setSelected: !0\n        },\n        slidingSubmenus: !0\n      }, e[n].configuration = {\n        classNames: {\n          divider: \"Divider\",\n          inset: \"Inset\",\n          nolistview: \"NoListview\",\n          nopanel: \"NoPanel\",\n          panel: \"Panel\",\n          selected: \"Selected\",\n          spacer: \"Spacer\",\n          vertical: \"Vertical\"\n        },\n        clone: !1,\n        openingInterval: 25,\n        panelNodetype: \"ul, ol, div\",\n        transitionDuration: 400\n      }, e[n].prototype = {\n        getInstance: function getInstance() {\n          return this;\n        },\n        initPanels: function initPanels(e) {\n          this._initPanels(e);\n        },\n        openPanel: function openPanel(t, i) {\n          if (this.trigger(\"openPanel:before\", t), t && t.length && (t.is(\".\" + s.panel) || (t = t.closest(\".\" + s.panel)), t.is(\".\" + s.panel))) {\n            var o = this;\n            if (\"boolean\" != typeof i && (i = !0), t.hasClass(s.vertical)) t.add(t.parents(\".\" + s.vertical)).removeClass(s.hidden).parent(\"li\").addClass(s.opened), this.openPanel(t.parents(\".\" + s.panel).not(\".\" + s.vertical).first()), this.trigger(\"openPanel:start\", t), this.trigger(\"openPanel:finish\", t);else {\n              if (t.hasClass(s.opened)) return;\n              var r = this.$pnls.children(\".\" + s.panel),\n                  l = r.filter(\".\" + s.opened);\n              if (!e[n].support.csstransitions) return l.addClass(s.hidden).removeClass(s.opened), t.removeClass(s.hidden).addClass(s.opened), this.trigger(\"openPanel:start\", t), void this.trigger(\"openPanel:finish\", t);\n              r.not(t).removeClass(s.subopened);\n\n              for (var d = t.data(a.parent); d;) {\n                d = d.closest(\".\" + s.panel), d.is(\".\" + s.vertical) || d.addClass(s.subopened), d = d.data(a.parent);\n              }\n\n              r.removeClass(s.highest).not(l).not(t).addClass(s.hidden), t.removeClass(s.hidden), this.openPanelStart = function () {\n                l.removeClass(s.opened), t.addClass(s.opened), t.hasClass(s.subopened) ? (l.addClass(s.highest), t.removeClass(s.subopened)) : (l.addClass(s.subopened), t.addClass(s.highest)), this.trigger(\"openPanel:start\", t);\n              }, this.openPanelFinish = function () {\n                l.removeClass(s.highest).addClass(s.hidden), t.removeClass(s.highest), this.trigger(\"openPanel:finish\", t);\n              }, i && !t.hasClass(s.noanimation) ? setTimeout(function () {\n                o.__transitionend(t, function () {\n                  o.openPanelFinish.call(o);\n                }, o.conf.transitionDuration), o.openPanelStart.call(o);\n              }, o.conf.openingInterval) : (this.openPanelStart.call(this), this.openPanelFinish.call(this));\n            }\n            this.trigger(\"openPanel:after\", t);\n          }\n        },\n        closePanel: function closePanel(e) {\n          this.trigger(\"closePanel:before\", e);\n          var t = e.parent();\n          t.hasClass(s.vertical) && (t.removeClass(s.opened), this.trigger(\"closePanel\", e)), this.trigger(\"closePanel:after\", e);\n        },\n        closeAllPanels: function closeAllPanels(e) {\n          this.trigger(\"closeAllPanels:before\"), this.$pnls.find(\".\" + s.listview).children().removeClass(s.selected).filter(\".\" + s.vertical).removeClass(s.opened);\n          var t = this.$pnls.children(\".\" + s.panel),\n              n = e && e.length ? e : t.first();\n          this.$pnls.children(\".\" + s.panel).not(n).removeClass(s.subopened).removeClass(s.opened).removeClass(s.highest).addClass(s.hidden), this.openPanel(n, !1), this.trigger(\"closeAllPanels:after\");\n        },\n        togglePanel: function togglePanel(e) {\n          var t = e.parent();\n          t.hasClass(s.vertical) && this[t.hasClass(s.opened) ? \"closePanel\" : \"openPanel\"](e);\n        },\n        setSelected: function setSelected(e) {\n          this.trigger(\"setSelected:before\", e), this.$menu.find(\".\" + s.listview).children(\".\" + s.selected).removeClass(s.selected), e.addClass(s.selected), this.trigger(\"setSelected:after\", e);\n        },\n        bind: function bind(e, t) {\n          this.cbck[e] = this.cbck[e] || [], this.cbck[e].push(t);\n        },\n        trigger: function trigger() {\n          var e = this,\n              t = Array.prototype.slice.call(arguments),\n              n = t.shift();\n          if (this.cbck[n]) for (var i = 0, s = this.cbck[n].length; i < s; i++) {\n            this.cbck[n][i].apply(e, t);\n          }\n        },\n        matchMedia: function matchMedia(e, t, n) {\n          var i = {\n            yes: t,\n            no: n\n          };\n          this.mtch[e] = this.mtch[e] || [], this.mtch[e].push(i);\n        },\n        _initAddons: function _initAddons() {\n          this.trigger(\"initAddons:before\");\n          var t;\n\n          for (t in e[n].addons) {\n            e[n].addons[t].add.call(this), e[n].addons[t].add = function () {};\n          }\n\n          for (t in e[n].addons) {\n            e[n].addons[t].setup.call(this);\n          }\n\n          this.trigger(\"initAddons:after\");\n        },\n        _initExtensions: function _initExtensions() {\n          this.trigger(\"initExtensions:before\");\n          var e = this;\n          this.opts.extensions.constructor === Array && (this.opts.extensions = {\n            all: this.opts.extensions\n          });\n\n          for (var t in this.opts.extensions) {\n            this.opts.extensions[t] = this.opts.extensions[t].length ? \"mm-\" + this.opts.extensions[t].join(\" mm-\") : \"\", this.opts.extensions[t] && !function (t) {\n              e.matchMedia(t, function () {\n                this.$menu.addClass(this.opts.extensions[t]);\n              }, function () {\n                this.$menu.removeClass(this.opts.extensions[t]);\n              });\n            }(t);\n          }\n\n          this.trigger(\"initExtensions:after\");\n        },\n        _initMenu: function _initMenu() {\n          this.trigger(\"initMenu:before\");\n          this.conf.clone && (this.$orig = this.$menu, this.$menu = this.$orig.clone(), this.$menu.add(this.$menu.find(\"[id]\")).filter(\"[id]\").each(function () {\n            e(this).attr(\"id\", s.mm(e(this).attr(\"id\")));\n          })), this.opts.initMenu.call(this, this.$menu, this.$orig), this.$menu.attr(\"id\", this.$menu.attr(\"id\") || this.__getUniqueId()), this.$pnls = e('<div class=\"' + s.panels + '\" />').append(this.$menu.children(this.conf.panelNodetype)).prependTo(this.$menu);\n          var t = [s.menu];\n          this.opts.slidingSubmenus || t.push(s.vertical), this.$menu.addClass(t.join(\" \")).parent().addClass(s.wrapper), this.trigger(\"initMenu:after\");\n        },\n        _initPanels: function _initPanels(t) {\n          this.trigger(\"initPanels:before\", t), t = t || this.$pnls.children(this.conf.panelNodetype);\n\n          var n = e(),\n              i = this,\n              a = function a(t) {\n            t.filter(this.conf.panelNodetype).each(function () {\n              var t = i._initPanel(e(this));\n\n              if (t) {\n                i._initNavbar(t), i._initListview(t), n = n.add(t);\n                var o = t.children(\".\" + s.listview).children(\"li\").children(i.conf.panelNodeType).add(t.children(\".\" + i.conf.classNames.panel));\n                o.length && a.call(i, o);\n              }\n            });\n          };\n\n          a.call(this, t), this.opts.initPanels.call(this, n), this.trigger(\"initPanels:after\", n);\n        },\n        _initPanel: function _initPanel(e) {\n          this.trigger(\"initPanel:before\", e);\n          if (e.hasClass(s.panel)) return e;\n          if (this.__refactorClass(e, this.conf.classNames.panel, \"panel\"), this.__refactorClass(e, this.conf.classNames.nopanel, \"nopanel\"), this.__refactorClass(e, this.conf.classNames.vertical, \"vertical\"), this.__refactorClass(e, this.conf.classNames.inset, \"inset\"), e.filter(\".\" + s.inset).addClass(s.nopanel), e.hasClass(s.nopanel)) return !1;\n          var t = e.hasClass(s.vertical) || !this.opts.slidingSubmenus;\n          e.removeClass(s.vertical);\n\n          var n = e.attr(\"id\") || this.__getUniqueId();\n\n          e.removeAttr(\"id\"), e.is(\"ul, ol\") && (e.wrap(\"<div />\"), e = e.parent()), e.addClass(s.panel + \" \" + s.hidden).attr(\"id\", n);\n          var i = e.parent(\"li\");\n          return t ? e.add(i).addClass(s.vertical) : e.appendTo(this.$pnls), i.length && (i.data(a.child, e), e.data(a.parent, i)), this.trigger(\"initPanel:after\", e), e;\n        },\n        _initNavbar: function _initNavbar(t) {\n          if (this.trigger(\"initNavbar:before\", t), !t.children(\".\" + s.navbar).length) {\n            var i = t.data(a.parent),\n                o = e('<div class=\"' + s.navbar + '\" />'),\n                r = e[n].i18n(this.opts.navbar.title),\n                l = \"\";\n\n            if (i && i.length) {\n              if (i.hasClass(s.vertical)) return;\n              if (i.parent().is(\".\" + s.listview)) var d = i.children(\"a, span\").not(\".\" + s.next);else var d = i.closest(\".\" + s.panel).find('a[href=\"#' + t.attr(\"id\") + '\"]');\n              d = d.first(), i = d.closest(\".\" + s.panel);\n              var c = i.attr(\"id\");\n\n              switch (r = d.text(), this.opts.navbar.titleLink) {\n                case \"anchor\":\n                  l = d.attr(\"href\");\n                  break;\n\n                case \"parent\":\n                  l = \"#\" + c;\n              }\n\n              o.append('<a class=\"' + s.btn + \" \" + s.prev + '\" href=\"#' + c + '\" />');\n            } else if (!this.opts.navbar.title) return;\n\n            this.opts.navbar.add && t.addClass(s.hasnavbar), o.append('<a class=\"' + s.title + '\"' + (l.length ? ' href=\"' + l + '\"' : \"\") + \">\" + r + \"</a>\").prependTo(t), this.trigger(\"initNavbar:after\", t);\n          }\n        },\n        _initListview: function _initListview(t) {\n          this.trigger(\"initListview:before\", t);\n\n          var n = this.__childAddBack(t, \"ul, ol\");\n\n          this.__refactorClass(n, this.conf.classNames.nolistview, \"nolistview\"), n.filter(\".\" + this.conf.classNames.inset).addClass(s.nolistview);\n          var i = n.not(\".\" + s.nolistview).addClass(s.listview).children();\n          this.__refactorClass(i, this.conf.classNames.selected, \"selected\"), this.__refactorClass(i, this.conf.classNames.divider, \"divider\"), this.__refactorClass(i, this.conf.classNames.spacer, \"spacer\");\n          var o = t.data(a.parent);\n\n          if (o && o.parent().is(\".\" + s.listview) && !o.children(\".\" + s.next).length) {\n            var r = o.children(\"a, span\").first(),\n                l = e('<a class=\"' + s.next + '\" href=\"#' + t.attr(\"id\") + '\" />').insertBefore(r);\n            r.is(\"span\") && l.addClass(s.fullsubopen);\n          }\n\n          this.trigger(\"initListview:after\", t);\n        },\n        _initOpened: function _initOpened() {\n          this.trigger(\"initOpened:before\");\n          var e = this.$pnls.find(\".\" + s.listview).children(\".\" + s.selected).removeClass(s.selected).last().addClass(s.selected),\n              t = e.length ? e.closest(\".\" + s.panel) : this.$pnls.children(\".\" + s.panel).first();\n          this.openPanel(t, !1), this.trigger(\"initOpened:after\");\n        },\n        _initAnchors: function _initAnchors() {\n          var t = this;\n          r.$body.on(o.click + \"-oncanvas\", \"a[href]\", function (i) {\n            var a = e(this),\n                o = !1,\n                r = t.$menu.find(a).length;\n\n            for (var l in e[n].addons) {\n              if (e[n].addons[l].clickAnchor.call(t, a, r)) {\n                o = !0;\n                break;\n              }\n            }\n\n            var d = a.attr(\"href\");\n            if (!o && r && d.length > 1 && \"#\" == d.slice(0, 1)) try {\n              var c = e(d, t.$menu);\n              c.is(\".\" + s.panel) && (o = !0, t[a.parent().hasClass(s.vertical) ? \"togglePanel\" : \"openPanel\"](c));\n            } catch (h) {}\n\n            if (o && i.preventDefault(), !o && r && a.is(\".\" + s.listview + \" > li > a\") && !a.is('[rel=\"external\"]') && !a.is('[target=\"_blank\"]')) {\n              t.__valueOrFn(t.opts.onClick.setSelected, a) && t.setSelected(e(i.target).parent());\n\n              var f = t.__valueOrFn(t.opts.onClick.preventDefault, a, \"#\" == d.slice(0, 1));\n\n              f && i.preventDefault(), t.__valueOrFn(t.opts.onClick.close, a, f) && t.opts.offCanvas && \"function\" == typeof t.close && t.close();\n            }\n          });\n        },\n        _initMatchMedia: function _initMatchMedia() {\n          var e = this;\n          this._fireMatchMedia(), r.$wndw.on(o.resize, function (t) {\n            e._fireMatchMedia();\n          });\n        },\n        _fireMatchMedia: function _fireMatchMedia() {\n          for (var e in this.mtch) {\n            for (var t = window.matchMedia && window.matchMedia(e).matches ? \"yes\" : \"no\", n = 0; n < this.mtch[e].length; n++) {\n              this.mtch[e][n][t].call(this);\n            }\n          }\n        },\n        _getOriginalMenuId: function _getOriginalMenuId() {\n          var e = this.$menu.attr(\"id\");\n          return this.conf.clone && e && e.length && (e = s.umm(e)), e;\n        },\n        __api: function __api() {\n          var t = this,\n              n = {};\n          return e.each(this._api, function (e) {\n            var i = this;\n\n            n[i] = function () {\n              var e = t[i].apply(t, arguments);\n              return \"undefined\" == typeof e ? n : e;\n            };\n          }), n;\n        },\n        __valueOrFn: function __valueOrFn(e, t, n) {\n          return \"function\" == typeof e ? e.call(t[0]) : \"undefined\" == typeof e && \"undefined\" != typeof n ? n : e;\n        },\n        __refactorClass: function __refactorClass(e, t, n) {\n          return e.filter(\".\" + t).removeClass(t).addClass(s[n]);\n        },\n        __findAddBack: function __findAddBack(e, t) {\n          return e.find(t).add(e.filter(t));\n        },\n        __childAddBack: function __childAddBack(e, t) {\n          return e.children(t).add(e.filter(t));\n        },\n        __filterListItems: function __filterListItems(e) {\n          return e.not(\".\" + s.divider).not(\".\" + s.hidden);\n        },\n        __filterListItemAnchors: function __filterListItemAnchors(e) {\n          return this.__filterListItems(e).children(\"a\").not(\".\" + s.next);\n        },\n        __transitionend: function __transitionend(e, t, n) {\n          var i = !1,\n              s = function s(n) {\n            \"undefined\" != typeof n && n.target != e[0] || (i || (e.off(o.transitionend), e.off(o.webkitTransitionEnd), t.call(e[0])), i = !0);\n          };\n\n          e.on(o.transitionend, s), e.on(o.webkitTransitionEnd, s), setTimeout(s, 1.1 * n);\n        },\n        __getUniqueId: function __getUniqueId() {\n          return s.mm(e[n].uniqueId++);\n        }\n      }, e.fn[n] = function (i, s) {\n        t(), i = e.extend(!0, {}, e[n].defaults, i), s = e.extend(!0, {}, e[n].configuration, s);\n        var a = e();\n        return this.each(function () {\n          var t = e(this);\n\n          if (!t.data(n)) {\n            var o = new e[n](t, i, s);\n            o.$menu.data(n, o.__api()), a = a.add(o.$menu);\n          }\n        }), a;\n      }, e[n].i18n = function () {\n        var t = {};\n        return function (n) {\n          switch (_typeof(n)) {\n            case \"object\":\n              return e.extend(t, n), t;\n\n            case \"string\":\n              return t[n] || n;\n\n            case \"undefined\":\n            default:\n              return t;\n          }\n        };\n      }(), e[n].support = {\n        touch: \"ontouchstart\" in window || navigator.msMaxTouchPoints || !1,\n        csstransitions: function () {\n          return \"undefined\" == typeof Modernizr || \"undefined\" == typeof Modernizr.csstransitions || Modernizr.csstransitions;\n        }(),\n        csstransforms: function () {\n          return \"undefined\" == typeof Modernizr || \"undefined\" == typeof Modernizr.csstransforms || Modernizr.csstransforms;\n        }(),\n        csstransforms3d: function () {\n          return \"undefined\" == typeof Modernizr || \"undefined\" == typeof Modernizr.csstransforms3d || Modernizr.csstransforms3d;\n        }()\n      };\n      var s, a, o, r;\n    }\n  }(jQuery),\n  /*\n  * jQuery mmenu offCanvas add-on\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    var t = \"mmenu\",\n        n = \"offCanvas\";\n    e[t].addons[n] = {\n      setup: function setup() {\n        if (this.opts[n]) {\n          var s = this,\n              a = this.opts[n],\n              r = this.conf[n];\n          o = e[t].glbl, this._api = e.merge(this._api, [\"open\", \"close\", \"setPage\"]), \"object\" != _typeof(a) && (a = {}), \"top\" != a.position && \"bottom\" != a.position || (a.zposition = \"front\"), a = this.opts[n] = e.extend(!0, {}, e[t].defaults[n], a), \"string\" != typeof r.pageSelector && (r.pageSelector = \"> \" + r.pageNodetype), this.vars.opened = !1;\n          var l = [i.offcanvas];\n          \"left\" != a.position && l.push(i.mm(a.position)), \"back\" != a.zposition && l.push(i.mm(a.zposition)), e[t].support.csstransforms || l.push(i[\"no-csstransforms\"]), e[t].support.csstransforms3d || l.push(i[\"no-csstransforms3d\"]), this.bind(\"initMenu:after\", function () {\n            var e = this;\n            this.setPage(o.$page), this._initBlocker(), this[\"_initWindow_\" + n](), this.$menu.addClass(l.join(\" \")).parent(\".\" + i.wrapper).removeClass(i.wrapper), this.$menu[r.menuInsertMethod](r.menuInsertSelector);\n            var t = window.location.hash;\n\n            if (t) {\n              var s = this._getOriginalMenuId();\n\n              s && s == t.slice(1) && setTimeout(function () {\n                e.open();\n              }, 1e3);\n            }\n          }), this.bind(\"initExtensions:after\", function () {\n            for (var e = [i.mm(\"widescreen\"), i.mm(\"iconbar\")], t = 0; t < e.length; t++) {\n              for (var n in this.opts.extensions) {\n                if (this.opts.extensions[n].indexOf(e[t]) > -1) {\n                  !function (t, n) {\n                    s.matchMedia(t, function () {\n                      o.$html.addClass(e[n]);\n                    }, function () {\n                      o.$html.removeClass(e[n]);\n                    });\n                  }(n, t);\n                  break;\n                }\n              }\n            }\n          }), this.bind(\"open:start:sr-aria\", function () {\n            this.__sr_aria(this.$menu, \"hidden\", !1);\n          }), this.bind(\"close:finish:sr-aria\", function () {\n            this.__sr_aria(this.$menu, \"hidden\", !0);\n          }), this.bind(\"initMenu:after:sr-aria\", function () {\n            this.__sr_aria(this.$menu, \"hidden\", !0);\n          });\n        }\n      },\n      add: function add() {\n        i = e[t]._c, s = e[t]._d, a = e[t]._e, i.add(\"offcanvas slideout blocking modal background opening blocker page no-csstransforms3d\"), s.add(\"style\");\n      },\n      clickAnchor: function clickAnchor(e, t) {\n        var s = this;\n\n        if (this.opts[n]) {\n          var a = this._getOriginalMenuId();\n\n          if (a && e.is('[href=\"#' + a + '\"]')) {\n            if (t) return !0;\n            var r = e.closest(\".\" + i.menu);\n\n            if (r.length) {\n              var l = r.data(\"mmenu\");\n              if (l && l.close) return l.close(), s.__transitionend(r, function () {\n                s.open();\n              }, s.conf.transitionDuration), !0;\n            }\n\n            return this.open(), !0;\n          }\n\n          if (o.$page) return a = o.$page.first().attr(\"id\"), a && e.is('[href=\"#' + a + '\"]') ? (this.close(), !0) : void 0;\n        }\n      }\n    }, e[t].defaults[n] = {\n      position: \"left\",\n      zposition: \"back\",\n      blockUI: !0,\n      moveBackground: !0\n    }, e[t].configuration[n] = {\n      pageNodetype: \"div\",\n      pageSelector: null,\n      noPageSelector: [],\n      wrapPageIfNeeded: !0,\n      menuInsertMethod: \"prependTo\",\n      menuInsertSelector: \"body\"\n    }, e[t].prototype.open = function () {\n      if (this.trigger(\"open:before\"), !this.vars.opened) {\n        var e = this;\n        this._openSetup(), setTimeout(function () {\n          e._openFinish();\n        }, this.conf.openingInterval), this.trigger(\"open:after\");\n      }\n    }, e[t].prototype._openSetup = function () {\n      var t = this,\n          r = this.opts[n];\n      this.closeAllOthers(), o.$page.each(function () {\n        e(this).data(s.style, e(this).attr(\"style\") || \"\");\n      }), o.$wndw.trigger(a.resize + \"-\" + n, [!0]);\n      var l = [i.opened];\n      r.blockUI && l.push(i.blocking), \"modal\" == r.blockUI && l.push(i.modal), r.moveBackground && l.push(i.background), \"left\" != r.position && l.push(i.mm(this.opts[n].position)), \"back\" != r.zposition && l.push(i.mm(this.opts[n].zposition)), o.$html.addClass(l.join(\" \")), setTimeout(function () {\n        t.vars.opened = !0;\n      }, this.conf.openingInterval), this.$menu.addClass(i.opened);\n    }, e[t].prototype._openFinish = function () {\n      var e = this;\n      this.__transitionend(o.$page.first(), function () {\n        e.trigger(\"open:finish\");\n      }, this.conf.transitionDuration), this.trigger(\"open:start\"), o.$html.addClass(i.opening);\n    }, e[t].prototype.close = function () {\n      if (this.trigger(\"close:before\"), this.vars.opened) {\n        var t = this;\n        this.__transitionend(o.$page.first(), function () {\n          t.$menu.removeClass(i.opened);\n          var a = [i.opened, i.blocking, i.modal, i.background, i.mm(t.opts[n].position), i.mm(t.opts[n].zposition)];\n          o.$html.removeClass(a.join(\" \")), o.$page.each(function () {\n            e(this).attr(\"style\", e(this).data(s.style));\n          }), t.vars.opened = !1, t.trigger(\"close:finish\");\n        }, this.conf.transitionDuration), this.trigger(\"close:start\"), o.$html.removeClass(i.opening), this.trigger(\"close:after\");\n      }\n    }, e[t].prototype.closeAllOthers = function () {\n      o.$body.find(\".\" + i.menu + \".\" + i.offcanvas).not(this.$menu).each(function () {\n        var n = e(this).data(t);\n        n && n.close && n.close();\n      });\n    }, e[t].prototype.setPage = function (t) {\n      this.trigger(\"setPage:before\", t);\n      var s = this,\n          a = this.conf[n];\n      t && t.length || (t = o.$body.find(a.pageSelector), a.noPageSelector.length && (t = t.not(a.noPageSelector.join(\", \"))), t.length > 1 && a.wrapPageIfNeeded && (t = t.wrapAll(\"<\" + this.conf[n].pageNodetype + \" />\").parent())), t.each(function () {\n        e(this).attr(\"id\", e(this).attr(\"id\") || s.__getUniqueId());\n      }), t.addClass(i.page + \" \" + i.slideout), o.$page = t, this.trigger(\"setPage:after\", t);\n    }, e[t].prototype[\"_initWindow_\" + n] = function () {\n      o.$wndw.off(a.keydown + \"-\" + n).on(a.keydown + \"-\" + n, function (e) {\n        if (o.$html.hasClass(i.opened) && 9 == e.keyCode) return e.preventDefault(), !1;\n      });\n      var e = 0;\n      o.$wndw.off(a.resize + \"-\" + n).on(a.resize + \"-\" + n, function (t, n) {\n        if (1 == o.$page.length && (n || o.$html.hasClass(i.opened))) {\n          var s = o.$wndw.height();\n          (n || s != e) && (e = s, o.$page.css(\"minHeight\", s));\n        }\n      });\n    }, e[t].prototype._initBlocker = function () {\n      var t = this;\n      this.opts[n].blockUI && (o.$blck || (o.$blck = e('<div id=\"' + i.blocker + '\" class=\"' + i.slideout + '\" />')), o.$blck.appendTo(o.$body).off(a.touchstart + \"-\" + n + \" \" + a.touchmove + \"-\" + n).on(a.touchstart + \"-\" + n + \" \" + a.touchmove + \"-\" + n, function (e) {\n        e.preventDefault(), e.stopPropagation(), o.$blck.trigger(a.mousedown + \"-\" + n);\n      }).off(a.mousedown + \"-\" + n).on(a.mousedown + \"-\" + n, function (e) {\n        e.preventDefault(), o.$html.hasClass(i.modal) || (t.closeAllOthers(), t.close());\n      }));\n    };\n    var i, s, a, o;\n  }(jQuery),\n  /*\n  * jQuery mmenu scrollBugFix add-on\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    var t = \"mmenu\",\n        n = \"scrollBugFix\";\n    e[t].addons[n] = {\n      setup: function setup() {\n        var s = this.opts[n];\n        this.conf[n];\n        o = e[t].glbl, e[t].support.touch && this.opts.offCanvas && this.opts.offCanvas.blockUI && (\"boolean\" == typeof s && (s = {\n          fix: s\n        }), \"object\" != _typeof(s) && (s = {}), s = this.opts[n] = e.extend(!0, {}, e[t].defaults[n], s), s.fix && (this.bind(\"open:start\", function () {\n          this.$pnls.children(\".\" + i.opened).scrollTop(0);\n        }), this.bind(\"initMenu:after\", function () {\n          this[\"_initWindow_\" + n]();\n        })));\n      },\n      add: function add() {\n        i = e[t]._c, s = e[t]._d, a = e[t]._e;\n      },\n      clickAnchor: function clickAnchor(e, t) {}\n    }, e[t].defaults[n] = {\n      fix: !0\n    }, e[t].prototype[\"_initWindow_\" + n] = function () {\n      var t = this;\n      o.$docu.off(a.touchmove + \"-\" + n).on(a.touchmove + \"-\" + n, function (e) {\n        o.$html.hasClass(i.opened) && e.preventDefault();\n      });\n      var s = !1;\n      o.$body.off(a.touchstart + \"-\" + n).on(a.touchstart + \"-\" + n, \".\" + i.panels + \"> .\" + i.panel, function (e) {\n        o.$html.hasClass(i.opened) && (s || (s = !0, 0 === e.currentTarget.scrollTop ? e.currentTarget.scrollTop = 1 : e.currentTarget.scrollHeight === e.currentTarget.scrollTop + e.currentTarget.offsetHeight && (e.currentTarget.scrollTop -= 1), s = !1));\n      }).off(a.touchmove + \"-\" + n).on(a.touchmove + \"-\" + n, \".\" + i.panels + \"> .\" + i.panel, function (t) {\n        o.$html.hasClass(i.opened) && e(this)[0].scrollHeight > e(this).innerHeight() && t.stopPropagation();\n      }), o.$wndw.off(a.orientationchange + \"-\" + n).on(a.orientationchange + \"-\" + n, function () {\n        t.$pnls.children(\".\" + i.opened).scrollTop(0).css({\n          \"-webkit-overflow-scrolling\": \"auto\"\n        }).css({\n          \"-webkit-overflow-scrolling\": \"touch\"\n        });\n      });\n    };\n    var i, s, a, o;\n  }(jQuery),\n  /*\n  * jQuery mmenu screenReader add-on\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    var t = \"mmenu\",\n        n = \"screenReader\";\n    e[t].addons[n] = {\n      setup: function setup() {\n        var a = this,\n            r = this.opts[n],\n            l = this.conf[n];\n        o = e[t].glbl, \"boolean\" == typeof r && (r = {\n          aria: r,\n          text: r\n        }), \"object\" != _typeof(r) && (r = {}), r = this.opts[n] = e.extend(!0, {}, e[t].defaults[n], r), r.aria && (this.bind(\"initAddons:after\", function () {\n          this.bind(\"initMenu:after\", function () {\n            this.trigger(\"initMenu:after:sr-aria\");\n          }), this.bind(\"initNavbar:after\", function () {\n            this.trigger(\"initNavbar:after:sr-aria\", arguments[0]);\n          }), this.bind(\"openPanel:start\", function () {\n            this.trigger(\"openPanel:start:sr-aria\", arguments[0]);\n          }), this.bind(\"close:start\", function () {\n            this.trigger(\"close:start:sr-aria\");\n          }), this.bind(\"close:finish\", function () {\n            this.trigger(\"close:finish:sr-aria\");\n          }), this.bind(\"open:start\", function () {\n            this.trigger(\"open:start:sr-aria\");\n          }), this.bind(\"open:finish\", function () {\n            this.trigger(\"open:finish:sr-aria\");\n          });\n        }), this.bind(\"updateListview\", function () {\n          this.$pnls.find(\".\" + i.listview).children().each(function () {\n            a.__sr_aria(e(this), \"hidden\", e(this).is(\".\" + i.hidden));\n          });\n        }), this.bind(\"openPanel:start\", function (e) {\n          var t = this.$menu.find(\".\" + i.panel).not(e).not(e.parents(\".\" + i.panel)),\n              n = e.add(e.find(\".\" + i.vertical + \".\" + i.opened).children(\".\" + i.panel));\n          this.__sr_aria(t, \"hidden\", !0), this.__sr_aria(n, \"hidden\", !1);\n        }), this.bind(\"closePanel\", function (e) {\n          this.__sr_aria(e, \"hidden\", !0);\n        }), this.bind(\"initPanels:after\", function (t) {\n          var n = t.find(\".\" + i.prev + \", .\" + i.next).each(function () {\n            a.__sr_aria(e(this), \"owns\", e(this).attr(\"href\").replace(\"#\", \"\"));\n          });\n\n          this.__sr_aria(n, \"haspopup\", !0);\n        }), this.bind(\"initNavbar:after\", function (e) {\n          var t = e.children(\".\" + i.navbar);\n\n          this.__sr_aria(t, \"hidden\", !e.hasClass(i.hasnavbar));\n        }), r.text && (this.bind(\"initlistview:after\", function (e) {\n          var t = e.find(\".\" + i.listview).find(\".\" + i.fullsubopen).parent().children(\"span\");\n\n          this.__sr_aria(t, \"hidden\", !0);\n        }), \"parent\" == this.opts.navbar.titleLink && this.bind(\"initNavbar:after\", function (e) {\n          var t = e.children(\".\" + i.navbar),\n              n = !!t.children(\".\" + i.prev).length;\n\n          this.__sr_aria(t.children(\".\" + i.title), \"hidden\", n);\n        }))), r.text && (this.bind(\"initAddons:after\", function () {\n          this.bind(\"setPage:after\", function () {\n            this.trigger(\"setPage:after:sr-text\", arguments[0]);\n          });\n        }), this.bind(\"initNavbar:after\", function (n) {\n          var s = n.children(\".\" + i.navbar),\n              a = s.children(\".\" + i.title).text(),\n              o = e[t].i18n(l.text.closeSubmenu);\n          a && (o += \" (\" + a + \")\"), s.children(\".\" + i.prev).html(this.__sr_text(o));\n        }), this.bind(\"initListview:after\", function (n) {\n          var o = n.data(s.parent);\n\n          if (o && o.length) {\n            var r = o.children(\".\" + i.next),\n                d = r.nextAll(\"span, a\").first().text(),\n                c = e[t].i18n(l.text[r.parent().is(\".\" + i.vertical) ? \"toggleSubmenu\" : \"openSubmenu\"]);\n            d && (c += \" (\" + d + \")\"), r.html(a.__sr_text(c));\n          }\n        }));\n      },\n      add: function add() {\n        i = e[t]._c, s = e[t]._d, a = e[t]._e, i.add(\"sronly\");\n      },\n      clickAnchor: function clickAnchor(e, t) {}\n    }, e[t].defaults[n] = {\n      aria: !0,\n      text: !0\n    }, e[t].configuration[n] = {\n      text: {\n        closeMenu: \"Close menu\",\n        closeSubmenu: \"Close submenu\",\n        openSubmenu: \"Open submenu\",\n        toggleSubmenu: \"Toggle submenu\"\n      }\n    }, e[t].prototype.__sr_aria = function (e, t, n) {\n      e.prop(\"aria-\" + t, n)[n ? \"attr\" : \"removeAttr\"](\"aria-\" + t, n);\n    }, e[t].prototype.__sr_text = function (e) {\n      return '<span class=\"' + i.sronly + '\">' + e + \"</span>\";\n    };\n    var i, s, a, o;\n  }(jQuery),\n  /*\n  * jQuery mmenu autoHeight add-on\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    var t = \"mmenu\",\n        n = \"autoHeight\";\n    e[t].addons[n] = {\n      setup: function setup() {\n        var s = this.opts[n];\n        this.conf[n];\n\n        if (o = e[t].glbl, \"boolean\" == typeof s && s && (s = {\n          height: \"auto\"\n        }), \"string\" == typeof s && (s = {\n          height: s\n        }), \"object\" != _typeof(s) && (s = {}), s = this.opts[n] = e.extend(!0, {}, e[t].defaults[n], s), \"auto\" == s.height || \"highest\" == s.height) {\n          this.bind(\"initMenu:after\", function () {\n            this.$menu.addClass(i.autoheight);\n          });\n\n          var a = function a(t) {\n            if (!this.opts.offCanvas || this.vars.opened) {\n              var n = Math.max(parseInt(this.$pnls.css(\"top\"), 10), 0) || 0,\n                  a = Math.max(parseInt(this.$pnls.css(\"bottom\"), 10), 0) || 0,\n                  o = 0;\n              this.$menu.addClass(i.measureheight), \"auto\" == s.height ? (t = t || this.$pnls.children(\".\" + i.opened), t.is(\".\" + i.vertical) && (t = t.parents(\".\" + i.panel).not(\".\" + i.vertical)), t.length || (t = this.$pnls.children(\".\" + i.panel)), o = t.first().outerHeight()) : \"highest\" == s.height && this.$pnls.children().each(function () {\n                var t = e(this);\n                t.is(\".\" + i.vertical) && (t = t.parents(\".\" + i.panel).not(\".\" + i.vertical).first()), o = Math.max(o, t.outerHeight());\n              }), this.$menu.height(o + n + a).removeClass(i.measureheight);\n            }\n          };\n\n          this.opts.offCanvas && this.bind(\"open:start\", a), \"highest\" == s.height && this.bind(\"initPanels:after\", a), \"auto\" == s.height && (this.bind(\"updateListview\", a), this.bind(\"openPanel:start\", a), this.bind(\"closePanel\", a));\n        }\n      },\n      add: function add() {\n        i = e[t]._c, s = e[t]._d, a = e[t]._e, i.add(\"autoheight measureheight\"), a.add(\"resize\");\n      },\n      clickAnchor: function clickAnchor(e, t) {}\n    }, e[t].defaults[n] = {\n      height: \"default\"\n    };\n    var i, s, a, o;\n  }(jQuery),\n  /*\n  * jQuery mmenu backButton add-on\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    var t = \"mmenu\",\n        n = \"backButton\";\n    e[t].addons[n] = {\n      setup: function setup() {\n        if (this.opts.offCanvas) {\n          var s = this,\n              a = this.opts[n];\n          this.conf[n];\n\n          if (o = e[t].glbl, \"boolean\" == typeof a && (a = {\n            close: a\n          }), \"object\" != _typeof(a) && (a = {}), a = e.extend(!0, {}, e[t].defaults[n], a), a.close) {\n            var r = \"#\" + s.$menu.attr(\"id\");\n            this.bind(\"open:finish\", function (e) {\n              location.hash != r && history.pushState(null, document.title, r);\n            }), e(window).on(\"popstate\", function (e) {\n              o.$html.hasClass(i.opened) ? (e.stopPropagation(), s.close()) : location.hash == r && (e.stopPropagation(), s.open());\n            });\n          }\n        }\n      },\n      add: function add() {\n        return window.history && window.history.pushState ? (i = e[t]._c, s = e[t]._d, void (a = e[t]._e)) : void (e[t].addons[n].setup = function () {});\n      },\n      clickAnchor: function clickAnchor(e, t) {}\n    }, e[t].defaults[n] = {\n      close: !1\n    };\n    var i, s, a, o;\n  }(jQuery),\n  /*\n  * jQuery mmenu counters add-on\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    var t = \"mmenu\",\n        n = \"counters\";\n    e[t].addons[n] = {\n      setup: function setup() {\n        var a = this,\n            r = this.opts[n];\n        this.conf[n];\n\n        if (o = e[t].glbl, \"boolean\" == typeof r && (r = {\n          add: r,\n          update: r\n        }), \"object\" != _typeof(r) && (r = {}), r = this.opts[n] = e.extend(!0, {}, e[t].defaults[n], r), this.bind(\"initListview:after\", function (t) {\n          this.__refactorClass(e(\"em\", t), this.conf.classNames[n].counter, \"counter\");\n        }), r.add && this.bind(\"initListview:after\", function (t) {\n          var n;\n\n          switch (r.addTo) {\n            case \"panels\":\n              n = t;\n              break;\n\n            default:\n              n = t.filter(r.addTo);\n          }\n\n          n.each(function () {\n            var t = e(this).data(s.parent);\n            t && (t.children(\"em.\" + i.counter).length || t.prepend(e('<em class=\"' + i.counter + '\" />')));\n          });\n        }), r.update) {\n          var l = function l(t) {\n            t = t || this.$pnls.children(\".\" + i.panel), t.each(function () {\n              var t = e(this),\n                  n = t.data(s.parent);\n\n              if (n) {\n                var o = n.children(\"em.\" + i.counter);\n                o.length && (t = t.children(\".\" + i.listview), t.length && o.html(a.__filterListItems(t.children()).length));\n              }\n            });\n          };\n\n          this.bind(\"initListview:after\", l), this.bind(\"updateListview\", l);\n        }\n      },\n      add: function add() {\n        i = e[t]._c, s = e[t]._d, a = e[t]._e, i.add(\"counter search noresultsmsg\");\n      },\n      clickAnchor: function clickAnchor(e, t) {}\n    }, e[t].defaults[n] = {\n      add: !1,\n      addTo: \"panels\",\n      count: !1\n    }, e[t].configuration.classNames[n] = {\n      counter: \"Counter\"\n    };\n    var i, s, a, o;\n  }(jQuery),\n  /*\n  * jQuery mmenu columns add-on\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    var t = \"mmenu\",\n        n = \"columns\";\n    e[t].addons[n] = {\n      setup: function setup() {\n        var s = this.opts[n];\n        this.conf[n];\n\n        if (o = e[t].glbl, \"boolean\" == typeof s && (s = {\n          add: s\n        }), \"number\" == typeof s && (s = {\n          add: !0,\n          visible: s\n        }), \"object\" != _typeof(s) && (s = {}), \"number\" == typeof s.visible && (s.visible = {\n          min: s.visible,\n          max: s.visible\n        }), s = this.opts[n] = e.extend(!0, {}, e[t].defaults[n], s), s.add) {\n          s.visible.min = Math.max(1, Math.min(6, s.visible.min)), s.visible.max = Math.max(s.visible.min, Math.min(6, s.visible.max));\n\n          for (var a = this.opts.offCanvas ? this.$menu.add(o.$html) : this.$menu, r = \"\", l = 0; l <= s.visible.max; l++) {\n            r += \" \" + i.columns + \"-\" + l;\n          }\n\n          r.length && (r = r.slice(1));\n\n          var d = function d(e) {\n            var t = this.$pnls.children(\".\" + i.subopened).length;\n            e && !e.hasClass(i.subopened) && t++, t = Math.min(s.visible.max, Math.max(s.visible.min, t)), a.removeClass(r).addClass(i.columns + \"-\" + t);\n          },\n              c = function c(t) {\n            t = t || this.$pnls.children(\".\" + i.opened), this.$pnls.children(\".\" + i.panel).removeClass(r).filter(\".\" + i.subopened).add(t).slice(-s.visible.max).each(function (t) {\n              e(this).addClass(i.columns + \"-\" + t);\n            });\n          };\n\n          this.bind(\"initMenu:after\", function () {\n            this.$menu.addClass(i.columns);\n          }), this.bind(\"openPanel:start\", d), this.bind(\"openPanel:start\", c);\n        }\n      },\n      add: function add() {\n        i = e[t]._c, s = e[t]._d, a = e[t]._e, i.add(\"columns\");\n      },\n      clickAnchor: function clickAnchor(t, s) {\n        if (!this.opts[n].add) return !1;\n\n        if (s) {\n          var a = t.attr(\"href\");\n          if (a.length > 1 && \"#\" == a.slice(0, 1)) try {\n            var o = e(a, this.$menu);\n            if (o.is(\".\" + i.panel)) for (var r = parseInt(t.closest(\".\" + i.panel).attr(\"class\").split(i.columns + \"-\")[1].split(\" \")[0], 10) + 1; r > 0;) {\n              var l = this.$pnls.children(\".\" + i.columns + \"-\" + r);\n\n              if (!l.length) {\n                r = -1;\n                break;\n              }\n\n              r++, l.removeClass(i.subopened).removeClass(i.opened).removeClass(i.highest).addClass(i.hidden);\n            }\n          } catch (d) {}\n        }\n      }\n    }, e[t].defaults[n] = {\n      add: !1,\n      visible: {\n        min: 1,\n        max: 3\n      }\n    };\n    var i, s, a, o;\n  }(jQuery),\n  /*\n  * jQuery mmenu dividers add-on\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    var t = \"mmenu\",\n        n = \"dividers\";\n    e[t].addons[n] = {\n      setup: function setup() {\n        var s = this,\n            r = this.opts[n];\n        this.conf[n];\n\n        if (o = e[t].glbl, \"boolean\" == typeof r && (r = {\n          add: r,\n          fixed: r\n        }), \"object\" != _typeof(r) && (r = {}), r = this.opts[n] = e.extend(!0, {}, e[t].defaults[n], r), this.bind(\"initListview:after\", function (e) {\n          this.__refactorClass(e.find(\"li\"), this.conf.classNames[n].collapsed, \"collapsed\");\n        }), r.add && this.bind(\"initListview:after\", function (t) {\n          var n;\n\n          switch (r.addTo) {\n            case \"panels\":\n              n = t;\n              break;\n\n            default:\n              n = t.filter(r.addTo);\n          }\n\n          n.length && n.find(\".\" + i.listview).find(\".\" + i.divider).remove().end().each(function () {\n            var t = \"\";\n\n            s.__filterListItems(e(this).children()).each(function () {\n              var n = e.trim(e(this).children(\"a, span\").text()).slice(0, 1).toLowerCase();\n              n != t && n.length && (t = n, e('<li class=\"' + i.divider + '\">' + n + \"</li>\").insertBefore(this));\n            });\n          });\n        }), r.collapse && this.bind(\"initListview:after\", function (t) {\n          t.find(\".\" + i.divider).each(function () {\n            var t = e(this),\n                n = t.nextUntil(\".\" + i.divider, \".\" + i.collapsed);\n            n.length && (t.children(\".\" + i.next).length || (t.wrapInner(\"<span />\"), t.prepend('<a href=\"#\" class=\"' + i.next + \" \" + i.fullsubopen + '\" />')));\n          });\n        }), r.fixed) {\n          this.bind(\"initPanels:after\", function () {\n            \"undefined\" == typeof this.$fixeddivider && (this.$fixeddivider = e('<ul class=\"' + i.listview + \" \" + i.fixeddivider + '\"><li class=\"' + i.divider + '\"></li></ul>').prependTo(this.$pnls).children());\n          });\n\n          var l = function l(t) {\n            if (t = t || this.$pnls.children(\".\" + i.opened), !t.is(\":hidden\")) {\n              var n = t.children(\".\" + i.listview).children(\".\" + i.divider).not(\".\" + i.hidden),\n                  s = t.scrollTop() || 0,\n                  a = \"\";\n              n.each(function () {\n                e(this).position().top + s < s + 1 && (a = e(this).text());\n              }), this.$fixeddivider.text(a), this.$pnls[a.length ? \"addClass\" : \"removeClass\"](i.hasdividers);\n            }\n          };\n\n          this.bind(\"open:start\", l), this.bind(\"openPanel:start\", l), this.bind(\"updateListview\", l), this.bind(\"initPanel:after\", function (e) {\n            e.off(a.scroll + \"-\" + n + \" \" + a.touchmove + \"-\" + n).on(a.scroll + \"-\" + n + \" \" + a.touchmove + \"-\" + n, function (t) {\n              l.call(s, e);\n            });\n          });\n        }\n      },\n      add: function add() {\n        i = e[t]._c, s = e[t]._d, a = e[t]._e, i.add(\"collapsed uncollapsed fixeddivider hasdividers\"), a.add(\"scroll\");\n      },\n      clickAnchor: function clickAnchor(e, t) {\n        if (this.opts[n].collapse && t) {\n          var s = e.parent();\n\n          if (s.is(\".\" + i.divider)) {\n            var a = s.nextUntil(\".\" + i.divider, \".\" + i.collapsed);\n            return s.toggleClass(i.opened), a[s.hasClass(i.opened) ? \"addClass\" : \"removeClass\"](i.uncollapsed), !0;\n          }\n        }\n\n        return !1;\n      }\n    }, e[t].defaults[n] = {\n      add: !1,\n      addTo: \"panels\",\n      fixed: !1,\n      collapse: !1\n    }, e[t].configuration.classNames[n] = {\n      collapsed: \"Collapsed\"\n    };\n    var i, s, a, o;\n  }(jQuery),\n  /*\n  * jQuery mmenu drag add-on\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    function t(e, t, n) {\n      return e < t && (e = t), e > n && (e = n), e;\n    }\n\n    function n(n, i, s) {\n      var r,\n          l,\n          d,\n          c = this,\n          h = {\n        events: \"panleft panright\",\n        typeLower: \"x\",\n        typeUpper: \"X\",\n        open_dir: \"right\",\n        close_dir: \"left\",\n        negative: !1\n      },\n          f = \"width\",\n          u = h.open_dir,\n          p = function p(e) {\n        e <= n.maxStartPos && (m = 1);\n      },\n          v = function v() {\n        return e(\".\" + o.slideout);\n      },\n          m = 0,\n          b = 0,\n          g = 0;\n\n      switch (this.opts.offCanvas.position) {\n        case \"top\":\n        case \"bottom\":\n          h.events = \"panup pandown\", h.typeLower = \"y\", h.typeUpper = \"Y\", f = \"height\";\n      }\n\n      switch (this.opts.offCanvas.position) {\n        case \"right\":\n        case \"bottom\":\n          h.negative = !0, p = function p(e) {\n            e >= s.$wndw[f]() - n.maxStartPos && (m = 1);\n          };\n      }\n\n      switch (this.opts.offCanvas.position) {\n        case \"left\":\n          break;\n\n        case \"right\":\n          h.open_dir = \"left\", h.close_dir = \"right\";\n          break;\n\n        case \"top\":\n          h.open_dir = \"down\", h.close_dir = \"up\";\n          break;\n\n        case \"bottom\":\n          h.open_dir = \"up\", h.close_dir = \"down\";\n      }\n\n      switch (this.opts.offCanvas.zposition) {\n        case \"front\":\n          v = function v() {\n            return this.$menu;\n          };\n\n      }\n\n      var _ = this.__valueOrFn(n.node, this.$menu, s.$page);\n\n      \"string\" == typeof _ && (_ = e(_));\n      var y = new Hammer(_[0], this.opts[a].vendors.hammer);\n      y.on(\"panstart\", function (e) {\n        p(e.center[h.typeLower]), s.$slideOutNodes = v(), u = h.open_dir;\n      }), y.on(h.events + \" panend\", function (e) {\n        m > 0 && e.preventDefault();\n      }), y.on(h.events, function (e) {\n        if (r = e[\"delta\" + h.typeUpper], h.negative && (r = -r), r != b && (u = r >= b ? h.open_dir : h.close_dir), b = r, b > n.threshold && 1 == m) {\n          if (s.$html.hasClass(o.opened)) return;\n          m = 2, c._openSetup(), c.trigger(\"open:start\"), s.$html.addClass(o.dragging), g = t(s.$wndw[f]() * i[f].perc, i[f].min, i[f].max);\n        }\n\n        2 == m && (l = t(b, 10, g) - (\"front\" == c.opts.offCanvas.zposition ? g : 0), h.negative && (l = -l), d = \"translate\" + h.typeUpper + \"(\" + l + \"px )\", s.$slideOutNodes.css({\n          \"-webkit-transform\": \"-webkit-\" + d,\n          transform: d\n        }));\n      }), y.on(\"panend\", function (e) {\n        2 == m && (s.$html.removeClass(o.dragging), s.$slideOutNodes.css(\"transform\", \"\"), c[u == h.open_dir ? \"_openFinish\" : \"close\"]()), m = 0;\n      });\n    }\n\n    function i(e, t, n, i) {\n      var s = this,\n          l = e.data(r.parent);\n\n      if (l) {\n        l = l.closest(\".\" + o.panel);\n        var d = new Hammer(e[0], s.opts[a].vendors.hammer),\n            c = null;\n        d.on(\"panright\", function (e) {\n          c || (s.openPanel(l), c = setTimeout(function () {\n            clearTimeout(c), c = null;\n          }, s.conf.openingInterval + s.conf.transitionDuration));\n        });\n      }\n    }\n\n    var s = \"mmenu\",\n        a = \"drag\";\n    e[s].addons[a] = {\n      setup: function setup() {\n        if (this.opts.offCanvas) {\n          var t = this.opts[a],\n              o = this.conf[a];\n          d = e[s].glbl, \"boolean\" == typeof t && (t = {\n            menu: t,\n            panels: t\n          }), \"object\" != _typeof(t) && (t = {}), \"boolean\" == typeof t.menu && (t.menu = {\n            open: t.menu\n          }), \"object\" != _typeof(t.menu) && (t.menu = {}), \"boolean\" == typeof t.panels && (t.panels = {\n            close: t.panels\n          }), \"object\" != _typeof(t.panels) && (t.panels = {}), t = this.opts[a] = e.extend(!0, {}, e[s].defaults[a], t), t.menu.open && this.bind(\"setPage:after\", function () {\n            n.call(this, t.menu, o.menu, d);\n          }), t.panels.close && this.bind(\"initPanel:after\", function (e) {\n            i.call(this, e, t.panels, o.panels, d);\n          });\n        }\n      },\n      add: function add() {\n        return \"function\" != typeof Hammer || Hammer.VERSION < 2 ? (e[s].addons[a].add = function () {}, void (e[s].addons[a].setup = function () {})) : (o = e[s]._c, r = e[s]._d, l = e[s]._e, void o.add(\"dragging\"));\n      },\n      clickAnchor: function clickAnchor(e, t) {}\n    }, e[s].defaults[a] = {\n      menu: {\n        open: !1,\n        maxStartPos: 100,\n        threshold: 50\n      },\n      panels: {\n        close: !1\n      },\n      vendors: {\n        hammer: {}\n      }\n    }, e[s].configuration[a] = {\n      menu: {\n        width: {\n          perc: .8,\n          min: 140,\n          max: 440\n        },\n        height: {\n          perc: .8,\n          min: 140,\n          max: 880\n        }\n      },\n      panels: {}\n    };\n    var o, r, l, d;\n  }(jQuery),\n  /*\n  * jQuery mmenu dropdown add-on\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    var t = \"mmenu\",\n        n = \"dropdown\";\n    e[t].addons[n] = {\n      setup: function setup() {\n        if (this.opts.offCanvas) {\n          var r = this,\n              l = this.opts[n],\n              d = this.conf[n];\n\n          if (o = e[t].glbl, \"boolean\" == typeof l && l && (l = {\n            drop: l\n          }), \"object\" != _typeof(l) && (l = {}), \"string\" == typeof l.position && (l.position = {\n            of: l.position\n          }), l = this.opts[n] = e.extend(!0, {}, e[t].defaults[n], l), l.drop) {\n            var c;\n            this.bind(\"initMenu:after\", function () {\n              if (this.$menu.addClass(i.dropdown), l.tip && this.$menu.addClass(i.tip), \"string\" != typeof l.position.of) {\n                var t = this._getOriginalMenuId();\n\n                t && t.length && (l.position.of = '[href=\"#' + t + '\"]');\n              }\n\n              \"string\" == typeof l.position.of && (c = e(l.position.of), l.event = l.event.split(\" \"), 1 == l.event.length && (l.event[1] = l.event[0]), \"hover\" == l.event[0] && c.on(a.mouseenter + \"-\" + n, function () {\n                r.open();\n              }), \"hover\" == l.event[1] && this.$menu.on(a.mouseleave + \"-\" + n, function () {\n                r.close();\n              }));\n            }), this.bind(\"open:start\", function () {\n              this.$menu.data(s.style, this.$menu.attr(\"style\") || \"\"), o.$html.addClass(i.dropdown);\n            }), this.bind(\"close:finish\", function () {\n              this.$menu.attr(\"style\", this.$menu.data(s.style)), o.$html.removeClass(i.dropdown);\n            });\n\n            var h = function h(e, t) {\n              var n = t[0],\n                  s = t[1],\n                  a = \"x\" == e ? \"scrollLeft\" : \"scrollTop\",\n                  r = \"x\" == e ? \"outerWidth\" : \"outerHeight\",\n                  h = \"x\" == e ? \"left\" : \"top\",\n                  f = \"x\" == e ? \"right\" : \"bottom\",\n                  u = \"x\" == e ? \"width\" : \"height\",\n                  p = \"x\" == e ? \"maxWidth\" : \"maxHeight\",\n                  v = null,\n                  m = o.$wndw[a](),\n                  b = c.offset()[h] -= m,\n                  g = b + c[r](),\n                  _ = o.$wndw[u](),\n                  y = d.offset.button[e] + d.offset.viewport[e];\n\n              if (l.position[e]) switch (l.position[e]) {\n                case \"left\":\n                case \"bottom\":\n                  v = \"after\";\n                  break;\n\n                case \"right\":\n                case \"top\":\n                  v = \"before\";\n              }\n              null === v && (v = b + (g - b) / 2 < _ / 2 ? \"after\" : \"before\");\n              var C, w;\n              return \"after\" == v ? (C = \"x\" == e ? b : g, w = _ - (C + y), n[h] = C + d.offset.button[e], n[f] = \"auto\", s.push(i[\"x\" == e ? \"tipleft\" : \"tiptop\"])) : (C = \"x\" == e ? g : b, w = C - y, n[f] = \"calc( 100% - \" + (C - d.offset.button[e]) + \"px )\", n[h] = \"auto\", s.push(i[\"x\" == e ? \"tipright\" : \"tipbottom\"])), n[p] = Math.min(d[u].max, w), [n, s];\n            },\n                f = function f(e) {\n              if (this.vars.opened) {\n                this.$menu.attr(\"style\", this.$menu.data(s.style));\n                var t = [{}, []];\n                t = h.call(this, \"y\", t), t = h.call(this, \"x\", t), this.$menu.css(t[0]), l.tip && this.$menu.removeClass(i.tipleft + \" \" + i.tipright + \" \" + i.tiptop + \" \" + i.tipbottom).addClass(t[1].join(\" \"));\n              }\n            };\n\n            this.bind(\"open:start\", f), o.$wndw.on(a.resize + \"-\" + n, function (e) {\n              f.call(r);\n            }), this.opts.offCanvas.blockUI || o.$wndw.on(a.scroll + \"-\" + n, function (e) {\n              f.call(r);\n            });\n          }\n        }\n      },\n      add: function add() {\n        i = e[t]._c, s = e[t]._d, a = e[t]._e, i.add(\"dropdown tip tipleft tipright tiptop tipbottom\"), a.add(\"mouseenter mouseleave resize scroll\");\n      },\n      clickAnchor: function clickAnchor(e, t) {}\n    }, e[t].defaults[n] = {\n      drop: !1,\n      event: \"click\",\n      position: {},\n      tip: !0\n    }, e[t].configuration[n] = {\n      offset: {\n        button: {\n          x: -10,\n          y: 10\n        },\n        viewport: {\n          x: 20,\n          y: 20\n        }\n      },\n      height: {\n        max: 880\n      },\n      width: {\n        max: 440\n      }\n    };\n    var i, s, a, o;\n  }(jQuery),\n  /*\n  * jQuery mmenu fixedElements add-on\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    var t = \"mmenu\",\n        n = \"fixedElements\";\n    e[t].addons[n] = {\n      setup: function setup() {\n        if (this.opts.offCanvas) {\n          var s = (this.opts[n], this.conf[n]);\n          o = e[t].glbl;\n\n          var a = function a(t) {\n            var a = this.conf.classNames[n].fixed,\n                r = t.find(\".\" + a);\n            this.__refactorClass(r, a, \"slideout\"), r[s.elemInsertMethod](s.elemInsertSelector);\n            var l = this.conf.classNames[n].sticky,\n                d = t.find(\".\" + l);\n            this.__refactorClass(d, l, \"sticky\"), d = t.find(\".\" + i.sticky), d.length && (this.bind(\"open:before\", function () {\n              var t = o.$wndw.scrollTop() + s.sticky.offset;\n              d.each(function () {\n                e(this).css(\"top\", parseInt(e(this).css(\"top\"), 10) + t);\n              });\n            }), this.bind(\"close:finish\", function () {\n              d.css(\"top\", \"\");\n            }));\n          };\n\n          this.bind(\"setPage:after\", a);\n        }\n      },\n      add: function add() {\n        i = e[t]._c, s = e[t]._d, a = e[t]._e, i.add(\"sticky\");\n      },\n      clickAnchor: function clickAnchor(e, t) {}\n    }, e[t].configuration[n] = {\n      sticky: {\n        offset: 0\n      },\n      elemInsertMethod: \"appendTo\",\n      elemInsertSelector: \"body\"\n    }, e[t].configuration.classNames[n] = {\n      fixed: \"Fixed\",\n      sticky: \"Sticky\"\n    };\n    var i, s, a, o;\n  }(jQuery),\n  /*\n  * jQuery mmenu iconPanels add-on\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    var t = \"mmenu\",\n        n = \"iconPanels\";\n    e[t].addons[n] = {\n      setup: function setup() {\n        var s = this,\n            a = this.opts[n];\n        this.conf[n];\n\n        if (o = e[t].glbl, \"boolean\" == typeof a && (a = {\n          add: a\n        }), \"number\" == typeof a && (a = {\n          add: !0,\n          visible: a\n        }), \"object\" != _typeof(a) && (a = {}), a = this.opts[n] = e.extend(!0, {}, e[t].defaults[n], a), a.visible++, a.add) {\n          for (var r = \"\", l = 0; l <= a.visible; l++) {\n            r += \" \" + i.iconpanel + \"-\" + l;\n          }\n\n          r.length && (r = r.slice(1));\n\n          var d = function d(t) {\n            t.hasClass(i.vertical) || s.$pnls.children(\".\" + i.panel).removeClass(r).filter(\".\" + i.subopened).removeClass(i.hidden).add(t).not(\".\" + i.vertical).slice(-a.visible).each(function (t) {\n              e(this).addClass(i.iconpanel + \"-\" + t);\n            });\n          };\n\n          this.bind(\"initMenu:after\", function () {\n            this.$menu.addClass(i.iconpanel);\n          }), this.bind(\"openPanel:start\", d), this.bind(\"initPanels:after\", function (e) {\n            d.call(s, s.$pnls.children(\".\" + i.opened));\n          }), this.bind(\"initListview:after\", function (e) {\n            e.hasClass(i.vertical) || e.children(\".\" + i.subblocker).length || e.prepend('<a href=\"#' + e.closest(\".\" + i.panel).attr(\"id\") + '\" class=\"' + i.subblocker + '\" />');\n          });\n        }\n      },\n      add: function add() {\n        i = e[t]._c, s = e[t]._d, a = e[t]._e, i.add(\"iconpanel subblocker\");\n      },\n      clickAnchor: function clickAnchor(e, t) {}\n    }, e[t].defaults[n] = {\n      add: !1,\n      visible: 3\n    };\n    var i, s, a, o;\n  }(jQuery),\n  /*\n  * jQuery mmenu keyboardNavigation add-on\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    function t(t, n) {\n      t = t || this.$pnls.children(\".\" + a.opened);\n      var i = e(),\n          s = this.$menu.children(\".\" + a.mm(\"navbars-top\") + \", .\" + a.mm(\"navbars-bottom\")).children(\".\" + a.navbar);\n      s.find(d).filter(\":focus\").length || (\"default\" == n && (i = t.children(\".\" + a.listview).find(\"a[href]\").not(\".\" + a.hidden), i.length || (i = t.find(d).not(\".\" + a.hidden)), i.length || (i = s.find(d).not(\".\" + a.hidden))), i.length || (i = this.$menu.children(\".\" + a.tabstart)), i.first().focus());\n    }\n\n    function n(e) {\n      e || (e = this.$pnls.children(\".\" + a.opened));\n      var t = this.$pnls.children(\".\" + a.panel),\n          n = t.not(e);\n      n.find(d).attr(\"tabindex\", -1), e.find(d).attr(\"tabindex\", 0), e.find(\".\" + a.mm(\"toggle\") + \", .\" + a.mm(\"check\")).attr(\"tabindex\", -1), e.children(\".\" + a.navbar).children(\".\" + a.title).attr(\"tabindex\", -1);\n    }\n\n    var i = \"mmenu\",\n        s = \"keyboardNavigation\";\n    e[i].addons[s] = {\n      setup: function setup() {\n        if (!e[i].support.touch) {\n          var o = this.opts[s];\n          this.conf[s];\n\n          if (l = e[i].glbl, \"boolean\" != typeof o && \"string\" != typeof o || (o = {\n            enable: o\n          }), \"object\" != _typeof(o) && (o = {}), o = this.opts[s] = e.extend(!0, {}, e[i].defaults[s], o), o.enable) {\n            var r = e('<button class=\"' + a.tabstart + '\" tabindex=\"0\" type=\"button\" />'),\n                d = e('<button class=\"' + a.tabend + '\" tabindex=\"0\" type=\"button\" />');\n            this.bind(\"initMenu:after\", function () {\n              o.enhance && this.$menu.addClass(a.keyboardfocus), this[\"_initWindow_\" + s](o.enhance);\n            }), this.bind(\"initOpened:before\", function () {\n              this.$menu.prepend(r).append(d).children(\".\" + a.mm(\"navbars-top\") + \", .\" + a.mm(\"navbars-bottom\")).children(\".\" + a.navbar).children(\"a.\" + a.title).attr(\"tabindex\", -1);\n            }), this.bind(\"open:start\", function () {\n              n.call(this);\n            }), this.bind(\"open:finish\", function () {\n              t.call(this, null, o.enable);\n            }), this.bind(\"openPanel:start\", function (e) {\n              n.call(this, e);\n            }), this.bind(\"openPanel:finish\", function (e) {\n              t.call(this, e, o.enable);\n            }), this.bind(\"initOpened:after\", function () {\n              this.__sr_aria(this.$menu.children(\".\" + a.mm(\"tabstart\") + \", .\" + a.mm(\"tabend\")), \"hidden\", !0);\n            });\n          }\n        }\n      },\n      add: function add() {\n        a = e[i]._c, o = e[i]._d, r = e[i]._e, a.add(\"tabstart tabend keyboardfocus\"), r.add(\"focusin keydown\");\n      },\n      clickAnchor: function clickAnchor(e, t) {}\n    }, e[i].defaults[s] = {\n      enable: !1,\n      enhance: !1\n    }, e[i].configuration[s] = {}, e[i].prototype[\"_initWindow_\" + s] = function (t) {\n      l.$wndw.off(r.keydown + \"-offCanvas\"), l.$wndw.off(r.focusin + \"-\" + s).on(r.focusin + \"-\" + s, function (t) {\n        if (l.$html.hasClass(a.opened)) {\n          var n = e(t.target);\n          n.is(\".\" + a.tabend) && n.parent().find(\".\" + a.tabstart).focus();\n        }\n      }), l.$wndw.off(r.keydown + \"-\" + s).on(r.keydown + \"-\" + s, function (t) {\n        var n = e(t.target),\n            i = n.closest(\".\" + a.menu);\n\n        if (i.length) {\n          i.data(\"mmenu\");\n          if (n.is(\"input, textarea\")) ;else switch (t.keyCode) {\n            case 13:\n              (n.is(\".mm-toggle\") || n.is(\".mm-check\")) && n.trigger(r.click);\n              break;\n\n            case 32:\n            case 37:\n            case 38:\n            case 39:\n            case 40:\n              t.preventDefault();\n          }\n        }\n      }), t && l.$wndw.off(r.keydown + \"-\" + s).on(r.keydown + \"-\" + s, function (t) {\n        var n = e(t.target),\n            i = n.closest(\".\" + a.menu);\n\n        if (i.length) {\n          var s = i.data(\"mmenu\");\n          if (n.is(\"input, textarea\")) switch (t.keyCode) {\n            case 27:\n              n.val(\"\");\n          } else switch (t.keyCode) {\n            case 8:\n              var r = n.closest(\".\" + a.panel).data(o.parent);\n              r && r.length && s.openPanel(r.closest(\".\" + a.panel));\n              break;\n\n            case 27:\n              i.hasClass(a.offcanvas) && s.close();\n          }\n        }\n      });\n    };\n    var a,\n        o,\n        r,\n        l,\n        d = \"input, select, textarea, button, label, a[href]\";\n  }(jQuery),\n  /*\n  * jQuery mmenu lazySubmenus add-on\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    var t = \"mmenu\",\n        n = \"lazySubmenus\";\n    e[t].addons[n] = {\n      setup: function setup() {\n        var s = this.opts[n];\n        this.conf[n];\n        o = e[t].glbl, \"boolean\" == typeof s && (s = {\n          load: s\n        }), \"object\" != _typeof(s) && (s = {}), s = this.opts[n] = e.extend(!0, {}, e[t].defaults[n], s), s.load && (this.bind(\"initMenu:after\", function () {\n          this.$pnls.find(\"li\").children(this.conf.panelNodetype).not(\".\" + i.inset).not(\".\" + i.nolistview).not(\".\" + i.nopanel).addClass(i.lazysubmenu + \" \" + i.nolistview + \" \" + i.nopanel);\n        }), this.bind(\"initPanels:before\", function (e) {\n          e = e || this.$pnls.children(this.conf.panelNodetype), this.__findAddBack(e, \".\" + i.lazysubmenu).not(\".\" + i.lazysubmenu + \" .\" + i.lazysubmenu).removeClass(i.lazysubmenu + \" \" + i.nolistview + \" \" + i.nopanel);\n        }), this.bind(\"initOpened:before\", function () {\n          var e = this.$pnls.find(\".\" + this.conf.classNames.selected).parents(\".\" + i.lazysubmenu);\n          e.length && (e.removeClass(i.lazysubmenu + \" \" + i.nolistview + \" \" + i.nopanel), this.initPanels(e.last()));\n        }), this.bind(\"openPanel:before\", function (e) {\n          var t = this.__findAddBack(e, \".\" + i.lazysubmenu).not(\".\" + i.lazysubmenu + \" .\" + i.lazysubmenu);\n\n          t.length && this.initPanels(t);\n        }));\n      },\n      add: function add() {\n        i = e[t]._c, s = e[t]._d, a = e[t]._e, i.add(\"lazysubmenu\"), s.add(\"lazysubmenu\");\n      },\n      clickAnchor: function clickAnchor(e, t) {}\n    }, e[t].defaults[n] = {\n      load: !1\n    }, e[t].configuration[n] = {};\n    var i, s, a, o;\n  }(jQuery),\n  /*\n  * jQuery mmenu navbar add-on\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    var t = \"mmenu\",\n        n = \"navbars\";\n    e[t].addons[n] = {\n      setup: function setup() {\n        var s = this,\n            a = this.opts[n],\n            r = this.conf[n];\n\n        if (o = e[t].glbl, \"undefined\" != typeof a) {\n          a instanceof Array || (a = [a]);\n          var l = {},\n              d = {};\n          a.length && (e.each(a, function (o) {\n            var c = a[o];\n            \"boolean\" == typeof c && c && (c = {}), \"object\" != _typeof(c) && (c = {}), \"undefined\" == typeof c.content && (c.content = [\"prev\", \"title\"]), c.content instanceof Array || (c.content = [c.content]), c = e.extend(!0, {}, s.opts.navbar, c);\n            var h = e('<div class=\"' + i.navbar + '\" />'),\n                f = c.height;\n            \"number\" != typeof f && (f = 1), f = Math.min(4, Math.max(1, f)), h.addClass(i.navbar + \"-size-\" + f);\n            var u = c.position;\n            \"bottom\" != u && (u = \"top\"), l[u] || (l[u] = 0), l[u] += f, d[u] || (d[u] = e('<div class=\"' + i.navbars + \"-\" + u + '\" />')), d[u].append(h);\n\n            for (var p = 0, v = 0, m = c.content.length; v < m; v++) {\n              var b = e[t].addons[n][c.content[v]] || !1;\n              b ? p += b.call(s, h, c, r) : (b = c.content[v], b instanceof e || (b = e(c.content[v])), h.append(b));\n            }\n\n            p += Math.ceil(h.children().not(\".\" + i.btn).length / f), p > 1 && h.addClass(i.navbar + \"-content-\" + p), h.children(\".\" + i.btn).length && h.addClass(i.hasbtns);\n          }), this.bind(\"initMenu:after\", function () {\n            for (var e in l) {\n              this.$menu.addClass(i.hasnavbar + \"-\" + e + \"-\" + l[e]), this.$menu[\"bottom\" == e ? \"append\" : \"prepend\"](d[e]);\n            }\n          }));\n        }\n      },\n      add: function add() {\n        i = e[t]._c, s = e[t]._d, a = e[t]._e, i.add(\"navbars close hasbtns\");\n      },\n      clickAnchor: function clickAnchor(e, t) {}\n    }, e[t].configuration[n] = {\n      breadcrumbSeparator: \"/\"\n    }, e[t].configuration.classNames[n] = {};\n    var i, s, a, o;\n  }(jQuery),\n  /*\n  * jQuery mmenu navbar add-on breadcrumbs content\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    var t = \"mmenu\",\n        n = \"navbars\",\n        i = \"breadcrumbs\";\n\n    e[t].addons[n][i] = function (n, i, s) {\n      var a = this,\n          o = e[t]._c,\n          r = e[t]._d;\n      o.add(\"breadcrumbs separator\");\n      var l = e('<span class=\"' + o.breadcrumbs + '\" />').appendTo(n);\n      return this.bind(\"initNavbar:after\", function (t) {\n        t.removeClass(o.hasnavbar);\n\n        for (var n = [], i = e('<span class=\"' + o.breadcrumbs + '\"></span>'), a = t, l = !0; a && a.length;) {\n          if (a.is(\".\" + o.panel) || (a = a.closest(\".\" + o.panel)), !a.hasClass(o.vertical)) {\n            var d = a.children(\".\" + o.navbar).children(\".\" + o.title).text();\n            n.unshift(l ? \"<span>\" + d + \"</span>\" : '<a href=\"#' + a.attr(\"id\") + '\">' + d + \"</a>\"), l = !1;\n          }\n\n          a = a.data(r.parent);\n        }\n\n        i.append(n.join('<span class=\"' + o.separator + '\">' + s.breadcrumbSeparator + \"</span>\")).appendTo(t.children(\".\" + o.navbar));\n      }), this.bind(\"openPanel:start\", function (e) {\n        l.html(e.children(\".\" + o.navbar).children(\".\" + o.breadcrumbs).html() || \"\");\n      }), this.bind(\"initNavbar:after:sr-aria\", function (t) {\n        t.children(\".\" + o.navbar).children(\".\" + o.breadcrumbs).children(\"a\").each(function () {\n          a.__sr_aria(e(this), \"owns\", e(this).attr(\"href\").slice(1));\n        });\n      }), 0;\n    };\n  }(jQuery),\n  /*\n  * jQuery mmenu navbar add-on close content\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    var t = \"mmenu\",\n        n = \"navbars\",\n        i = \"close\";\n\n    e[t].addons[n][i] = function (n, i) {\n      var s = e[t]._c,\n          a = (e[t].glbl, e('<a class=\"' + s.close + \" \" + s.btn + '\" href=\"#\" />').appendTo(n));\n      return this.bind(\"setPage:after\", function (e) {\n        a.attr(\"href\", \"#\" + e.attr(\"id\"));\n      }), this.bind(\"setPage:after:sr-text\", function (n) {\n        a.html(this.__sr_text(e[t].i18n(this.conf.screenReader.text.closeMenu))), this.__sr_aria(a, \"owns\", a.attr(\"href\").slice(1));\n      }), -1;\n    };\n  }(jQuery),\n  /*\n  * jQuery mmenu navbar add-on next content\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    var t = \"mmenu\",\n        n = \"navbars\",\n        i = \"next\";\n    e[t].addons[n][i] = function (i, s) {\n      var a,\n          o,\n          r,\n          l = e[t]._c,\n          d = e('<a class=\"' + l.next + \" \" + l.btn + '\" href=\"#\" />').appendTo(i);\n      return this.bind(\"openPanel:start\", function (e) {\n        a = e.find(\".\" + this.conf.classNames[n].panelNext), o = a.attr(\"href\"), r = a.html(), o ? d.attr(\"href\", o) : d.removeAttr(\"href\"), d[o || r ? \"removeClass\" : \"addClass\"](l.hidden), d.html(r);\n      }), this.bind(\"openPanel:start:sr-aria\", function (e) {\n        this.__sr_aria(d, \"hidden\", d.hasClass(l.hidden)), this.__sr_aria(d, \"owns\", (d.attr(\"href\") || \"\").slice(1));\n      }), -1;\n    }, e[t].configuration.classNames[n].panelNext = \"Next\";\n  }(jQuery),\n  /*\n  * jQuery mmenu navbar add-on prev content\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    var t = \"mmenu\",\n        n = \"navbars\",\n        i = \"prev\";\n    e[t].addons[n][i] = function (i, s) {\n      var a = e[t]._c,\n          o = e('<a class=\"' + a.prev + \" \" + a.btn + '\" href=\"#\" />').appendTo(i);\n      this.bind(\"initNavbar:after\", function (e) {\n        e.removeClass(a.hasnavbar);\n      });\n      var r, l, d;\n      return this.bind(\"openPanel:start\", function (e) {\n        e.hasClass(a.vertical) || (r = e.find(\".\" + this.conf.classNames[n].panelPrev), r.length || (r = e.children(\".\" + a.navbar).children(\".\" + a.prev)), l = r.attr(\"href\"), d = r.html(), l ? o.attr(\"href\", l) : o.removeAttr(\"href\"), o[l || d ? \"removeClass\" : \"addClass\"](a.hidden), o.html(d));\n      }), this.bind(\"initNavbar:after:sr-aria\", function (e) {\n        var t = e.children(\".\" + a.navbar);\n\n        this.__sr_aria(t, \"hidden\", !0);\n      }), this.bind(\"openPanel:start:sr-aria\", function (e) {\n        this.__sr_aria(o, \"hidden\", o.hasClass(a.hidden)), this.__sr_aria(o, \"owns\", (o.attr(\"href\") || \"\").slice(1));\n      }), -1;\n    }, e[t].configuration.classNames[n].panelPrev = \"Prev\";\n  }(jQuery),\n  /*\n  * jQuery mmenu navbar add-on searchfield content\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    var t = \"mmenu\",\n        n = \"navbars\",\n        i = \"searchfield\";\n\n    e[t].addons[n][i] = function (n, i) {\n      var s = e[t]._c,\n          a = e('<div class=\"' + s.search + '\" />').appendTo(n);\n      return \"object\" != _typeof(this.opts.searchfield) && (this.opts.searchfield = {}), this.opts.searchfield.add = !0, this.opts.searchfield.addTo = a, 0;\n    };\n  }(jQuery),\n  /*\n  * jQuery mmenu navbar add-on title content\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    var t = \"mmenu\",\n        n = \"navbars\",\n        i = \"title\";\n    e[t].addons[n][i] = function (i, s) {\n      var a,\n          o,\n          r,\n          l = e[t]._c,\n          d = e('<a class=\"' + l.title + '\" />').appendTo(i);\n      this.bind(\"openPanel:start\", function (e) {\n        e.hasClass(l.vertical) || (r = e.find(\".\" + this.conf.classNames[n].panelTitle), r.length || (r = e.children(\".\" + l.navbar).children(\".\" + l.title)), a = r.attr(\"href\"), o = r.html() || s.title, a ? d.attr(\"href\", a) : d.removeAttr(\"href\"), d[a || o ? \"removeClass\" : \"addClass\"](l.hidden), d.html(o));\n      });\n      var c;\n      return this.bind(\"openPanel:start:sr-aria\", function (e) {\n        if (this.opts.screenReader.text && (c || (c = this.$menu.children(\".\" + l.navbars + \"-top, .\" + l.navbars + \"-bottom\").children(\".\" + l.navbar).children(\".\" + l.prev)), c.length)) {\n          var t = !0;\n          \"parent\" == this.opts.navbar.titleLink && (t = !c.hasClass(l.hidden)), this.__sr_aria(d, \"hidden\", t);\n        }\n      }), 0;\n    }, e[t].configuration.classNames[n].panelTitle = \"Title\";\n  }(jQuery),\n  /*\n  * jQuery mmenu pageScroll add-on\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    function t(e) {\n      d && d.length && d.is(\":visible\") && l.$html.add(l.$body).animate({\n        scrollTop: d.offset().top + e\n      }), d = !1;\n    }\n\n    function n(e) {\n      try {\n        return !(\"#\" == e || \"#\" != e.slice(0, 1) || !l.$page.find(e).length);\n      } catch (t) {\n        return !1;\n      }\n    }\n\n    var i = \"mmenu\",\n        s = \"pageScroll\";\n    e[i].addons[s] = {\n      setup: function setup() {\n        var o = this,\n            d = this.opts[s],\n            c = this.conf[s];\n\n        if (l = e[i].glbl, \"boolean\" == typeof d && (d = {\n          scroll: d\n        }), d = this.opts[s] = e.extend(!0, {}, e[i].defaults[s], d), d.scroll && this.bind(\"close:finish\", function () {\n          t(c.scrollOffset);\n        }), d.update) {\n          var o = this,\n              h = [],\n              f = [];\n          o.bind(\"initListview:after\", function (t) {\n            o.__filterListItemAnchors(t.find(\".\" + a.listview).children(\"li\")).each(function () {\n              var t = e(this).attr(\"href\");\n              n(t) && h.push(t);\n            }), f = h.reverse();\n          });\n          var u = -1;\n          l.$wndw.on(r.scroll + \"-\" + s, function (t) {\n            for (var n = l.$wndw.scrollTop(), i = 0; i < f.length; i++) {\n              if (e(f[i]).offset().top < n + c.updateOffset) {\n                u !== i && (u = i, o.setSelected(o.__filterListItemAnchors(o.$pnls.children(\".\" + a.opened).find(\".\" + a.listview).children(\"li\")).filter('[href=\"' + f[i] + '\"]').parent()));\n                break;\n              }\n            }\n          });\n        }\n      },\n      add: function add() {\n        a = e[i]._c, o = e[i]._d, r = e[i]._e;\n      },\n      clickAnchor: function clickAnchor(i, o) {\n        if (d = !1, o && this.opts[s].scroll && this.opts.offCanvas && l.$page && l.$page.length) {\n          var r = i.attr(\"href\");\n          n(r) && (d = e(r), l.$html.hasClass(a.mm(\"widescreen\")) && t(this.conf[s].scrollOffset));\n        }\n      }\n    }, e[i].defaults[s] = {\n      scroll: !1,\n      update: !1\n    }, e[i].configuration[s] = {\n      scrollOffset: 0,\n      updateOffset: 50\n    };\n    var a,\n        o,\n        r,\n        l,\n        d = !1;\n  }(jQuery),\n  /*\n  * jQuery mmenu RTL add-on\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    var t = \"mmenu\",\n        n = \"rtl\";\n    e[t].addons[n] = {\n      setup: function setup() {\n        var s = this.opts[n];\n        this.conf[n];\n        o = e[t].glbl, \"object\" != _typeof(s) && (s = {\n          use: s\n        }), s = this.opts[n] = e.extend(!0, {}, e[t].defaults[n], s), \"boolean\" != typeof s.use && (s.use = \"rtl\" == (o.$html.attr(\"dir\") || \"\").toLowerCase()), s.use && this.bind(\"initMenu:after\", function () {\n          this.$menu.addClass(i.rtl);\n        });\n      },\n      add: function add() {\n        i = e[t]._c, s = e[t]._d, a = e[t]._e, i.add(\"rtl\");\n      },\n      clickAnchor: function clickAnchor(e, t) {}\n    }, e[t].defaults[n] = {\n      use: \"detect\"\n    };\n    var i, s, a, o;\n  }(jQuery),\n  /*\n  * jQuery mmenu searchfield add-on\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    function t(e) {\n      switch (e) {\n        case 9:\n        case 16:\n        case 17:\n        case 18:\n        case 37:\n        case 38:\n        case 39:\n        case 40:\n          return !0;\n      }\n\n      return !1;\n    }\n\n    var n = \"mmenu\",\n        i = \"searchfield\";\n    e[n].addons[i] = {\n      setup: function setup() {\n        var l = this,\n            d = this.opts[i],\n            c = this.conf[i];\n        r = e[n].glbl, \"boolean\" == typeof d && (d = {\n          add: d\n        }), \"object\" != _typeof(d) && (d = {}), \"boolean\" == typeof d.resultsPanel && (d.resultsPanel = {\n          add: d.resultsPanel\n        }), d = this.opts[i] = e.extend(!0, {}, e[n].defaults[i], d), c = this.conf[i] = e.extend(!0, {}, e[n].configuration[i], c), this.bind(\"close:start\", function () {\n          this.$menu.find(\".\" + s.search).find(\"input\").blur();\n        }), this.bind(\"initPanels:after\", function (r) {\n          if (d.add) {\n            var h;\n\n            switch (d.addTo) {\n              case \"panels\":\n                h = r;\n                break;\n\n              default:\n                h = this.$menu.find(d.addTo);\n            }\n\n            if (h.each(function () {\n              var t = e(this);\n\n              if (!t.is(\".\" + s.panel) || !t.is(\".\" + s.vertical)) {\n                if (!t.children(\".\" + s.search).length) {\n                  var i = l.__valueOrFn(c.clear, t),\n                      a = l.__valueOrFn(c.form, t),\n                      r = l.__valueOrFn(c.input, t),\n                      h = l.__valueOrFn(c.submit, t),\n                      f = e(\"<\" + (a ? \"form\" : \"div\") + ' class=\"' + s.search + '\" />'),\n                      u = e('<input placeholder=\"' + e[n].i18n(d.placeholder) + '\" type=\"text\" autocomplete=\"off\" />');\n\n                  f.append(u);\n                  var p;\n                  if (r) for (p in r) {\n                    u.attr(p, r[p]);\n                  }\n\n                  if (i && e('<a class=\"' + s.btn + \" \" + s.clear + '\" href=\"#\" />').appendTo(f).on(o.click + \"-searchfield\", function (e) {\n                    e.preventDefault(), u.val(\"\").trigger(o.keyup + \"-searchfield\");\n                  }), a) {\n                    for (p in a) {\n                      f.attr(p, a[p]);\n                    }\n\n                    h && !i && e('<a class=\"' + s.btn + \" \" + s.next + '\" href=\"#\" />').appendTo(f).on(o.click + \"-searchfield\", function (e) {\n                      e.preventDefault(), f.submit();\n                    });\n                  }\n\n                  t.hasClass(s.search) ? t.replaceWith(f) : t.prepend(f).addClass(s.hassearch);\n                }\n\n                if (d.noResults) {\n                  var v = t.closest(\".\" + s.panel).length;\n\n                  if (v || (t = l.$pnls.children(\".\" + s.panel).first()), !t.children(\".\" + s.noresultsmsg).length) {\n                    var m = t.children(\".\" + s.listview).first(),\n                        b = e('<div class=\"' + s.noresultsmsg + \" \" + s.hidden + '\" />');\n                    b.append(e[n].i18n(d.noResults))[m.length ? \"insertAfter\" : \"prependTo\"](m.length ? m : t);\n                  }\n                }\n              }\n            }), d.search) {\n              if (d.resultsPanel.add) {\n                d.showSubPanels = !1;\n                var f = this.$pnls.children(\".\" + s.resultspanel);\n                f.length || (f = e('<div class=\"' + s.resultspanel + \" \" + s.noanimation + \" \" + s.hidden + '\" />').appendTo(this.$pnls).append('<div class=\"' + s.navbar + \" \" + s.hidden + '\"><a class=\"' + s.title + '\">' + e[n].i18n(d.resultsPanel.title) + \"</a></div>\").append('<ul class=\"' + s.listview + '\" />').append(this.$pnls.find(\".\" + s.noresultsmsg).first().clone()), this._initPanel(f));\n              }\n\n              this.$menu.find(\".\" + s.search).each(function () {\n                var n,\n                    r,\n                    c = e(this),\n                    h = c.closest(\".\" + s.panel).length;\n                h ? (n = c.closest(\".\" + s.panel), r = n) : (n = l.$pnls.find(\".\" + s.panel), r = l.$menu), d.resultsPanel.add && (n = n.not(f));\n\n                var u = c.children(\"input\"),\n                    p = l.__findAddBack(n, \".\" + s.listview).children(\"li\"),\n                    v = p.filter(\".\" + s.divider),\n                    m = l.__filterListItems(p),\n                    b = \"a\",\n                    g = b + \", span\",\n                    _ = \"\",\n                    y = function y() {\n                  var t = u.val().toLowerCase();\n\n                  if (t != _) {\n                    if (_ = t, d.resultsPanel.add && f.children(\".\" + s.listview).empty(), n.scrollTop(0), m.add(v).addClass(s.hidden).find(\".\" + s.fullsubopensearch).removeClass(s.fullsubopen + \" \" + s.fullsubopensearch), m.each(function () {\n                      var t = e(this),\n                          n = b;\n                      (d.showTextItems || d.showSubPanels && t.find(\".\" + s.next)) && (n = g);\n                      var i = t.data(a.searchtext) || t.children(n).not(\".\" + s.next).text();\n                      i.toLowerCase().indexOf(_) > -1 && t.add(t.prevAll(\".\" + s.divider).first()).removeClass(s.hidden);\n                    }), d.showSubPanels && n.each(function (t) {\n                      var n = e(this);\n\n                      l.__filterListItems(n.find(\".\" + s.listview).children()).each(function () {\n                        var t = e(this),\n                            n = t.data(a.child);\n                        t.removeClass(s.nosubresults), n && n.find(\".\" + s.listview).children().removeClass(s.hidden);\n                      });\n                    }), d.resultsPanel.add) {\n                      if (\"\" === _) this.closeAllPanels(this.$pnls.children(\".\" + s.subopened).last());else {\n                        var i = e();\n                        n.each(function () {\n                          var t = l.__filterListItems(e(this).find(\".\" + s.listview).children()).not(\".\" + s.hidden).clone(!0);\n\n                          t.length && (d.resultsPanel.dividers && (i = i.add('<li class=\"' + s.divider + '\">' + e(this).children(\".\" + s.navbar).children(\".\" + s.title).text() + \"</li>\")), t.children(\".\" + s.mm(\"toggle\") + \", .\" + s.mm(\"check\")).remove(), i = i.add(t));\n                        }), i.find(\".\" + s.next).remove(), f.children(\".\" + s.listview).append(i), this.openPanel(f);\n                      }\n                    } else e(n.get().reverse()).each(function (t) {\n                      var n = e(this),\n                          i = n.data(a.parent);\n                      i && (l.__filterListItems(n.find(\".\" + s.listview).children()).length ? (i.hasClass(s.hidden) && i.children(\".\" + s.next).not(\".\" + s.fullsubopen).addClass(s.fullsubopen).addClass(s.fullsubopensearch), i.removeClass(s.hidden).removeClass(s.nosubresults).prevAll(\".\" + s.divider).first().removeClass(s.hidden)) : h || ((n.hasClass(s.opened) || n.hasClass(s.subopened)) && setTimeout(function () {\n                        l.openPanel(i.closest(\".\" + s.panel));\n                      }, (t + 1) * (1.5 * l.conf.openingInterval)), i.addClass(s.nosubresults)));\n                    });\n                    r.find(\".\" + s.noresultsmsg)[m.not(\".\" + s.hidden).length ? \"addClass\" : \"removeClass\"](s.hidden), this.trigger(\"updateListview\");\n                  }\n                };\n\n                u.off(o.keyup + \"-\" + i + \" \" + o.change + \"-\" + i).on(o.keyup + \"-\" + i, function (e) {\n                  t(e.keyCode) || y.call(l);\n                }).on(o.change + \"-\" + i, function (e) {\n                  y.call(l);\n                });\n                var C = c.children(\".\" + s.btn);\n                C.length && u.on(o.keyup + \"-\" + i, function (e) {\n                  C[u.val().length ? \"removeClass\" : \"addClass\"](s.hidden);\n                }), u.trigger(o.keyup + \"-\" + i);\n              });\n            }\n          }\n        });\n      },\n      add: function add() {\n        s = e[n]._c, a = e[n]._d, o = e[n]._e, s.add(\"clear search hassearch resultspanel noresultsmsg noresults nosubresults fullsubopensearch\"), a.add(\"searchtext\"), o.add(\"change keyup\");\n      },\n      clickAnchor: function clickAnchor(e, t) {}\n    }, e[n].defaults[i] = {\n      add: !1,\n      addTo: \"panels\",\n      placeholder: \"Search\",\n      noResults: \"No results found.\",\n      resultsPanel: {\n        add: !1,\n        dividers: !0,\n        title: \"Search results\"\n      },\n      search: !0,\n      showTextItems: !1,\n      showSubPanels: !0\n    }, e[n].configuration[i] = {\n      clear: !1,\n      form: !1,\n      input: !1,\n      submit: !1\n    };\n    var s, a, o, r;\n  }(jQuery),\n  /*\n  * jQuery mmenu sectionIndexer add-on\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    var t = \"mmenu\",\n        n = \"sectionIndexer\";\n    e[t].addons[n] = {\n      setup: function setup() {\n        var s = this,\n            r = this.opts[n];\n        this.conf[n];\n        o = e[t].glbl, \"boolean\" == typeof r && (r = {\n          add: r\n        }), \"object\" != _typeof(r) && (r = {}), r = this.opts[n] = e.extend(!0, {}, e[t].defaults[n], r), this.bind(\"initPanels:after\", function (t) {\n          if (r.add) {\n            var o;\n\n            switch (r.addTo) {\n              case \"panels\":\n                o = t;\n                break;\n\n              default:\n                o = e(r.addTo, this.$menu).filter(\".\" + i.panel);\n            }\n\n            o.find(\".\" + i.divider).closest(\".\" + i.panel).addClass(i.hasindexer), this.$indexer || (this.$indexer = e('<div class=\"' + i.indexer + '\" />').prependTo(this.$pnls).append('<a href=\"#a\">a</a><a href=\"#b\">b</a><a href=\"#c\">c</a><a href=\"#d\">d</a><a href=\"#e\">e</a><a href=\"#f\">f</a><a href=\"#g\">g</a><a href=\"#h\">h</a><a href=\"#i\">i</a><a href=\"#j\">j</a><a href=\"#k\">k</a><a href=\"#l\">l</a><a href=\"#m\">m</a><a href=\"#n\">n</a><a href=\"#o\">o</a><a href=\"#p\">p</a><a href=\"#q\">q</a><a href=\"#r\">r</a><a href=\"#s\">s</a><a href=\"#t\">t</a><a href=\"#u\">u</a><a href=\"#v\">v</a><a href=\"#w\">w</a><a href=\"#x\">x</a><a href=\"#y\">y</a><a href=\"#z\">z</a>'), this.$indexer.children().on(a.mouseover + \"-\" + n + \" \" + a.touchstart + \"-\" + n, function (t) {\n              var n = e(this).attr(\"href\").slice(1),\n                  a = s.$pnls.children(\".\" + i.opened),\n                  o = a.find(\".\" + i.listview),\n                  r = -1,\n                  l = a.scrollTop();\n              a.scrollTop(0), o.children(\".\" + i.divider).not(\".\" + i.hidden).each(function () {\n                r < 0 && n == e(this).text().slice(0, 1).toLowerCase() && (r = e(this).position().top);\n              }), a.scrollTop(r > -1 ? r : l);\n            }));\n\n            var l = function l(e) {\n              e = e || this.$pnls.children(\".\" + i.opened), this.$menu[(e.hasClass(i.hasindexer) ? \"add\" : \"remove\") + \"Class\"](i.hasindexer);\n            };\n\n            this.bind(\"openPanel:start\", l), this.bind(\"initPanels:after\", l);\n          }\n        });\n      },\n      add: function add() {\n        i = e[t]._c, s = e[t]._d, a = e[t]._e, i.add(\"indexer hasindexer\"), a.add(\"mouseover\");\n      },\n      clickAnchor: function clickAnchor(e, t) {\n        if (e.parent().is(\".\" + i.indexer)) return !0;\n      }\n    }, e[t].defaults[n] = {\n      add: !1,\n      addTo: \"panels\"\n    };\n    var i, s, a, o;\n  }(jQuery),\n  /*\n  * jQuery mmenu setSelected add-on\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    var t = \"mmenu\",\n        n = \"setSelected\";\n    e[t].addons[n] = {\n      setup: function setup() {\n        var a = this,\n            r = this.opts[n];\n        this.conf[n];\n\n        if (o = e[t].glbl, \"boolean\" == typeof r && (r = {\n          hover: r,\n          parent: r\n        }), \"object\" != _typeof(r) && (r = {}), r = this.opts[n] = e.extend(!0, {}, e[t].defaults[n], r), \"detect\" == r.current) {\n          var l = function l(e) {\n            e = e.split(\"?\")[0].split(\"#\")[0];\n            var t = a.$menu.find('a[href=\"' + e + '\"], a[href=\"' + e + '/\"]');\n            t.length ? a.setSelected(t.parent(), !0) : (e = e.split(\"/\").slice(0, -1), e.length && l(e.join(\"/\")));\n          };\n\n          this.bind(\"initMenu:after\", function () {\n            l(window.location.href);\n          });\n        } else r.current || this.bind(\"initListview:after\", function (e) {\n          this.$pnls.find(\".\" + i.listview).children(\".\" + i.selected).removeClass(i.selected);\n        });\n\n        r.hover && this.bind(\"initMenu:after\", function () {\n          this.$menu.addClass(i.hoverselected);\n        }), r.parent && (this.bind(\"openPanel:finish\", function (e) {\n          this.$pnls.find(\".\" + i.listview).find(\".\" + i.next).removeClass(i.selected);\n\n          for (var t = e.data(s.parent); t;) {\n            t.not(\".\" + i.vertical).children(\".\" + i.next).addClass(i.selected), t = t.closest(\".\" + i.panel).data(s.parent);\n          }\n        }), this.bind(\"initMenu:after\", function () {\n          this.$menu.addClass(i.parentselected);\n        }));\n      },\n      add: function add() {\n        i = e[t]._c, s = e[t]._d, a = e[t]._e, i.add(\"hoverselected parentselected\");\n      },\n      clickAnchor: function clickAnchor(e, t) {}\n    }, e[t].defaults[n] = {\n      current: !0,\n      hover: !1,\n      parent: !1\n    };\n    var i, s, a, o;\n  }(jQuery),\n  /*\n  * jQuery mmenu toggles add-on\n  * mmenu.frebsite.nl\n  *\n  * Copyright (c) Fred Heusschen\n  */\n  function (e) {\n    var t = \"mmenu\",\n        n = \"toggles\";\n    e[t].addons[n] = {\n      setup: function setup() {\n        var s = this;\n        this.opts[n], this.conf[n];\n        o = e[t].glbl, this.bind(\"initListview:after\", function (t) {\n          this.__refactorClass(t.find(\"input\"), this.conf.classNames[n].toggle, \"toggle\"), this.__refactorClass(t.find(\"input\"), this.conf.classNames[n].check, \"check\"), t.find(\"input.\" + i.toggle + \", input.\" + i.check).each(function () {\n            var t = e(this),\n                n = t.closest(\"li\"),\n                a = t.hasClass(i.toggle) ? \"toggle\" : \"check\",\n                o = t.attr(\"id\") || s.__getUniqueId();\n\n            n.children('label[for=\"' + o + '\"]').length || (t.attr(\"id\", o), n.prepend(t), e('<label for=\"' + o + '\" class=\"' + i[a] + '\"></label>').insertBefore(n.children(\"a, span\").last()));\n          });\n        });\n      },\n      add: function add() {\n        i = e[t]._c, s = e[t]._d, a = e[t]._e, i.add(\"toggle check\");\n      },\n      clickAnchor: function clickAnchor(e, t) {}\n    }, e[t].configuration.classNames[n] = {\n      toggle: \"Toggle\",\n      check: \"Check\"\n    };\n    var i, s, a, o;\n  }(jQuery);\n  return true;\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tbW9uX3NjcmlwdHMuanM/MThhNyJdLCJuYW1lcyI6WyJlIiwidCIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJ0b1N0cmluZyIsImNhbGwiLCJub2RlVHlwZSIsIm8iLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwibm9kZU5hbWUiLCJwYXJlbnROb2RlIiwiaG9zdCIsIm4iLCJpbmRleE9mIiwiZG9jdW1lbnQiLCJib2R5IiwiaSIsInIiLCJvdmVyZmxvdyIsInAiLCJvdmVyZmxvd1giLCJzIiwib3ZlcmZsb3dZIiwidGVzdCIsIm9mZnNldFBhcmVudCIsImRvY3VtZW50RWxlbWVudCIsImZpcnN0RWxlbWVudENoaWxkIiwiZCIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiTm9kZSIsIkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyIsImEiLCJjcmVhdGVSYW5nZSIsInNldFN0YXJ0Iiwic2V0RW5kIiwiZiIsImNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIiwiY29udGFpbnMiLCJsIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic2Nyb2xsaW5nRWxlbWVudCIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsInNwbGl0IiwibSIsIl8iLCJpZSIsImgiLCJoZWlnaHQiLCJ3aWR0aCIsImMiLCJzZSIsImciLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwidSIsImJvcmRlclRvcFdpZHRoIiwiYm9yZGVyTGVmdFdpZHRoIiwibWFyZ2luVG9wIiwibWFyZ2luTGVmdCIsImIiLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJ5IiwidyIsInYiLCJFIiwiT2JqZWN0Iiwia2V5cyIsIm1hcCIsImtleSIsImFyZWEiLCJzb3J0IiwiZmlsdGVyIiwieCIsIk8iLCJwYXJzZUZsb2F0IiwibWFyZ2luQm90dG9tIiwibWFyZ2luUmlnaHQiLCJMIiwicmVwbGFjZSIsIlMiLCJUIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJmaW5kIiwiQyIsImZpbmRJbmRleCIsIk4iLCJzbGljZSIsImZvckVhY2giLCJjb25zb2xlIiwid2FybiIsImZuIiwiZW5hYmxlZCIsIm9mZnNldHMiLCJwb3BwZXIiLCJyZWZlcmVuY2UiLCJrIiwic3RhdGUiLCJpc0Rlc3Ryb3llZCIsImluc3RhbmNlIiwic3R5bGVzIiwiYXR0cmlidXRlcyIsImZsaXBwZWQiLCJwbGFjZW1lbnQiLCJvcHRpb25zIiwibW9kaWZpZXJzIiwiZmxpcCIsImJvdW5kYXJpZXNFbGVtZW50IiwicGFkZGluZyIsIm9yaWdpbmFsUGxhY2VtZW50IiwicG9zaXRpb24iLCJpc0NyZWF0ZWQiLCJvblVwZGF0ZSIsIm9uQ3JlYXRlIiwiVyIsInNvbWUiLCJuYW1lIiwiQiIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic3R5bGUiLCJEIiwicmVtb3ZlQXR0cmlidXRlIiwiZGlzYWJsZUV2ZW50TGlzdGVuZXJzIiwicmVtb3ZlT25EZXN0cm95IiwicmVtb3ZlQ2hpbGQiLCJIIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJwdXNoIiwiUCIsInVwZGF0ZUJvdW5kIiwic2Nyb2xsUGFyZW50cyIsInNjcm9sbEVsZW1lbnQiLCJldmVudHNFbmFibGVkIiwiQSIsInNjaGVkdWxlVXBkYXRlIiwiTSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJJIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJSIiwiaXNOYU4iLCJpc0Zpbml0ZSIsIlUiLCJZIiwic2V0QXR0cmlidXRlIiwiRiIsIm9yZGVyIiwiaiIsIksiLCJhZSIsImNvbmNhdCIsInJldmVyc2UiLCJxIiwibWF0Y2giLCJHIiwidHJpbSIsInNlYXJjaCIsInJlZHVjZSIsInoiLCJNYXRoIiwibWluIiwiViIsImZsb29yIiwibWF4IiwiWCIsIlEiLCJKIiwiWiIsIiQiLCJlZSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInRlIiwiTXV0YXRpb25PYnNlcnZlciIsIm9lIiwiY3JlYXRlRWxlbWVudCIsIm9ic2VydmUiLCJzZXRUaW1lb3V0IiwiYXBwVmVyc2lvbiIsIm5lIiwiVHlwZUVycm9yIiwicmUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsInBlIiwidmFsdWUiLCJhc3NpZ24iLCJoYXNPd25Qcm9wZXJ0eSIsImRlIiwiZmUiLCJGTElQIiwiQ0xPQ0tXSVNFIiwiQ09VTlRFUkNMT0NLV0lTRSIsImxlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwidXBkYXRlIiwiYmluZCIsIkRlZmF1bHRzIiwianF1ZXJ5Iiwib25Mb2FkIiwiZW5hYmxlRXZlbnRMaXN0ZW5lcnMiLCJVdGlscyIsImdsb2JhbCIsIlBvcHBlclV0aWxzIiwicGxhY2VtZW50cyIsInNoaWZ0Iiwic3RhcnQiLCJlbmQiLCJvZmZzZXQiLCJwcmV2ZW50T3ZlcmZsb3ciLCJib3VuZGFyaWVzIiwicHJpb3JpdHkiLCJwcmltYXJ5IiwiZXNjYXBlV2l0aFJlZmVyZW5jZSIsInNlY29uZGFyeSIsImtlZXBUb2dldGhlciIsImFycm93IiwiZWxlbWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJhcnJvd0VsZW1lbnQiLCJyb3VuZCIsImJlaGF2aW9yIiwiZmxpcFZhcmlhdGlvbnMiLCJpbm5lciIsImhpZGUiLCJjb21wdXRlU3R5bGUiLCJncHVBY2NlbGVyYXRpb24iLCJ3aWxsQ2hhbmdlIiwiYXBwbHlTdHlsZSIsImpRdWVyeSIsIkVycm9yIiwiUmVmZXJlbmNlRXJyb3IiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJ0b0xvd2VyQ2FzZSIsImJpbmRUeXBlIiwiZGVsZWdhdGVUeXBlIiwiaGFuZGxlIiwidGFyZ2V0IiwiaXMiLCJoYW5kbGVPYmoiLCJoYW5kbGVyIiwiYXBwbHkiLCJRVW5pdCIsIm9uZSIsIlRSQU5TSVRJT05fRU5EIiwidHJpZ2dlclRyYW5zaXRpb25FbmQiLCJXZWJraXRUcmFuc2l0aW9uIiwiTW96VHJhbnNpdGlvbiIsIk9UcmFuc2l0aW9uIiwidHJhbnNpdGlvbiIsImdldFVJRCIsInJhbmRvbSIsImdldEVsZW1lbnRCeUlkIiwiZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCIsImdldEF0dHJpYnV0ZSIsInJlZmxvdyIsInRyaWdnZXIiLCJzdXBwb3J0c1RyYW5zaXRpb25FbmQiLCJCb29sZWFuIiwidHlwZUNoZWNrQ29uZmlnIiwiUmVnRXhwIiwiZW11bGF0ZVRyYW5zaXRpb25FbmQiLCJldmVudCIsInNwZWNpYWwiLCJESVNNSVNTIiwiQ0xPU0UiLCJDTE9TRUQiLCJDTElDS19EQVRBX0FQSSIsIkFMRVJUIiwiRkFERSIsIlNIT1ciLCJfZWxlbWVudCIsImNsb3NlIiwiX2dldFJvb3RFbGVtZW50IiwiX3RyaWdnZXJDbG9zZUV2ZW50IiwiaXNEZWZhdWx0UHJldmVudGVkIiwiX3JlbW92ZUVsZW1lbnQiLCJkaXNwb3NlIiwicmVtb3ZlRGF0YSIsImNsb3Nlc3QiLCJFdmVudCIsInJlbW92ZUNsYXNzIiwiaGFzQ2xhc3MiLCJfZGVzdHJveUVsZW1lbnQiLCJkZXRhY2giLCJyZW1vdmUiLCJfalF1ZXJ5SW50ZXJmYWNlIiwiZWFjaCIsImRhdGEiLCJfaGFuZGxlRGlzbWlzcyIsInByZXZlbnREZWZhdWx0IiwiZ2V0Iiwib24iLCJDb25zdHJ1Y3RvciIsIm5vQ29uZmxpY3QiLCJBQ1RJVkUiLCJCVVRUT04iLCJGT0NVUyIsIkRBVEFfVE9HR0xFX0NBUlJPVCIsIkRBVEFfVE9HR0xFIiwiSU5QVVQiLCJGT0NVU19CTFVSX0RBVEFfQVBJIiwidG9nZ2xlIiwidHlwZSIsImNoZWNrZWQiLCJoYXNBdHRyaWJ1dGUiLCJjbGFzc0xpc3QiLCJmb2N1cyIsInRvZ2dsZUNsYXNzIiwiaW50ZXJ2YWwiLCJrZXlib2FyZCIsInNsaWRlIiwicGF1c2UiLCJ3cmFwIiwiTkVYVCIsIlBSRVYiLCJMRUZUIiwiUklHSFQiLCJTTElERSIsIlNMSUQiLCJLRVlET1dOIiwiTU9VU0VFTlRFUiIsIk1PVVNFTEVBVkUiLCJUT1VDSEVORCIsIkxPQURfREFUQV9BUEkiLCJDQVJPVVNFTCIsIklURU0iLCJBQ1RJVkVfSVRFTSIsIk5FWFRfUFJFViIsIklORElDQVRPUlMiLCJEQVRBX1NMSURFIiwiREFUQV9SSURFIiwiX2l0ZW1zIiwiX2ludGVydmFsIiwiX2FjdGl2ZUVsZW1lbnQiLCJfaXNQYXVzZWQiLCJfaXNTbGlkaW5nIiwidG91Y2hUaW1lb3V0IiwiX2NvbmZpZyIsIl9nZXRDb25maWciLCJfaW5kaWNhdG9yc0VsZW1lbnQiLCJfYWRkRXZlbnRMaXN0ZW5lcnMiLCJuZXh0IiwiX3NsaWRlIiwibmV4dFdoZW5WaXNpYmxlIiwiaGlkZGVuIiwicHJldiIsImN5Y2xlIiwiY2xlYXJJbnRlcnZhbCIsInNldEludGVydmFsIiwidmlzaWJpbGl0eVN0YXRlIiwidG8iLCJfZ2V0SXRlbUluZGV4Iiwib2ZmIiwiZXh0ZW5kIiwiX2tleWRvd24iLCJjbGVhclRpbWVvdXQiLCJ0YWdOYW1lIiwid2hpY2giLCJtYWtlQXJyYXkiLCJwYXJlbnQiLCJfZ2V0SXRlbUJ5RGlyZWN0aW9uIiwiX3RyaWdnZXJTbGlkZUV2ZW50IiwicmVsYXRlZFRhcmdldCIsImRpcmVjdGlvbiIsImZyb20iLCJfc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudCIsImNoaWxkcmVuIiwiYWRkQ2xhc3MiLCJfZGF0YUFwaUNsaWNrSGFuZGxlciIsIlNIT1dOIiwiSElERSIsIkhJRERFTiIsIkNPTExBUFNFIiwiQ09MTEFQU0lORyIsIkNPTExBUFNFRCIsIldJRFRIIiwiSEVJR0hUIiwiQUNUSVZFUyIsIl9pc1RyYW5zaXRpb25pbmciLCJfdHJpZ2dlckFycmF5IiwiaWQiLCJfcGFyZW50IiwiX2dldFBhcmVudCIsIl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MiLCJzaG93IiwiX2dldERpbWVuc2lvbiIsImF0dHIiLCJzZXRUcmFuc2l0aW9uaW5nIiwiX2dldFRhcmdldEZyb21FbGVtZW50IiwiUG9wcGVyIiwiQ0xJQ0siLCJLRVlET1dOX0RBVEFfQVBJIiwiS0VZVVBfREFUQV9BUEkiLCJESVNBQkxFRCIsIkRST1BVUCIsIk1FTlVSSUdIVCIsIk1FTlVMRUZUIiwiRk9STV9DSElMRCIsIk1FTlUiLCJOQVZCQVJfTkFWIiwiVklTSUJMRV9JVEVNUyIsIlRPUCIsIlRPUEVORCIsIkJPVFRPTSIsIkJPVFRPTUVORCIsIl9wb3BwZXIiLCJfbWVudSIsIl9nZXRNZW51RWxlbWVudCIsIl9pbk5hdmJhciIsIl9kZXRlY3ROYXZiYXIiLCJkaXNhYmxlZCIsIl9nZXRQYXJlbnRGcm9tRWxlbWVudCIsIl9jbGVhck1lbnVzIiwiX2dldFBvcHBlckNvbmZpZyIsIm5vb3AiLCJkZXN0cm95Iiwic3RvcFByb3BhZ2F0aW9uIiwiRGVmYXVsdCIsIkRlZmF1bHRUeXBlIiwiX2dldFBsYWNlbWVudCIsIl9kYXRhQXBpS2V5ZG93bkhhbmRsZXIiLCJiYWNrZHJvcCIsIkZPQ1VTSU4iLCJSRVNJWkUiLCJDTElDS19ESVNNSVNTIiwiS0VZRE9XTl9ESVNNSVNTIiwiTU9VU0VVUF9ESVNNSVNTIiwiTU9VU0VET1dOX0RJU01JU1MiLCJTQ1JPTExCQVJfTUVBU1VSRVIiLCJCQUNLRFJPUCIsIk9QRU4iLCJESUFMT0ciLCJEQVRBX0RJU01JU1MiLCJGSVhFRF9DT05URU5UIiwiTkFWQkFSX1RPR0dMRVIiLCJfZGlhbG9nIiwiX2JhY2tkcm9wIiwiX2lzU2hvd24iLCJfaXNCb2R5T3ZlcmZsb3dpbmciLCJfaWdub3JlQmFja2Ryb3BDbGljayIsIl9vcmlnaW5hbEJvZHlQYWRkaW5nIiwiX3Njcm9sbGJhcldpZHRoIiwiX2NoZWNrU2Nyb2xsYmFyIiwiX3NldFNjcm9sbGJhciIsIl9zZXRFc2NhcGVFdmVudCIsIl9zZXRSZXNpemVFdmVudCIsIl9zaG93QmFja2Ryb3AiLCJfc2hvd0VsZW1lbnQiLCJfaGlkZU1vZGFsIiwiaGFuZGxlVXBkYXRlIiwiX2FkanVzdERpYWxvZyIsIkVMRU1FTlRfTk9ERSIsImFwcGVuZENoaWxkIiwiZGlzcGxheSIsInNjcm9sbFRvcCIsIl9lbmZvcmNlRm9jdXMiLCJoYXMiLCJfcmVzZXRBZGp1c3RtZW50cyIsIl9yZXNldFNjcm9sbGJhciIsIl9yZW1vdmVCYWNrZHJvcCIsImNsYXNzTmFtZSIsImFwcGVuZFRvIiwiY3VycmVudFRhcmdldCIsInNjcm9sbEhlaWdodCIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwiX2dldFNjcm9sbGJhcldpZHRoIiwiY3NzIiwibWV0aG9kIiwiQUNUSVZBVEUiLCJTQ1JPTEwiLCJEUk9QRE9XTl9JVEVNIiwiRFJPUERPV05fTUVOVSIsIkRBVEFfU1BZIiwiTkFWX0xJU1RfR1JPVVAiLCJOQVZfTElOS1MiLCJMSVNUX0lURU1TIiwiRFJPUERPV04iLCJEUk9QRE9XTl9JVEVNUyIsIkRST1BET1dOX1RPR0dMRSIsIk9GRlNFVCIsIlBPU0lUSU9OIiwiX3Njcm9sbEVsZW1lbnQiLCJfc2VsZWN0b3IiLCJfb2Zmc2V0cyIsIl90YXJnZXRzIiwiX2FjdGl2ZVRhcmdldCIsIl9zY3JvbGxIZWlnaHQiLCJfcHJvY2VzcyIsInJlZnJlc2giLCJfZ2V0U2Nyb2xsVG9wIiwiX2dldFNjcm9sbEhlaWdodCIsInBhZ2VZT2Zmc2V0IiwiX2dldE9mZnNldEhlaWdodCIsIl9hY3RpdmF0ZSIsIl9jbGVhciIsImpvaW4iLCJwYXJlbnRzIiwidGFiIiwiRFJPUERPV05fQUNUSVZFX0NISUxEIiwiX3RyYW5zaXRpb25Db21wbGV0ZSIsImFuaW1hdGlvbiIsInRlbXBsYXRlIiwidGl0bGUiLCJkZWxheSIsImh0bWwiLCJzZWxlY3RvciIsImNvbnRhaW5lciIsImZhbGxiYWNrUGxhY2VtZW50IiwiQVVUTyIsIk9VVCIsIklOU0VSVEVEIiwiRk9DVVNPVVQiLCJUT09MVElQIiwiVE9PTFRJUF9JTk5FUiIsIkFSUk9XIiwiSE9WRVIiLCJNQU5VQUwiLCJfaXNFbmFibGVkIiwiX3RpbWVvdXQiLCJfaG92ZXJTdGF0ZSIsIl9hY3RpdmVUcmlnZ2VyIiwiY29uZmlnIiwidGlwIiwiX3NldExpc3RlbmVycyIsImVuYWJsZSIsImRpc2FibGUiLCJ0b2dnbGVFbmFibGVkIiwiREFUQV9LRVkiLCJfZ2V0RGVsZWdhdGVDb25maWciLCJjbGljayIsIl9pc1dpdGhBY3RpdmVUcmlnZ2VyIiwiX2VudGVyIiwiX2xlYXZlIiwiZ2V0VGlwRWxlbWVudCIsIkVWRU5UX0tFWSIsImlzV2l0aENvbnRlbnQiLCJvd25lckRvY3VtZW50IiwiTkFNRSIsInNldENvbnRlbnQiLCJfZ2V0QXR0YWNobWVudCIsImFkZEF0dGFjaG1lbnRDbGFzcyIsIl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UiLCJfZml4VHJhbnNpdGlvbiIsIl9UUkFOU0lUSU9OX0RVUkFUSU9OIiwiX2NsZWFuVGlwQ2xhc3MiLCJnZXRUaXRsZSIsInNldEVsZW1lbnRDb250ZW50IiwiZW1wdHkiLCJhcHBlbmQiLCJ0ZXh0IiwiX2ZpeFRpdGxlIiwiY29udGVudCIsIlRJVExFIiwiQ09OVEVOVCIsIl9nZXRDb250ZW50IiwiaXNNb2JpbGUiLCJjcmVhdGVFdmVudCIsImluaXRDdXN0b21FdmVudCIsImNyZWF0ZUV2ZW50T2JqZWN0IiwiZXZlbnRUeXBlIiwiZXZlbnROYW1lIiwiZW1pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImFkZEV2ZW50IiwiYXR0YWNoRXZlbnQiLCJyZW1vdmVFdmVudCIsImRldGFjaEV2ZW50IiwiV2Vha01hcCIsIk1veldlYWtNYXAiLCJ2YWx1ZXMiLCJzZXQiLCJXZWJraXRNdXRhdGlvbk9ic2VydmVyIiwiTW96TXV0YXRpb25PYnNlcnZlciIsIm5vdFN1cHBvcnRlZCIsImdldFByb3BlcnR5VmFsdWUiLCJjdXJyZW50U3R5bGUiLCJXT1ciLCJzY3JvbGxDYWxsYmFjayIsInNjcm9sbEhhbmRsZXIiLCJyZXNldEFuaW1hdGlvbiIsInNjcm9sbGVkIiwidXRpbCIsImRlZmF1bHRzIiwic2Nyb2xsQ29udGFpbmVyIiwiYW5pbWF0aW9uTmFtZUNhY2hlIiwid293RXZlbnQiLCJib3hDbGFzcyIsImFuaW1hdGVDbGFzcyIsIm1vYmlsZSIsImxpdmUiLCJjYWxsYmFjayIsImluaXQiLCJyZWFkeVN0YXRlIiwiZmluaXNoZWQiLCJzdG9wcGVkIiwiYm94ZXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiYWxsIiwicmVzZXRTdHlsZSIsImFkZGVkTm9kZXMiLCJkb1N5bmMiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwic3RvcCIsInN5bmMiLCJhbmltYXRlIiwiY3VzdG9tU3R5bGUiLCJ2aXNpYmlsaXR5Iiwic3JjRWxlbWVudCIsImNhY2hlQW5pbWF0aW9uTmFtZSIsInZlbmRvclNldCIsImFuaW1hdGlvbkR1cmF0aW9uIiwiYW5pbWF0aW9uRGVsYXkiLCJhbmltYXRpb25JdGVyYXRpb25Db3VudCIsImFuaW1hdGlvbk5hbWUiLCJjYWNoZWRBbmltYXRpb25OYW1lIiwidmVuZG9ycyIsInN1YnN0ciIsInZlbmRvckNTUyIsImdldFByb3BlcnR5Q1NTVmFsdWUiLCJjc3NUZXh0IiwiaXNWaXNpYmxlIiwib2Zmc2V0VG9wIiwiX3V0aWwiLCJiYWNrZ3JvdW5kSW1hZ2VVcmwiLCJnZW5lcmF0ZVVybCIsImJhY2tncm91bmRTaXplIiwicmV0aW5hUmVwbGFjZSIsImRldmljZVBpeGVsUmF0aW8iLCJzdWZmaXgiLCJsYXN0SW5kZXhPZiIsInNldHRpbmdzIiwiJGVsZW1lbnQiLCJfaGFuZGxlcnMiLCJfcGx1Z2lucyIsIl9zdXByZXNzIiwiX2N1cnJlbnQiLCJfc3BlZWQiLCJfY29vcmRpbmF0ZXMiLCJfYnJlYWtwb2ludCIsIl93aWR0aCIsIl9jbG9uZXMiLCJfbWVyZ2VycyIsIl93aWR0aHMiLCJfaW52YWxpZGF0ZWQiLCJfcGlwZSIsIl9kcmFnIiwidGltZSIsInBvaW50ZXIiLCJzdGFnZSIsImN1cnJlbnQiLCJfc3RhdGVzIiwidGFncyIsImluaXRpYWxpemluZyIsImFuaW1hdGluZyIsImRyYWdnaW5nIiwicHJveHkiLCJQbHVnaW5zIiwiV29ya2VycyIsInJ1biIsInNldHVwIiwiaW5pdGlhbGl6ZSIsIml0ZW1zIiwibG9vcCIsImNlbnRlciIsInJld2luZCIsIm1vdXNlRHJhZyIsInRvdWNoRHJhZyIsInB1bGxEcmFnIiwiZnJlZURyYWciLCJtYXJnaW4iLCJzdGFnZVBhZGRpbmciLCJtZXJnZSIsIm1lcmdlRml0IiwiYXV0b1dpZHRoIiwic3RhcnRQb3NpdGlvbiIsInJ0bCIsInNtYXJ0U3BlZWQiLCJmbHVpZFNwZWVkIiwiZHJhZ0VuZFNwZWVkIiwicmVzcG9uc2l2ZSIsInJlc3BvbnNpdmVSZWZyZXNoUmF0ZSIsInJlc3BvbnNpdmVCYXNlRWxlbWVudCIsImZhbGxiYWNrRWFzaW5nIiwiaW5mbyIsIm5lc3RlZEl0ZW1TZWxlY3RvciIsIml0ZW1FbGVtZW50Iiwic3RhZ2VFbGVtZW50IiwicmVmcmVzaENsYXNzIiwibG9hZGVkQ2xhc3MiLCJsb2FkaW5nQ2xhc3MiLCJydGxDbGFzcyIsInJlc3BvbnNpdmVDbGFzcyIsImRyYWdDbGFzcyIsIml0ZW1DbGFzcyIsInN0YWdlQ2xhc3MiLCJzdGFnZU91dGVyQ2xhc3MiLCJncmFiQ2xhc3MiLCJXaWR0aCIsIklubmVyIiwiT3V0ZXIiLCJUeXBlIiwiU3RhdGUiLCJyZWxhdGl2ZSIsIiRzdGFnZSIsInRvRml4ZWQiLCJjZWlsIiwibm9ybWFsaXplIiwib3V0ZXJIVE1MIiwicHJlcGVuZFRvIiwiYWJzIiwiZXEiLCJyZW1vdmVBdHRyIiwiaW5kZXgiLCJtaW5pbXVtIiwibWF4aW11bSIsInJlc2V0IiwiY29vcmRpbmF0ZXMiLCJvcCIsImVudGVyIiwicHJlbG9hZEF1dG9XaWR0aEltYWdlcyIsIm5vdCIsImludmFsaWRhdGUiLCJyZWdpc3RlckV2ZW50SGFuZGxlcnMiLCJsZWF2ZSIsInZpZXdwb3J0IiwiTnVtYmVyIiwicHJvcGVydHkiLCJvcHRpb25zTG9naWMiLCJwcmVwYXJlIiwiZ3JlcCIsIm9uVGhyb3R0bGVkUmVzaXplIiwicmVzaXplVGltZXIiLCJvblJlc2l6ZSIsInN1cHBvcnQiLCJvblRyYW5zaXRpb25FbmQiLCJvbkRyYWdTdGFydCIsIm9uRHJhZ0VuZCIsInRyYW5zZm9ybSIsInNwZWVkIiwiRGF0ZSIsImdldFRpbWUiLCJkaWZmZXJlbmNlIiwib25EcmFnTW92ZSIsInRyYW5zZm9ybTNkIiwic3VwcHJlc3MiLCJyZWxlYXNlIiwiaXNOdW1lcmljIiwibWVyZ2VycyIsImNsb25lcyIsImR1cmF0aW9uIiwib3JpZ2luYWxUYXJnZXQiLCJhZGRCYWNrIiwiYWRkIiwiYWZ0ZXIiLCJiZWZvcmUiLCJzcGxpY2UiLCJJbWFnZSIsInNyYyIsInVud3JhcCIsImNvbnRlbnRzIiwiaXRlbSIsImNvdW50IiwiY2FtZWxDYXNlIiwib25UcmlnZ2VyIiwicmVnaXN0ZXIiLCJvd2wiLCJfZGVmYXVsdCIsIm5hbWVzcGFjZSIsImluQXJyYXkiLCJvcmlnaW5hbEV2ZW50IiwidG91Y2hlcyIsImNoYW5nZWRUb3VjaGVzIiwicGFnZVgiLCJwYWdlWSIsImNsaWVudFgiLCJjbGllbnRZIiwib3dsQ2Fyb3VzZWwiLCJaZXB0byIsIl9jb3JlIiwiX3Zpc2libGUiLCJhdXRvUmVmcmVzaCIsIndhdGNoIiwiYXV0b1JlZnJlc2hJbnRlcnZhbCIsImdldE93blByb3BlcnR5TmFtZXMiLCJBdXRvUmVmcmVzaCIsIl9sb2FkZWQiLCJsYXp5TG9hZCIsImxvYWQiLCJ1cmwiLCJvbmxvYWQiLCJvcGFjaXR5IiwiaGFuZGxlcnMiLCJMYXp5IiwiYXV0b0hlaWdodCIsImF1dG9IZWlnaHRDbGFzcyIsInRvQXJyYXkiLCJBdXRvSGVpZ2h0IiwiX3ZpZGVvcyIsIl9wbGF5aW5nIiwidmlkZW8iLCJpc0luRnVsbFNjcmVlbiIsImZldGNoIiwicGxheSIsInZpZGVvSGVpZ2h0IiwidmlkZW9XaWR0aCIsInRodW1ibmFpbCIsImFqYXgiLCJqc29ucCIsImRhdGFUeXBlIiwic3VjY2VzcyIsInRodW1ibmFpbF9sYXJnZSIsImZyYW1lZ3JhYl91cmwiLCJpbnNlcnRBZnRlciIsImZ1bGxzY3JlZW5FbGVtZW50IiwibW96RnVsbFNjcmVlbkVsZW1lbnQiLCJ3ZWJraXRGdWxsc2NyZWVuRWxlbWVudCIsIlZpZGVvIiwiY29yZSIsInN3YXBwaW5nIiwicHJldmlvdXMiLCJhbmltYXRlT3V0IiwiYW5pbWF0ZUluIiwic3dhcCIsImNsZWFyIiwiQW5pbWF0ZSIsIl9wYXVzZWQiLCJhdXRvcGxheSIsIl9zZXRBdXRvUGxheUludGVydmFsIiwiYXV0b3BsYXlIb3ZlclBhdXNlIiwiYXV0b3BsYXlUaW1lb3V0IiwiYXV0b3BsYXlTcGVlZCIsIl9nZXROZXh0VGltZW91dCIsIl9pbml0aWFsaXplZCIsIl9wYWdlcyIsIl9jb250cm9scyIsIl90ZW1wbGF0ZXMiLCJfb3ZlcnJpZGVzIiwiZG90c0RhdGEiLCJkb3RDbGFzcyIsInBvcCIsImRyYXciLCJuYXYiLCJuYXZUZXh0IiwibmF2U3BlZWQiLCJuYXZFbGVtZW50IiwibmF2Q29udGFpbmVyIiwibmF2Q29udGFpbmVyQ2xhc3MiLCJuYXZDbGFzcyIsInNsaWRlQnkiLCJkb3RzQ2xhc3MiLCJkb3RzIiwiZG90c0VhY2giLCJkb3RzU3BlZWQiLCJkb3RzQ29udGFpbmVyIiwiJHJlbGF0aXZlIiwiJHByZXZpb3VzIiwiJG5leHQiLCJwcm9wIiwiJGFic29sdXRlIiwib3ZlcmlkZXMiLCJwYWdlIiwic2l6ZSIsImdldFBvc2l0aW9uIiwiTmF2aWdhdGlvbiIsIl9oYXNoZXMiLCJsb2NhdGlvbiIsImhhc2giLCJzdWJzdHJpbmciLCJVUkxoYXNoTGlzdGVuZXIiLCJIYXNoIiwiV2Via2l0QW5pbWF0aW9uIiwiTW96QW5pbWF0aW9uIiwiT0FuaW1hdGlvbiIsImNzc3RyYW5zZm9ybXMiLCJjc3N0cmFuc2Zvcm1zM2QiLCJjc3N0cmFuc2l0aW9ucyIsImNzc2FuaW1hdGlvbnMiLCJTdHJpbmciLCJldiIsImlubmVySFRNTCIsInRyaWdnZXJIYW5kbGVyIiwic3QiLCJjYWxsYmFja3MiLCJpc0FycmF5IiwiY3VyclRlbXBsYXRlIiwiY2xvc2VCdG4iLCJjbG9zZU1hcmt1cCIsInRDbG9zZSIsIm1hZ25pZmljUG9wdXAiLCJpc0xvd0lFIiwiaXNJRTgiLCJpc0FuZHJvaWQiLCJpc0lPUyIsInN1cHBvcnRzVHJhbnNpdGlvbiIsInByb2JhYmx5TW9iaWxlIiwicG9wdXBzQ2FjaGUiLCJvcGVuIiwiaXNPYmoiLCJwYXJzZWQiLCJlbCIsImlzT3BlbiIsInVwZGF0ZUl0ZW1IVE1MIiwidHlwZXMiLCJtYWluRWwiLCJmaXhlZENvbnRlbnRQb3MiLCJtb2RhbCIsImNsb3NlT25Db250ZW50Q2xpY2siLCJjbG9zZU9uQmdDbGljayIsInNob3dDbG9zZUJ0biIsImVuYWJsZUVzY2FwZUtleSIsImJnT3ZlcmxheSIsIl9jaGVja0lmQ2xvc2UiLCJjb250ZW50Q29udGFpbmVyIiwicHJlbG9hZGVyIiwidExvYWRpbmciLCJtb2R1bGVzIiwiY2xvc2VCdG5JbnNpZGUiLCJjbG9zZV9yZXBsYWNlV2l0aCIsImFsaWduVG9wIiwiZml4ZWRCZ1BvcyIsImtleUNvZGUiLCJ1cGRhdGVTaXplIiwid0giLCJfaGFzU2Nyb2xsQmFyIiwiX2dldFNjcm9sbGJhclNpemUiLCJpc0lFNyIsIm1haW5DbGFzcyIsIl9hZGRDbGFzc1RvTUZQIiwiX2xhc3RGb2N1c2VkRWwiLCJhY3RpdmVFbGVtZW50IiwiX3NldEZvY3VzIiwiX29uRm9jdXNJbiIsInJlbW92YWxEZWxheSIsIl9jbG9zZSIsIl9yZW1vdmVDbGFzc0Zyb21NRlAiLCJjdXJySXRlbSIsImF1dG9Gb2N1c0xhc3QiLCJwcmV2SGVpZ2h0IiwicGFyc2VFbCIsIm1hcmt1cCIsImFwcGVuZENvbnRlbnQiLCJwcmVsb2FkZWQiLCJwcmVwZW5kIiwiYWRkR3JvdXAiLCJtZnBFbCIsIl9vcGVuQ2xpY2siLCJkZWxlZ2F0ZSIsIm1pZENsaWNrIiwiY3RybEtleSIsIm1ldGFLZXkiLCJhbHRLZXkiLCJzaGlmdEtleSIsImRpc2FibGVPbiIsImlzRnVuY3Rpb24iLCJ1cGRhdGVTdGF0dXMiLCJzdGF0dXMiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJfcGFyc2VNYXJrdXAiLCJyZXBsYWNlV2l0aCIsInNjcm9sbGJhclNpemUiLCJwcm90byIsInJlZ2lzdGVyTW9kdWxlIiwicGFyc2VJbnQiLCJoaWRkZW5DbGFzcyIsInROb3RGb3VuZCIsImluaXRJbmxpbmUiLCJnZXRJbmxpbmUiLCJpbmxpbmUiLCJpbmxpbmVFbGVtZW50IiwicmVxIiwiYWJvcnQiLCJjdXJzb3IiLCJ0RXJyb3IiLCJpbml0QWpheCIsImdldEFqYXgiLCJ4aHIiLCJlcnJvciIsImxvYWRFcnJvciIsImltYWdlIiwidGl0bGVTcmMiLCJ2ZXJ0aWNhbEZpdCIsImluaXRJbWFnZSIsInJlc2l6ZUltYWdlIiwiaW1nIiwiX29uSW1hZ2VIYXNTaXplIiwiaGFzU2l6ZSIsImlzQ2hlY2tpbmdJbWdTaXplIiwiaW1nSGlkZGVuIiwiZmluZEltYWdlU2l6ZSIsIm5hdHVyYWxXaWR0aCIsImdldEltYWdlIiwiY29tcGxldGUiLCJsb2FkZWQiLCJhbHQiLCJjbG9uZSIsImltZ19yZXBsYWNlV2l0aCIsImxvYWRpbmciLCJNb3pUcmFuc2Zvcm0iLCJlYXNpbmciLCJvcGVuZXIiLCJpbml0Wm9vbSIsInpvb20iLCJ6SW5kZXgiLCJfYWxsb3dab29tIiwiX2dldEl0ZW1Ub1pvb20iLCJfZ2V0T2Zmc2V0Iiwic3JjQWN0aW9uIiwicGF0dGVybnMiLCJ5b3V0dWJlIiwidmltZW8iLCJnbWFwcyIsImluaXRJZnJhbWUiLCJnZXRJZnJhbWUiLCJpZnJhbWUiLCJhcnJvd01hcmt1cCIsInByZWxvYWQiLCJuYXZpZ2F0ZUJ5SW1nQ2xpY2siLCJhcnJvd3MiLCJ0UHJldiIsInROZXh0IiwidENvdW50ZXIiLCJpbml0R2FsbGVyeSIsImdhbGxlcnkiLCJjb3VudGVyIiwiYXJyb3dMZWZ0IiwiYXJyb3dSaWdodCIsIl9wcmVsb2FkVGltZW91dCIsInByZWxvYWROZWFyYnlJbWFnZXMiLCJnb1RvIiwiX3ByZWxvYWRJdGVtIiwicmVwbGFjZVNyYyIsInJhdGlvIiwiaW5pdFJldGluYSIsInJldGluYSIsInJlc2l6ZWRBdHRhY2hlZCIsInJlc2l6ZVNlbnNvciIsImZpeGVkIiwiYWJzb2x1dGUiLCJjaGlsZE5vZGVzIiwic2Nyb2xsTGVmdCIsInNjcm9sbFdpZHRoIiwiRWxlbWVudHMiLCJSZXNpemVTZW5zb3IiLCJ0aGVpYVN0aWNreVNpZGViYXIiLCJpbml0aWFsaXplZCIsIm1pbldpZHRoIiwiZml4ZWRTY3JvbGxUb3AiLCJzaWRlYmFyIiwic3RpY2t5U2lkZWJhciIsImNvbnRhaW5lclNlbGVjdG9yIiwiZGVmYXVsdFBvc2l0aW9uIiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJvdXRlckhlaWdodCIsInN0aWNreVNpZGViYXJQYWRkaW5nVG9wIiwic3RpY2t5U2lkZWJhclBhZGRpbmdCb3R0b20iLCJwcmV2aW91c1Njcm9sbFRvcCIsIm9uU2Nyb2xsIiwiZGlzYWJsZU9uUmVzcG9uc2l2ZUxheW91dHMiLCJvdXRlcldpZHRoIiwiYWRkaXRpb25hbE1hcmdpblRvcCIsImFkZGl0aW9uYWxNYXJnaW5Cb3R0b20iLCJzaWRlYmFyQmVoYXZpb3IiLCJ1cGRhdGVTaWRlYmFySGVpZ2h0IiwibG9nIiwidW5iaW5kIiwiX3N0YXRlIiwiX2RlZmF1bHRzIiwiY2xhc3NIb2xkZXIiLCJjbGFzc0hvbGRlckRpc2FibGVkIiwiY2xhc3NTZWxlY3RvciIsImNsYXNzT3B0aW9ucyIsImNsYXNzR3JvdXAiLCJjbGFzc1N1YiIsImNsYXNzRGlzYWJsZWQiLCJjbGFzc1RvZ2dsZU9wZW4iLCJjbGFzc1RvZ2dsZSIsImNsYXNzRm9jdXMiLCJlZmZlY3QiLCJvbkNoYW5nZSIsIm9uT3BlbiIsIm9uQ2xvc2UiLCJfaXNPcGVuU2VsZWN0Ym94IiwiX2dldEluc3QiLCJfaXNEaXNhYmxlZFNlbGVjdGJveCIsImlzRGlzYWJsZWQiLCJfYXR0YWNoU2VsZWN0Ym94IiwiX2Nsb3NlU2VsZWN0Ym94Iiwic3ViIiwiaHJlZiIsInZhbCIsInJlbCIsIl9jaGFuZ2VTZWxlY3Rib3giLCJzaWJsaW5ncyIsIl9uZXdJbnN0IiwidWlkIiwidGFiaW5kZXgiLCJfb3BlblNlbGVjdGJveCIsImZpcnN0IiwiY2hhckNvZGUiLCJwcmV2QWxsIiwibmV4dEFsbCIsIm1vdXNlZG93biIsIl9kZXRhY2hTZWxlY3Rib3giLCJfZ2V0IiwiaW5wdXQiLCJfZW5hYmxlU2VsZWN0Ym94IiwiX2Rpc2FibGVTZWxlY3Rib3giLCJfb3B0aW9uU2VsZWN0Ym94IiwibWF4SGVpZ2h0IiwiZmFkZUluIiwic2xpZGVEb3duIiwiZmFkZU91dCIsInNsaWRlVXAiLCJzZWxlY3Rib3giLCJ2ZXJzaW9uIiwic3RpY2tfaW5fcGFyZW50Iiwic3RpY2t5X2NsYXNzIiwiaW5uZXJfc2Nyb2xsaW5nIiwicmVjYWxjX2V2ZXJ5Iiwib2Zmc2V0X3RvcCIsInNwYWNlciIsImJvdHRvbWluZyIsIl9pbmRldGVybWluYXRlIiwiX3VwZGF0ZSIsImluZGV0ZXJtaW5hdGUiLCJfZGV0ZXJtaW5hdGUiLCJfY2FsbGJhY2siLCJfdHlwZSIsIl9jdXJzb3IiLCJfYWRkIiwiX3JlbW92ZSIsIl9sYWJlbCIsIl9jbGljayIsIl90b3VjaCIsIl9tb2JpbGUiLCJjaGVja2VkQ2xhc3MiLCJkaXNhYmxlZENsYXNzIiwiaW5kZXRlcm1pbmF0ZUNsYXNzIiwibGFiZWxIb3ZlciIsImhvdmVyQ2xhc3MiLCJmb2N1c0NsYXNzIiwiYWN0aXZlQ2xhc3MiLCJsYWJlbEhvdmVyQ2xhc3MiLCJpbmNyZWFzZUFyZWEiLCJiYWNrZ3JvdW5kIiwiYm9yZGVyIiwiY2hlY2tib3hDbGFzcyIsInJhZGlvQ2xhc3MiLCJhcmlhIiwiaW5zZXJ0IiwiaW5oZXJpdENsYXNzIiwiaW5oZXJpdElEIiwicm9vdCIsImZhY3RvcnkiLCJnbGJsIiwiJHduZHciLCIkZG9jdSIsIiRodG1sIiwiJGJvZHkiLCJtbSIsInVtbSIsIl9jIiwiX2QiLCJfZSIsIiRtZW51IiwiX2FwaSIsIm9wdHMiLCJjb25mIiwidmFycyIsImNiY2siLCJtdGNoIiwiX19fZGVwcmVjYXRlZCIsIl9pbml0QWRkb25zIiwiX2luaXRFeHRlbnNpb25zIiwiX2luaXRNZW51IiwiX2luaXRQYW5lbHMiLCJfaW5pdE9wZW5lZCIsIl9pbml0QW5jaG9ycyIsIl9pbml0TWF0Y2hNZWRpYSIsIl9fX2RlYnVnIiwiYWRkb25zIiwidW5pcXVlSWQiLCJleHRlbnNpb25zIiwiaW5pdE1lbnUiLCJpbml0UGFuZWxzIiwibmF2YmFyIiwidGl0bGVMaW5rIiwib25DbGljayIsInNldFNlbGVjdGVkIiwic2xpZGluZ1N1Ym1lbnVzIiwiY29uZmlndXJhdGlvbiIsImNsYXNzTmFtZXMiLCJkaXZpZGVyIiwiaW5zZXQiLCJub2xpc3R2aWV3Iiwibm9wYW5lbCIsInBhbmVsIiwic2VsZWN0ZWQiLCJ2ZXJ0aWNhbCIsIm9wZW5pbmdJbnRlcnZhbCIsInBhbmVsTm9kZXR5cGUiLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJnZXRJbnN0YW5jZSIsIm9wZW5QYW5lbCIsIm9wZW5lZCIsIiRwbmxzIiwic3Vib3BlbmVkIiwiaGlnaGVzdCIsIm9wZW5QYW5lbFN0YXJ0Iiwib3BlblBhbmVsRmluaXNoIiwibm9hbmltYXRpb24iLCJfX3RyYW5zaXRpb25lbmQiLCJjbG9zZVBhbmVsIiwiY2xvc2VBbGxQYW5lbHMiLCJsaXN0dmlldyIsInRvZ2dsZVBhbmVsIiwibWF0Y2hNZWRpYSIsInllcyIsIm5vIiwiJG9yaWciLCJfX2dldFVuaXF1ZUlkIiwicGFuZWxzIiwibWVudSIsIndyYXBwZXIiLCJfaW5pdFBhbmVsIiwiX2luaXROYXZiYXIiLCJfaW5pdExpc3R2aWV3IiwicGFuZWxOb2RlVHlwZSIsIl9fcmVmYWN0b3JDbGFzcyIsImNoaWxkIiwiaTE4biIsImJ0biIsImhhc25hdmJhciIsIl9fY2hpbGRBZGRCYWNrIiwiaW5zZXJ0QmVmb3JlIiwiZnVsbHN1Ym9wZW4iLCJsYXN0IiwiY2xpY2tBbmNob3IiLCJfX3ZhbHVlT3JGbiIsIm9mZkNhbnZhcyIsIl9maXJlTWF0Y2hNZWRpYSIsInJlc2l6ZSIsIm1hdGNoZXMiLCJfZ2V0T3JpZ2luYWxNZW51SWQiLCJfX2FwaSIsIl9fZmluZEFkZEJhY2siLCJfX2ZpbHRlckxpc3RJdGVtcyIsIl9fZmlsdGVyTGlzdEl0ZW1BbmNob3JzIiwidHJhbnNpdGlvbmVuZCIsIndlYmtpdFRyYW5zaXRpb25FbmQiLCJ0b3VjaCIsIm1zTWF4VG91Y2hQb2ludHMiLCJNb2Rlcm5penIiLCJ6cG9zaXRpb24iLCJwYWdlU2VsZWN0b3IiLCJwYWdlTm9kZXR5cGUiLCJvZmZjYW52YXMiLCJzZXRQYWdlIiwiJHBhZ2UiLCJfaW5pdEJsb2NrZXIiLCJtZW51SW5zZXJ0TWV0aG9kIiwibWVudUluc2VydFNlbGVjdG9yIiwiX19zcl9hcmlhIiwiYmxvY2tVSSIsIm1vdmVCYWNrZ3JvdW5kIiwibm9QYWdlU2VsZWN0b3IiLCJ3cmFwUGFnZUlmTmVlZGVkIiwiX29wZW5TZXR1cCIsIl9vcGVuRmluaXNoIiwiY2xvc2VBbGxPdGhlcnMiLCJibG9ja2luZyIsIm9wZW5pbmciLCJ3cmFwQWxsIiwic2xpZGVvdXQiLCJrZXlkb3duIiwiJGJsY2siLCJibG9ja2VyIiwidG91Y2hzdGFydCIsInRvdWNobW92ZSIsImZpeCIsIm9yaWVudGF0aW9uY2hhbmdlIiwiY2xvc2VTdWJtZW51IiwiX19zcl90ZXh0IiwiY2xvc2VNZW51Iiwib3BlblN1Ym1lbnUiLCJ0b2dnbGVTdWJtZW51Iiwic3Jvbmx5IiwiYXV0b2hlaWdodCIsIm1lYXN1cmVoZWlnaHQiLCJoaXN0b3J5IiwicHVzaFN0YXRlIiwiYWRkVG8iLCJ2aXNpYmxlIiwiY29sdW1ucyIsImNvbGxhcHNlZCIsImNvbGxhcHNlIiwibmV4dFVudGlsIiwid3JhcElubmVyIiwiJGZpeGVkZGl2aWRlciIsImZpeGVkZGl2aWRlciIsImhhc2RpdmlkZXJzIiwic2Nyb2xsIiwidW5jb2xsYXBzZWQiLCJldmVudHMiLCJ0eXBlTG93ZXIiLCJ0eXBlVXBwZXIiLCJvcGVuX2RpciIsImNsb3NlX2RpciIsIm5lZ2F0aXZlIiwibWF4U3RhcnRQb3MiLCJub2RlIiwiSGFtbWVyIiwiaGFtbWVyIiwiJHNsaWRlT3V0Tm9kZXMiLCJ0aHJlc2hvbGQiLCJwZXJjIiwiVkVSU0lPTiIsImRyb3AiLCJvZiIsImRyb3Bkb3duIiwibW91c2VlbnRlciIsIm1vdXNlbGVhdmUiLCJidXR0b24iLCJ0aXBsZWZ0IiwidGlwcmlnaHQiLCJ0aXB0b3AiLCJ0aXBib3R0b20iLCJlbGVtSW5zZXJ0TWV0aG9kIiwiZWxlbUluc2VydFNlbGVjdG9yIiwic3RpY2t5IiwiaWNvbnBhbmVsIiwic3ViYmxvY2tlciIsInRhYnN0YXJ0IiwidGFiZW5kIiwiZW5oYW5jZSIsImtleWJvYXJkZm9jdXMiLCJmb2N1c2luIiwibGF6eXN1Ym1lbnUiLCJuYXZiYXJzIiwiaGFzYnRucyIsImJyZWFkY3J1bWJTZXBhcmF0b3IiLCJicmVhZGNydW1icyIsInVuc2hpZnQiLCJzZXBhcmF0b3IiLCJzY3JlZW5SZWFkZXIiLCJwYW5lbE5leHQiLCJwYW5lbFByZXYiLCJzZWFyY2hmaWVsZCIsInBhbmVsVGl0bGUiLCJzY3JvbGxPZmZzZXQiLCJ1cGRhdGVPZmZzZXQiLCJ1c2UiLCJyZXN1bHRzUGFuZWwiLCJibHVyIiwiZm9ybSIsInN1Ym1pdCIsInBsYWNlaG9sZGVyIiwia2V5dXAiLCJoYXNzZWFyY2giLCJub1Jlc3VsdHMiLCJub3Jlc3VsdHNtc2ciLCJzaG93U3ViUGFuZWxzIiwicmVzdWx0c3BhbmVsIiwiZnVsbHN1Ym9wZW5zZWFyY2giLCJzaG93VGV4dEl0ZW1zIiwic2VhcmNodGV4dCIsIm5vc3VicmVzdWx0cyIsImRpdmlkZXJzIiwiY2hhbmdlIiwiaGFzaW5kZXhlciIsIiRpbmRleGVyIiwiaW5kZXhlciIsIm1vdXNlb3ZlciIsImhvdmVyIiwiaG92ZXJzZWxlY3RlZCIsInBhcmVudHNlbGVjdGVkIiwiY2hlY2siXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7O0FBSUcsQ0FBQyxVQUFTQSxDQUFULEVBQVdDLENBQVgsRUFBYTtBQUFDLDRDQUFpQkMsT0FBakIsTUFBMEIsZUFBYSxPQUFPQyxNQUE5QyxHQUFxREEsTUFBTSxDQUFDRCxPQUFQLEdBQWVELENBQUMsRUFBckUsR0FBd0UsUUFBc0NHLG9DQUFPSCxDQUFEO0FBQUE7QUFBQTtBQUFBO0FB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c2pDLFdBQUssRUFBQztBQUF2QixLQUF6dUI7QUFBeXdCLFFBQUlyMkMsQ0FBSixFQUFNSyxDQUFOLEVBQVFVLENBQVIsRUFBVXpCLENBQVY7QUFBWSxHQUEzekIsQ0FBNHpCMk8sTUFBNXpCLENBbEtBO0FBbUtBLFNBQU8sSUFBUDtBQUNDLENBOUtDLENBQUQsQyIsImZpbGUiOiIuL3Jlc291cmNlcy9qcy9jb21tb25fc2NyaXB0cy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5QT1BQRVIuTUlOLkpTXG4gQ29weXJpZ2h0IChDKSBGZWRlcmljbyBaaXZvbG8gMjAxN1xuIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAobGljZW5zZSB0ZXJtcyBhcmUgYXQgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVCkuXG4gKi8oZnVuY3Rpb24oZSx0KXsnb2JqZWN0Jz09dHlwZW9mIGV4cG9ydHMmJid1bmRlZmluZWQnIT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQoKTonZnVuY3Rpb24nPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZSh0KTplLlBvcHBlcj10KCl9KSh0aGlzLGZ1bmN0aW9uKCl7J3VzZSBzdHJpY3QnO2Z1bmN0aW9uIGUoZSl7cmV0dXJuIGUmJidbb2JqZWN0IEZ1bmN0aW9uXSc9PT17fS50b1N0cmluZy5jYWxsKGUpfWZ1bmN0aW9uIHQoZSx0KXtpZigxIT09ZS5ub2RlVHlwZSlyZXR1cm5bXTt2YXIgbz13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlLG51bGwpO3JldHVybiB0P29bdF06b31mdW5jdGlvbiBvKGUpe3JldHVybidIVE1MJz09PWUubm9kZU5hbWU/ZTplLnBhcmVudE5vZGV8fGUuaG9zdH1mdW5jdGlvbiBuKGUpe2lmKCFlfHwtMSE9PVsnSFRNTCcsJ0JPRFknLCcjZG9jdW1lbnQnXS5pbmRleE9mKGUubm9kZU5hbWUpKXJldHVybiB3aW5kb3cuZG9jdW1lbnQuYm9keTt2YXIgaT10KGUpLHI9aS5vdmVyZmxvdyxwPWkub3ZlcmZsb3dYLHM9aS5vdmVyZmxvd1k7cmV0dXJuIC8oYXV0b3xzY3JvbGwpLy50ZXN0KHIrcytwKT9lOm4obyhlKSl9ZnVuY3Rpb24gcihlKXt2YXIgbz1lJiZlLm9mZnNldFBhcmVudCxpPW8mJm8ubm9kZU5hbWU7cmV0dXJuIGkmJidCT0RZJyE9PWkmJidIVE1MJyE9PWk/LTEhPT1bJ1REJywnVEFCTEUnXS5pbmRleE9mKG8ubm9kZU5hbWUpJiYnc3RhdGljJz09PXQobywncG9zaXRpb24nKT9yKG8pOm86d2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudH1mdW5jdGlvbiBwKGUpe3ZhciB0PWUubm9kZU5hbWU7cmV0dXJuJ0JPRFknIT09dCYmKCdIVE1MJz09PXR8fHIoZS5maXJzdEVsZW1lbnRDaGlsZCk9PT1lKX1mdW5jdGlvbiBzKGUpe3JldHVybiBudWxsPT09ZS5wYXJlbnROb2RlP2U6cyhlLnBhcmVudE5vZGUpfWZ1bmN0aW9uIGQoZSx0KXtpZighZXx8IWUubm9kZVR5cGV8fCF0fHwhdC5ub2RlVHlwZSlyZXR1cm4gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDt2YXIgbz1lLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHQpJk5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HLGk9bz9lOnQsbj1vP3Q6ZSxhPWRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7YS5zZXRTdGFydChpLDApLGEuc2V0RW5kKG4sMCk7dmFyIGY9YS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtpZihlIT09ZiYmdCE9PWZ8fGkuY29udGFpbnMobikpcmV0dXJuIHAoZik/ZjpyKGYpO3ZhciBsPXMoZSk7cmV0dXJuIGwuaG9zdD9kKGwuaG9zdCx0KTpkKGUscyh0KS5ob3N0KX1mdW5jdGlvbiBhKGUpe3ZhciB0PTE8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTondG9wJyxvPSd0b3AnPT09dD8nc2Nyb2xsVG9wJzonc2Nyb2xsTGVmdCcsaT1lLm5vZGVOYW1lO2lmKCdCT0RZJz09PWl8fCdIVE1MJz09PWkpe3ZhciBuPXdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQscj13aW5kb3cuZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudHx8bjtyZXR1cm4gcltvXX1yZXR1cm4gZVtvXX1mdW5jdGlvbiBmKGUsdCl7dmFyIG89Mjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXSxpPWEodCwndG9wJyksbj1hKHQsJ2xlZnQnKSxyPW8/LTE6MTtyZXR1cm4gZS50b3ArPWkqcixlLmJvdHRvbSs9aSpyLGUubGVmdCs9bipyLGUucmlnaHQrPW4qcixlfWZ1bmN0aW9uIGwoZSx0KXt2YXIgbz0neCc9PT10PydMZWZ0JzonVG9wJyxpPSdMZWZ0Jz09bz8nUmlnaHQnOidCb3R0b20nO3JldHVybitlWydib3JkZXInK28rJ1dpZHRoJ10uc3BsaXQoJ3B4JylbMF0rICtlWydib3JkZXInK2krJ1dpZHRoJ10uc3BsaXQoJ3B4JylbMF19ZnVuY3Rpb24gbShlLHQsbyxpKXtyZXR1cm4gXyh0WydvZmZzZXQnK2VdLG9bJ2NsaWVudCcrZV0sb1snb2Zmc2V0JytlXSxpZSgpP29bJ29mZnNldCcrZV0raVsnbWFyZ2luJysoJ0hlaWdodCc9PT1lPydUb3AnOidMZWZ0JyldK2lbJ21hcmdpbicrKCdIZWlnaHQnPT09ZT8nQm90dG9tJzonUmlnaHQnKV06MCl9ZnVuY3Rpb24gaCgpe3ZhciBlPXdpbmRvdy5kb2N1bWVudC5ib2R5LHQ9d2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxvPWllKCkmJndpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHQpO3JldHVybntoZWlnaHQ6bSgnSGVpZ2h0JyxlLHQsbyksd2lkdGg6bSgnV2lkdGgnLGUsdCxvKX19ZnVuY3Rpb24gYyhlKXtyZXR1cm4gc2Uoe30sZSx7cmlnaHQ6ZS5sZWZ0K2Uud2lkdGgsYm90dG9tOmUudG9wK2UuaGVpZ2h0fSl9ZnVuY3Rpb24gZyhlKXt2YXIgbz17fTtpZihpZSgpKXRyeXtvPWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7dmFyIGk9YShlLCd0b3AnKSxuPWEoZSwnbGVmdCcpO28udG9wKz1pLG8ubGVmdCs9bixvLmJvdHRvbSs9aSxvLnJpZ2h0Kz1ufWNhdGNoKGUpe31lbHNlIG89ZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTt2YXIgcj17bGVmdDpvLmxlZnQsdG9wOm8udG9wLHdpZHRoOm8ucmlnaHQtby5sZWZ0LGhlaWdodDpvLmJvdHRvbS1vLnRvcH0scD0nSFRNTCc9PT1lLm5vZGVOYW1lP2goKTp7fSxzPXAud2lkdGh8fGUuY2xpZW50V2lkdGh8fHIucmlnaHQtci5sZWZ0LGQ9cC5oZWlnaHR8fGUuY2xpZW50SGVpZ2h0fHxyLmJvdHRvbS1yLnRvcCxmPWUub2Zmc2V0V2lkdGgtcyxtPWUub2Zmc2V0SGVpZ2h0LWQ7aWYoZnx8bSl7dmFyIGc9dChlKTtmLT1sKGcsJ3gnKSxtLT1sKGcsJ3knKSxyLndpZHRoLT1mLHIuaGVpZ2h0LT1tfXJldHVybiBjKHIpfWZ1bmN0aW9uIHUoZSxvKXt2YXIgaT1pZSgpLHI9J0hUTUwnPT09by5ub2RlTmFtZSxwPWcoZSkscz1nKG8pLGQ9bihlKSxhPXQobyksbD0rYS5ib3JkZXJUb3BXaWR0aC5zcGxpdCgncHgnKVswXSxtPSthLmJvcmRlckxlZnRXaWR0aC5zcGxpdCgncHgnKVswXSxoPWMoe3RvcDpwLnRvcC1zLnRvcC1sLGxlZnQ6cC5sZWZ0LXMubGVmdC1tLHdpZHRoOnAud2lkdGgsaGVpZ2h0OnAuaGVpZ2h0fSk7aWYoaC5tYXJnaW5Ub3A9MCxoLm1hcmdpbkxlZnQ9MCwhaSYmcil7dmFyIHU9K2EubWFyZ2luVG9wLnNwbGl0KCdweCcpWzBdLGI9K2EubWFyZ2luTGVmdC5zcGxpdCgncHgnKVswXTtoLnRvcC09bC11LGguYm90dG9tLT1sLXUsaC5sZWZ0LT1tLWIsaC5yaWdodC09bS1iLGgubWFyZ2luVG9wPXUsaC5tYXJnaW5MZWZ0PWJ9cmV0dXJuKGk/by5jb250YWlucyhkKTpvPT09ZCYmJ0JPRFknIT09ZC5ub2RlTmFtZSkmJihoPWYoaCxvKSksaH1mdW5jdGlvbiBiKGUpe3ZhciB0PXdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsbz11KGUsdCksaT1fKHQuY2xpZW50V2lkdGgsd2luZG93LmlubmVyV2lkdGh8fDApLG49Xyh0LmNsaWVudEhlaWdodCx3aW5kb3cuaW5uZXJIZWlnaHR8fDApLHI9YSh0KSxwPWEodCwnbGVmdCcpLHM9e3RvcDpyLW8udG9wK28ubWFyZ2luVG9wLGxlZnQ6cC1vLmxlZnQrby5tYXJnaW5MZWZ0LHdpZHRoOmksaGVpZ2h0Om59O3JldHVybiBjKHMpfWZ1bmN0aW9uIHkoZSl7dmFyIGk9ZS5ub2RlTmFtZTtyZXR1cm4nQk9EWSc9PT1pfHwnSFRNTCc9PT1pPyExOidmaXhlZCc9PT10KGUsJ3Bvc2l0aW9uJyl8fHkobyhlKSl9ZnVuY3Rpb24gdyhlLHQsaSxyKXt2YXIgcD17dG9wOjAsbGVmdDowfSxzPWQoZSx0KTtpZigndmlld3BvcnQnPT09cilwPWIocyk7ZWxzZXt2YXIgYTsnc2Nyb2xsUGFyZW50Jz09PXI/KGE9bihvKGUpKSwnQk9EWSc9PT1hLm5vZGVOYW1lJiYoYT13aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSk6J3dpbmRvdyc9PT1yP2E9d2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDphPXI7dmFyIGY9dShhLHMpO2lmKCdIVE1MJz09PWEubm9kZU5hbWUmJiF5KHMpKXt2YXIgbD1oKCksbT1sLmhlaWdodCxjPWwud2lkdGg7cC50b3ArPWYudG9wLWYubWFyZ2luVG9wLHAuYm90dG9tPW0rZi50b3AscC5sZWZ0Kz1mLmxlZnQtZi5tYXJnaW5MZWZ0LHAucmlnaHQ9YytmLmxlZnR9ZWxzZSBwPWZ9cmV0dXJuIHAubGVmdCs9aSxwLnRvcCs9aSxwLnJpZ2h0LT1pLHAuYm90dG9tLT1pLHB9ZnVuY3Rpb24gdihlKXt2YXIgdD1lLndpZHRoLG89ZS5oZWlnaHQ7cmV0dXJuIHQqb31mdW5jdGlvbiBFKGUsdCxvLGksbil7dmFyIHI9NTxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbNV0/YXJndW1lbnRzWzVdOjA7aWYoLTE9PT1lLmluZGV4T2YoJ2F1dG8nKSlyZXR1cm4gZTt2YXIgcD13KG8saSxyLG4pLHM9e3RvcDp7d2lkdGg6cC53aWR0aCxoZWlnaHQ6dC50b3AtcC50b3B9LHJpZ2h0Ont3aWR0aDpwLnJpZ2h0LXQucmlnaHQsaGVpZ2h0OnAuaGVpZ2h0fSxib3R0b206e3dpZHRoOnAud2lkdGgsaGVpZ2h0OnAuYm90dG9tLXQuYm90dG9tfSxsZWZ0Ont3aWR0aDp0LmxlZnQtcC5sZWZ0LGhlaWdodDpwLmhlaWdodH19LGQ9T2JqZWN0LmtleXMocykubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBzZSh7a2V5OmV9LHNbZV0se2FyZWE6dihzW2VdKX0pfSkuc29ydChmdW5jdGlvbihlLHQpe3JldHVybiB0LmFyZWEtZS5hcmVhfSksYT1kLmZpbHRlcihmdW5jdGlvbihlKXt2YXIgdD1lLndpZHRoLGk9ZS5oZWlnaHQ7cmV0dXJuIHQ+PW8uY2xpZW50V2lkdGgmJmk+PW8uY2xpZW50SGVpZ2h0fSksZj0wPGEubGVuZ3RoP2FbMF0ua2V5OmRbMF0ua2V5LGw9ZS5zcGxpdCgnLScpWzFdO3JldHVybiBmKyhsPyctJytsOicnKX1mdW5jdGlvbiB4KGUsdCxvKXt2YXIgaT1kKHQsbyk7cmV0dXJuIHUobyxpKX1mdW5jdGlvbiBPKGUpe3ZhciB0PXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUpLG89cGFyc2VGbG9hdCh0Lm1hcmdpblRvcCkrcGFyc2VGbG9hdCh0Lm1hcmdpbkJvdHRvbSksaT1wYXJzZUZsb2F0KHQubWFyZ2luTGVmdCkrcGFyc2VGbG9hdCh0Lm1hcmdpblJpZ2h0KSxuPXt3aWR0aDplLm9mZnNldFdpZHRoK2ksaGVpZ2h0OmUub2Zmc2V0SGVpZ2h0K299O3JldHVybiBufWZ1bmN0aW9uIEwoZSl7dmFyIHQ9e2xlZnQ6J3JpZ2h0JyxyaWdodDonbGVmdCcsYm90dG9tOid0b3AnLHRvcDonYm90dG9tJ307cmV0dXJuIGUucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csZnVuY3Rpb24oZSl7cmV0dXJuIHRbZV19KX1mdW5jdGlvbiBTKGUsdCxvKXtvPW8uc3BsaXQoJy0nKVswXTt2YXIgaT1PKGUpLG49e3dpZHRoOmkud2lkdGgsaGVpZ2h0OmkuaGVpZ2h0fSxyPS0xIT09WydyaWdodCcsJ2xlZnQnXS5pbmRleE9mKG8pLHA9cj8ndG9wJzonbGVmdCcscz1yPydsZWZ0JzondG9wJyxkPXI/J2hlaWdodCc6J3dpZHRoJyxhPXI/J3dpZHRoJzonaGVpZ2h0JztyZXR1cm4gbltwXT10W3BdK3RbZF0vMi1pW2RdLzIsbltzXT1vPT09cz90W3NdLWlbYV06dFtMKHMpXSxufWZ1bmN0aW9uIFQoZSx0KXtyZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbmQ/ZS5maW5kKHQpOmUuZmlsdGVyKHQpWzBdfWZ1bmN0aW9uIEMoZSx0LG8pe2lmKEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgpcmV0dXJuIGUuZmluZEluZGV4KGZ1bmN0aW9uKGUpe3JldHVybiBlW3RdPT09b30pO3ZhciBpPVQoZSxmdW5jdGlvbihlKXtyZXR1cm4gZVt0XT09PW99KTtyZXR1cm4gZS5pbmRleE9mKGkpfWZ1bmN0aW9uIE4odCxvLGkpe3ZhciBuPXZvaWQgMD09PWk/dDp0LnNsaWNlKDAsQyh0LCduYW1lJyxpKSk7cmV0dXJuIG4uZm9yRWFjaChmdW5jdGlvbih0KXt0LmZ1bmN0aW9uJiZjb25zb2xlLndhcm4oJ2Btb2RpZmllci5mdW5jdGlvbmAgaXMgZGVwcmVjYXRlZCwgdXNlIGBtb2RpZmllci5mbmAhJyk7dmFyIGk9dC5mdW5jdGlvbnx8dC5mbjt0LmVuYWJsZWQmJmUoaSkmJihvLm9mZnNldHMucG9wcGVyPWMoby5vZmZzZXRzLnBvcHBlciksby5vZmZzZXRzLnJlZmVyZW5jZT1jKG8ub2Zmc2V0cy5yZWZlcmVuY2UpLG89aShvLHQpKX0pLG99ZnVuY3Rpb24gaygpe2lmKCF0aGlzLnN0YXRlLmlzRGVzdHJveWVkKXt2YXIgZT17aW5zdGFuY2U6dGhpcyxzdHlsZXM6e30sYXR0cmlidXRlczp7fSxmbGlwcGVkOiExLG9mZnNldHM6e319O2Uub2Zmc2V0cy5yZWZlcmVuY2U9eCh0aGlzLnN0YXRlLHRoaXMucG9wcGVyLHRoaXMucmVmZXJlbmNlKSxlLnBsYWNlbWVudD1FKHRoaXMub3B0aW9ucy5wbGFjZW1lbnQsZS5vZmZzZXRzLnJlZmVyZW5jZSx0aGlzLnBvcHBlcix0aGlzLnJlZmVyZW5jZSx0aGlzLm9wdGlvbnMubW9kaWZpZXJzLmZsaXAuYm91bmRhcmllc0VsZW1lbnQsdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpLGUub3JpZ2luYWxQbGFjZW1lbnQ9ZS5wbGFjZW1lbnQsZS5vZmZzZXRzLnBvcHBlcj1TKHRoaXMucG9wcGVyLGUub2Zmc2V0cy5yZWZlcmVuY2UsZS5wbGFjZW1lbnQpLGUub2Zmc2V0cy5wb3BwZXIucG9zaXRpb249J2Fic29sdXRlJyxlPU4odGhpcy5tb2RpZmllcnMsZSksdGhpcy5zdGF0ZS5pc0NyZWF0ZWQ/dGhpcy5vcHRpb25zLm9uVXBkYXRlKGUpOih0aGlzLnN0YXRlLmlzQ3JlYXRlZD0hMCx0aGlzLm9wdGlvbnMub25DcmVhdGUoZSkpfX1mdW5jdGlvbiBXKGUsdCl7cmV0dXJuIGUuc29tZShmdW5jdGlvbihlKXt2YXIgbz1lLm5hbWUsaT1lLmVuYWJsZWQ7cmV0dXJuIGkmJm89PT10fSl9ZnVuY3Rpb24gQihlKXtmb3IodmFyIHQ9WyExLCdtcycsJ1dlYmtpdCcsJ01veicsJ08nXSxvPWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKSxuPTA7bjx0Lmxlbmd0aC0xO24rKyl7dmFyIGk9dFtuXSxyPWk/JycraStvOmU7aWYoJ3VuZGVmaW5lZCchPXR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuYm9keS5zdHlsZVtyXSlyZXR1cm4gcn1yZXR1cm4gbnVsbH1mdW5jdGlvbiBEKCl7cmV0dXJuIHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQ9ITAsVyh0aGlzLm1vZGlmaWVycywnYXBwbHlTdHlsZScpJiYodGhpcy5wb3BwZXIucmVtb3ZlQXR0cmlidXRlKCd4LXBsYWNlbWVudCcpLHRoaXMucG9wcGVyLnN0eWxlLmxlZnQ9JycsdGhpcy5wb3BwZXIuc3R5bGUucG9zaXRpb249JycsdGhpcy5wb3BwZXIuc3R5bGUudG9wPScnLHRoaXMucG9wcGVyLnN0eWxlW0IoJ3RyYW5zZm9ybScpXT0nJyksdGhpcy5kaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKSx0aGlzLm9wdGlvbnMucmVtb3ZlT25EZXN0cm95JiZ0aGlzLnBvcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wcGVyKSx0aGlzfWZ1bmN0aW9uIEgoZSx0LG8saSl7dmFyIHI9J0JPRFknPT09ZS5ub2RlTmFtZSxwPXI/d2luZG93OmU7cC5hZGRFdmVudExpc3RlbmVyKHQsbyx7cGFzc2l2ZTohMH0pLHJ8fEgobihwLnBhcmVudE5vZGUpLHQsbyxpKSxpLnB1c2gocCl9ZnVuY3Rpb24gUChlLHQsbyxpKXtvLnVwZGF0ZUJvdW5kPWksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsby51cGRhdGVCb3VuZCx7cGFzc2l2ZTohMH0pO3ZhciByPW4oZSk7cmV0dXJuIEgociwnc2Nyb2xsJyxvLnVwZGF0ZUJvdW5kLG8uc2Nyb2xsUGFyZW50cyksby5zY3JvbGxFbGVtZW50PXIsby5ldmVudHNFbmFibGVkPSEwLG99ZnVuY3Rpb24gQSgpe3RoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZHx8KHRoaXMuc3RhdGU9UCh0aGlzLnJlZmVyZW5jZSx0aGlzLm9wdGlvbnMsdGhpcy5zdGF0ZSx0aGlzLnNjaGVkdWxlVXBkYXRlKSl9ZnVuY3Rpb24gTShlLHQpe3JldHVybiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJyx0LnVwZGF0ZUJvdW5kKSx0LnNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbihlKXtlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsdC51cGRhdGVCb3VuZCl9KSx0LnVwZGF0ZUJvdW5kPW51bGwsdC5zY3JvbGxQYXJlbnRzPVtdLHQuc2Nyb2xsRWxlbWVudD1udWxsLHQuZXZlbnRzRW5hYmxlZD0hMSx0fWZ1bmN0aW9uIEkoKXt0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQmJih3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5zY2hlZHVsZVVwZGF0ZSksdGhpcy5zdGF0ZT1NKHRoaXMucmVmZXJlbmNlLHRoaXMuc3RhdGUpKX1mdW5jdGlvbiBSKGUpe3JldHVybicnIT09ZSYmIWlzTmFOKHBhcnNlRmxvYXQoZSkpJiZpc0Zpbml0ZShlKX1mdW5jdGlvbiBVKGUsdCl7T2JqZWN0LmtleXModCkuZm9yRWFjaChmdW5jdGlvbihvKXt2YXIgaT0nJzstMSE9PVsnd2lkdGgnLCdoZWlnaHQnLCd0b3AnLCdyaWdodCcsJ2JvdHRvbScsJ2xlZnQnXS5pbmRleE9mKG8pJiZSKHRbb10pJiYoaT0ncHgnKSxlLnN0eWxlW29dPXRbb10raX0pfWZ1bmN0aW9uIFkoZSx0KXtPYmplY3Qua2V5cyh0KS5mb3JFYWNoKGZ1bmN0aW9uKG8pe3ZhciBpPXRbb107ITE9PT1pP2UucmVtb3ZlQXR0cmlidXRlKG8pOmUuc2V0QXR0cmlidXRlKG8sdFtvXSl9KX1mdW5jdGlvbiBGKGUsdCxvKXt2YXIgaT1UKGUsZnVuY3Rpb24oZSl7dmFyIG89ZS5uYW1lO3JldHVybiBvPT09dH0pLG49ISFpJiZlLnNvbWUoZnVuY3Rpb24oZSl7cmV0dXJuIGUubmFtZT09PW8mJmUuZW5hYmxlZCYmZS5vcmRlcjxpLm9yZGVyfSk7aWYoIW4pe3ZhciByPSdgJyt0KydgJztjb25zb2xlLndhcm4oJ2AnK28rJ2AnKycgbW9kaWZpZXIgaXMgcmVxdWlyZWQgYnkgJytyKycgbW9kaWZpZXIgaW4gb3JkZXIgdG8gd29yaywgYmUgc3VyZSB0byBpbmNsdWRlIGl0IGJlZm9yZSAnK3IrJyEnKX1yZXR1cm4gbn1mdW5jdGlvbiBqKGUpe3JldHVybidlbmQnPT09ZT8nc3RhcnQnOidzdGFydCc9PT1lPydlbmQnOmV9ZnVuY3Rpb24gSyhlKXt2YXIgdD0xPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzFdLG89YWUuaW5kZXhPZihlKSxpPWFlLnNsaWNlKG8rMSkuY29uY2F0KGFlLnNsaWNlKDAsbykpO3JldHVybiB0P2kucmV2ZXJzZSgpOml9ZnVuY3Rpb24gcShlLHQsbyxpKXt2YXIgbj1lLm1hdGNoKC8oKD86XFwtfFxcKyk/XFxkKlxcLj9cXGQqKSguKikvKSxyPStuWzFdLHA9blsyXTtpZighcilyZXR1cm4gZTtpZigwPT09cC5pbmRleE9mKCclJykpe3ZhciBzO3N3aXRjaChwKXtjYXNlJyVwJzpzPW87YnJlYWs7Y2FzZSclJzpjYXNlJyVyJzpkZWZhdWx0OnM9aTt9dmFyIGQ9YyhzKTtyZXR1cm4gZFt0XS8xMDAqcn1pZigndmgnPT09cHx8J3Z3Jz09PXApe3ZhciBhO3JldHVybiBhPSd2aCc9PT1wP18oZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCx3aW5kb3cuaW5uZXJIZWlnaHR8fDApOl8oZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLHdpbmRvdy5pbm5lcldpZHRofHwwKSxhLzEwMCpyfXJldHVybiByfWZ1bmN0aW9uIEcoZSx0LG8saSl7dmFyIG49WzAsMF0scj0tMSE9PVsncmlnaHQnLCdsZWZ0J10uaW5kZXhPZihpKSxwPWUuc3BsaXQoLyhcXCt8XFwtKS8pLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gZS50cmltKCl9KSxzPXAuaW5kZXhPZihUKHAsZnVuY3Rpb24oZSl7cmV0dXJuLTEhPT1lLnNlYXJjaCgvLHxcXHMvKX0pKTtwW3NdJiYtMT09PXBbc10uaW5kZXhPZignLCcpJiZjb25zb2xlLndhcm4oJ09mZnNldHMgc2VwYXJhdGVkIGJ5IHdoaXRlIHNwYWNlKHMpIGFyZSBkZXByZWNhdGVkLCB1c2UgYSBjb21tYSAoLCkgaW5zdGVhZC4nKTt2YXIgZD0vXFxzKixcXHMqfFxccysvLGE9LTE9PT1zP1twXTpbcC5zbGljZSgwLHMpLmNvbmNhdChbcFtzXS5zcGxpdChkKVswXV0pLFtwW3NdLnNwbGl0KGQpWzFdXS5jb25jYXQocC5zbGljZShzKzEpKV07cmV0dXJuIGE9YS5tYXAoZnVuY3Rpb24oZSxpKXt2YXIgbj0oMT09PWk/IXI6cik/J2hlaWdodCc6J3dpZHRoJyxwPSExO3JldHVybiBlLnJlZHVjZShmdW5jdGlvbihlLHQpe3JldHVybicnPT09ZVtlLmxlbmd0aC0xXSYmLTEhPT1bJysnLCctJ10uaW5kZXhPZih0KT8oZVtlLmxlbmd0aC0xXT10LHA9ITAsZSk6cD8oZVtlLmxlbmd0aC0xXSs9dCxwPSExLGUpOmUuY29uY2F0KHQpfSxbXSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBxKGUsbix0LG8pfSl9KSxhLmZvckVhY2goZnVuY3Rpb24oZSx0KXtlLmZvckVhY2goZnVuY3Rpb24obyxpKXtSKG8pJiYoblt0XSs9byooJy0nPT09ZVtpLTFdPy0xOjEpKX0pfSksbn1mb3IodmFyIHo9TWF0aC5taW4sVj1NYXRoLmZsb29yLF89TWF0aC5tYXgsWD1bJ25hdGl2ZSBjb2RlJywnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJ10sUT1mdW5jdGlvbihlKXtyZXR1cm4gWC5zb21lKGZ1bmN0aW9uKHQpe3JldHVybi0xPChlfHwnJykudG9TdHJpbmcoKS5pbmRleE9mKHQpfSl9LEo9J3VuZGVmaW5lZCchPXR5cGVvZiB3aW5kb3csWj1bJ0VkZ2UnLCdUcmlkZW50JywnRmlyZWZveCddLCQ9MCxlZT0wO2VlPFoubGVuZ3RoO2VlKz0xKWlmKEomJjA8PW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihaW2VlXSkpeyQ9MTticmVha312YXIgaSx0ZT1KJiZRKHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyKSxvZT10ZT9mdW5jdGlvbihlKXt2YXIgdD0hMSxvPTAsaT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyksbj1uZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbigpe2UoKSx0PSExfSk7cmV0dXJuIG4ub2JzZXJ2ZShpLHthdHRyaWJ1dGVzOiEwfSksZnVuY3Rpb24oKXt0fHwodD0hMCxpLnNldEF0dHJpYnV0ZSgneC1pbmRleCcsbyksKytvKX19OmZ1bmN0aW9uKGUpe3ZhciB0PSExO3JldHVybiBmdW5jdGlvbigpe3R8fCh0PSEwLHNldFRpbWVvdXQoZnVuY3Rpb24oKXt0PSExLGUoKX0sJCkpfX0saWU9ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwPT1pJiYoaT0tMSE9PW5hdmlnYXRvci5hcHBWZXJzaW9uLmluZGV4T2YoJ01TSUUgMTAnKSksaX0sbmU9ZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKX0scmU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7Zm9yKHZhciBvLG49MDtuPHQubGVuZ3RoO24rKylvPXRbbl0sby5lbnVtZXJhYmxlPW8uZW51bWVyYWJsZXx8ITEsby5jb25maWd1cmFibGU9ITAsJ3ZhbHVlJ2luIG8mJihvLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxvLmtleSxvKX1yZXR1cm4gZnVuY3Rpb24odCxvLGkpe3JldHVybiBvJiZlKHQucHJvdG90eXBlLG8pLGkmJmUodCxpKSx0fX0oKSxwZT1mdW5jdGlvbihlLHQsbyl7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTpvLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1vLGV9LHNlPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxvPTE7bzxhcmd1bWVudHMubGVuZ3RoO28rKylmb3IodmFyIGkgaW4gdD1hcmd1bWVudHNbb10sdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxpKSYmKGVbaV09dFtpXSk7cmV0dXJuIGV9LGRlPVsnYXV0by1zdGFydCcsJ2F1dG8nLCdhdXRvLWVuZCcsJ3RvcC1zdGFydCcsJ3RvcCcsJ3RvcC1lbmQnLCdyaWdodC1zdGFydCcsJ3JpZ2h0JywncmlnaHQtZW5kJywnYm90dG9tLWVuZCcsJ2JvdHRvbScsJ2JvdHRvbS1zdGFydCcsJ2xlZnQtZW5kJywnbGVmdCcsJ2xlZnQtc3RhcnQnXSxhZT1kZS5zbGljZSgzKSxmZT17RkxJUDonZmxpcCcsQ0xPQ0tXSVNFOidjbG9ja3dpc2UnLENPVU5URVJDTE9DS1dJU0U6J2NvdW50ZXJjbG9ja3dpc2UnfSxsZT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQobyxpKXt2YXIgbj10aGlzLHI9Mjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOnt9O25lKHRoaXMsdCksdGhpcy5zY2hlZHVsZVVwZGF0ZT1mdW5jdGlvbigpe3JldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobi51cGRhdGUpfSx0aGlzLnVwZGF0ZT1vZSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKSx0aGlzLm9wdGlvbnM9c2Uoe30sdC5EZWZhdWx0cyxyKSx0aGlzLnN0YXRlPXtpc0Rlc3Ryb3llZDohMSxpc0NyZWF0ZWQ6ITEsc2Nyb2xsUGFyZW50czpbXX0sdGhpcy5yZWZlcmVuY2U9by5qcXVlcnk/b1swXTpvLHRoaXMucG9wcGVyPWkuanF1ZXJ5P2lbMF06aSx0aGlzLm9wdGlvbnMubW9kaWZpZXJzPXt9LE9iamVjdC5rZXlzKHNlKHt9LHQuRGVmYXVsdHMubW9kaWZpZXJzLHIubW9kaWZpZXJzKSkuZm9yRWFjaChmdW5jdGlvbihlKXtuLm9wdGlvbnMubW9kaWZpZXJzW2VdPXNlKHt9LHQuRGVmYXVsdHMubW9kaWZpZXJzW2VdfHx7fSxyLm1vZGlmaWVycz9yLm1vZGlmaWVyc1tlXTp7fSl9KSx0aGlzLm1vZGlmaWVycz1PYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMubW9kaWZpZXJzKS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIHNlKHtuYW1lOmV9LG4ub3B0aW9ucy5tb2RpZmllcnNbZV0pfSkuc29ydChmdW5jdGlvbihlLHQpe3JldHVybiBlLm9yZGVyLXQub3JkZXJ9KSx0aGlzLm1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QuZW5hYmxlZCYmZSh0Lm9uTG9hZCkmJnQub25Mb2FkKG4ucmVmZXJlbmNlLG4ucG9wcGVyLG4ub3B0aW9ucyx0LG4uc3RhdGUpfSksdGhpcy51cGRhdGUoKTt2YXIgcD10aGlzLm9wdGlvbnMuZXZlbnRzRW5hYmxlZDtwJiZ0aGlzLmVuYWJsZUV2ZW50TGlzdGVuZXJzKCksdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkPXB9cmV0dXJuIHJlKHQsW3trZXk6J3VwZGF0ZScsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gay5jYWxsKHRoaXMpfX0se2tleTonZGVzdHJveScsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gRC5jYWxsKHRoaXMpfX0se2tleTonZW5hYmxlRXZlbnRMaXN0ZW5lcnMnLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIEEuY2FsbCh0aGlzKX19LHtrZXk6J2Rpc2FibGVFdmVudExpc3RlbmVycycsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gSS5jYWxsKHRoaXMpfX1dKSx0fSgpO3JldHVybiBsZS5VdGlscz0oJ3VuZGVmaW5lZCc9PXR5cGVvZiB3aW5kb3c/Z2xvYmFsOndpbmRvdykuUG9wcGVyVXRpbHMsbGUucGxhY2VtZW50cz1kZSxsZS5EZWZhdWx0cz17cGxhY2VtZW50Oidib3R0b20nLGV2ZW50c0VuYWJsZWQ6ITAscmVtb3ZlT25EZXN0cm95OiExLG9uQ3JlYXRlOmZ1bmN0aW9uKCl7fSxvblVwZGF0ZTpmdW5jdGlvbigpe30sbW9kaWZpZXJzOntzaGlmdDp7b3JkZXI6MTAwLGVuYWJsZWQ6ITAsZm46ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5wbGFjZW1lbnQsbz10LnNwbGl0KCctJylbMF0saT10LnNwbGl0KCctJylbMV07aWYoaSl7dmFyIG49ZS5vZmZzZXRzLHI9bi5yZWZlcmVuY2UscD1uLnBvcHBlcixzPS0xIT09Wydib3R0b20nLCd0b3AnXS5pbmRleE9mKG8pLGQ9cz8nbGVmdCc6J3RvcCcsYT1zPyd3aWR0aCc6J2hlaWdodCcsZj17c3RhcnQ6cGUoe30sZCxyW2RdKSxlbmQ6cGUoe30sZCxyW2RdK3JbYV0tcFthXSl9O2Uub2Zmc2V0cy5wb3BwZXI9c2Uoe30scCxmW2ldKX1yZXR1cm4gZX19LG9mZnNldDp7b3JkZXI6MjAwLGVuYWJsZWQ6ITAsZm46ZnVuY3Rpb24oZSx0KXt2YXIgbyxpPXQub2Zmc2V0LG49ZS5wbGFjZW1lbnQscj1lLm9mZnNldHMscD1yLnBvcHBlcixzPXIucmVmZXJlbmNlLGQ9bi5zcGxpdCgnLScpWzBdO3JldHVybiBvPVIoK2kpP1sraSwwXTpHKGkscCxzLGQpLCdsZWZ0Jz09PWQ/KHAudG9wKz1vWzBdLHAubGVmdC09b1sxXSk6J3JpZ2h0Jz09PWQ/KHAudG9wKz1vWzBdLHAubGVmdCs9b1sxXSk6J3RvcCc9PT1kPyhwLmxlZnQrPW9bMF0scC50b3AtPW9bMV0pOidib3R0b20nPT09ZCYmKHAubGVmdCs9b1swXSxwLnRvcCs9b1sxXSksZS5wb3BwZXI9cCxlfSxvZmZzZXQ6MH0scHJldmVudE92ZXJmbG93OntvcmRlcjozMDAsZW5hYmxlZDohMCxmbjpmdW5jdGlvbihlLHQpe3ZhciBvPXQuYm91bmRhcmllc0VsZW1lbnR8fHIoZS5pbnN0YW5jZS5wb3BwZXIpO2UuaW5zdGFuY2UucmVmZXJlbmNlPT09byYmKG89cihvKSk7dmFyIGk9dyhlLmluc3RhbmNlLnBvcHBlcixlLmluc3RhbmNlLnJlZmVyZW5jZSx0LnBhZGRpbmcsbyk7dC5ib3VuZGFyaWVzPWk7dmFyIG49dC5wcmlvcml0eSxwPWUub2Zmc2V0cy5wb3BwZXIscz17cHJpbWFyeTpmdW5jdGlvbihlKXt2YXIgbz1wW2VdO3JldHVybiBwW2VdPGlbZV0mJiF0LmVzY2FwZVdpdGhSZWZlcmVuY2UmJihvPV8ocFtlXSxpW2VdKSkscGUoe30sZSxvKX0sc2Vjb25kYXJ5OmZ1bmN0aW9uKGUpe3ZhciBvPSdyaWdodCc9PT1lPydsZWZ0JzondG9wJyxuPXBbb107cmV0dXJuIHBbZV0+aVtlXSYmIXQuZXNjYXBlV2l0aFJlZmVyZW5jZSYmKG49eihwW29dLGlbZV0tKCdyaWdodCc9PT1lP3Aud2lkdGg6cC5oZWlnaHQpKSkscGUoe30sbyxuKX19O3JldHVybiBuLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9LTE9PT1bJ2xlZnQnLCd0b3AnXS5pbmRleE9mKGUpPydzZWNvbmRhcnknOidwcmltYXJ5JztwPXNlKHt9LHAsc1t0XShlKSl9KSxlLm9mZnNldHMucG9wcGVyPXAsZX0scHJpb3JpdHk6WydsZWZ0JywncmlnaHQnLCd0b3AnLCdib3R0b20nXSxwYWRkaW5nOjUsYm91bmRhcmllc0VsZW1lbnQ6J3Njcm9sbFBhcmVudCd9LGtlZXBUb2dldGhlcjp7b3JkZXI6NDAwLGVuYWJsZWQ6ITAsZm46ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5vZmZzZXRzLG89dC5wb3BwZXIsaT10LnJlZmVyZW5jZSxuPWUucGxhY2VtZW50LnNwbGl0KCctJylbMF0scj1WLHA9LTEhPT1bJ3RvcCcsJ2JvdHRvbSddLmluZGV4T2Yobikscz1wPydyaWdodCc6J2JvdHRvbScsZD1wPydsZWZ0JzondG9wJyxhPXA/J3dpZHRoJzonaGVpZ2h0JztyZXR1cm4gb1tzXTxyKGlbZF0pJiYoZS5vZmZzZXRzLnBvcHBlcltkXT1yKGlbZF0pLW9bYV0pLG9bZF0+cihpW3NdKSYmKGUub2Zmc2V0cy5wb3BwZXJbZF09cihpW3NdKSksZX19LGFycm93OntvcmRlcjo1MDAsZW5hYmxlZDohMCxmbjpmdW5jdGlvbihlLHQpe2lmKCFGKGUuaW5zdGFuY2UubW9kaWZpZXJzLCdhcnJvdycsJ2tlZXBUb2dldGhlcicpKXJldHVybiBlO3ZhciBvPXQuZWxlbWVudDtpZignc3RyaW5nJz09dHlwZW9mIG8pe2lmKG89ZS5pbnN0YW5jZS5wb3BwZXIucXVlcnlTZWxlY3RvcihvKSwhbylyZXR1cm4gZTt9ZWxzZSBpZighZS5pbnN0YW5jZS5wb3BwZXIuY29udGFpbnMobykpcmV0dXJuIGNvbnNvbGUud2FybignV0FSTklORzogYGFycm93LmVsZW1lbnRgIG11c3QgYmUgY2hpbGQgb2YgaXRzIHBvcHBlciBlbGVtZW50IScpLGU7dmFyIGk9ZS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXSxuPWUub2Zmc2V0cyxyPW4ucG9wcGVyLHA9bi5yZWZlcmVuY2Uscz0tMSE9PVsnbGVmdCcsJ3JpZ2h0J10uaW5kZXhPZihpKSxkPXM/J2hlaWdodCc6J3dpZHRoJyxhPXM/J3RvcCc6J2xlZnQnLGY9cz8nbGVmdCc6J3RvcCcsbD1zPydib3R0b20nOidyaWdodCcsbT1PKG8pW2RdO3BbbF0tbTxyW2FdJiYoZS5vZmZzZXRzLnBvcHBlclthXS09clthXS0ocFtsXS1tKSkscFthXSttPnJbbF0mJihlLm9mZnNldHMucG9wcGVyW2FdKz1wW2FdK20tcltsXSk7dmFyIGg9cFthXStwW2RdLzItbS8yLGc9aC1jKGUub2Zmc2V0cy5wb3BwZXIpW2FdO3JldHVybiBnPV8oeihyW2RdLW0sZyksMCksZS5hcnJvd0VsZW1lbnQ9byxlLm9mZnNldHMuYXJyb3c9e30sZS5vZmZzZXRzLmFycm93W2FdPU1hdGgucm91bmQoZyksZS5vZmZzZXRzLmFycm93W2ZdPScnLGV9LGVsZW1lbnQ6J1t4LWFycm93XSd9LGZsaXA6e29yZGVyOjYwMCxlbmFibGVkOiEwLGZuOmZ1bmN0aW9uKGUsdCl7aWYoVyhlLmluc3RhbmNlLm1vZGlmaWVycywnaW5uZXInKSlyZXR1cm4gZTtpZihlLmZsaXBwZWQmJmUucGxhY2VtZW50PT09ZS5vcmlnaW5hbFBsYWNlbWVudClyZXR1cm4gZTt2YXIgbz13KGUuaW5zdGFuY2UucG9wcGVyLGUuaW5zdGFuY2UucmVmZXJlbmNlLHQucGFkZGluZyx0LmJvdW5kYXJpZXNFbGVtZW50KSxpPWUucGxhY2VtZW50LnNwbGl0KCctJylbMF0sbj1MKGkpLHI9ZS5wbGFjZW1lbnQuc3BsaXQoJy0nKVsxXXx8JycscD1bXTtzd2l0Y2godC5iZWhhdmlvcil7Y2FzZSBmZS5GTElQOnA9W2ksbl07YnJlYWs7Y2FzZSBmZS5DTE9DS1dJU0U6cD1LKGkpO2JyZWFrO2Nhc2UgZmUuQ09VTlRFUkNMT0NLV0lTRTpwPUsoaSwhMCk7YnJlYWs7ZGVmYXVsdDpwPXQuYmVoYXZpb3I7fXJldHVybiBwLmZvckVhY2goZnVuY3Rpb24ocyxkKXtpZihpIT09c3x8cC5sZW5ndGg9PT1kKzEpcmV0dXJuIGU7aT1lLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdLG49TChpKTt2YXIgYT1lLm9mZnNldHMucG9wcGVyLGY9ZS5vZmZzZXRzLnJlZmVyZW5jZSxsPVYsbT0nbGVmdCc9PT1pJiZsKGEucmlnaHQpPmwoZi5sZWZ0KXx8J3JpZ2h0Jz09PWkmJmwoYS5sZWZ0KTxsKGYucmlnaHQpfHwndG9wJz09PWkmJmwoYS5ib3R0b20pPmwoZi50b3ApfHwnYm90dG9tJz09PWkmJmwoYS50b3ApPGwoZi5ib3R0b20pLGg9bChhLmxlZnQpPGwoby5sZWZ0KSxjPWwoYS5yaWdodCk+bChvLnJpZ2h0KSxnPWwoYS50b3ApPGwoby50b3ApLHU9bChhLmJvdHRvbSk+bChvLmJvdHRvbSksYj0nbGVmdCc9PT1pJiZofHwncmlnaHQnPT09aSYmY3x8J3RvcCc9PT1pJiZnfHwnYm90dG9tJz09PWkmJnUseT0tMSE9PVsndG9wJywnYm90dG9tJ10uaW5kZXhPZihpKSx3PSEhdC5mbGlwVmFyaWF0aW9ucyYmKHkmJidzdGFydCc9PT1yJiZofHx5JiYnZW5kJz09PXImJmN8fCF5JiYnc3RhcnQnPT09ciYmZ3x8IXkmJidlbmQnPT09ciYmdSk7KG18fGJ8fHcpJiYoZS5mbGlwcGVkPSEwLChtfHxiKSYmKGk9cFtkKzFdKSx3JiYocj1qKHIpKSxlLnBsYWNlbWVudD1pKyhyPyctJytyOicnKSxlLm9mZnNldHMucG9wcGVyPXNlKHt9LGUub2Zmc2V0cy5wb3BwZXIsUyhlLmluc3RhbmNlLnBvcHBlcixlLm9mZnNldHMucmVmZXJlbmNlLGUucGxhY2VtZW50KSksZT1OKGUuaW5zdGFuY2UubW9kaWZpZXJzLGUsJ2ZsaXAnKSl9KSxlfSxiZWhhdmlvcjonZmxpcCcscGFkZGluZzo1LGJvdW5kYXJpZXNFbGVtZW50Oid2aWV3cG9ydCd9LGlubmVyOntvcmRlcjo3MDAsZW5hYmxlZDohMSxmbjpmdW5jdGlvbihlKXt2YXIgdD1lLnBsYWNlbWVudCxvPXQuc3BsaXQoJy0nKVswXSxpPWUub2Zmc2V0cyxuPWkucG9wcGVyLHI9aS5yZWZlcmVuY2UscD0tMSE9PVsnbGVmdCcsJ3JpZ2h0J10uaW5kZXhPZihvKSxzPS0xPT09Wyd0b3AnLCdsZWZ0J10uaW5kZXhPZihvKTtyZXR1cm4gbltwPydsZWZ0JzondG9wJ109clt0XS0ocz9uW3A/J3dpZHRoJzonaGVpZ2h0J106MCksZS5wbGFjZW1lbnQ9TCh0KSxlLm9mZnNldHMucG9wcGVyPWMobiksZX19LGhpZGU6e29yZGVyOjgwMCxlbmFibGVkOiEwLGZuOmZ1bmN0aW9uKGUpe2lmKCFGKGUuaW5zdGFuY2UubW9kaWZpZXJzLCdoaWRlJywncHJldmVudE92ZXJmbG93JykpcmV0dXJuIGU7dmFyIHQ9ZS5vZmZzZXRzLnJlZmVyZW5jZSxvPVQoZS5pbnN0YW5jZS5tb2RpZmllcnMsZnVuY3Rpb24oZSl7cmV0dXJuJ3ByZXZlbnRPdmVyZmxvdyc9PT1lLm5hbWV9KS5ib3VuZGFyaWVzO2lmKHQuYm90dG9tPG8udG9wfHx0LmxlZnQ+by5yaWdodHx8dC50b3A+by5ib3R0b218fHQucmlnaHQ8by5sZWZ0KXtpZighMD09PWUuaGlkZSlyZXR1cm4gZTtlLmhpZGU9ITAsZS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ109Jyd9ZWxzZXtpZighMT09PWUuaGlkZSlyZXR1cm4gZTtlLmhpZGU9ITEsZS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ109ITF9cmV0dXJuIGV9fSxjb21wdXRlU3R5bGU6e29yZGVyOjg1MCxlbmFibGVkOiEwLGZuOmZ1bmN0aW9uKGUsdCl7dmFyIG89dC54LGk9dC55LG49ZS5vZmZzZXRzLnBvcHBlcixwPVQoZS5pbnN0YW5jZS5tb2RpZmllcnMsZnVuY3Rpb24oZSl7cmV0dXJuJ2FwcGx5U3R5bGUnPT09ZS5uYW1lfSkuZ3B1QWNjZWxlcmF0aW9uO3ZvaWQgMCE9PXAmJmNvbnNvbGUud2FybignV0FSTklORzogYGdwdUFjY2VsZXJhdGlvbmAgb3B0aW9uIG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyIGFuZCB3aWxsIG5vdCBiZSBzdXBwb3J0ZWQgaW4gZnV0dXJlIHZlcnNpb25zIG9mIFBvcHBlci5qcyEnKTt2YXIgcyxkLGE9dm9pZCAwPT09cD90LmdwdUFjY2VsZXJhdGlvbjpwLGY9cihlLmluc3RhbmNlLnBvcHBlciksbD1nKGYpLG09e3Bvc2l0aW9uOm4ucG9zaXRpb259LGg9e2xlZnQ6VihuLmxlZnQpLHRvcDpWKG4udG9wKSxib3R0b206VihuLmJvdHRvbSkscmlnaHQ6VihuLnJpZ2h0KX0sYz0nYm90dG9tJz09PW8/J3RvcCc6J2JvdHRvbScsdT0ncmlnaHQnPT09aT8nbGVmdCc6J3JpZ2h0JyxiPUIoJ3RyYW5zZm9ybScpO2lmKGQ9J2JvdHRvbSc9PWM/LWwuaGVpZ2h0K2guYm90dG9tOmgudG9wLHM9J3JpZ2h0Jz09dT8tbC53aWR0aCtoLnJpZ2h0OmgubGVmdCxhJiZiKW1bYl09J3RyYW5zbGF0ZTNkKCcrcysncHgsICcrZCsncHgsIDApJyxtW2NdPTAsbVt1XT0wLG0ud2lsbENoYW5nZT0ndHJhbnNmb3JtJztlbHNle3ZhciB5PSdib3R0b20nPT1jPy0xOjEsdz0ncmlnaHQnPT11Py0xOjE7bVtjXT1kKnksbVt1XT1zKncsbS53aWxsQ2hhbmdlPWMrJywgJyt1fXZhciB2PXtcIngtcGxhY2VtZW50XCI6ZS5wbGFjZW1lbnR9O3JldHVybiBlLmF0dHJpYnV0ZXM9c2Uoe30sdixlLmF0dHJpYnV0ZXMpLGUuc3R5bGVzPXNlKHt9LG0sZS5zdHlsZXMpLGV9LGdwdUFjY2VsZXJhdGlvbjohMCx4Oidib3R0b20nLHk6J3JpZ2h0J30sYXBwbHlTdHlsZTp7b3JkZXI6OTAwLGVuYWJsZWQ6ITAsZm46ZnVuY3Rpb24oZSl7cmV0dXJuIFUoZS5pbnN0YW5jZS5wb3BwZXIsZS5zdHlsZXMpLFkoZS5pbnN0YW5jZS5wb3BwZXIsZS5hdHRyaWJ1dGVzKSxlLm9mZnNldHMuYXJyb3cmJlUoZS5hcnJvd0VsZW1lbnQsZS5vZmZzZXRzLmFycm93KSxlfSxvbkxvYWQ6ZnVuY3Rpb24oZSx0LG8saSxuKXt2YXIgcj14KG4sdCxlKSxwPUUoby5wbGFjZW1lbnQscix0LGUsby5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCxvLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO3JldHVybiB0LnNldEF0dHJpYnV0ZSgneC1wbGFjZW1lbnQnLHApLFUodCx7cG9zaXRpb246J2Fic29sdXRlJ30pLG99LGdwdUFjY2VsZXJhdGlvbjp2b2lkIDB9fX0sbGV9KTtcblxuXG4vKiFcbiAqIEJvb3RzdHJhcCB2NC4wLjAtYmV0YSAoaHR0cHM6Ly9nZXRib290c3RyYXAuY29tKVxuICogQ29weXJpZ2h0IDIwMTEtMjAxNyBUaGUgQm9vdHN0cmFwIEF1dGhvcnMgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ncmFwaHMvY29udHJpYnV0b3JzKVxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcbiAqL1xuaWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGpRdWVyeSl0aHJvdyBuZXcgRXJyb3IoXCJCb290c3RyYXAncyBKYXZhU2NyaXB0IHJlcXVpcmVzIGpRdWVyeS4galF1ZXJ5IG11c3QgYmUgaW5jbHVkZWQgYmVmb3JlIEJvb3RzdHJhcCdzIEphdmFTY3JpcHQuXCIpOyFmdW5jdGlvbih0KXt2YXIgZT1qUXVlcnkuZm4uanF1ZXJ5LnNwbGl0KFwiIFwiKVswXS5zcGxpdChcIi5cIik7aWYoZVswXTwyJiZlWzFdPDl8fDE9PWVbMF0mJjk9PWVbMV0mJmVbMl08MXx8ZVswXT49NCl0aHJvdyBuZXcgRXJyb3IoXCJCb290c3RyYXAncyBKYXZhU2NyaXB0IHJlcXVpcmVzIGF0IGxlYXN0IGpRdWVyeSB2MS45LjEgYnV0IGxlc3MgdGhhbiB2NC4wLjBcIil9KCksZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7aWYoIXQpdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO3JldHVybiFlfHxcIm9iamVjdFwiIT10eXBlb2YgZSYmXCJmdW5jdGlvblwiIT10eXBlb2YgZT90OmV9ZnVuY3Rpb24gZSh0LGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJm51bGwhPT1lKXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiK3R5cGVvZiBlKTt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUmJmUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6dCxlbnVtZXJhYmxlOiExLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSxlJiYoT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZih0LGUpOnQuX19wcm90b19fPWUpfWZ1bmN0aW9uIG4odCxlKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfXZhciBpPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9LG89ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciBpPWVbbl07aS5lbnVtZXJhYmxlPWkuZW51bWVyYWJsZXx8ITEsaS5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gaSYmKGkud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGkua2V5LGkpfX1yZXR1cm4gZnVuY3Rpb24oZSxuLGkpe3JldHVybiBuJiZ0KGUucHJvdG90eXBlLG4pLGkmJnQoZSxpKSxlfX0oKSxyPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCl7cmV0dXJue30udG9TdHJpbmcuY2FsbCh0KS5tYXRjaCgvXFxzKFthLXpBLVpdKykvKVsxXS50b0xvd2VyQ2FzZSgpfWZ1bmN0aW9uIG4odCl7cmV0dXJuKHRbMF18fHQpLm5vZGVUeXBlfWZ1bmN0aW9uIGkoKXtyZXR1cm57YmluZFR5cGU6cy5lbmQsZGVsZWdhdGVUeXBlOnMuZW5kLGhhbmRsZTpmdW5jdGlvbihlKXtpZih0KGUudGFyZ2V0KS5pcyh0aGlzKSlyZXR1cm4gZS5oYW5kbGVPYmouaGFuZGxlci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fX1mdW5jdGlvbiBvKCl7aWYod2luZG93LlFVbml0KXJldHVybiExO3ZhciB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJib290c3RyYXBcIik7Zm9yKHZhciBlIGluIGEpaWYodm9pZCAwIT09dC5zdHlsZVtlXSlyZXR1cm57ZW5kOmFbZV19O3JldHVybiExfWZ1bmN0aW9uIHIoZSl7dmFyIG49dGhpcyxpPSExO3JldHVybiB0KHRoaXMpLm9uZShsLlRSQU5TSVRJT05fRU5ELGZ1bmN0aW9uKCl7aT0hMH0pLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtpfHxsLnRyaWdnZXJUcmFuc2l0aW9uRW5kKG4pfSxlKSx0aGlzfXZhciBzPSExLGE9e1dlYmtpdFRyYW5zaXRpb246XCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCIsTW96VHJhbnNpdGlvbjpcInRyYW5zaXRpb25lbmRcIixPVHJhbnNpdGlvbjpcIm9UcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kXCIsdHJhbnNpdGlvbjpcInRyYW5zaXRpb25lbmRcIn0sbD17VFJBTlNJVElPTl9FTkQ6XCJic1RyYW5zaXRpb25FbmRcIixnZXRVSUQ6ZnVuY3Rpb24odCl7ZG97dCs9fn4oMWU2Kk1hdGgucmFuZG9tKCkpfXdoaWxlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHQpKTtyZXR1cm4gdH0sZ2V0U2VsZWN0b3JGcm9tRWxlbWVudDpmdW5jdGlvbihlKXt2YXIgbj1lLmdldEF0dHJpYnV0ZShcImRhdGEtdGFyZ2V0XCIpO24mJlwiI1wiIT09bnx8KG49ZS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpfHxcIlwiKTt0cnl7cmV0dXJuIHQobikubGVuZ3RoPjA/bjpudWxsfWNhdGNoKHQpe3JldHVybiBudWxsfX0scmVmbG93OmZ1bmN0aW9uKHQpe3JldHVybiB0Lm9mZnNldEhlaWdodH0sdHJpZ2dlclRyYW5zaXRpb25FbmQ6ZnVuY3Rpb24oZSl7dChlKS50cmlnZ2VyKHMuZW5kKX0sc3VwcG9ydHNUcmFuc2l0aW9uRW5kOmZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4ocyl9LHR5cGVDaGVja0NvbmZpZzpmdW5jdGlvbih0LGksbyl7Zm9yKHZhciByIGluIG8paWYoby5oYXNPd25Qcm9wZXJ0eShyKSl7dmFyIHM9b1tyXSxhPWlbcl0sbD1hJiZuKGEpP1wiZWxlbWVudFwiOmUoYSk7aWYoIW5ldyBSZWdFeHAocykudGVzdChsKSl0aHJvdyBuZXcgRXJyb3IodC50b1VwcGVyQ2FzZSgpKyc6IE9wdGlvbiBcIicrcisnXCIgcHJvdmlkZWQgdHlwZSBcIicrbCsnXCIgYnV0IGV4cGVjdGVkIHR5cGUgXCInK3MrJ1wiLicpfX19O3JldHVybiBzPW8oKSx0LmZuLmVtdWxhdGVUcmFuc2l0aW9uRW5kPXIsbC5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKSYmKHQuZXZlbnQuc3BlY2lhbFtsLlRSQU5TSVRJT05fRU5EXT1pKCkpLGx9KGpRdWVyeSkscz0oZnVuY3Rpb24odCl7dmFyIGU9XCJhbGVydFwiLGk9dC5mbltlXSxzPXtESVNNSVNTOidbZGF0YS1kaXNtaXNzPVwiYWxlcnRcIl0nfSxhPXtDTE9TRTpcImNsb3NlLmJzLmFsZXJ0XCIsQ0xPU0VEOlwiY2xvc2VkLmJzLmFsZXJ0XCIsQ0xJQ0tfREFUQV9BUEk6XCJjbGljay5icy5hbGVydC5kYXRhLWFwaVwifSxsPXtBTEVSVDpcImFsZXJ0XCIsRkFERTpcImZhZGVcIixTSE9XOlwic2hvd1wifSxoPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXtuKHRoaXMsZSksdGhpcy5fZWxlbWVudD10fXJldHVybiBlLnByb3RvdHlwZS5jbG9zZT1mdW5jdGlvbih0KXt0PXR8fHRoaXMuX2VsZW1lbnQ7dmFyIGU9dGhpcy5fZ2V0Um9vdEVsZW1lbnQodCk7dGhpcy5fdHJpZ2dlckNsb3NlRXZlbnQoZSkuaXNEZWZhdWx0UHJldmVudGVkKCl8fHRoaXMuX3JlbW92ZUVsZW1lbnQoZSl9LGUucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0LnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCxcImJzLmFsZXJ0XCIpLHRoaXMuX2VsZW1lbnQ9bnVsbH0sZS5wcm90b3R5cGUuX2dldFJvb3RFbGVtZW50PWZ1bmN0aW9uKGUpe3ZhciBuPXIuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlKSxpPSExO3JldHVybiBuJiYoaT10KG4pWzBdKSxpfHwoaT10KGUpLmNsb3Nlc3QoXCIuXCIrbC5BTEVSVClbMF0pLGl9LGUucHJvdG90eXBlLl90cmlnZ2VyQ2xvc2VFdmVudD1mdW5jdGlvbihlKXt2YXIgbj10LkV2ZW50KGEuQ0xPU0UpO3JldHVybiB0KGUpLnRyaWdnZXIobiksbn0sZS5wcm90b3R5cGUuX3JlbW92ZUVsZW1lbnQ9ZnVuY3Rpb24oZSl7dmFyIG49dGhpczt0KGUpLnJlbW92ZUNsYXNzKGwuU0hPVyksci5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKSYmdChlKS5oYXNDbGFzcyhsLkZBREUpP3QoZSkub25lKHIuVFJBTlNJVElPTl9FTkQsZnVuY3Rpb24odCl7cmV0dXJuIG4uX2Rlc3Ryb3lFbGVtZW50KGUsdCl9KS5lbXVsYXRlVHJhbnNpdGlvbkVuZCgxNTApOnRoaXMuX2Rlc3Ryb3lFbGVtZW50KGUpfSxlLnByb3RvdHlwZS5fZGVzdHJveUVsZW1lbnQ9ZnVuY3Rpb24oZSl7dChlKS5kZXRhY2goKS50cmlnZ2VyKGEuQ0xPU0VEKS5yZW1vdmUoKX0sZS5falF1ZXJ5SW50ZXJmYWNlPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgaT10KHRoaXMpLG89aS5kYXRhKFwiYnMuYWxlcnRcIik7b3x8KG89bmV3IGUodGhpcyksaS5kYXRhKFwiYnMuYWxlcnRcIixvKSksXCJjbG9zZVwiPT09biYmb1tuXSh0aGlzKX0pfSxlLl9oYW5kbGVEaXNtaXNzPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtlJiZlLnByZXZlbnREZWZhdWx0KCksdC5jbG9zZSh0aGlzKX19LG8oZSxudWxsLFt7a2V5OlwiVkVSU0lPTlwiLGdldDpmdW5jdGlvbigpe3JldHVyblwiNC4wLjAtYmV0YVwifX1dKSxlfSgpO3QoZG9jdW1lbnQpLm9uKGEuQ0xJQ0tfREFUQV9BUEkscy5ESVNNSVNTLGguX2hhbmRsZURpc21pc3MobmV3IGgpKSx0LmZuW2VdPWguX2pRdWVyeUludGVyZmFjZSx0LmZuW2VdLkNvbnN0cnVjdG9yPWgsdC5mbltlXS5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIHQuZm5bZV09aSxoLl9qUXVlcnlJbnRlcmZhY2V9fShqUXVlcnkpLGZ1bmN0aW9uKHQpe3ZhciBlPVwiYnV0dG9uXCIsaT10LmZuW2VdLHI9e0FDVElWRTpcImFjdGl2ZVwiLEJVVFRPTjpcImJ0blwiLEZPQ1VTOlwiZm9jdXNcIn0scz17REFUQV9UT0dHTEVfQ0FSUk9UOidbZGF0YS10b2dnbGVePVwiYnV0dG9uXCJdJyxEQVRBX1RPR0dMRTonW2RhdGEtdG9nZ2xlPVwiYnV0dG9uc1wiXScsSU5QVVQ6XCJpbnB1dFwiLEFDVElWRTpcIi5hY3RpdmVcIixCVVRUT046XCIuYnRuXCJ9LGE9e0NMSUNLX0RBVEFfQVBJOlwiY2xpY2suYnMuYnV0dG9uLmRhdGEtYXBpXCIsRk9DVVNfQkxVUl9EQVRBX0FQSTpcImZvY3VzLmJzLmJ1dHRvbi5kYXRhLWFwaSBibHVyLmJzLmJ1dHRvbi5kYXRhLWFwaVwifSxsPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXtuKHRoaXMsZSksdGhpcy5fZWxlbWVudD10fXJldHVybiBlLnByb3RvdHlwZS50b2dnbGU9ZnVuY3Rpb24oKXt2YXIgZT0hMCxuPSEwLGk9dCh0aGlzLl9lbGVtZW50KS5jbG9zZXN0KHMuREFUQV9UT0dHTEUpWzBdO2lmKGkpe3ZhciBvPXQodGhpcy5fZWxlbWVudCkuZmluZChzLklOUFVUKVswXTtpZihvKXtpZihcInJhZGlvXCI9PT1vLnR5cGUpaWYoby5jaGVja2VkJiZ0KHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKHIuQUNUSVZFKSllPSExO2Vsc2V7dmFyIGE9dChpKS5maW5kKHMuQUNUSVZFKVswXTthJiZ0KGEpLnJlbW92ZUNsYXNzKHIuQUNUSVZFKX1pZihlKXtpZihvLmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpfHxpLmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpfHxvLmNsYXNzTGlzdC5jb250YWlucyhcImRpc2FibGVkXCIpfHxpLmNsYXNzTGlzdC5jb250YWlucyhcImRpc2FibGVkXCIpKXJldHVybjtvLmNoZWNrZWQ9IXQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3Moci5BQ1RJVkUpLHQobykudHJpZ2dlcihcImNoYW5nZVwiKX1vLmZvY3VzKCksbj0hMX19biYmdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXByZXNzZWRcIiwhdCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhyLkFDVElWRSkpLGUmJnQodGhpcy5fZWxlbWVudCkudG9nZ2xlQ2xhc3Moci5BQ1RJVkUpfSxlLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsXCJicy5idXR0b25cIiksdGhpcy5fZWxlbWVudD1udWxsfSxlLl9qUXVlcnlJbnRlcmZhY2U9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBpPXQodGhpcykuZGF0YShcImJzLmJ1dHRvblwiKTtpfHwoaT1uZXcgZSh0aGlzKSx0KHRoaXMpLmRhdGEoXCJicy5idXR0b25cIixpKSksXCJ0b2dnbGVcIj09PW4mJmlbbl0oKX0pfSxvKGUsbnVsbCxbe2tleTpcIlZFUlNJT05cIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cIjQuMC4wLWJldGFcIn19XSksZX0oKTt0KGRvY3VtZW50KS5vbihhLkNMSUNLX0RBVEFfQVBJLHMuREFUQV9UT0dHTEVfQ0FSUk9ULGZ1bmN0aW9uKGUpe2UucHJldmVudERlZmF1bHQoKTt2YXIgbj1lLnRhcmdldDt0KG4pLmhhc0NsYXNzKHIuQlVUVE9OKXx8KG49dChuKS5jbG9zZXN0KHMuQlVUVE9OKSksbC5falF1ZXJ5SW50ZXJmYWNlLmNhbGwodChuKSxcInRvZ2dsZVwiKX0pLm9uKGEuRk9DVVNfQkxVUl9EQVRBX0FQSSxzLkRBVEFfVE9HR0xFX0NBUlJPVCxmdW5jdGlvbihlKXt2YXIgbj10KGUudGFyZ2V0KS5jbG9zZXN0KHMuQlVUVE9OKVswXTt0KG4pLnRvZ2dsZUNsYXNzKHIuRk9DVVMsL15mb2N1cyhpbik/JC8udGVzdChlLnR5cGUpKX0pLHQuZm5bZV09bC5falF1ZXJ5SW50ZXJmYWNlLHQuZm5bZV0uQ29uc3RydWN0b3I9bCx0LmZuW2VdLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdC5mbltlXT1pLGwuX2pRdWVyeUludGVyZmFjZX19KGpRdWVyeSksZnVuY3Rpb24odCl7dmFyIGU9XCJjYXJvdXNlbFwiLHM9XCJicy5jYXJvdXNlbFwiLGE9XCIuXCIrcyxsPXQuZm5bZV0saD17aW50ZXJ2YWw6NWUzLGtleWJvYXJkOiEwLHNsaWRlOiExLHBhdXNlOlwiaG92ZXJcIix3cmFwOiEwfSxjPXtpbnRlcnZhbDpcIihudW1iZXJ8Ym9vbGVhbilcIixrZXlib2FyZDpcImJvb2xlYW5cIixzbGlkZTpcIihib29sZWFufHN0cmluZylcIixwYXVzZTpcIihzdHJpbmd8Ym9vbGVhbilcIix3cmFwOlwiYm9vbGVhblwifSx1PXtORVhUOlwibmV4dFwiLFBSRVY6XCJwcmV2XCIsTEVGVDpcImxlZnRcIixSSUdIVDpcInJpZ2h0XCJ9LGQ9e1NMSURFOlwic2xpZGVcIithLFNMSUQ6XCJzbGlkXCIrYSxLRVlET1dOOlwia2V5ZG93blwiK2EsTU9VU0VFTlRFUjpcIm1vdXNlZW50ZXJcIithLE1PVVNFTEVBVkU6XCJtb3VzZWxlYXZlXCIrYSxUT1VDSEVORDpcInRvdWNoZW5kXCIrYSxMT0FEX0RBVEFfQVBJOlwibG9hZC5icy5jYXJvdXNlbC5kYXRhLWFwaVwiLENMSUNLX0RBVEFfQVBJOlwiY2xpY2suYnMuY2Fyb3VzZWwuZGF0YS1hcGlcIn0sZj17Q0FST1VTRUw6XCJjYXJvdXNlbFwiLEFDVElWRTpcImFjdGl2ZVwiLFNMSURFOlwic2xpZGVcIixSSUdIVDpcImNhcm91c2VsLWl0ZW0tcmlnaHRcIixMRUZUOlwiY2Fyb3VzZWwtaXRlbS1sZWZ0XCIsTkVYVDpcImNhcm91c2VsLWl0ZW0tbmV4dFwiLFBSRVY6XCJjYXJvdXNlbC1pdGVtLXByZXZcIixJVEVNOlwiY2Fyb3VzZWwtaXRlbVwifSxwPXtBQ1RJVkU6XCIuYWN0aXZlXCIsQUNUSVZFX0lURU06XCIuYWN0aXZlLmNhcm91c2VsLWl0ZW1cIixJVEVNOlwiLmNhcm91c2VsLWl0ZW1cIixORVhUX1BSRVY6XCIuY2Fyb3VzZWwtaXRlbS1uZXh0LCAuY2Fyb3VzZWwtaXRlbS1wcmV2XCIsSU5ESUNBVE9SUzpcIi5jYXJvdXNlbC1pbmRpY2F0b3JzXCIsREFUQV9TTElERTpcIltkYXRhLXNsaWRlXSwgW2RhdGEtc2xpZGUtdG9dXCIsREFUQV9SSURFOidbZGF0YS1yaWRlPVwiY2Fyb3VzZWxcIl0nfSxfPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbChlLGkpe24odGhpcyxsKSx0aGlzLl9pdGVtcz1udWxsLHRoaXMuX2ludGVydmFsPW51bGwsdGhpcy5fYWN0aXZlRWxlbWVudD1udWxsLHRoaXMuX2lzUGF1c2VkPSExLHRoaXMuX2lzU2xpZGluZz0hMSx0aGlzLnRvdWNoVGltZW91dD1udWxsLHRoaXMuX2NvbmZpZz10aGlzLl9nZXRDb25maWcoaSksdGhpcy5fZWxlbWVudD10KGUpWzBdLHRoaXMuX2luZGljYXRvcnNFbGVtZW50PXQodGhpcy5fZWxlbWVudCkuZmluZChwLklORElDQVRPUlMpWzBdLHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCl9cmV0dXJuIGwucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXt0aGlzLl9pc1NsaWRpbmd8fHRoaXMuX3NsaWRlKHUuTkVYVCl9LGwucHJvdG90eXBlLm5leHRXaGVuVmlzaWJsZT1mdW5jdGlvbigpe2RvY3VtZW50LmhpZGRlbnx8dGhpcy5uZXh0KCl9LGwucHJvdG90eXBlLnByZXY9ZnVuY3Rpb24oKXt0aGlzLl9pc1NsaWRpbmd8fHRoaXMuX3NsaWRlKHUuUFJFVil9LGwucHJvdG90eXBlLnBhdXNlPWZ1bmN0aW9uKGUpe2V8fCh0aGlzLl9pc1BhdXNlZD0hMCksdCh0aGlzLl9lbGVtZW50KS5maW5kKHAuTkVYVF9QUkVWKVswXSYmci5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKSYmKHIudHJpZ2dlclRyYW5zaXRpb25FbmQodGhpcy5fZWxlbWVudCksdGhpcy5jeWNsZSghMCkpLGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpLHRoaXMuX2ludGVydmFsPW51bGx9LGwucHJvdG90eXBlLmN5Y2xlPWZ1bmN0aW9uKHQpe3R8fCh0aGlzLl9pc1BhdXNlZD0hMSksdGhpcy5faW50ZXJ2YWwmJihjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKSx0aGlzLl9pbnRlcnZhbD1udWxsKSx0aGlzLl9jb25maWcuaW50ZXJ2YWwmJiF0aGlzLl9pc1BhdXNlZCYmKHRoaXMuX2ludGVydmFsPXNldEludGVydmFsKChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGU/dGhpcy5uZXh0V2hlblZpc2libGU6dGhpcy5uZXh0KS5iaW5kKHRoaXMpLHRoaXMuX2NvbmZpZy5pbnRlcnZhbCkpfSxsLnByb3RvdHlwZS50bz1mdW5jdGlvbihlKXt2YXIgbj10aGlzO3RoaXMuX2FjdGl2ZUVsZW1lbnQ9dCh0aGlzLl9lbGVtZW50KS5maW5kKHAuQUNUSVZFX0lURU0pWzBdO3ZhciBpPXRoaXMuX2dldEl0ZW1JbmRleCh0aGlzLl9hY3RpdmVFbGVtZW50KTtpZighKGU+dGhpcy5faXRlbXMubGVuZ3RoLTF8fGU8MCkpaWYodGhpcy5faXNTbGlkaW5nKXQodGhpcy5fZWxlbWVudCkub25lKGQuU0xJRCxmdW5jdGlvbigpe3JldHVybiBuLnRvKGUpfSk7ZWxzZXtpZihpPT09ZSlyZXR1cm4gdGhpcy5wYXVzZSgpLHZvaWQgdGhpcy5jeWNsZSgpO3ZhciBvPWU+aT91Lk5FWFQ6dS5QUkVWO3RoaXMuX3NsaWRlKG8sdGhpcy5faXRlbXNbZV0pfX0sbC5wcm90b3R5cGUuZGlzcG9zZT1mdW5jdGlvbigpe3QodGhpcy5fZWxlbWVudCkub2ZmKGEpLHQucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LHMpLHRoaXMuX2l0ZW1zPW51bGwsdGhpcy5fY29uZmlnPW51bGwsdGhpcy5fZWxlbWVudD1udWxsLHRoaXMuX2ludGVydmFsPW51bGwsdGhpcy5faXNQYXVzZWQ9bnVsbCx0aGlzLl9pc1NsaWRpbmc9bnVsbCx0aGlzLl9hY3RpdmVFbGVtZW50PW51bGwsdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQ9bnVsbH0sbC5wcm90b3R5cGUuX2dldENvbmZpZz1mdW5jdGlvbihuKXtyZXR1cm4gbj10LmV4dGVuZCh7fSxoLG4pLHIudHlwZUNoZWNrQ29uZmlnKGUsbixjKSxufSxsLnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lcnM9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMuX2NvbmZpZy5rZXlib2FyZCYmdCh0aGlzLl9lbGVtZW50KS5vbihkLktFWURPV04sZnVuY3Rpb24odCl7cmV0dXJuIGUuX2tleWRvd24odCl9KSxcImhvdmVyXCI9PT10aGlzLl9jb25maWcucGF1c2UmJih0KHRoaXMuX2VsZW1lbnQpLm9uKGQuTU9VU0VFTlRFUixmdW5jdGlvbih0KXtyZXR1cm4gZS5wYXVzZSh0KX0pLm9uKGQuTU9VU0VMRUFWRSxmdW5jdGlvbih0KXtyZXR1cm4gZS5jeWNsZSh0KX0pLFwib250b3VjaHN0YXJ0XCJpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQmJnQodGhpcy5fZWxlbWVudCkub24oZC5UT1VDSEVORCxmdW5jdGlvbigpe2UucGF1c2UoKSxlLnRvdWNoVGltZW91dCYmY2xlYXJUaW1lb3V0KGUudG91Y2hUaW1lb3V0KSxlLnRvdWNoVGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKHQpe3JldHVybiBlLmN5Y2xlKHQpfSw1MDArZS5fY29uZmlnLmludGVydmFsKX0pKX0sbC5wcm90b3R5cGUuX2tleWRvd249ZnVuY3Rpb24odCl7aWYoIS9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QodC50YXJnZXQudGFnTmFtZSkpc3dpdGNoKHQud2hpY2gpe2Nhc2UgMzc6dC5wcmV2ZW50RGVmYXVsdCgpLHRoaXMucHJldigpO2JyZWFrO2Nhc2UgMzk6dC5wcmV2ZW50RGVmYXVsdCgpLHRoaXMubmV4dCgpO2JyZWFrO2RlZmF1bHQ6cmV0dXJufX0sbC5wcm90b3R5cGUuX2dldEl0ZW1JbmRleD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5faXRlbXM9dC5tYWtlQXJyYXkodChlKS5wYXJlbnQoKS5maW5kKHAuSVRFTSkpLHRoaXMuX2l0ZW1zLmluZGV4T2YoZSl9LGwucHJvdG90eXBlLl9nZXRJdGVtQnlEaXJlY3Rpb249ZnVuY3Rpb24odCxlKXt2YXIgbj10PT09dS5ORVhULGk9dD09PXUuUFJFVixvPXRoaXMuX2dldEl0ZW1JbmRleChlKSxyPXRoaXMuX2l0ZW1zLmxlbmd0aC0xO2lmKChpJiYwPT09b3x8biYmbz09PXIpJiYhdGhpcy5fY29uZmlnLndyYXApcmV0dXJuIGU7dmFyIHM9KG8rKHQ9PT11LlBSRVY/LTE6MSkpJXRoaXMuX2l0ZW1zLmxlbmd0aDtyZXR1cm4tMT09PXM/dGhpcy5faXRlbXNbdGhpcy5faXRlbXMubGVuZ3RoLTFdOnRoaXMuX2l0ZW1zW3NdfSxsLnByb3RvdHlwZS5fdHJpZ2dlclNsaWRlRXZlbnQ9ZnVuY3Rpb24oZSxuKXt2YXIgaT10aGlzLl9nZXRJdGVtSW5kZXgoZSksbz10aGlzLl9nZXRJdGVtSW5kZXgodCh0aGlzLl9lbGVtZW50KS5maW5kKHAuQUNUSVZFX0lURU0pWzBdKSxyPXQuRXZlbnQoZC5TTElERSx7cmVsYXRlZFRhcmdldDplLGRpcmVjdGlvbjpuLGZyb206byx0bzppfSk7cmV0dXJuIHQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihyKSxyfSxsLnByb3RvdHlwZS5fc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudD1mdW5jdGlvbihlKXtpZih0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCl7dCh0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCkuZmluZChwLkFDVElWRSkucmVtb3ZlQ2xhc3MoZi5BQ1RJVkUpO3ZhciBuPXRoaXMuX2luZGljYXRvcnNFbGVtZW50LmNoaWxkcmVuW3RoaXMuX2dldEl0ZW1JbmRleChlKV07biYmdChuKS5hZGRDbGFzcyhmLkFDVElWRSl9fSxsLnByb3RvdHlwZS5fc2xpZGU9ZnVuY3Rpb24oZSxuKXt2YXIgaT10aGlzLG89dCh0aGlzLl9lbGVtZW50KS5maW5kKHAuQUNUSVZFX0lURU0pWzBdLHM9dGhpcy5fZ2V0SXRlbUluZGV4KG8pLGE9bnx8byYmdGhpcy5fZ2V0SXRlbUJ5RGlyZWN0aW9uKGUsbyksbD10aGlzLl9nZXRJdGVtSW5kZXgoYSksaD1Cb29sZWFuKHRoaXMuX2ludGVydmFsKSxjPXZvaWQgMCxfPXZvaWQgMCxnPXZvaWQgMDtpZihlPT09dS5ORVhUPyhjPWYuTEVGVCxfPWYuTkVYVCxnPXUuTEVGVCk6KGM9Zi5SSUdIVCxfPWYuUFJFVixnPXUuUklHSFQpLGEmJnQoYSkuaGFzQ2xhc3MoZi5BQ1RJVkUpKXRoaXMuX2lzU2xpZGluZz0hMTtlbHNlIGlmKCF0aGlzLl90cmlnZ2VyU2xpZGVFdmVudChhLGcpLmlzRGVmYXVsdFByZXZlbnRlZCgpJiZvJiZhKXt0aGlzLl9pc1NsaWRpbmc9ITAsaCYmdGhpcy5wYXVzZSgpLHRoaXMuX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQoYSk7dmFyIG09dC5FdmVudChkLlNMSUQse3JlbGF0ZWRUYXJnZXQ6YSxkaXJlY3Rpb246Zyxmcm9tOnMsdG86bH0pO3Iuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkmJnQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoZi5TTElERSk/KHQoYSkuYWRkQ2xhc3MoXyksci5yZWZsb3coYSksdChvKS5hZGRDbGFzcyhjKSx0KGEpLmFkZENsYXNzKGMpLHQobykub25lKHIuVFJBTlNJVElPTl9FTkQsZnVuY3Rpb24oKXt0KGEpLnJlbW92ZUNsYXNzKGMrXCIgXCIrXykuYWRkQ2xhc3MoZi5BQ1RJVkUpLHQobykucmVtb3ZlQ2xhc3MoZi5BQ1RJVkUrXCIgXCIrXytcIiBcIitjKSxpLl9pc1NsaWRpbmc9ITEsc2V0VGltZW91dChmdW5jdGlvbigpe3JldHVybiB0KGkuX2VsZW1lbnQpLnRyaWdnZXIobSl9LDApfSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoNjAwKSk6KHQobykucmVtb3ZlQ2xhc3MoZi5BQ1RJVkUpLHQoYSkuYWRkQ2xhc3MoZi5BQ1RJVkUpLHRoaXMuX2lzU2xpZGluZz0hMSx0KHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIobSkpLGgmJnRoaXMuY3ljbGUoKX19LGwuX2pRdWVyeUludGVyZmFjZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIG49dCh0aGlzKS5kYXRhKHMpLG89dC5leHRlbmQoe30saCx0KHRoaXMpLmRhdGEoKSk7XCJvYmplY3RcIj09PSh2b2lkIDA9PT1lP1widW5kZWZpbmVkXCI6aShlKSkmJnQuZXh0ZW5kKG8sZSk7dmFyIHI9XCJzdHJpbmdcIj09dHlwZW9mIGU/ZTpvLnNsaWRlO2lmKG58fChuPW5ldyBsKHRoaXMsbyksdCh0aGlzKS5kYXRhKHMsbikpLFwibnVtYmVyXCI9PXR5cGVvZiBlKW4udG8oZSk7ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2Ygcil7aWYodm9pZCAwPT09bltyXSl0aHJvdyBuZXcgRXJyb3IoJ05vIG1ldGhvZCBuYW1lZCBcIicrcisnXCInKTtuW3JdKCl9ZWxzZSBvLmludGVydmFsJiYobi5wYXVzZSgpLG4uY3ljbGUoKSl9KX0sbC5fZGF0YUFwaUNsaWNrSGFuZGxlcj1mdW5jdGlvbihlKXt2YXIgbj1yLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcyk7aWYobil7dmFyIGk9dChuKVswXTtpZihpJiZ0KGkpLmhhc0NsYXNzKGYuQ0FST1VTRUwpKXt2YXIgbz10LmV4dGVuZCh7fSx0KGkpLmRhdGEoKSx0KHRoaXMpLmRhdGEoKSksYT10aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtc2xpZGUtdG9cIik7YSYmKG8uaW50ZXJ2YWw9ITEpLGwuX2pRdWVyeUludGVyZmFjZS5jYWxsKHQoaSksbyksYSYmdChpKS5kYXRhKHMpLnRvKGEpLGUucHJldmVudERlZmF1bHQoKX19fSxvKGwsbnVsbCxbe2tleTpcIlZFUlNJT05cIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cIjQuMC4wLWJldGFcIn19LHtrZXk6XCJEZWZhdWx0XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGh9fV0pLGx9KCk7dChkb2N1bWVudCkub24oZC5DTElDS19EQVRBX0FQSSxwLkRBVEFfU0xJREUsXy5fZGF0YUFwaUNsaWNrSGFuZGxlciksdCh3aW5kb3cpLm9uKGQuTE9BRF9EQVRBX0FQSSxmdW5jdGlvbigpe3QocC5EQVRBX1JJREUpLmVhY2goZnVuY3Rpb24oKXt2YXIgZT10KHRoaXMpO18uX2pRdWVyeUludGVyZmFjZS5jYWxsKGUsZS5kYXRhKCkpfSl9KSx0LmZuW2VdPV8uX2pRdWVyeUludGVyZmFjZSx0LmZuW2VdLkNvbnN0cnVjdG9yPV8sdC5mbltlXS5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIHQuZm5bZV09bCxfLl9qUXVlcnlJbnRlcmZhY2V9fShqUXVlcnkpLGZ1bmN0aW9uKHQpe3ZhciBlPVwiY29sbGFwc2VcIixzPVwiYnMuY29sbGFwc2VcIixhPXQuZm5bZV0sbD17dG9nZ2xlOiEwLHBhcmVudDpcIlwifSxoPXt0b2dnbGU6XCJib29sZWFuXCIscGFyZW50Olwic3RyaW5nXCJ9LGM9e1NIT1c6XCJzaG93LmJzLmNvbGxhcHNlXCIsU0hPV046XCJzaG93bi5icy5jb2xsYXBzZVwiLEhJREU6XCJoaWRlLmJzLmNvbGxhcHNlXCIsSElEREVOOlwiaGlkZGVuLmJzLmNvbGxhcHNlXCIsQ0xJQ0tfREFUQV9BUEk6XCJjbGljay5icy5jb2xsYXBzZS5kYXRhLWFwaVwifSx1PXtTSE9XOlwic2hvd1wiLENPTExBUFNFOlwiY29sbGFwc2VcIixDT0xMQVBTSU5HOlwiY29sbGFwc2luZ1wiLENPTExBUFNFRDpcImNvbGxhcHNlZFwifSxkPXtXSURUSDpcIndpZHRoXCIsSEVJR0hUOlwiaGVpZ2h0XCJ9LGY9e0FDVElWRVM6XCIuc2hvdywgLmNvbGxhcHNpbmdcIixEQVRBX1RPR0dMRTonW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl0nfSxwPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShlLGkpe24odGhpcyxhKSx0aGlzLl9pc1RyYW5zaXRpb25pbmc9ITEsdGhpcy5fZWxlbWVudD1lLHRoaXMuX2NvbmZpZz10aGlzLl9nZXRDb25maWcoaSksdGhpcy5fdHJpZ2dlckFycmF5PXQubWFrZUFycmF5KHQoJ1tkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdW2hyZWY9XCIjJytlLmlkKydcIl0sW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1bZGF0YS10YXJnZXQ9XCIjJytlLmlkKydcIl0nKSk7Zm9yKHZhciBvPXQoZi5EQVRBX1RPR0dMRSkscz0wO3M8by5sZW5ndGg7cysrKXt2YXIgbD1vW3NdLGg9ci5nZXRTZWxlY3RvckZyb21FbGVtZW50KGwpO251bGwhPT1oJiZ0KGgpLmZpbHRlcihlKS5sZW5ndGg+MCYmdGhpcy5fdHJpZ2dlckFycmF5LnB1c2gobCl9dGhpcy5fcGFyZW50PXRoaXMuX2NvbmZpZy5wYXJlbnQ/dGhpcy5fZ2V0UGFyZW50KCk6bnVsbCx0aGlzLl9jb25maWcucGFyZW50fHx0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy5fZWxlbWVudCx0aGlzLl90cmlnZ2VyQXJyYXkpLHRoaXMuX2NvbmZpZy50b2dnbGUmJnRoaXMudG9nZ2xlKCl9cmV0dXJuIGEucHJvdG90eXBlLnRvZ2dsZT1mdW5jdGlvbigpe3QodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3ModS5TSE9XKT90aGlzLmhpZGUoKTp0aGlzLnNob3coKX0sYS5wcm90b3R5cGUuc2hvdz1mdW5jdGlvbigpe3ZhciBlPXRoaXM7aWYoIXRoaXMuX2lzVHJhbnNpdGlvbmluZyYmIXQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3ModS5TSE9XKSl7dmFyIG49dm9pZCAwLGk9dm9pZCAwO2lmKHRoaXMuX3BhcmVudCYmKChuPXQubWFrZUFycmF5KHQodGhpcy5fcGFyZW50KS5jaGlsZHJlbigpLmNoaWxkcmVuKGYuQUNUSVZFUykpKS5sZW5ndGh8fChuPW51bGwpKSwhKG4mJihpPXQobikuZGF0YShzKSkmJmkuX2lzVHJhbnNpdGlvbmluZykpe3ZhciBvPXQuRXZlbnQoYy5TSE9XKTtpZih0KHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIobyksIW8uaXNEZWZhdWx0UHJldmVudGVkKCkpe24mJihhLl9qUXVlcnlJbnRlcmZhY2UuY2FsbCh0KG4pLFwiaGlkZVwiKSxpfHx0KG4pLmRhdGEocyxudWxsKSk7dmFyIGw9dGhpcy5fZ2V0RGltZW5zaW9uKCk7dCh0aGlzLl9lbGVtZW50KS5yZW1vdmVDbGFzcyh1LkNPTExBUFNFKS5hZGRDbGFzcyh1LkNPTExBUFNJTkcpLHRoaXMuX2VsZW1lbnQuc3R5bGVbbF09MCx0aGlzLl90cmlnZ2VyQXJyYXkubGVuZ3RoJiZ0KHRoaXMuX3RyaWdnZXJBcnJheSkucmVtb3ZlQ2xhc3ModS5DT0xMQVBTRUQpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsITApLHRoaXMuc2V0VHJhbnNpdGlvbmluZyghMCk7dmFyIGg9ZnVuY3Rpb24oKXt0KGUuX2VsZW1lbnQpLnJlbW92ZUNsYXNzKHUuQ09MTEFQU0lORykuYWRkQ2xhc3ModS5DT0xMQVBTRSkuYWRkQ2xhc3ModS5TSE9XKSxlLl9lbGVtZW50LnN0eWxlW2xdPVwiXCIsZS5zZXRUcmFuc2l0aW9uaW5nKCExKSx0KGUuX2VsZW1lbnQpLnRyaWdnZXIoYy5TSE9XTil9O2lmKHIuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkpe3ZhciBkPVwic2Nyb2xsXCIrKGxbMF0udG9VcHBlckNhc2UoKStsLnNsaWNlKDEpKTt0KHRoaXMuX2VsZW1lbnQpLm9uZShyLlRSQU5TSVRJT05fRU5ELGgpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKDYwMCksdGhpcy5fZWxlbWVudC5zdHlsZVtsXT10aGlzLl9lbGVtZW50W2RdK1wicHhcIn1lbHNlIGgoKX19fX0sYS5wcm90b3R5cGUuaGlkZT1mdW5jdGlvbigpe3ZhciBlPXRoaXM7aWYoIXRoaXMuX2lzVHJhbnNpdGlvbmluZyYmdCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyh1LlNIT1cpKXt2YXIgbj10LkV2ZW50KGMuSElERSk7aWYodCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKG4pLCFuLmlzRGVmYXVsdFByZXZlbnRlZCgpKXt2YXIgaT10aGlzLl9nZXREaW1lbnNpb24oKTtpZih0aGlzLl9lbGVtZW50LnN0eWxlW2ldPXRoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbaV0rXCJweFwiLHIucmVmbG93KHRoaXMuX2VsZW1lbnQpLHQodGhpcy5fZWxlbWVudCkuYWRkQ2xhc3ModS5DT0xMQVBTSU5HKS5yZW1vdmVDbGFzcyh1LkNPTExBUFNFKS5yZW1vdmVDbGFzcyh1LlNIT1cpLHRoaXMuX3RyaWdnZXJBcnJheS5sZW5ndGgpZm9yKHZhciBvPTA7bzx0aGlzLl90cmlnZ2VyQXJyYXkubGVuZ3RoO28rKyl7dmFyIHM9dGhpcy5fdHJpZ2dlckFycmF5W29dLGE9ci5nZXRTZWxlY3RvckZyb21FbGVtZW50KHMpO251bGwhPT1hJiYodChhKS5oYXNDbGFzcyh1LlNIT1cpfHx0KHMpLmFkZENsYXNzKHUuQ09MTEFQU0VEKS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCExKSl9dGhpcy5zZXRUcmFuc2l0aW9uaW5nKCEwKTt2YXIgbD1mdW5jdGlvbigpe2Uuc2V0VHJhbnNpdGlvbmluZyghMSksdChlLl9lbGVtZW50KS5yZW1vdmVDbGFzcyh1LkNPTExBUFNJTkcpLmFkZENsYXNzKHUuQ09MTEFQU0UpLnRyaWdnZXIoYy5ISURERU4pfTt0aGlzLl9lbGVtZW50LnN0eWxlW2ldPVwiXCIsci5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKT90KHRoaXMuX2VsZW1lbnQpLm9uZShyLlRSQU5TSVRJT05fRU5ELGwpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKDYwMCk6bCgpfX19LGEucHJvdG90eXBlLnNldFRyYW5zaXRpb25pbmc9ZnVuY3Rpb24odCl7dGhpcy5faXNUcmFuc2l0aW9uaW5nPXR9LGEucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0LnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCxzKSx0aGlzLl9jb25maWc9bnVsbCx0aGlzLl9wYXJlbnQ9bnVsbCx0aGlzLl9lbGVtZW50PW51bGwsdGhpcy5fdHJpZ2dlckFycmF5PW51bGwsdGhpcy5faXNUcmFuc2l0aW9uaW5nPW51bGx9LGEucHJvdG90eXBlLl9nZXRDb25maWc9ZnVuY3Rpb24obil7cmV0dXJuIG49dC5leHRlbmQoe30sbCxuKSxuLnRvZ2dsZT1Cb29sZWFuKG4udG9nZ2xlKSxyLnR5cGVDaGVja0NvbmZpZyhlLG4saCksbn0sYS5wcm90b3R5cGUuX2dldERpbWVuc2lvbj1mdW5jdGlvbigpe3JldHVybiB0KHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKGQuV0lEVEgpP2QuV0lEVEg6ZC5IRUlHSFR9LGEucHJvdG90eXBlLl9nZXRQYXJlbnQ9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLG49dCh0aGlzLl9jb25maWcucGFyZW50KVswXSxpPSdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtkYXRhLXBhcmVudD1cIicrdGhpcy5fY29uZmlnLnBhcmVudCsnXCJdJztyZXR1cm4gdChuKS5maW5kKGkpLmVhY2goZnVuY3Rpb24odCxuKXtlLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoYS5fZ2V0VGFyZ2V0RnJvbUVsZW1lbnQobiksW25dKX0pLG59LGEucHJvdG90eXBlLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3M9ZnVuY3Rpb24oZSxuKXtpZihlKXt2YXIgaT10KGUpLmhhc0NsYXNzKHUuU0hPVyk7bi5sZW5ndGgmJnQobikudG9nZ2xlQ2xhc3ModS5DT0xMQVBTRUQsIWkpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsaSl9fSxhLl9nZXRUYXJnZXRGcm9tRWxlbWVudD1mdW5jdGlvbihlKXt2YXIgbj1yLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZSk7cmV0dXJuIG4/dChuKVswXTpudWxsfSxhLl9qUXVlcnlJbnRlcmZhY2U9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBuPXQodGhpcyksbz1uLmRhdGEocykscj10LmV4dGVuZCh7fSxsLG4uZGF0YSgpLFwib2JqZWN0XCI9PT0odm9pZCAwPT09ZT9cInVuZGVmaW5lZFwiOmkoZSkpJiZlKTtpZighbyYmci50b2dnbGUmJi9zaG93fGhpZGUvLnRlc3QoZSkmJihyLnRvZ2dsZT0hMSksb3x8KG89bmV3IGEodGhpcyxyKSxuLmRhdGEocyxvKSksXCJzdHJpbmdcIj09dHlwZW9mIGUpe2lmKHZvaWQgMD09PW9bZV0pdGhyb3cgbmV3IEVycm9yKCdObyBtZXRob2QgbmFtZWQgXCInK2UrJ1wiJyk7b1tlXSgpfX0pfSxvKGEsbnVsbCxbe2tleTpcIlZFUlNJT05cIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cIjQuMC4wLWJldGFcIn19LHtrZXk6XCJEZWZhdWx0XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGx9fV0pLGF9KCk7dChkb2N1bWVudCkub24oYy5DTElDS19EQVRBX0FQSSxmLkRBVEFfVE9HR0xFLGZ1bmN0aW9uKGUpey9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZS50YXJnZXQudGFnTmFtZSl8fGUucHJldmVudERlZmF1bHQoKTt2YXIgbj10KHRoaXMpLGk9ci5nZXRTZWxlY3RvckZyb21FbGVtZW50KHRoaXMpO3QoaSkuZWFjaChmdW5jdGlvbigpe3ZhciBlPXQodGhpcyksaT1lLmRhdGEocyk/XCJ0b2dnbGVcIjpuLmRhdGEoKTtwLl9qUXVlcnlJbnRlcmZhY2UuY2FsbChlLGkpfSl9KSx0LmZuW2VdPXAuX2pRdWVyeUludGVyZmFjZSx0LmZuW2VdLkNvbnN0cnVjdG9yPXAsdC5mbltlXS5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIHQuZm5bZV09YSxwLl9qUXVlcnlJbnRlcmZhY2V9fShqUXVlcnkpLGZ1bmN0aW9uKHQpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBQb3BwZXIpdGhyb3cgbmV3IEVycm9yKFwiQm9vdHN0cmFwIGRyb3Bkb3duIHJlcXVpcmUgUG9wcGVyLmpzIChodHRwczovL3BvcHBlci5qcy5vcmcpXCIpO3ZhciBlPVwiZHJvcGRvd25cIixzPVwiYnMuZHJvcGRvd25cIixhPVwiLlwiK3MsbD10LmZuW2VdLGg9bmV3IFJlZ0V4cChcIjM4fDQwfDI3XCIpLGM9e0hJREU6XCJoaWRlXCIrYSxISURERU46XCJoaWRkZW5cIithLFNIT1c6XCJzaG93XCIrYSxTSE9XTjpcInNob3duXCIrYSxDTElDSzpcImNsaWNrXCIrYSxDTElDS19EQVRBX0FQSTpcImNsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpXCIsS0VZRE9XTl9EQVRBX0FQSTpcImtleWRvd24uYnMuZHJvcGRvd24uZGF0YS1hcGlcIixLRVlVUF9EQVRBX0FQSTpcImtleXVwLmJzLmRyb3Bkb3duLmRhdGEtYXBpXCJ9LHU9e0RJU0FCTEVEOlwiZGlzYWJsZWRcIixTSE9XOlwic2hvd1wiLERST1BVUDpcImRyb3B1cFwiLE1FTlVSSUdIVDpcImRyb3Bkb3duLW1lbnUtcmlnaHRcIixNRU5VTEVGVDpcImRyb3Bkb3duLW1lbnUtbGVmdFwifSxkPXtEQVRBX1RPR0dMRTonW2RhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIl0nLEZPUk1fQ0hJTEQ6XCIuZHJvcGRvd24gZm9ybVwiLE1FTlU6XCIuZHJvcGRvd24tbWVudVwiLE5BVkJBUl9OQVY6XCIubmF2YmFyLW5hdlwiLFZJU0lCTEVfSVRFTVM6XCIuZHJvcGRvd24tbWVudSAuZHJvcGRvd24taXRlbTpub3QoLmRpc2FibGVkKVwifSxmPXtUT1A6XCJ0b3Atc3RhcnRcIixUT1BFTkQ6XCJ0b3AtZW5kXCIsQk9UVE9NOlwiYm90dG9tLXN0YXJ0XCIsQk9UVE9NRU5EOlwiYm90dG9tLWVuZFwifSxwPXtwbGFjZW1lbnQ6Zi5CT1RUT00sb2Zmc2V0OjAsZmxpcDohMH0sXz17cGxhY2VtZW50Olwic3RyaW5nXCIsb2Zmc2V0OlwiKG51bWJlcnxzdHJpbmcpXCIsZmxpcDpcImJvb2xlYW5cIn0sZz1mdW5jdGlvbigpe2Z1bmN0aW9uIGwodCxlKXtuKHRoaXMsbCksdGhpcy5fZWxlbWVudD10LHRoaXMuX3BvcHBlcj1udWxsLHRoaXMuX2NvbmZpZz10aGlzLl9nZXRDb25maWcoZSksdGhpcy5fbWVudT10aGlzLl9nZXRNZW51RWxlbWVudCgpLHRoaXMuX2luTmF2YmFyPXRoaXMuX2RldGVjdE5hdmJhcigpLHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCl9cmV0dXJuIGwucHJvdG90eXBlLnRvZ2dsZT1mdW5jdGlvbigpe2lmKCF0aGlzLl9lbGVtZW50LmRpc2FibGVkJiYhdCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyh1LkRJU0FCTEVEKSl7dmFyIGU9bC5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCksbj10KHRoaXMuX21lbnUpLmhhc0NsYXNzKHUuU0hPVyk7aWYobC5fY2xlYXJNZW51cygpLCFuKXt2YXIgaT17cmVsYXRlZFRhcmdldDp0aGlzLl9lbGVtZW50fSxvPXQuRXZlbnQoYy5TSE9XLGkpO2lmKHQoZSkudHJpZ2dlcihvKSwhby5pc0RlZmF1bHRQcmV2ZW50ZWQoKSl7dmFyIHI9dGhpcy5fZWxlbWVudDt0KGUpLmhhc0NsYXNzKHUuRFJPUFVQKSYmKHQodGhpcy5fbWVudSkuaGFzQ2xhc3ModS5NRU5VTEVGVCl8fHQodGhpcy5fbWVudSkuaGFzQ2xhc3ModS5NRU5VUklHSFQpKSYmKHI9ZSksdGhpcy5fcG9wcGVyPW5ldyBQb3BwZXIocix0aGlzLl9tZW51LHRoaXMuX2dldFBvcHBlckNvbmZpZygpKSxcIm9udG91Y2hzdGFydFwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiYhdChlKS5jbG9zZXN0KGQuTkFWQkFSX05BVikubGVuZ3RoJiZ0KFwiYm9keVwiKS5jaGlsZHJlbigpLm9uKFwibW91c2VvdmVyXCIsbnVsbCx0Lm5vb3ApLHRoaXMuX2VsZW1lbnQuZm9jdXMoKSx0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwhMCksdCh0aGlzLl9tZW51KS50b2dnbGVDbGFzcyh1LlNIT1cpLHQoZSkudG9nZ2xlQ2xhc3ModS5TSE9XKS50cmlnZ2VyKHQuRXZlbnQoYy5TSE9XTixpKSl9fX19LGwucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0LnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCxzKSx0KHRoaXMuX2VsZW1lbnQpLm9mZihhKSx0aGlzLl9lbGVtZW50PW51bGwsdGhpcy5fbWVudT1udWxsLG51bGwhPT10aGlzLl9wb3BwZXImJnRoaXMuX3BvcHBlci5kZXN0cm95KCksdGhpcy5fcG9wcGVyPW51bGx9LGwucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbigpe3RoaXMuX2luTmF2YmFyPXRoaXMuX2RldGVjdE5hdmJhcigpLG51bGwhPT10aGlzLl9wb3BwZXImJnRoaXMuX3BvcHBlci5zY2hlZHVsZVVwZGF0ZSgpfSxsLnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lcnM9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3QodGhpcy5fZWxlbWVudCkub24oYy5DTElDSyxmdW5jdGlvbih0KXt0LnByZXZlbnREZWZhdWx0KCksdC5zdG9wUHJvcGFnYXRpb24oKSxlLnRvZ2dsZSgpfSl9LGwucHJvdG90eXBlLl9nZXRDb25maWc9ZnVuY3Rpb24obil7dmFyIGk9dCh0aGlzLl9lbGVtZW50KS5kYXRhKCk7cmV0dXJuIHZvaWQgMCE9PWkucGxhY2VtZW50JiYoaS5wbGFjZW1lbnQ9ZltpLnBsYWNlbWVudC50b1VwcGVyQ2FzZSgpXSksbj10LmV4dGVuZCh7fSx0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQsdCh0aGlzLl9lbGVtZW50KS5kYXRhKCksbiksci50eXBlQ2hlY2tDb25maWcoZSxuLHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpLG59LGwucHJvdG90eXBlLl9nZXRNZW51RWxlbWVudD1mdW5jdGlvbigpe2lmKCF0aGlzLl9tZW51KXt2YXIgZT1sLl9nZXRQYXJlbnRGcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTt0aGlzLl9tZW51PXQoZSkuZmluZChkLk1FTlUpWzBdfXJldHVybiB0aGlzLl9tZW51fSxsLnByb3RvdHlwZS5fZ2V0UGxhY2VtZW50PWZ1bmN0aW9uKCl7dmFyIGU9dCh0aGlzLl9lbGVtZW50KS5wYXJlbnQoKSxuPXRoaXMuX2NvbmZpZy5wbGFjZW1lbnQ7cmV0dXJuIGUuaGFzQ2xhc3ModS5EUk9QVVApfHx0aGlzLl9jb25maWcucGxhY2VtZW50PT09Zi5UT1A/KG49Zi5UT1AsdCh0aGlzLl9tZW51KS5oYXNDbGFzcyh1Lk1FTlVSSUdIVCkmJihuPWYuVE9QRU5EKSk6dCh0aGlzLl9tZW51KS5oYXNDbGFzcyh1Lk1FTlVSSUdIVCkmJihuPWYuQk9UVE9NRU5EKSxufSxsLnByb3RvdHlwZS5fZGV0ZWN0TmF2YmFyPWZ1bmN0aW9uKCl7cmV0dXJuIHQodGhpcy5fZWxlbWVudCkuY2xvc2VzdChcIi5uYXZiYXJcIikubGVuZ3RoPjB9LGwucHJvdG90eXBlLl9nZXRQb3BwZXJDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17cGxhY2VtZW50OnRoaXMuX2dldFBsYWNlbWVudCgpLG1vZGlmaWVyczp7b2Zmc2V0OntvZmZzZXQ6dGhpcy5fY29uZmlnLm9mZnNldH0sZmxpcDp7ZW5hYmxlZDp0aGlzLl9jb25maWcuZmxpcH19fTtyZXR1cm4gdGhpcy5faW5OYXZiYXImJih0Lm1vZGlmaWVycy5hcHBseVN0eWxlPXtlbmFibGVkOiF0aGlzLl9pbk5hdmJhcn0pLHR9LGwuX2pRdWVyeUludGVyZmFjZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIG49dCh0aGlzKS5kYXRhKHMpLG89XCJvYmplY3RcIj09PSh2b2lkIDA9PT1lP1widW5kZWZpbmVkXCI6aShlKSk/ZTpudWxsO2lmKG58fChuPW5ldyBsKHRoaXMsbyksdCh0aGlzKS5kYXRhKHMsbikpLFwic3RyaW5nXCI9PXR5cGVvZiBlKXtpZih2b2lkIDA9PT1uW2VdKXRocm93IG5ldyBFcnJvcignTm8gbWV0aG9kIG5hbWVkIFwiJytlKydcIicpO25bZV0oKX19KX0sbC5fY2xlYXJNZW51cz1mdW5jdGlvbihlKXtpZighZXx8MyE9PWUud2hpY2gmJihcImtleXVwXCIhPT1lLnR5cGV8fDk9PT1lLndoaWNoKSlmb3IodmFyIG49dC5tYWtlQXJyYXkodChkLkRBVEFfVE9HR0xFKSksaT0wO2k8bi5sZW5ndGg7aSsrKXt2YXIgbz1sLl9nZXRQYXJlbnRGcm9tRWxlbWVudChuW2ldKSxyPXQobltpXSkuZGF0YShzKSxhPXtyZWxhdGVkVGFyZ2V0Om5baV19O2lmKHIpe3ZhciBoPXIuX21lbnU7aWYodChvKS5oYXNDbGFzcyh1LlNIT1cpJiYhKGUmJihcImNsaWNrXCI9PT1lLnR5cGUmJi9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZS50YXJnZXQudGFnTmFtZSl8fFwia2V5dXBcIj09PWUudHlwZSYmOT09PWUud2hpY2gpJiZ0LmNvbnRhaW5zKG8sZS50YXJnZXQpKSl7dmFyIGY9dC5FdmVudChjLkhJREUsYSk7dChvKS50cmlnZ2VyKGYpLGYuaXNEZWZhdWx0UHJldmVudGVkKCl8fChcIm9udG91Y2hzdGFydFwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiZ0KFwiYm9keVwiKS5jaGlsZHJlbigpLm9mZihcIm1vdXNlb3ZlclwiLG51bGwsdC5ub29wKSxuW2ldLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIixcImZhbHNlXCIpLHQoaCkucmVtb3ZlQ2xhc3ModS5TSE9XKSx0KG8pLnJlbW92ZUNsYXNzKHUuU0hPVykudHJpZ2dlcih0LkV2ZW50KGMuSElEREVOLGEpKSl9fX19LGwuX2dldFBhcmVudEZyb21FbGVtZW50PWZ1bmN0aW9uKGUpe3ZhciBuPXZvaWQgMCxpPXIuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlKTtyZXR1cm4gaSYmKG49dChpKVswXSksbnx8ZS5wYXJlbnROb2RlfSxsLl9kYXRhQXBpS2V5ZG93bkhhbmRsZXI9ZnVuY3Rpb24oZSl7aWYoISghaC50ZXN0KGUud2hpY2gpfHwvYnV0dG9uL2kudGVzdChlLnRhcmdldC50YWdOYW1lKSYmMzI9PT1lLndoaWNofHwvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGUudGFyZ2V0LnRhZ05hbWUpfHwoZS5wcmV2ZW50RGVmYXVsdCgpLGUuc3RvcFByb3BhZ2F0aW9uKCksdGhpcy5kaXNhYmxlZHx8dCh0aGlzKS5oYXNDbGFzcyh1LkRJU0FCTEVEKSkpKXt2YXIgbj1sLl9nZXRQYXJlbnRGcm9tRWxlbWVudCh0aGlzKSxpPXQobikuaGFzQ2xhc3ModS5TSE9XKTtpZigoaXx8Mjc9PT1lLndoaWNoJiYzMj09PWUud2hpY2gpJiYoIWl8fDI3IT09ZS53aGljaCYmMzIhPT1lLndoaWNoKSl7dmFyIG89dChuKS5maW5kKGQuVklTSUJMRV9JVEVNUykuZ2V0KCk7aWYoby5sZW5ndGgpe3ZhciByPW8uaW5kZXhPZihlLnRhcmdldCk7Mzg9PT1lLndoaWNoJiZyPjAmJnItLSw0MD09PWUud2hpY2gmJnI8by5sZW5ndGgtMSYmcisrLHI8MCYmKHI9MCksb1tyXS5mb2N1cygpfX1lbHNle2lmKDI3PT09ZS53aGljaCl7dmFyIHM9dChuKS5maW5kKGQuREFUQV9UT0dHTEUpWzBdO3QocykudHJpZ2dlcihcImZvY3VzXCIpfXQodGhpcykudHJpZ2dlcihcImNsaWNrXCIpfX19LG8obCxudWxsLFt7a2V5OlwiVkVSU0lPTlwiLGdldDpmdW5jdGlvbigpe3JldHVyblwiNC4wLjAtYmV0YVwifX0se2tleTpcIkRlZmF1bHRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcH19LHtrZXk6XCJEZWZhdWx0VHlwZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiBffX1dKSxsfSgpO3QoZG9jdW1lbnQpLm9uKGMuS0VZRE9XTl9EQVRBX0FQSSxkLkRBVEFfVE9HR0xFLGcuX2RhdGFBcGlLZXlkb3duSGFuZGxlcikub24oYy5LRVlET1dOX0RBVEFfQVBJLGQuTUVOVSxnLl9kYXRhQXBpS2V5ZG93bkhhbmRsZXIpLm9uKGMuQ0xJQ0tfREFUQV9BUEkrXCIgXCIrYy5LRVlVUF9EQVRBX0FQSSxnLl9jbGVhck1lbnVzKS5vbihjLkNMSUNLX0RBVEFfQVBJLGQuREFUQV9UT0dHTEUsZnVuY3Rpb24oZSl7ZS5wcmV2ZW50RGVmYXVsdCgpLGUuc3RvcFByb3BhZ2F0aW9uKCksZy5falF1ZXJ5SW50ZXJmYWNlLmNhbGwodCh0aGlzKSxcInRvZ2dsZVwiKX0pLm9uKGMuQ0xJQ0tfREFUQV9BUEksZC5GT1JNX0NISUxELGZ1bmN0aW9uKHQpe3Quc3RvcFByb3BhZ2F0aW9uKCl9KSx0LmZuW2VdPWcuX2pRdWVyeUludGVyZmFjZSx0LmZuW2VdLkNvbnN0cnVjdG9yPWcsdC5mbltlXS5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIHQuZm5bZV09bCxnLl9qUXVlcnlJbnRlcmZhY2V9fShqUXVlcnkpLGZ1bmN0aW9uKHQpe3ZhciBlPVwibW9kYWxcIixzPVwiLmJzLm1vZGFsXCIsYT10LmZuW2VdLGw9e2JhY2tkcm9wOiEwLGtleWJvYXJkOiEwLGZvY3VzOiEwLHNob3c6ITB9LGg9e2JhY2tkcm9wOlwiKGJvb2xlYW58c3RyaW5nKVwiLGtleWJvYXJkOlwiYm9vbGVhblwiLGZvY3VzOlwiYm9vbGVhblwiLHNob3c6XCJib29sZWFuXCJ9LGM9e0hJREU6XCJoaWRlLmJzLm1vZGFsXCIsSElEREVOOlwiaGlkZGVuLmJzLm1vZGFsXCIsU0hPVzpcInNob3cuYnMubW9kYWxcIixTSE9XTjpcInNob3duLmJzLm1vZGFsXCIsRk9DVVNJTjpcImZvY3VzaW4uYnMubW9kYWxcIixSRVNJWkU6XCJyZXNpemUuYnMubW9kYWxcIixDTElDS19ESVNNSVNTOlwiY2xpY2suZGlzbWlzcy5icy5tb2RhbFwiLEtFWURPV05fRElTTUlTUzpcImtleWRvd24uZGlzbWlzcy5icy5tb2RhbFwiLE1PVVNFVVBfRElTTUlTUzpcIm1vdXNldXAuZGlzbWlzcy5icy5tb2RhbFwiLE1PVVNFRE9XTl9ESVNNSVNTOlwibW91c2Vkb3duLmRpc21pc3MuYnMubW9kYWxcIixDTElDS19EQVRBX0FQSTpcImNsaWNrLmJzLm1vZGFsLmRhdGEtYXBpXCJ9LHU9e1NDUk9MTEJBUl9NRUFTVVJFUjpcIm1vZGFsLXNjcm9sbGJhci1tZWFzdXJlXCIsQkFDS0RST1A6XCJtb2RhbC1iYWNrZHJvcFwiLE9QRU46XCJtb2RhbC1vcGVuXCIsRkFERTpcImZhZGVcIixTSE9XOlwic2hvd1wifSxkPXtESUFMT0c6XCIubW9kYWwtZGlhbG9nXCIsREFUQV9UT0dHTEU6J1tkYXRhLXRvZ2dsZT1cIm1vZGFsXCJdJyxEQVRBX0RJU01JU1M6J1tkYXRhLWRpc21pc3M9XCJtb2RhbFwiXScsRklYRURfQ09OVEVOVDpcIi5maXhlZC10b3AsIC5maXhlZC1ib3R0b20sIC5pcy1maXhlZCwgLnN0aWNreS10b3BcIixOQVZCQVJfVE9HR0xFUjpcIi5uYXZiYXItdG9nZ2xlclwifSxmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShlLGkpe24odGhpcyxhKSx0aGlzLl9jb25maWc9dGhpcy5fZ2V0Q29uZmlnKGkpLHRoaXMuX2VsZW1lbnQ9ZSx0aGlzLl9kaWFsb2c9dChlKS5maW5kKGQuRElBTE9HKVswXSx0aGlzLl9iYWNrZHJvcD1udWxsLHRoaXMuX2lzU2hvd249ITEsdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmc9ITEsdGhpcy5faWdub3JlQmFja2Ryb3BDbGljaz0hMSx0aGlzLl9vcmlnaW5hbEJvZHlQYWRkaW5nPTAsdGhpcy5fc2Nyb2xsYmFyV2lkdGg9MH1yZXR1cm4gYS5wcm90b3R5cGUudG9nZ2xlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9pc1Nob3duP3RoaXMuaGlkZSgpOnRoaXMuc2hvdyh0KX0sYS5wcm90b3R5cGUuc2hvdz1mdW5jdGlvbihlKXt2YXIgbj10aGlzO2lmKCF0aGlzLl9pc1RyYW5zaXRpb25pbmcpe3Iuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkmJnQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3ModS5GQURFKSYmKHRoaXMuX2lzVHJhbnNpdGlvbmluZz0hMCk7dmFyIGk9dC5FdmVudChjLlNIT1cse3JlbGF0ZWRUYXJnZXQ6ZX0pO3QodGhpcy5fZWxlbWVudCkudHJpZ2dlcihpKSx0aGlzLl9pc1Nob3dufHxpLmlzRGVmYXVsdFByZXZlbnRlZCgpfHwodGhpcy5faXNTaG93bj0hMCx0aGlzLl9jaGVja1Njcm9sbGJhcigpLHRoaXMuX3NldFNjcm9sbGJhcigpLHQoZG9jdW1lbnQuYm9keSkuYWRkQ2xhc3ModS5PUEVOKSx0aGlzLl9zZXRFc2NhcGVFdmVudCgpLHRoaXMuX3NldFJlc2l6ZUV2ZW50KCksdCh0aGlzLl9lbGVtZW50KS5vbihjLkNMSUNLX0RJU01JU1MsZC5EQVRBX0RJU01JU1MsZnVuY3Rpb24odCl7cmV0dXJuIG4uaGlkZSh0KX0pLHQodGhpcy5fZGlhbG9nKS5vbihjLk1PVVNFRE9XTl9ESVNNSVNTLGZ1bmN0aW9uKCl7dChuLl9lbGVtZW50KS5vbmUoYy5NT1VTRVVQX0RJU01JU1MsZnVuY3Rpb24oZSl7dChlLnRhcmdldCkuaXMobi5fZWxlbWVudCkmJihuLl9pZ25vcmVCYWNrZHJvcENsaWNrPSEwKX0pfSksdGhpcy5fc2hvd0JhY2tkcm9wKGZ1bmN0aW9uKCl7cmV0dXJuIG4uX3Nob3dFbGVtZW50KGUpfSkpfX0sYS5wcm90b3R5cGUuaGlkZT1mdW5jdGlvbihlKXt2YXIgbj10aGlzO2lmKGUmJmUucHJldmVudERlZmF1bHQoKSwhdGhpcy5faXNUcmFuc2l0aW9uaW5nJiZ0aGlzLl9pc1Nob3duKXt2YXIgaT1yLnN1cHBvcnRzVHJhbnNpdGlvbkVuZCgpJiZ0KHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKHUuRkFERSk7aSYmKHRoaXMuX2lzVHJhbnNpdGlvbmluZz0hMCk7dmFyIG89dC5FdmVudChjLkhJREUpO3QodGhpcy5fZWxlbWVudCkudHJpZ2dlcihvKSx0aGlzLl9pc1Nob3duJiYhby5pc0RlZmF1bHRQcmV2ZW50ZWQoKSYmKHRoaXMuX2lzU2hvd249ITEsdGhpcy5fc2V0RXNjYXBlRXZlbnQoKSx0aGlzLl9zZXRSZXNpemVFdmVudCgpLHQoZG9jdW1lbnQpLm9mZihjLkZPQ1VTSU4pLHQodGhpcy5fZWxlbWVudCkucmVtb3ZlQ2xhc3ModS5TSE9XKSx0KHRoaXMuX2VsZW1lbnQpLm9mZihjLkNMSUNLX0RJU01JU1MpLHQodGhpcy5fZGlhbG9nKS5vZmYoYy5NT1VTRURPV05fRElTTUlTUyksaT90KHRoaXMuX2VsZW1lbnQpLm9uZShyLlRSQU5TSVRJT05fRU5ELGZ1bmN0aW9uKHQpe3JldHVybiBuLl9oaWRlTW9kYWwodCl9KS5lbXVsYXRlVHJhbnNpdGlvbkVuZCgzMDApOnRoaXMuX2hpZGVNb2RhbCgpKX19LGEucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0LnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCxcImJzLm1vZGFsXCIpLHQod2luZG93LGRvY3VtZW50LHRoaXMuX2VsZW1lbnQsdGhpcy5fYmFja2Ryb3ApLm9mZihzKSx0aGlzLl9jb25maWc9bnVsbCx0aGlzLl9lbGVtZW50PW51bGwsdGhpcy5fZGlhbG9nPW51bGwsdGhpcy5fYmFja2Ryb3A9bnVsbCx0aGlzLl9pc1Nob3duPW51bGwsdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmc9bnVsbCx0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrPW51bGwsdGhpcy5fc2Nyb2xsYmFyV2lkdGg9bnVsbH0sYS5wcm90b3R5cGUuaGFuZGxlVXBkYXRlPWZ1bmN0aW9uKCl7dGhpcy5fYWRqdXN0RGlhbG9nKCl9LGEucHJvdG90eXBlLl9nZXRDb25maWc9ZnVuY3Rpb24obil7cmV0dXJuIG49dC5leHRlbmQoe30sbCxuKSxyLnR5cGVDaGVja0NvbmZpZyhlLG4saCksbn0sYS5wcm90b3R5cGUuX3Nob3dFbGVtZW50PWZ1bmN0aW9uKGUpe3ZhciBuPXRoaXMsaT1yLnN1cHBvcnRzVHJhbnNpdGlvbkVuZCgpJiZ0KHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKHUuRkFERSk7dGhpcy5fZWxlbWVudC5wYXJlbnROb2RlJiZ0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGU9PT1Ob2RlLkVMRU1FTlRfTk9ERXx8ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50KSx0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiksdGhpcy5fZWxlbWVudC5zY3JvbGxUb3A9MCxpJiZyLnJlZmxvdyh0aGlzLl9lbGVtZW50KSx0KHRoaXMuX2VsZW1lbnQpLmFkZENsYXNzKHUuU0hPVyksdGhpcy5fY29uZmlnLmZvY3VzJiZ0aGlzLl9lbmZvcmNlRm9jdXMoKTt2YXIgbz10LkV2ZW50KGMuU0hPV04se3JlbGF0ZWRUYXJnZXQ6ZX0pLHM9ZnVuY3Rpb24oKXtuLl9jb25maWcuZm9jdXMmJm4uX2VsZW1lbnQuZm9jdXMoKSxuLl9pc1RyYW5zaXRpb25pbmc9ITEsdChuLl9lbGVtZW50KS50cmlnZ2VyKG8pfTtpP3QodGhpcy5fZGlhbG9nKS5vbmUoci5UUkFOU0lUSU9OX0VORCxzKS5lbXVsYXRlVHJhbnNpdGlvbkVuZCgzMDApOnMoKX0sYS5wcm90b3R5cGUuX2VuZm9yY2VGb2N1cz1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dChkb2N1bWVudCkub2ZmKGMuRk9DVVNJTikub24oYy5GT0NVU0lOLGZ1bmN0aW9uKG4pe2RvY3VtZW50PT09bi50YXJnZXR8fGUuX2VsZW1lbnQ9PT1uLnRhcmdldHx8dChlLl9lbGVtZW50KS5oYXMobi50YXJnZXQpLmxlbmd0aHx8ZS5fZWxlbWVudC5mb2N1cygpfSl9LGEucHJvdG90eXBlLl9zZXRFc2NhcGVFdmVudD1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5faXNTaG93biYmdGhpcy5fY29uZmlnLmtleWJvYXJkP3QodGhpcy5fZWxlbWVudCkub24oYy5LRVlET1dOX0RJU01JU1MsZnVuY3Rpb24odCl7Mjc9PT10LndoaWNoJiYodC5wcmV2ZW50RGVmYXVsdCgpLGUuaGlkZSgpKX0pOnRoaXMuX2lzU2hvd258fHQodGhpcy5fZWxlbWVudCkub2ZmKGMuS0VZRE9XTl9ESVNNSVNTKX0sYS5wcm90b3R5cGUuX3NldFJlc2l6ZUV2ZW50PWZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLl9pc1Nob3duP3Qod2luZG93KS5vbihjLlJFU0laRSxmdW5jdGlvbih0KXtyZXR1cm4gZS5oYW5kbGVVcGRhdGUodCl9KTp0KHdpbmRvdykub2ZmKGMuUkVTSVpFKX0sYS5wcm90b3R5cGUuX2hpZGVNb2RhbD1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwhMCksdGhpcy5faXNUcmFuc2l0aW9uaW5nPSExLHRoaXMuX3Nob3dCYWNrZHJvcChmdW5jdGlvbigpe3QoZG9jdW1lbnQuYm9keSkucmVtb3ZlQ2xhc3ModS5PUEVOKSxlLl9yZXNldEFkanVzdG1lbnRzKCksZS5fcmVzZXRTY3JvbGxiYXIoKSx0KGUuX2VsZW1lbnQpLnRyaWdnZXIoYy5ISURERU4pfSl9LGEucHJvdG90eXBlLl9yZW1vdmVCYWNrZHJvcD1mdW5jdGlvbigpe3RoaXMuX2JhY2tkcm9wJiYodCh0aGlzLl9iYWNrZHJvcCkucmVtb3ZlKCksdGhpcy5fYmFja2Ryb3A9bnVsbCl9LGEucHJvdG90eXBlLl9zaG93QmFja2Ryb3A9ZnVuY3Rpb24oZSl7dmFyIG49dGhpcyxpPXQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3ModS5GQURFKT91LkZBREU6XCJcIjtpZih0aGlzLl9pc1Nob3duJiZ0aGlzLl9jb25maWcuYmFja2Ryb3Ape3ZhciBvPXIuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkmJmk7aWYodGhpcy5fYmFja2Ryb3A9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLl9iYWNrZHJvcC5jbGFzc05hbWU9dS5CQUNLRFJPUCxpJiZ0KHRoaXMuX2JhY2tkcm9wKS5hZGRDbGFzcyhpKSx0KHRoaXMuX2JhY2tkcm9wKS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KSx0KHRoaXMuX2VsZW1lbnQpLm9uKGMuQ0xJQ0tfRElTTUlTUyxmdW5jdGlvbih0KXtuLl9pZ25vcmVCYWNrZHJvcENsaWNrP24uX2lnbm9yZUJhY2tkcm9wQ2xpY2s9ITE6dC50YXJnZXQ9PT10LmN1cnJlbnRUYXJnZXQmJihcInN0YXRpY1wiPT09bi5fY29uZmlnLmJhY2tkcm9wP24uX2VsZW1lbnQuZm9jdXMoKTpuLmhpZGUoKSl9KSxvJiZyLnJlZmxvdyh0aGlzLl9iYWNrZHJvcCksdCh0aGlzLl9iYWNrZHJvcCkuYWRkQ2xhc3ModS5TSE9XKSwhZSlyZXR1cm47aWYoIW8pcmV0dXJuIHZvaWQgZSgpO3QodGhpcy5fYmFja2Ryb3ApLm9uZShyLlRSQU5TSVRJT05fRU5ELGUpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKDE1MCl9ZWxzZSBpZighdGhpcy5faXNTaG93biYmdGhpcy5fYmFja2Ryb3Ape3QodGhpcy5fYmFja2Ryb3ApLnJlbW92ZUNsYXNzKHUuU0hPVyk7dmFyIHM9ZnVuY3Rpb24oKXtuLl9yZW1vdmVCYWNrZHJvcCgpLGUmJmUoKX07ci5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKSYmdCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyh1LkZBREUpP3QodGhpcy5fYmFja2Ryb3ApLm9uZShyLlRSQU5TSVRJT05fRU5ELHMpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKDE1MCk6cygpfWVsc2UgZSYmZSgpfSxhLnByb3RvdHlwZS5fYWRqdXN0RGlhbG9nPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQ+ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDshdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcmJnQmJih0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0PXRoaXMuX3Njcm9sbGJhcldpZHRoK1wicHhcIiksdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcmJiF0JiYodGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQ9dGhpcy5fc2Nyb2xsYmFyV2lkdGgrXCJweFwiKX0sYS5wcm90b3R5cGUuX3Jlc2V0QWRqdXN0bWVudHM9ZnVuY3Rpb24oKXt0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0PVwiXCIsdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQ9XCJcIn0sYS5wcm90b3R5cGUuX2NoZWNrU2Nyb2xsYmFyPWZ1bmN0aW9uKCl7dGhpcy5faXNCb2R5T3ZlcmZsb3dpbmc9ZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aDx3aW5kb3cuaW5uZXJXaWR0aCx0aGlzLl9zY3JvbGxiYXJXaWR0aD10aGlzLl9nZXRTY3JvbGxiYXJXaWR0aCgpfSxhLnByb3RvdHlwZS5fc2V0U2Nyb2xsYmFyPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcztpZih0aGlzLl9pc0JvZHlPdmVyZmxvd2luZyl7dChkLkZJWEVEX0NPTlRFTlQpLmVhY2goZnVuY3Rpb24obixpKXt2YXIgbz10KGkpWzBdLnN0eWxlLnBhZGRpbmdSaWdodCxyPXQoaSkuY3NzKFwicGFkZGluZy1yaWdodFwiKTt0KGkpLmRhdGEoXCJwYWRkaW5nLXJpZ2h0XCIsbykuY3NzKFwicGFkZGluZy1yaWdodFwiLHBhcnNlRmxvYXQocikrZS5fc2Nyb2xsYmFyV2lkdGgrXCJweFwiKX0pLHQoZC5OQVZCQVJfVE9HR0xFUikuZWFjaChmdW5jdGlvbihuLGkpe3ZhciBvPXQoaSlbMF0uc3R5bGUubWFyZ2luUmlnaHQscj10KGkpLmNzcyhcIm1hcmdpbi1yaWdodFwiKTt0KGkpLmRhdGEoXCJtYXJnaW4tcmlnaHRcIixvKS5jc3MoXCJtYXJnaW4tcmlnaHRcIixwYXJzZUZsb2F0KHIpK2UuX3Njcm9sbGJhcldpZHRoK1wicHhcIil9KTt2YXIgbj1kb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCxpPXQoXCJib2R5XCIpLmNzcyhcInBhZGRpbmctcmlnaHRcIik7dChcImJvZHlcIikuZGF0YShcInBhZGRpbmctcmlnaHRcIixuKS5jc3MoXCJwYWRkaW5nLXJpZ2h0XCIscGFyc2VGbG9hdChpKSt0aGlzLl9zY3JvbGxiYXJXaWR0aCtcInB4XCIpfX0sYS5wcm90b3R5cGUuX3Jlc2V0U2Nyb2xsYmFyPWZ1bmN0aW9uKCl7dChkLkZJWEVEX0NPTlRFTlQpLmVhY2goZnVuY3Rpb24oZSxuKXt2YXIgaT10KG4pLmRhdGEoXCJwYWRkaW5nLXJpZ2h0XCIpO3ZvaWQgMCE9PWkmJnQobikuY3NzKFwicGFkZGluZy1yaWdodFwiLGkpLnJlbW92ZURhdGEoXCJwYWRkaW5nLXJpZ2h0XCIpfSksdChkLk5BVkJBUl9UT0dHTEVSKS5lYWNoKGZ1bmN0aW9uKGUsbil7dmFyIGk9dChuKS5kYXRhKFwibWFyZ2luLXJpZ2h0XCIpO3ZvaWQgMCE9PWkmJnQobikuY3NzKFwibWFyZ2luLXJpZ2h0XCIsaSkucmVtb3ZlRGF0YShcIm1hcmdpbi1yaWdodFwiKX0pO3ZhciBlPXQoXCJib2R5XCIpLmRhdGEoXCJwYWRkaW5nLXJpZ2h0XCIpO3ZvaWQgMCE9PWUmJnQoXCJib2R5XCIpLmNzcyhcInBhZGRpbmctcmlnaHRcIixlKS5yZW1vdmVEYXRhKFwicGFkZGluZy1yaWdodFwiKX0sYS5wcm90b3R5cGUuX2dldFNjcm9sbGJhcldpZHRoPWZ1bmN0aW9uKCl7dmFyIHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTt0LmNsYXNzTmFtZT11LlNDUk9MTEJBUl9NRUFTVVJFUixkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHQpO3ZhciBlPXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgtdC5jbGllbnRXaWR0aDtyZXR1cm4gZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0KSxlfSxhLl9qUXVlcnlJbnRlcmZhY2U9ZnVuY3Rpb24oZSxuKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIG89dCh0aGlzKS5kYXRhKFwiYnMubW9kYWxcIikscj10LmV4dGVuZCh7fSxhLkRlZmF1bHQsdCh0aGlzKS5kYXRhKCksXCJvYmplY3RcIj09PSh2b2lkIDA9PT1lP1widW5kZWZpbmVkXCI6aShlKSkmJmUpO2lmKG98fChvPW5ldyBhKHRoaXMsciksdCh0aGlzKS5kYXRhKFwiYnMubW9kYWxcIixvKSksXCJzdHJpbmdcIj09dHlwZW9mIGUpe2lmKHZvaWQgMD09PW9bZV0pdGhyb3cgbmV3IEVycm9yKCdObyBtZXRob2QgbmFtZWQgXCInK2UrJ1wiJyk7b1tlXShuKX1lbHNlIHIuc2hvdyYmby5zaG93KG4pfSl9LG8oYSxudWxsLFt7a2V5OlwiVkVSU0lPTlwiLGdldDpmdW5jdGlvbigpe3JldHVyblwiNC4wLjAtYmV0YVwifX0se2tleTpcIkRlZmF1bHRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbH19XSksYX0oKTt0KGRvY3VtZW50KS5vbihjLkNMSUNLX0RBVEFfQVBJLGQuREFUQV9UT0dHTEUsZnVuY3Rpb24oZSl7dmFyIG49dGhpcyxpPXZvaWQgMCxvPXIuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0aGlzKTtvJiYoaT10KG8pWzBdKTt2YXIgcz10KGkpLmRhdGEoXCJicy5tb2RhbFwiKT9cInRvZ2dsZVwiOnQuZXh0ZW5kKHt9LHQoaSkuZGF0YSgpLHQodGhpcykuZGF0YSgpKTtcIkFcIiE9PXRoaXMudGFnTmFtZSYmXCJBUkVBXCIhPT10aGlzLnRhZ05hbWV8fGUucHJldmVudERlZmF1bHQoKTt2YXIgYT10KGkpLm9uZShjLlNIT1csZnVuY3Rpb24oZSl7ZS5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8YS5vbmUoYy5ISURERU4sZnVuY3Rpb24oKXt0KG4pLmlzKFwiOnZpc2libGVcIikmJm4uZm9jdXMoKX0pfSk7Zi5falF1ZXJ5SW50ZXJmYWNlLmNhbGwodChpKSxzLHRoaXMpfSksdC5mbltlXT1mLl9qUXVlcnlJbnRlcmZhY2UsdC5mbltlXS5Db25zdHJ1Y3Rvcj1mLHQuZm5bZV0ubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiB0LmZuW2VdPWEsZi5falF1ZXJ5SW50ZXJmYWNlfX0oalF1ZXJ5KSxmdW5jdGlvbih0KXt2YXIgZT1cInNjcm9sbHNweVwiLHM9dC5mbltlXSxhPXtvZmZzZXQ6MTAsbWV0aG9kOlwiYXV0b1wiLHRhcmdldDpcIlwifSxsPXtvZmZzZXQ6XCJudW1iZXJcIixtZXRob2Q6XCJzdHJpbmdcIix0YXJnZXQ6XCIoc3RyaW5nfGVsZW1lbnQpXCJ9LGg9e0FDVElWQVRFOlwiYWN0aXZhdGUuYnMuc2Nyb2xsc3B5XCIsU0NST0xMOlwic2Nyb2xsLmJzLnNjcm9sbHNweVwiLExPQURfREFUQV9BUEk6XCJsb2FkLmJzLnNjcm9sbHNweS5kYXRhLWFwaVwifSxjPXtEUk9QRE9XTl9JVEVNOlwiZHJvcGRvd24taXRlbVwiLERST1BET1dOX01FTlU6XCJkcm9wZG93bi1tZW51XCIsQUNUSVZFOlwiYWN0aXZlXCJ9LHU9e0RBVEFfU1BZOidbZGF0YS1zcHk9XCJzY3JvbGxcIl0nLEFDVElWRTpcIi5hY3RpdmVcIixOQVZfTElTVF9HUk9VUDpcIi5uYXYsIC5saXN0LWdyb3VwXCIsTkFWX0xJTktTOlwiLm5hdi1saW5rXCIsTElTVF9JVEVNUzpcIi5saXN0LWdyb3VwLWl0ZW1cIixEUk9QRE9XTjpcIi5kcm9wZG93blwiLERST1BET1dOX0lURU1TOlwiLmRyb3Bkb3duLWl0ZW1cIixEUk9QRE9XTl9UT0dHTEU6XCIuZHJvcGRvd24tdG9nZ2xlXCJ9LGQ9e09GRlNFVDpcIm9mZnNldFwiLFBPU0lUSU9OOlwicG9zaXRpb25cIn0sZj1mdW5jdGlvbigpe2Z1bmN0aW9uIHMoZSxpKXt2YXIgbz10aGlzO24odGhpcyxzKSx0aGlzLl9lbGVtZW50PWUsdGhpcy5fc2Nyb2xsRWxlbWVudD1cIkJPRFlcIj09PWUudGFnTmFtZT93aW5kb3c6ZSx0aGlzLl9jb25maWc9dGhpcy5fZ2V0Q29uZmlnKGkpLHRoaXMuX3NlbGVjdG9yPXRoaXMuX2NvbmZpZy50YXJnZXQrXCIgXCIrdS5OQVZfTElOS1MrXCIsXCIrdGhpcy5fY29uZmlnLnRhcmdldCtcIiBcIit1LkxJU1RfSVRFTVMrXCIsXCIrdGhpcy5fY29uZmlnLnRhcmdldCtcIiBcIit1LkRST1BET1dOX0lURU1TLHRoaXMuX29mZnNldHM9W10sdGhpcy5fdGFyZ2V0cz1bXSx0aGlzLl9hY3RpdmVUYXJnZXQ9bnVsbCx0aGlzLl9zY3JvbGxIZWlnaHQ9MCx0KHRoaXMuX3Njcm9sbEVsZW1lbnQpLm9uKGguU0NST0xMLGZ1bmN0aW9uKHQpe3JldHVybiBvLl9wcm9jZXNzKHQpfSksdGhpcy5yZWZyZXNoKCksdGhpcy5fcHJvY2VzcygpfXJldHVybiBzLnByb3RvdHlwZS5yZWZyZXNoPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcyxuPXRoaXMuX3Njcm9sbEVsZW1lbnQhPT10aGlzLl9zY3JvbGxFbGVtZW50LndpbmRvdz9kLlBPU0lUSU9OOmQuT0ZGU0VULGk9XCJhdXRvXCI9PT10aGlzLl9jb25maWcubWV0aG9kP246dGhpcy5fY29uZmlnLm1ldGhvZCxvPWk9PT1kLlBPU0lUSU9OP3RoaXMuX2dldFNjcm9sbFRvcCgpOjA7dGhpcy5fb2Zmc2V0cz1bXSx0aGlzLl90YXJnZXRzPVtdLHRoaXMuX3Njcm9sbEhlaWdodD10aGlzLl9nZXRTY3JvbGxIZWlnaHQoKSx0Lm1ha2VBcnJheSh0KHRoaXMuX3NlbGVjdG9yKSkubWFwKGZ1bmN0aW9uKGUpe3ZhciBuPXZvaWQgMCxzPXIuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlKTtpZihzJiYobj10KHMpWzBdKSxuKXt2YXIgYT1uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2lmKGEud2lkdGh8fGEuaGVpZ2h0KXJldHVyblt0KG4pW2ldKCkudG9wK28sc119cmV0dXJuIG51bGx9KS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHR9KS5zb3J0KGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRbMF0tZVswXX0pLmZvckVhY2goZnVuY3Rpb24odCl7ZS5fb2Zmc2V0cy5wdXNoKHRbMF0pLGUuX3RhcmdldHMucHVzaCh0WzFdKX0pfSxzLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7dC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsXCJicy5zY3JvbGxzcHlcIiksdCh0aGlzLl9zY3JvbGxFbGVtZW50KS5vZmYoXCIuYnMuc2Nyb2xsc3B5XCIpLHRoaXMuX2VsZW1lbnQ9bnVsbCx0aGlzLl9zY3JvbGxFbGVtZW50PW51bGwsdGhpcy5fY29uZmlnPW51bGwsdGhpcy5fc2VsZWN0b3I9bnVsbCx0aGlzLl9vZmZzZXRzPW51bGwsdGhpcy5fdGFyZ2V0cz1udWxsLHRoaXMuX2FjdGl2ZVRhcmdldD1udWxsLHRoaXMuX3Njcm9sbEhlaWdodD1udWxsfSxzLnByb3RvdHlwZS5fZ2V0Q29uZmlnPWZ1bmN0aW9uKG4pe2lmKFwic3RyaW5nXCIhPXR5cGVvZihuPXQuZXh0ZW5kKHt9LGEsbikpLnRhcmdldCl7dmFyIGk9dChuLnRhcmdldCkuYXR0cihcImlkXCIpO2l8fChpPXIuZ2V0VUlEKGUpLHQobi50YXJnZXQpLmF0dHIoXCJpZFwiLGkpKSxuLnRhcmdldD1cIiNcIitpfXJldHVybiByLnR5cGVDaGVja0NvbmZpZyhlLG4sbCksbn0scy5wcm90b3R5cGUuX2dldFNjcm9sbFRvcD1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50PT09d2luZG93P3RoaXMuX3Njcm9sbEVsZW1lbnQucGFnZVlPZmZzZXQ6dGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3B9LHMucHJvdG90eXBlLl9nZXRTY3JvbGxIZWlnaHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxIZWlnaHR8fE1hdGgubWF4KGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0LGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQpfSxzLnByb3RvdHlwZS5fZ2V0T2Zmc2V0SGVpZ2h0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQ9PT13aW5kb3c/d2luZG93LmlubmVySGVpZ2h0OnRoaXMuX3Njcm9sbEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0fSxzLnByb3RvdHlwZS5fcHJvY2Vzcz1mdW5jdGlvbigpe3ZhciB0PXRoaXMuX2dldFNjcm9sbFRvcCgpK3RoaXMuX2NvbmZpZy5vZmZzZXQsZT10aGlzLl9nZXRTY3JvbGxIZWlnaHQoKSxuPXRoaXMuX2NvbmZpZy5vZmZzZXQrZS10aGlzLl9nZXRPZmZzZXRIZWlnaHQoKTtpZih0aGlzLl9zY3JvbGxIZWlnaHQhPT1lJiZ0aGlzLnJlZnJlc2goKSx0Pj1uKXt2YXIgaT10aGlzLl90YXJnZXRzW3RoaXMuX3RhcmdldHMubGVuZ3RoLTFdO3RoaXMuX2FjdGl2ZVRhcmdldCE9PWkmJnRoaXMuX2FjdGl2YXRlKGkpfWVsc2V7aWYodGhpcy5fYWN0aXZlVGFyZ2V0JiZ0PHRoaXMuX29mZnNldHNbMF0mJnRoaXMuX29mZnNldHNbMF0+MClyZXR1cm4gdGhpcy5fYWN0aXZlVGFyZ2V0PW51bGwsdm9pZCB0aGlzLl9jbGVhcigpO2Zvcih2YXIgbz10aGlzLl9vZmZzZXRzLmxlbmd0aDtvLS07KXRoaXMuX2FjdGl2ZVRhcmdldCE9PXRoaXMuX3RhcmdldHNbb10mJnQ+PXRoaXMuX29mZnNldHNbb10mJih2b2lkIDA9PT10aGlzLl9vZmZzZXRzW28rMV18fHQ8dGhpcy5fb2Zmc2V0c1tvKzFdKSYmdGhpcy5fYWN0aXZhdGUodGhpcy5fdGFyZ2V0c1tvXSl9fSxzLnByb3RvdHlwZS5fYWN0aXZhdGU9ZnVuY3Rpb24oZSl7dGhpcy5fYWN0aXZlVGFyZ2V0PWUsdGhpcy5fY2xlYXIoKTt2YXIgbj10aGlzLl9zZWxlY3Rvci5zcGxpdChcIixcIik7bj1uLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdCsnW2RhdGEtdGFyZ2V0PVwiJytlKydcIl0sJyt0KydbaHJlZj1cIicrZSsnXCJdJ30pO3ZhciBpPXQobi5qb2luKFwiLFwiKSk7aS5oYXNDbGFzcyhjLkRST1BET1dOX0lURU0pPyhpLmNsb3Nlc3QodS5EUk9QRE9XTikuZmluZCh1LkRST1BET1dOX1RPR0dMRSkuYWRkQ2xhc3MoYy5BQ1RJVkUpLGkuYWRkQ2xhc3MoYy5BQ1RJVkUpKTooaS5hZGRDbGFzcyhjLkFDVElWRSksaS5wYXJlbnRzKHUuTkFWX0xJU1RfR1JPVVApLnByZXYodS5OQVZfTElOS1MrXCIsIFwiK3UuTElTVF9JVEVNUykuYWRkQ2xhc3MoYy5BQ1RJVkUpKSx0KHRoaXMuX3Njcm9sbEVsZW1lbnQpLnRyaWdnZXIoaC5BQ1RJVkFURSx7cmVsYXRlZFRhcmdldDplfSl9LHMucHJvdG90eXBlLl9jbGVhcj1mdW5jdGlvbigpe3QodGhpcy5fc2VsZWN0b3IpLmZpbHRlcih1LkFDVElWRSkucmVtb3ZlQ2xhc3MoYy5BQ1RJVkUpfSxzLl9qUXVlcnlJbnRlcmZhY2U9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBuPXQodGhpcykuZGF0YShcImJzLnNjcm9sbHNweVwiKSxvPVwib2JqZWN0XCI9PT0odm9pZCAwPT09ZT9cInVuZGVmaW5lZFwiOmkoZSkpJiZlO2lmKG58fChuPW5ldyBzKHRoaXMsbyksdCh0aGlzKS5kYXRhKFwiYnMuc2Nyb2xsc3B5XCIsbikpLFwic3RyaW5nXCI9PXR5cGVvZiBlKXtpZih2b2lkIDA9PT1uW2VdKXRocm93IG5ldyBFcnJvcignTm8gbWV0aG9kIG5hbWVkIFwiJytlKydcIicpO25bZV0oKX19KX0sbyhzLG51bGwsW3trZXk6XCJWRVJTSU9OXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCI0LjAuMC1iZXRhXCJ9fSx7a2V5OlwiRGVmYXVsdFwiLGdldDpmdW5jdGlvbigpe3JldHVybiBhfX1dKSxzfSgpO3Qod2luZG93KS5vbihoLkxPQURfREFUQV9BUEksZnVuY3Rpb24oKXtmb3IodmFyIGU9dC5tYWtlQXJyYXkodCh1LkRBVEFfU1BZKSksbj1lLmxlbmd0aDtuLS07KXt2YXIgaT10KGVbbl0pO2YuX2pRdWVyeUludGVyZmFjZS5jYWxsKGksaS5kYXRhKCkpfX0pLHQuZm5bZV09Zi5falF1ZXJ5SW50ZXJmYWNlLHQuZm5bZV0uQ29uc3RydWN0b3I9Zix0LmZuW2VdLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdC5mbltlXT1zLGYuX2pRdWVyeUludGVyZmFjZX19KGpRdWVyeSksZnVuY3Rpb24odCl7dmFyIGU9dC5mbi50YWIsaT17SElERTpcImhpZGUuYnMudGFiXCIsSElEREVOOlwiaGlkZGVuLmJzLnRhYlwiLFNIT1c6XCJzaG93LmJzLnRhYlwiLFNIT1dOOlwic2hvd24uYnMudGFiXCIsQ0xJQ0tfREFUQV9BUEk6XCJjbGljay5icy50YWIuZGF0YS1hcGlcIn0scz17RFJPUERPV05fTUVOVTpcImRyb3Bkb3duLW1lbnVcIixBQ1RJVkU6XCJhY3RpdmVcIixESVNBQkxFRDpcImRpc2FibGVkXCIsRkFERTpcImZhZGVcIixTSE9XOlwic2hvd1wifSxhPXtEUk9QRE9XTjpcIi5kcm9wZG93blwiLE5BVl9MSVNUX0dST1VQOlwiLm5hdiwgLmxpc3QtZ3JvdXBcIixBQ1RJVkU6XCIuYWN0aXZlXCIsREFUQV9UT0dHTEU6J1tkYXRhLXRvZ2dsZT1cInRhYlwiXSwgW2RhdGEtdG9nZ2xlPVwicGlsbFwiXSwgW2RhdGEtdG9nZ2xlPVwibGlzdFwiXScsRFJPUERPV05fVE9HR0xFOlwiLmRyb3Bkb3duLXRvZ2dsZVwiLERST1BET1dOX0FDVElWRV9DSElMRDpcIj4gLmRyb3Bkb3duLW1lbnUgLmFjdGl2ZVwifSxsPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXtuKHRoaXMsZSksdGhpcy5fZWxlbWVudD10fXJldHVybiBlLnByb3RvdHlwZS5zaG93PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcztpZighKHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSYmdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUmJnQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3Mocy5BQ1RJVkUpfHx0KHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKHMuRElTQUJMRUQpKSl7dmFyIG49dm9pZCAwLG89dm9pZCAwLGw9dCh0aGlzLl9lbGVtZW50KS5jbG9zZXN0KGEuTkFWX0xJU1RfR1JPVVApWzBdLGg9ci5nZXRTZWxlY3RvckZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpO2wmJihvPXQubWFrZUFycmF5KHQobCkuZmluZChhLkFDVElWRSkpLG89b1tvLmxlbmd0aC0xXSk7dmFyIGM9dC5FdmVudChpLkhJREUse3JlbGF0ZWRUYXJnZXQ6dGhpcy5fZWxlbWVudH0pLHU9dC5FdmVudChpLlNIT1cse3JlbGF0ZWRUYXJnZXQ6b30pO2lmKG8mJnQobykudHJpZ2dlcihjKSx0KHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIodSksIXUuaXNEZWZhdWx0UHJldmVudGVkKCkmJiFjLmlzRGVmYXVsdFByZXZlbnRlZCgpKXtoJiYobj10KGgpWzBdKSx0aGlzLl9hY3RpdmF0ZSh0aGlzLl9lbGVtZW50LGwpO3ZhciBkPWZ1bmN0aW9uKCl7dmFyIG49dC5FdmVudChpLkhJRERFTix7cmVsYXRlZFRhcmdldDplLl9lbGVtZW50fSkscj10LkV2ZW50KGkuU0hPV04se3JlbGF0ZWRUYXJnZXQ6b30pO3QobykudHJpZ2dlcihuKSx0KGUuX2VsZW1lbnQpLnRyaWdnZXIocil9O24/dGhpcy5fYWN0aXZhdGUobixuLnBhcmVudE5vZGUsZCk6ZCgpfX19LGUucHJvdG90eXBlLmRpc3Bvc2U9ZnVuY3Rpb24oKXt0LnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCxcImJzLnRhYlwiKSx0aGlzLl9lbGVtZW50PW51bGx9LGUucHJvdG90eXBlLl9hY3RpdmF0ZT1mdW5jdGlvbihlLG4saSl7dmFyIG89dGhpcyxsPXQobikuZmluZChhLkFDVElWRSlbMF0saD1pJiZyLnN1cHBvcnRzVHJhbnNpdGlvbkVuZCgpJiZsJiZ0KGwpLmhhc0NsYXNzKHMuRkFERSksYz1mdW5jdGlvbigpe3JldHVybiBvLl90cmFuc2l0aW9uQ29tcGxldGUoZSxsLGgsaSl9O2wmJmg/dChsKS5vbmUoci5UUkFOU0lUSU9OX0VORCxjKS5lbXVsYXRlVHJhbnNpdGlvbkVuZCgxNTApOmMoKSxsJiZ0KGwpLnJlbW92ZUNsYXNzKHMuU0hPVyl9LGUucHJvdG90eXBlLl90cmFuc2l0aW9uQ29tcGxldGU9ZnVuY3Rpb24oZSxuLGksbyl7aWYobil7dChuKS5yZW1vdmVDbGFzcyhzLkFDVElWRSk7dmFyIGw9dChuLnBhcmVudE5vZGUpLmZpbmQoYS5EUk9QRE9XTl9BQ1RJVkVfQ0hJTEQpWzBdO2wmJnQobCkucmVtb3ZlQ2xhc3Mocy5BQ1RJVkUpLG4uc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCExKX1pZih0KGUpLmFkZENsYXNzKHMuQUNUSVZFKSxlLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwhMCksaT8oci5yZWZsb3coZSksdChlKS5hZGRDbGFzcyhzLlNIT1cpKTp0KGUpLnJlbW92ZUNsYXNzKHMuRkFERSksZS5wYXJlbnROb2RlJiZ0KGUucGFyZW50Tm9kZSkuaGFzQ2xhc3Mocy5EUk9QRE9XTl9NRU5VKSl7dmFyIGg9dChlKS5jbG9zZXN0KGEuRFJPUERPV04pWzBdO2gmJnQoaCkuZmluZChhLkRST1BET1dOX1RPR0dMRSkuYWRkQ2xhc3Mocy5BQ1RJVkUpLGUuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCEwKX1vJiZvKCl9LGUuX2pRdWVyeUludGVyZmFjZT1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGk9dCh0aGlzKSxvPWkuZGF0YShcImJzLnRhYlwiKTtpZihvfHwobz1uZXcgZSh0aGlzKSxpLmRhdGEoXCJicy50YWJcIixvKSksXCJzdHJpbmdcIj09dHlwZW9mIG4pe2lmKHZvaWQgMD09PW9bbl0pdGhyb3cgbmV3IEVycm9yKCdObyBtZXRob2QgbmFtZWQgXCInK24rJ1wiJyk7b1tuXSgpfX0pfSxvKGUsbnVsbCxbe2tleTpcIlZFUlNJT05cIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cIjQuMC4wLWJldGFcIn19XSksZX0oKTt0KGRvY3VtZW50KS5vbihpLkNMSUNLX0RBVEFfQVBJLGEuREFUQV9UT0dHTEUsZnVuY3Rpb24oZSl7ZS5wcmV2ZW50RGVmYXVsdCgpLGwuX2pRdWVyeUludGVyZmFjZS5jYWxsKHQodGhpcyksXCJzaG93XCIpfSksdC5mbi50YWI9bC5falF1ZXJ5SW50ZXJmYWNlLHQuZm4udGFiLkNvbnN0cnVjdG9yPWwsdC5mbi50YWIubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiB0LmZuLnRhYj1lLGwuX2pRdWVyeUludGVyZmFjZX19KGpRdWVyeSksZnVuY3Rpb24odCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFBvcHBlcil0aHJvdyBuZXcgRXJyb3IoXCJCb290c3RyYXAgdG9vbHRpcHMgcmVxdWlyZSBQb3BwZXIuanMgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZylcIik7dmFyIGU9XCJ0b29sdGlwXCIscz1cIi5icy50b29sdGlwXCIsYT10LmZuW2VdLGw9bmV3IFJlZ0V4cChcIihefFxcXFxzKWJzLXRvb2x0aXBcXFxcUytcIixcImdcIiksaD17YW5pbWF0aW9uOlwiYm9vbGVhblwiLHRlbXBsYXRlOlwic3RyaW5nXCIsdGl0bGU6XCIoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pXCIsdHJpZ2dlcjpcInN0cmluZ1wiLGRlbGF5OlwiKG51bWJlcnxvYmplY3QpXCIsaHRtbDpcImJvb2xlYW5cIixzZWxlY3RvcjpcIihzdHJpbmd8Ym9vbGVhbilcIixwbGFjZW1lbnQ6XCIoc3RyaW5nfGZ1bmN0aW9uKVwiLG9mZnNldDpcIihudW1iZXJ8c3RyaW5nKVwiLGNvbnRhaW5lcjpcIihzdHJpbmd8ZWxlbWVudHxib29sZWFuKVwiLGZhbGxiYWNrUGxhY2VtZW50OlwiKHN0cmluZ3xhcnJheSlcIn0sYz17QVVUTzpcImF1dG9cIixUT1A6XCJ0b3BcIixSSUdIVDpcInJpZ2h0XCIsQk9UVE9NOlwiYm90dG9tXCIsTEVGVDpcImxlZnRcIn0sdT17YW5pbWF0aW9uOiEwLHRlbXBsYXRlOic8ZGl2IGNsYXNzPVwidG9vbHRpcFwiIHJvbGU9XCJ0b29sdGlwXCI+PGRpdiBjbGFzcz1cImFycm93XCI+PC9kaXY+PGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj48L2Rpdj4nLHRyaWdnZXI6XCJob3ZlciBmb2N1c1wiLHRpdGxlOlwiXCIsZGVsYXk6MCxodG1sOiExLHNlbGVjdG9yOiExLHBsYWNlbWVudDpcInRvcFwiLG9mZnNldDowLGNvbnRhaW5lcjohMSxmYWxsYmFja1BsYWNlbWVudDpcImZsaXBcIn0sZD17U0hPVzpcInNob3dcIixPVVQ6XCJvdXRcIn0sZj17SElERTpcImhpZGVcIitzLEhJRERFTjpcImhpZGRlblwiK3MsU0hPVzpcInNob3dcIitzLFNIT1dOOlwic2hvd25cIitzLElOU0VSVEVEOlwiaW5zZXJ0ZWRcIitzLENMSUNLOlwiY2xpY2tcIitzLEZPQ1VTSU46XCJmb2N1c2luXCIrcyxGT0NVU09VVDpcImZvY3Vzb3V0XCIrcyxNT1VTRUVOVEVSOlwibW91c2VlbnRlclwiK3MsTU9VU0VMRUFWRTpcIm1vdXNlbGVhdmVcIitzfSxwPXtGQURFOlwiZmFkZVwiLFNIT1c6XCJzaG93XCJ9LF89e1RPT0xUSVA6XCIudG9vbHRpcFwiLFRPT0xUSVBfSU5ORVI6XCIudG9vbHRpcC1pbm5lclwiLEFSUk9XOlwiLmFycm93XCJ9LGc9e0hPVkVSOlwiaG92ZXJcIixGT0NVUzpcImZvY3VzXCIsQ0xJQ0s6XCJjbGlja1wiLE1BTlVBTDpcIm1hbnVhbFwifSxtPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYSh0LGUpe24odGhpcyxhKSx0aGlzLl9pc0VuYWJsZWQ9ITAsdGhpcy5fdGltZW91dD0wLHRoaXMuX2hvdmVyU3RhdGU9XCJcIix0aGlzLl9hY3RpdmVUcmlnZ2VyPXt9LHRoaXMuX3BvcHBlcj1udWxsLHRoaXMuZWxlbWVudD10LHRoaXMuY29uZmlnPXRoaXMuX2dldENvbmZpZyhlKSx0aGlzLnRpcD1udWxsLHRoaXMuX3NldExpc3RlbmVycygpfXJldHVybiBhLnByb3RvdHlwZS5lbmFibGU9ZnVuY3Rpb24oKXt0aGlzLl9pc0VuYWJsZWQ9ITB9LGEucHJvdG90eXBlLmRpc2FibGU9ZnVuY3Rpb24oKXt0aGlzLl9pc0VuYWJsZWQ9ITF9LGEucHJvdG90eXBlLnRvZ2dsZUVuYWJsZWQ9ZnVuY3Rpb24oKXt0aGlzLl9pc0VuYWJsZWQ9IXRoaXMuX2lzRW5hYmxlZH0sYS5wcm90b3R5cGUudG9nZ2xlPWZ1bmN0aW9uKGUpe2lmKGUpe3ZhciBuPXRoaXMuY29uc3RydWN0b3IuREFUQV9LRVksaT10KGUuY3VycmVudFRhcmdldCkuZGF0YShuKTtpfHwoaT1uZXcgdGhpcy5jb25zdHJ1Y3RvcihlLmN1cnJlbnRUYXJnZXQsdGhpcy5fZ2V0RGVsZWdhdGVDb25maWcoKSksdChlLmN1cnJlbnRUYXJnZXQpLmRhdGEobixpKSksaS5fYWN0aXZlVHJpZ2dlci5jbGljaz0haS5fYWN0aXZlVHJpZ2dlci5jbGljayxpLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCk/aS5fZW50ZXIobnVsbCxpKTppLl9sZWF2ZShudWxsLGkpfWVsc2V7aWYodCh0aGlzLmdldFRpcEVsZW1lbnQoKSkuaGFzQ2xhc3MocC5TSE9XKSlyZXR1cm4gdm9pZCB0aGlzLl9sZWF2ZShudWxsLHRoaXMpO3RoaXMuX2VudGVyKG51bGwsdGhpcyl9fSxhLnByb3RvdHlwZS5kaXNwb3NlPWZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpLHQucmVtb3ZlRGF0YSh0aGlzLmVsZW1lbnQsdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSksdCh0aGlzLmVsZW1lbnQpLm9mZih0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0tFWSksdCh0aGlzLmVsZW1lbnQpLmNsb3Nlc3QoXCIubW9kYWxcIikub2ZmKFwiaGlkZS5icy5tb2RhbFwiKSx0aGlzLnRpcCYmdCh0aGlzLnRpcCkucmVtb3ZlKCksdGhpcy5faXNFbmFibGVkPW51bGwsdGhpcy5fdGltZW91dD1udWxsLHRoaXMuX2hvdmVyU3RhdGU9bnVsbCx0aGlzLl9hY3RpdmVUcmlnZ2VyPW51bGwsbnVsbCE9PXRoaXMuX3BvcHBlciYmdGhpcy5fcG9wcGVyLmRlc3Ryb3koKSx0aGlzLl9wb3BwZXI9bnVsbCx0aGlzLmVsZW1lbnQ9bnVsbCx0aGlzLmNvbmZpZz1udWxsLHRoaXMudGlwPW51bGx9LGEucHJvdG90eXBlLnNob3c9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO2lmKFwibm9uZVwiPT09dCh0aGlzLmVsZW1lbnQpLmNzcyhcImRpc3BsYXlcIikpdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHVzZSBzaG93IG9uIHZpc2libGUgZWxlbWVudHNcIik7dmFyIG49dC5FdmVudCh0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LlNIT1cpO2lmKHRoaXMuaXNXaXRoQ29udGVudCgpJiZ0aGlzLl9pc0VuYWJsZWQpe3QodGhpcy5lbGVtZW50KS50cmlnZ2VyKG4pO3ZhciBpPXQuY29udGFpbnModGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LHRoaXMuZWxlbWVudCk7aWYobi5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8IWkpcmV0dXJuO3ZhciBvPXRoaXMuZ2V0VGlwRWxlbWVudCgpLHM9ci5nZXRVSUQodGhpcy5jb25zdHJ1Y3Rvci5OQU1FKTtvLnNldEF0dHJpYnV0ZShcImlkXCIscyksdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtZGVzY3JpYmVkYnlcIixzKSx0aGlzLnNldENvbnRlbnQoKSx0aGlzLmNvbmZpZy5hbmltYXRpb24mJnQobykuYWRkQ2xhc3MocC5GQURFKTt2YXIgbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLmNvbmZpZy5wbGFjZW1lbnQ/dGhpcy5jb25maWcucGxhY2VtZW50LmNhbGwodGhpcyxvLHRoaXMuZWxlbWVudCk6dGhpcy5jb25maWcucGxhY2VtZW50LGg9dGhpcy5fZ2V0QXR0YWNobWVudChsKTt0aGlzLmFkZEF0dGFjaG1lbnRDbGFzcyhoKTt2YXIgYz0hMT09PXRoaXMuY29uZmlnLmNvbnRhaW5lcj9kb2N1bWVudC5ib2R5OnQodGhpcy5jb25maWcuY29udGFpbmVyKTt0KG8pLmRhdGEodGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSx0aGlzKSx0LmNvbnRhaW5zKHRoaXMuZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCx0aGlzLnRpcCl8fHQobykuYXBwZW5kVG8oYyksdCh0aGlzLmVsZW1lbnQpLnRyaWdnZXIodGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5JTlNFUlRFRCksdGhpcy5fcG9wcGVyPW5ldyBQb3BwZXIodGhpcy5lbGVtZW50LG8se3BsYWNlbWVudDpoLG1vZGlmaWVyczp7b2Zmc2V0OntvZmZzZXQ6dGhpcy5jb25maWcub2Zmc2V0fSxmbGlwOntiZWhhdmlvcjp0aGlzLmNvbmZpZy5mYWxsYmFja1BsYWNlbWVudH0sYXJyb3c6e2VsZW1lbnQ6Xy5BUlJPV319LG9uQ3JlYXRlOmZ1bmN0aW9uKHQpe3Qub3JpZ2luYWxQbGFjZW1lbnQhPT10LnBsYWNlbWVudCYmZS5faGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKHQpfSxvblVwZGF0ZTpmdW5jdGlvbih0KXtlLl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UodCl9fSksdChvKS5hZGRDbGFzcyhwLlNIT1cpLFwib250b3VjaHN0YXJ0XCJpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQmJnQoXCJib2R5XCIpLmNoaWxkcmVuKCkub24oXCJtb3VzZW92ZXJcIixudWxsLHQubm9vcCk7dmFyIHU9ZnVuY3Rpb24oKXtlLmNvbmZpZy5hbmltYXRpb24mJmUuX2ZpeFRyYW5zaXRpb24oKTt2YXIgbj1lLl9ob3ZlclN0YXRlO2UuX2hvdmVyU3RhdGU9bnVsbCx0KGUuZWxlbWVudCkudHJpZ2dlcihlLmNvbnN0cnVjdG9yLkV2ZW50LlNIT1dOKSxuPT09ZC5PVVQmJmUuX2xlYXZlKG51bGwsZSl9O3Iuc3VwcG9ydHNUcmFuc2l0aW9uRW5kKCkmJnQodGhpcy50aXApLmhhc0NsYXNzKHAuRkFERSk/dCh0aGlzLnRpcCkub25lKHIuVFJBTlNJVElPTl9FTkQsdSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoYS5fVFJBTlNJVElPTl9EVVJBVElPTik6dSgpfX0sYS5wcm90b3R5cGUuaGlkZT1mdW5jdGlvbihlKXt2YXIgbj10aGlzLGk9dGhpcy5nZXRUaXBFbGVtZW50KCksbz10LkV2ZW50KHRoaXMuY29uc3RydWN0b3IuRXZlbnQuSElERSkscz1mdW5jdGlvbigpe24uX2hvdmVyU3RhdGUhPT1kLlNIT1cmJmkucGFyZW50Tm9kZSYmaS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGkpLG4uX2NsZWFuVGlwQ2xhc3MoKSxuLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiKSx0KG4uZWxlbWVudCkudHJpZ2dlcihuLmNvbnN0cnVjdG9yLkV2ZW50LkhJRERFTiksbnVsbCE9PW4uX3BvcHBlciYmbi5fcG9wcGVyLmRlc3Ryb3koKSxlJiZlKCl9O3QodGhpcy5lbGVtZW50KS50cmlnZ2VyKG8pLG8uaXNEZWZhdWx0UHJldmVudGVkKCl8fCh0KGkpLnJlbW92ZUNsYXNzKHAuU0hPVyksXCJvbnRvdWNoc3RhcnRcImluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCYmdChcImJvZHlcIikuY2hpbGRyZW4oKS5vZmYoXCJtb3VzZW92ZXJcIixudWxsLHQubm9vcCksdGhpcy5fYWN0aXZlVHJpZ2dlcltnLkNMSUNLXT0hMSx0aGlzLl9hY3RpdmVUcmlnZ2VyW2cuRk9DVVNdPSExLHRoaXMuX2FjdGl2ZVRyaWdnZXJbZy5IT1ZFUl09ITEsci5zdXBwb3J0c1RyYW5zaXRpb25FbmQoKSYmdCh0aGlzLnRpcCkuaGFzQ2xhc3MocC5GQURFKT90KGkpLm9uZShyLlRSQU5TSVRJT05fRU5ELHMpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKDE1MCk6cygpLHRoaXMuX2hvdmVyU3RhdGU9XCJcIil9LGEucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbigpe251bGwhPT10aGlzLl9wb3BwZXImJnRoaXMuX3BvcHBlci5zY2hlZHVsZVVwZGF0ZSgpfSxhLnByb3RvdHlwZS5pc1dpdGhDb250ZW50PWZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4odGhpcy5nZXRUaXRsZSgpKX0sYS5wcm90b3R5cGUuYWRkQXR0YWNobWVudENsYXNzPWZ1bmN0aW9uKGUpe3QodGhpcy5nZXRUaXBFbGVtZW50KCkpLmFkZENsYXNzKFwiYnMtdG9vbHRpcC1cIitlKX0sYS5wcm90b3R5cGUuZ2V0VGlwRWxlbWVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRpcD10aGlzLnRpcHx8dCh0aGlzLmNvbmZpZy50ZW1wbGF0ZSlbMF19LGEucHJvdG90eXBlLnNldENvbnRlbnQ9ZnVuY3Rpb24oKXt2YXIgZT10KHRoaXMuZ2V0VGlwRWxlbWVudCgpKTt0aGlzLnNldEVsZW1lbnRDb250ZW50KGUuZmluZChfLlRPT0xUSVBfSU5ORVIpLHRoaXMuZ2V0VGl0bGUoKSksZS5yZW1vdmVDbGFzcyhwLkZBREUrXCIgXCIrcC5TSE9XKX0sYS5wcm90b3R5cGUuc2V0RWxlbWVudENvbnRlbnQ9ZnVuY3Rpb24oZSxuKXt2YXIgbz10aGlzLmNvbmZpZy5odG1sO1wib2JqZWN0XCI9PT0odm9pZCAwPT09bj9cInVuZGVmaW5lZFwiOmkobikpJiYobi5ub2RlVHlwZXx8bi5qcXVlcnkpP28/dChuKS5wYXJlbnQoKS5pcyhlKXx8ZS5lbXB0eSgpLmFwcGVuZChuKTplLnRleHQodChuKS50ZXh0KCkpOmVbbz9cImh0bWxcIjpcInRleHRcIl0obil9LGEucHJvdG90eXBlLmdldFRpdGxlPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtb3JpZ2luYWwtdGl0bGVcIik7cmV0dXJuIHR8fCh0PVwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMuY29uZmlnLnRpdGxlP3RoaXMuY29uZmlnLnRpdGxlLmNhbGwodGhpcy5lbGVtZW50KTp0aGlzLmNvbmZpZy50aXRsZSksdH0sYS5wcm90b3R5cGUuX2dldEF0dGFjaG1lbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIGNbdC50b1VwcGVyQ2FzZSgpXX0sYS5wcm90b3R5cGUuX3NldExpc3RlbmVycz1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5jb25maWcudHJpZ2dlci5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihuKXtpZihcImNsaWNrXCI9PT1uKXQoZS5lbGVtZW50KS5vbihlLmNvbnN0cnVjdG9yLkV2ZW50LkNMSUNLLGUuY29uZmlnLnNlbGVjdG9yLGZ1bmN0aW9uKHQpe3JldHVybiBlLnRvZ2dsZSh0KX0pO2Vsc2UgaWYobiE9PWcuTUFOVUFMKXt2YXIgaT1uPT09Zy5IT1ZFUj9lLmNvbnN0cnVjdG9yLkV2ZW50Lk1PVVNFRU5URVI6ZS5jb25zdHJ1Y3Rvci5FdmVudC5GT0NVU0lOLG89bj09PWcuSE9WRVI/ZS5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUxFQVZFOmUuY29uc3RydWN0b3IuRXZlbnQuRk9DVVNPVVQ7dChlLmVsZW1lbnQpLm9uKGksZS5jb25maWcuc2VsZWN0b3IsZnVuY3Rpb24odCl7cmV0dXJuIGUuX2VudGVyKHQpfSkub24obyxlLmNvbmZpZy5zZWxlY3RvcixmdW5jdGlvbih0KXtyZXR1cm4gZS5fbGVhdmUodCl9KX10KGUuZWxlbWVudCkuY2xvc2VzdChcIi5tb2RhbFwiKS5vbihcImhpZGUuYnMubW9kYWxcIixmdW5jdGlvbigpe3JldHVybiBlLmhpZGUoKX0pfSksdGhpcy5jb25maWcuc2VsZWN0b3I/dGhpcy5jb25maWc9dC5leHRlbmQoe30sdGhpcy5jb25maWcse3RyaWdnZXI6XCJtYW51YWxcIixzZWxlY3RvcjpcIlwifSk6dGhpcy5fZml4VGl0bGUoKX0sYS5wcm90b3R5cGUuX2ZpeFRpdGxlPWZ1bmN0aW9uKCl7dmFyIHQ9aSh0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1vcmlnaW5hbC10aXRsZVwiKSk7KHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiKXx8XCJzdHJpbmdcIiE9PXQpJiYodGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtb3JpZ2luYWwtdGl0bGVcIix0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidGl0bGVcIil8fFwiXCIpLHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiLFwiXCIpKX0sYS5wcm90b3R5cGUuX2VudGVyPWZ1bmN0aW9uKGUsbil7dmFyIGk9dGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWTsobj1ufHx0KGUuY3VycmVudFRhcmdldCkuZGF0YShpKSl8fChuPW5ldyB0aGlzLmNvbnN0cnVjdG9yKGUuY3VycmVudFRhcmdldCx0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpKSx0KGUuY3VycmVudFRhcmdldCkuZGF0YShpLG4pKSxlJiYobi5fYWN0aXZlVHJpZ2dlcltcImZvY3VzaW5cIj09PWUudHlwZT9nLkZPQ1VTOmcuSE9WRVJdPSEwKSx0KG4uZ2V0VGlwRWxlbWVudCgpKS5oYXNDbGFzcyhwLlNIT1cpfHxuLl9ob3ZlclN0YXRlPT09ZC5TSE9XP24uX2hvdmVyU3RhdGU9ZC5TSE9XOihjbGVhclRpbWVvdXQobi5fdGltZW91dCksbi5faG92ZXJTdGF0ZT1kLlNIT1csbi5jb25maWcuZGVsYXkmJm4uY29uZmlnLmRlbGF5LnNob3c/bi5fdGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bi5faG92ZXJTdGF0ZT09PWQuU0hPVyYmbi5zaG93KCl9LG4uY29uZmlnLmRlbGF5LnNob3cpOm4uc2hvdygpKX0sYS5wcm90b3R5cGUuX2xlYXZlPWZ1bmN0aW9uKGUsbil7dmFyIGk9dGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWTsobj1ufHx0KGUuY3VycmVudFRhcmdldCkuZGF0YShpKSl8fChuPW5ldyB0aGlzLmNvbnN0cnVjdG9yKGUuY3VycmVudFRhcmdldCx0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpKSx0KGUuY3VycmVudFRhcmdldCkuZGF0YShpLG4pKSxlJiYobi5fYWN0aXZlVHJpZ2dlcltcImZvY3Vzb3V0XCI9PT1lLnR5cGU/Zy5GT0NVUzpnLkhPVkVSXT0hMSksbi5faXNXaXRoQWN0aXZlVHJpZ2dlcigpfHwoY2xlYXJUaW1lb3V0KG4uX3RpbWVvdXQpLG4uX2hvdmVyU3RhdGU9ZC5PVVQsbi5jb25maWcuZGVsYXkmJm4uY29uZmlnLmRlbGF5LmhpZGU/bi5fdGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7bi5faG92ZXJTdGF0ZT09PWQuT1VUJiZuLmhpZGUoKX0sbi5jb25maWcuZGVsYXkuaGlkZSk6bi5oaWRlKCkpfSxhLnByb3RvdHlwZS5faXNXaXRoQWN0aXZlVHJpZ2dlcj1mdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB0aGlzLl9hY3RpdmVUcmlnZ2VyKWlmKHRoaXMuX2FjdGl2ZVRyaWdnZXJbdF0pcmV0dXJuITA7cmV0dXJuITF9LGEucHJvdG90eXBlLl9nZXRDb25maWc9ZnVuY3Rpb24obil7cmV0dXJuKG49dC5leHRlbmQoe30sdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LHQodGhpcy5lbGVtZW50KS5kYXRhKCksbikpLmRlbGF5JiZcIm51bWJlclwiPT10eXBlb2Ygbi5kZWxheSYmKG4uZGVsYXk9e3Nob3c6bi5kZWxheSxoaWRlOm4uZGVsYXl9KSxuLnRpdGxlJiZcIm51bWJlclwiPT10eXBlb2Ygbi50aXRsZSYmKG4udGl0bGU9bi50aXRsZS50b1N0cmluZygpKSxuLmNvbnRlbnQmJlwibnVtYmVyXCI9PXR5cGVvZiBuLmNvbnRlbnQmJihuLmNvbnRlbnQ9bi5jb250ZW50LnRvU3RyaW5nKCkpLHIudHlwZUNoZWNrQ29uZmlnKGUsbix0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKSxufSxhLnByb3RvdHlwZS5fZ2V0RGVsZWdhdGVDb25maWc9ZnVuY3Rpb24oKXt2YXIgdD17fTtpZih0aGlzLmNvbmZpZylmb3IodmFyIGUgaW4gdGhpcy5jb25maWcpdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2VdIT09dGhpcy5jb25maWdbZV0mJih0W2VdPXRoaXMuY29uZmlnW2VdKTtyZXR1cm4gdH0sYS5wcm90b3R5cGUuX2NsZWFuVGlwQ2xhc3M9ZnVuY3Rpb24oKXt2YXIgZT10KHRoaXMuZ2V0VGlwRWxlbWVudCgpKSxuPWUuYXR0cihcImNsYXNzXCIpLm1hdGNoKGwpO251bGwhPT1uJiZuLmxlbmd0aD4wJiZlLnJlbW92ZUNsYXNzKG4uam9pbihcIlwiKSl9LGEucHJvdG90eXBlLl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2U9ZnVuY3Rpb24odCl7dGhpcy5fY2xlYW5UaXBDbGFzcygpLHRoaXMuYWRkQXR0YWNobWVudENsYXNzKHRoaXMuX2dldEF0dGFjaG1lbnQodC5wbGFjZW1lbnQpKX0sYS5wcm90b3R5cGUuX2ZpeFRyYW5zaXRpb249ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmdldFRpcEVsZW1lbnQoKSxuPXRoaXMuY29uZmlnLmFuaW1hdGlvbjtudWxsPT09ZS5nZXRBdHRyaWJ1dGUoXCJ4LXBsYWNlbWVudFwiKSYmKHQoZSkucmVtb3ZlQ2xhc3MocC5GQURFKSx0aGlzLmNvbmZpZy5hbmltYXRpb249ITEsdGhpcy5oaWRlKCksdGhpcy5zaG93KCksdGhpcy5jb25maWcuYW5pbWF0aW9uPW4pfSxhLl9qUXVlcnlJbnRlcmZhY2U9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBuPXQodGhpcykuZGF0YShcImJzLnRvb2x0aXBcIiksbz1cIm9iamVjdFwiPT09KHZvaWQgMD09PWU/XCJ1bmRlZmluZWRcIjppKGUpKSYmZTtpZigobnx8IS9kaXNwb3NlfGhpZGUvLnRlc3QoZSkpJiYobnx8KG49bmV3IGEodGhpcyxvKSx0KHRoaXMpLmRhdGEoXCJicy50b29sdGlwXCIsbikpLFwic3RyaW5nXCI9PXR5cGVvZiBlKSl7aWYodm9pZCAwPT09bltlXSl0aHJvdyBuZXcgRXJyb3IoJ05vIG1ldGhvZCBuYW1lZCBcIicrZSsnXCInKTtuW2VdKCl9fSl9LG8oYSxudWxsLFt7a2V5OlwiVkVSU0lPTlwiLGdldDpmdW5jdGlvbigpe3JldHVyblwiNC4wLjAtYmV0YVwifX0se2tleTpcIkRlZmF1bHRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdX19LHtrZXk6XCJOQU1FXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGV9fSx7a2V5OlwiREFUQV9LRVlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cImJzLnRvb2x0aXBcIn19LHtrZXk6XCJFdmVudFwiLGdldDpmdW5jdGlvbigpe3JldHVybiBmfX0se2tleTpcIkVWRU5UX0tFWVwiLGdldDpmdW5jdGlvbigpe3JldHVybiBzfX0se2tleTpcIkRlZmF1bHRUeXBlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGh9fV0pLGF9KCk7cmV0dXJuIHQuZm5bZV09bS5falF1ZXJ5SW50ZXJmYWNlLHQuZm5bZV0uQ29uc3RydWN0b3I9bSx0LmZuW2VdLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdC5mbltlXT1hLG0uX2pRdWVyeUludGVyZmFjZX0sbX0oalF1ZXJ5KSk7IWZ1bmN0aW9uKHIpe3ZhciBhPVwicG9wb3ZlclwiLGw9XCIuYnMucG9wb3ZlclwiLGg9ci5mblthXSxjPW5ldyBSZWdFeHAoXCIoXnxcXFxccylicy1wb3BvdmVyXFxcXFMrXCIsXCJnXCIpLHU9ci5leHRlbmQoe30scy5EZWZhdWx0LHtwbGFjZW1lbnQ6XCJyaWdodFwiLHRyaWdnZXI6XCJjbGlja1wiLGNvbnRlbnQ6XCJcIix0ZW1wbGF0ZTonPGRpdiBjbGFzcz1cInBvcG92ZXJcIiByb2xlPVwidG9vbHRpcFwiPjxkaXYgY2xhc3M9XCJhcnJvd1wiPjwvZGl2PjxoMyBjbGFzcz1cInBvcG92ZXItaGVhZGVyXCI+PC9oMz48ZGl2IGNsYXNzPVwicG9wb3Zlci1ib2R5XCI+PC9kaXY+PC9kaXY+J30pLGQ9ci5leHRlbmQoe30scy5EZWZhdWx0VHlwZSx7Y29udGVudDpcIihzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbilcIn0pLGY9e0ZBREU6XCJmYWRlXCIsU0hPVzpcInNob3dcIn0scD17VElUTEU6XCIucG9wb3Zlci1oZWFkZXJcIixDT05URU5UOlwiLnBvcG92ZXItYm9keVwifSxfPXtISURFOlwiaGlkZVwiK2wsSElEREVOOlwiaGlkZGVuXCIrbCxTSE9XOlwic2hvd1wiK2wsU0hPV046XCJzaG93blwiK2wsSU5TRVJURUQ6XCJpbnNlcnRlZFwiK2wsQ0xJQ0s6XCJjbGlja1wiK2wsRk9DVVNJTjpcImZvY3VzaW5cIitsLEZPQ1VTT1VUOlwiZm9jdXNvdXRcIitsLE1PVVNFRU5URVI6XCJtb3VzZWVudGVyXCIrbCxNT1VTRUxFQVZFOlwibW91c2VsZWF2ZVwiK2x9LGc9ZnVuY3Rpb24ocyl7ZnVuY3Rpb24gaCgpe3JldHVybiBuKHRoaXMsaCksdCh0aGlzLHMuYXBwbHkodGhpcyxhcmd1bWVudHMpKX1yZXR1cm4gZShoLHMpLGgucHJvdG90eXBlLmlzV2l0aENvbnRlbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRUaXRsZSgpfHx0aGlzLl9nZXRDb250ZW50KCl9LGgucHJvdG90eXBlLmFkZEF0dGFjaG1lbnRDbGFzcz1mdW5jdGlvbih0KXtyKHRoaXMuZ2V0VGlwRWxlbWVudCgpKS5hZGRDbGFzcyhcImJzLXBvcG92ZXItXCIrdCl9LGgucHJvdG90eXBlLmdldFRpcEVsZW1lbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aXA9dGhpcy50aXB8fHIodGhpcy5jb25maWcudGVtcGxhdGUpWzBdfSxoLnByb3RvdHlwZS5zZXRDb250ZW50PWZ1bmN0aW9uKCl7dmFyIHQ9cih0aGlzLmdldFRpcEVsZW1lbnQoKSk7dGhpcy5zZXRFbGVtZW50Q29udGVudCh0LmZpbmQocC5USVRMRSksdGhpcy5nZXRUaXRsZSgpKSx0aGlzLnNldEVsZW1lbnRDb250ZW50KHQuZmluZChwLkNPTlRFTlQpLHRoaXMuX2dldENvbnRlbnQoKSksdC5yZW1vdmVDbGFzcyhmLkZBREUrXCIgXCIrZi5TSE9XKX0saC5wcm90b3R5cGUuX2dldENvbnRlbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtY29udGVudFwiKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMuY29uZmlnLmNvbnRlbnQ/dGhpcy5jb25maWcuY29udGVudC5jYWxsKHRoaXMuZWxlbWVudCk6dGhpcy5jb25maWcuY29udGVudCl9LGgucHJvdG90eXBlLl9jbGVhblRpcENsYXNzPWZ1bmN0aW9uKCl7dmFyIHQ9cih0aGlzLmdldFRpcEVsZW1lbnQoKSksZT10LmF0dHIoXCJjbGFzc1wiKS5tYXRjaChjKTtudWxsIT09ZSYmZS5sZW5ndGg+MCYmdC5yZW1vdmVDbGFzcyhlLmpvaW4oXCJcIikpfSxoLl9qUXVlcnlJbnRlcmZhY2U9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBlPXIodGhpcykuZGF0YShcImJzLnBvcG92ZXJcIiksbj1cIm9iamVjdFwiPT09KHZvaWQgMD09PXQ/XCJ1bmRlZmluZWRcIjppKHQpKT90Om51bGw7aWYoKGV8fCEvZGVzdHJveXxoaWRlLy50ZXN0KHQpKSYmKGV8fChlPW5ldyBoKHRoaXMsbikscih0aGlzKS5kYXRhKFwiYnMucG9wb3ZlclwiLGUpKSxcInN0cmluZ1wiPT10eXBlb2YgdCkpe2lmKHZvaWQgMD09PWVbdF0pdGhyb3cgbmV3IEVycm9yKCdObyBtZXRob2QgbmFtZWQgXCInK3QrJ1wiJyk7ZVt0XSgpfX0pfSxvKGgsbnVsbCxbe2tleTpcIlZFUlNJT05cIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cIjQuMC4wLWJldGFcIn19LHtrZXk6XCJEZWZhdWx0XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHV9fSx7a2V5OlwiTkFNRVwiLGdldDpmdW5jdGlvbigpe3JldHVybiBhfX0se2tleTpcIkRBVEFfS0VZXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCJicy5wb3BvdmVyXCJ9fSx7a2V5OlwiRXZlbnRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gX319LHtrZXk6XCJFVkVOVF9LRVlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbH19LHtrZXk6XCJEZWZhdWx0VHlwZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiBkfX1dKSxofShzKTtyLmZuW2FdPWcuX2pRdWVyeUludGVyZmFjZSxyLmZuW2FdLkNvbnN0cnVjdG9yPWcsci5mblthXS5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIHIuZm5bYV09aCxnLl9qUXVlcnlJbnRlcmZhY2V9fShqUXVlcnkpfSgpO1xuXG4vKiEgV09XIC0gdjEuMS4zIC0gMjAxNi0wNS0wNlxuKiBDb3B5cmlnaHQgKGMpIDIwMTYgTWF0dGhpZXUgQXVzc2FndWVsOyovKGZ1bmN0aW9uKCl7dmFyIGEsYixjLGQsZSxmPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGEuYXBwbHkoYixhcmd1bWVudHMpfX0sZz1bXS5pbmRleE9mfHxmdW5jdGlvbihhKXtmb3IodmFyIGI9MCxjPXRoaXMubGVuZ3RoO2M+YjtiKyspaWYoYiBpbiB0aGlzJiZ0aGlzW2JdPT09YSlyZXR1cm4gYjtyZXR1cm4tMX07Yj1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoKXt9cmV0dXJuIGEucHJvdG90eXBlLmV4dGVuZD1mdW5jdGlvbihhLGIpe3ZhciBjLGQ7Zm9yKGMgaW4gYilkPWJbY10sbnVsbD09YVtjXSYmKGFbY109ZCk7cmV0dXJuIGF9LGEucHJvdG90eXBlLmlzTW9iaWxlPWZ1bmN0aW9uKGEpe3JldHVybi9BbmRyb2lkfHdlYk9TfGlQaG9uZXxpUGFkfGlQb2R8QmxhY2tCZXJyeXxJRU1vYmlsZXxPcGVyYSBNaW5pL2kudGVzdChhKX0sYS5wcm90b3R5cGUuY3JlYXRlRXZlbnQ9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU7cmV0dXJuIG51bGw9PWImJihiPSExKSxudWxsPT1jJiYoYz0hMSksbnVsbD09ZCYmKGQ9bnVsbCksbnVsbCE9ZG9jdW1lbnQuY3JlYXRlRXZlbnQ/KGU9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKSxlLmluaXRDdXN0b21FdmVudChhLGIsYyxkKSk6bnVsbCE9ZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3Q/KGU9ZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKSxlLmV2ZW50VHlwZT1hKTplLmV2ZW50TmFtZT1hLGV9LGEucHJvdG90eXBlLmVtaXRFdmVudD1mdW5jdGlvbihhLGIpe3JldHVybiBudWxsIT1hLmRpc3BhdGNoRXZlbnQ/YS5kaXNwYXRjaEV2ZW50KGIpOmIgaW4obnVsbCE9YSk/YVtiXSgpOlwib25cIitiIGluKG51bGwhPWEpP2FbXCJvblwiK2JdKCk6dm9pZCAwfSxhLnByb3RvdHlwZS5hZGRFdmVudD1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIG51bGwhPWEuYWRkRXZlbnRMaXN0ZW5lcj9hLmFkZEV2ZW50TGlzdGVuZXIoYixjLCExKTpudWxsIT1hLmF0dGFjaEV2ZW50P2EuYXR0YWNoRXZlbnQoXCJvblwiK2IsYyk6YVtiXT1jfSxhLnByb3RvdHlwZS5yZW1vdmVFdmVudD1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIG51bGwhPWEucmVtb3ZlRXZlbnRMaXN0ZW5lcj9hLnJlbW92ZUV2ZW50TGlzdGVuZXIoYixjLCExKTpudWxsIT1hLmRldGFjaEV2ZW50P2EuZGV0YWNoRXZlbnQoXCJvblwiK2IsYyk6ZGVsZXRlIGFbYl19LGEucHJvdG90eXBlLmlubmVySGVpZ2h0PWZ1bmN0aW9uKCl7cmV0dXJuXCJpbm5lckhlaWdodFwiaW4gd2luZG93P3dpbmRvdy5pbm5lckhlaWdodDpkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0fSxhfSgpLGM9dGhpcy5XZWFrTWFwfHx0aGlzLk1veldlYWtNYXB8fChjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYSgpe3RoaXMua2V5cz1bXSx0aGlzLnZhbHVlcz1bXX1yZXR1cm4gYS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlLGY7Zm9yKGY9dGhpcy5rZXlzLGI9ZD0wLGU9Zi5sZW5ndGg7ZT5kO2I9KytkKWlmKGM9ZltiXSxjPT09YSlyZXR1cm4gdGhpcy52YWx1ZXNbYl19LGEucHJvdG90eXBlLnNldD1mdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmLGc7Zm9yKGc9dGhpcy5rZXlzLGM9ZT0wLGY9Zy5sZW5ndGg7Zj5lO2M9KytlKWlmKGQ9Z1tjXSxkPT09YSlyZXR1cm4gdm9pZCh0aGlzLnZhbHVlc1tjXT1iKTtyZXR1cm4gdGhpcy5rZXlzLnB1c2goYSksdGhpcy52YWx1ZXMucHVzaChiKX0sYX0oKSksYT10aGlzLk11dGF0aW9uT2JzZXJ2ZXJ8fHRoaXMuV2Via2l0TXV0YXRpb25PYnNlcnZlcnx8dGhpcy5Nb3pNdXRhdGlvbk9ic2VydmVyfHwoYT1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoKXtcInVuZGVmaW5lZFwiIT10eXBlb2YgY29uc29sZSYmbnVsbCE9PWNvbnNvbGUmJmNvbnNvbGUud2FybihcIk11dGF0aW9uT2JzZXJ2ZXIgaXMgbm90IHN1cHBvcnRlZCBieSB5b3VyIGJyb3dzZXIuXCIpLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBjb25zb2xlJiZudWxsIT09Y29uc29sZSYmY29uc29sZS53YXJuKFwiV09XLmpzIGNhbm5vdCBkZXRlY3QgZG9tIG11dGF0aW9ucywgcGxlYXNlIGNhbGwgLnN5bmMoKSBhZnRlciBsb2FkaW5nIG5ldyBjb250ZW50LlwiKX1yZXR1cm4gYS5ub3RTdXBwb3J0ZWQ9ITAsYS5wcm90b3R5cGUub2JzZXJ2ZT1mdW5jdGlvbigpe30sYX0oKSksZD10aGlzLmdldENvbXB1dGVkU3R5bGV8fGZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuZ2V0UHJvcGVydHlWYWx1ZT1mdW5jdGlvbihiKXt2YXIgYztyZXR1cm5cImZsb2F0XCI9PT1iJiYoYj1cInN0eWxlRmxvYXRcIiksZS50ZXN0KGIpJiZiLnJlcGxhY2UoZSxmdW5jdGlvbihhLGIpe3JldHVybiBiLnRvVXBwZXJDYXNlKCl9KSwobnVsbCE9KGM9YS5jdXJyZW50U3R5bGUpP2NbYl06dm9pZCAwKXx8bnVsbH0sdGhpc30sZT0vKFxcLShbYS16XSl7MX0pL2csdGhpcy5XT1c9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGEpe251bGw9PWEmJihhPXt9KSx0aGlzLnNjcm9sbENhbGxiYWNrPWYodGhpcy5zY3JvbGxDYWxsYmFjayx0aGlzKSx0aGlzLnNjcm9sbEhhbmRsZXI9Zih0aGlzLnNjcm9sbEhhbmRsZXIsdGhpcyksdGhpcy5yZXNldEFuaW1hdGlvbj1mKHRoaXMucmVzZXRBbmltYXRpb24sdGhpcyksdGhpcy5zdGFydD1mKHRoaXMuc3RhcnQsdGhpcyksdGhpcy5zY3JvbGxlZD0hMCx0aGlzLmNvbmZpZz10aGlzLnV0aWwoKS5leHRlbmQoYSx0aGlzLmRlZmF1bHRzKSxudWxsIT1hLnNjcm9sbENvbnRhaW5lciYmKHRoaXMuY29uZmlnLnNjcm9sbENvbnRhaW5lcj1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKGEuc2Nyb2xsQ29udGFpbmVyKSksdGhpcy5hbmltYXRpb25OYW1lQ2FjaGU9bmV3IGMsdGhpcy53b3dFdmVudD10aGlzLnV0aWwoKS5jcmVhdGVFdmVudCh0aGlzLmNvbmZpZy5ib3hDbGFzcyl9cmV0dXJuIGUucHJvdG90eXBlLmRlZmF1bHRzPXtib3hDbGFzczpcIndvd1wiLGFuaW1hdGVDbGFzczpcImFuaW1hdGVkXCIsb2Zmc2V0OjAsbW9iaWxlOiEwLGxpdmU6ITAsY2FsbGJhY2s6bnVsbCxzY3JvbGxDb250YWluZXI6bnVsbH0sZS5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbigpe3ZhciBhO3JldHVybiB0aGlzLmVsZW1lbnQ9d2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcImludGVyYWN0aXZlXCI9PT0oYT1kb2N1bWVudC5yZWFkeVN0YXRlKXx8XCJjb21wbGV0ZVwiPT09YT90aGlzLnN0YXJ0KCk6dGhpcy51dGlsKCkuYWRkRXZlbnQoZG9jdW1lbnQsXCJET01Db250ZW50TG9hZGVkXCIsdGhpcy5zdGFydCksdGhpcy5maW5pc2hlZD1bXX0sZS5wcm90b3R5cGUuc3RhcnQ9ZnVuY3Rpb24oKXt2YXIgYixjLGQsZTtpZih0aGlzLnN0b3BwZWQ9ITEsdGhpcy5ib3hlcz1mdW5jdGlvbigpe3ZhciBhLGMsZCxlO2ZvcihkPXRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLlwiK3RoaXMuY29uZmlnLmJveENsYXNzKSxlPVtdLGE9MCxjPWQubGVuZ3RoO2M+YTthKyspYj1kW2FdLGUucHVzaChiKTtyZXR1cm4gZX0uY2FsbCh0aGlzKSx0aGlzLmFsbD1mdW5jdGlvbigpe3ZhciBhLGMsZCxlO2ZvcihkPXRoaXMuYm94ZXMsZT1bXSxhPTAsYz1kLmxlbmd0aDtjPmE7YSsrKWI9ZFthXSxlLnB1c2goYik7cmV0dXJuIGV9LmNhbGwodGhpcyksdGhpcy5ib3hlcy5sZW5ndGgpaWYodGhpcy5kaXNhYmxlZCgpKXRoaXMucmVzZXRTdHlsZSgpO2Vsc2UgZm9yKGU9dGhpcy5ib3hlcyxjPTAsZD1lLmxlbmd0aDtkPmM7YysrKWI9ZVtjXSx0aGlzLmFwcGx5U3R5bGUoYiwhMCk7cmV0dXJuIHRoaXMuZGlzYWJsZWQoKXx8KHRoaXMudXRpbCgpLmFkZEV2ZW50KHRoaXMuY29uZmlnLnNjcm9sbENvbnRhaW5lcnx8d2luZG93LFwic2Nyb2xsXCIsdGhpcy5zY3JvbGxIYW5kbGVyKSx0aGlzLnV0aWwoKS5hZGRFdmVudCh3aW5kb3csXCJyZXNpemVcIix0aGlzLnNjcm9sbEhhbmRsZXIpLHRoaXMuaW50ZXJ2YWw9c2V0SW50ZXJ2YWwodGhpcy5zY3JvbGxDYWxsYmFjayw1MCkpLHRoaXMuY29uZmlnLmxpdmU/bmV3IGEoZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3ZhciBjLGQsZSxmLGc7Zm9yKGc9W10sYz0wLGQ9Yi5sZW5ndGg7ZD5jO2MrKylmPWJbY10sZy5wdXNoKGZ1bmN0aW9uKCl7dmFyIGEsYixjLGQ7Zm9yKGM9Zi5hZGRlZE5vZGVzfHxbXSxkPVtdLGE9MCxiPWMubGVuZ3RoO2I+YTthKyspZT1jW2FdLGQucHVzaCh0aGlzLmRvU3luYyhlKSk7cmV0dXJuIGR9LmNhbGwoYSkpO3JldHVybiBnfX0odGhpcykpLm9ic2VydmUoZG9jdW1lbnQuYm9keSx7Y2hpbGRMaXN0OiEwLHN1YnRyZWU6ITB9KTp2b2lkIDB9LGUucHJvdG90eXBlLnN0b3A9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdG9wcGVkPSEwLHRoaXMudXRpbCgpLnJlbW92ZUV2ZW50KHRoaXMuY29uZmlnLnNjcm9sbENvbnRhaW5lcnx8d2luZG93LFwic2Nyb2xsXCIsdGhpcy5zY3JvbGxIYW5kbGVyKSx0aGlzLnV0aWwoKS5yZW1vdmVFdmVudCh3aW5kb3csXCJyZXNpemVcIix0aGlzLnNjcm9sbEhhbmRsZXIpLG51bGwhPXRoaXMuaW50ZXJ2YWw/Y2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTp2b2lkIDB9LGUucHJvdG90eXBlLnN5bmM9ZnVuY3Rpb24oYil7cmV0dXJuIGEubm90U3VwcG9ydGVkP3RoaXMuZG9TeW5jKHRoaXMuZWxlbWVudCk6dm9pZCAwfSxlLnByb3RvdHlwZS5kb1N5bmM9ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGUsZjtpZihudWxsPT1hJiYoYT10aGlzLmVsZW1lbnQpLDE9PT1hLm5vZGVUeXBlKXtmb3IoYT1hLnBhcmVudE5vZGV8fGEsZT1hLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuXCIrdGhpcy5jb25maWcuYm94Q2xhc3MpLGY9W10sYz0wLGQ9ZS5sZW5ndGg7ZD5jO2MrKyliPWVbY10sZy5jYWxsKHRoaXMuYWxsLGIpPDA/KHRoaXMuYm94ZXMucHVzaChiKSx0aGlzLmFsbC5wdXNoKGIpLHRoaXMuc3RvcHBlZHx8dGhpcy5kaXNhYmxlZCgpP3RoaXMucmVzZXRTdHlsZSgpOnRoaXMuYXBwbHlTdHlsZShiLCEwKSxmLnB1c2godGhpcy5zY3JvbGxlZD0hMCkpOmYucHVzaCh2b2lkIDApO3JldHVybiBmfX0sZS5wcm90b3R5cGUuc2hvdz1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5hcHBseVN0eWxlKGEpLGEuY2xhc3NOYW1lPWEuY2xhc3NOYW1lK1wiIFwiK3RoaXMuY29uZmlnLmFuaW1hdGVDbGFzcyxudWxsIT10aGlzLmNvbmZpZy5jYWxsYmFjayYmdGhpcy5jb25maWcuY2FsbGJhY2soYSksdGhpcy51dGlsKCkuZW1pdEV2ZW50KGEsdGhpcy53b3dFdmVudCksdGhpcy51dGlsKCkuYWRkRXZlbnQoYSxcImFuaW1hdGlvbmVuZFwiLHRoaXMucmVzZXRBbmltYXRpb24pLHRoaXMudXRpbCgpLmFkZEV2ZW50KGEsXCJvYW5pbWF0aW9uZW5kXCIsdGhpcy5yZXNldEFuaW1hdGlvbiksdGhpcy51dGlsKCkuYWRkRXZlbnQoYSxcIndlYmtpdEFuaW1hdGlvbkVuZFwiLHRoaXMucmVzZXRBbmltYXRpb24pLHRoaXMudXRpbCgpLmFkZEV2ZW50KGEsXCJNU0FuaW1hdGlvbkVuZFwiLHRoaXMucmVzZXRBbmltYXRpb24pLGF9LGUucHJvdG90eXBlLmFwcGx5U3R5bGU9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGU7cmV0dXJuIGQ9YS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXdvdy1kdXJhdGlvblwiKSxjPWEuZ2V0QXR0cmlidXRlKFwiZGF0YS13b3ctZGVsYXlcIiksZT1hLmdldEF0dHJpYnV0ZShcImRhdGEtd293LWl0ZXJhdGlvblwiKSx0aGlzLmFuaW1hdGUoZnVuY3Rpb24oZil7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGYuY3VzdG9tU3R5bGUoYSxiLGQsYyxlKX19KHRoaXMpKX0sZS5wcm90b3R5cGUuYW5pbWF0ZT1mdW5jdGlvbigpe3JldHVyblwicmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJpbiB3aW5kb3c/ZnVuY3Rpb24oYSl7cmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYSl9OmZ1bmN0aW9uKGEpe3JldHVybiBhKCl9fSgpLGUucHJvdG90eXBlLnJlc2V0U3R5bGU9ZnVuY3Rpb24oKXt2YXIgYSxiLGMsZCxlO2ZvcihkPXRoaXMuYm94ZXMsZT1bXSxiPTAsYz1kLmxlbmd0aDtjPmI7YisrKWE9ZFtiXSxlLnB1c2goYS5zdHlsZS52aXNpYmlsaXR5PVwidmlzaWJsZVwiKTtyZXR1cm4gZX0sZS5wcm90b3R5cGUucmVzZXRBbmltYXRpb249ZnVuY3Rpb24oYSl7dmFyIGI7cmV0dXJuIGEudHlwZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJhbmltYXRpb25lbmRcIik+PTA/KGI9YS50YXJnZXR8fGEuc3JjRWxlbWVudCxiLmNsYXNzTmFtZT1iLmNsYXNzTmFtZS5yZXBsYWNlKHRoaXMuY29uZmlnLmFuaW1hdGVDbGFzcyxcIlwiKS50cmltKCkpOnZvaWQgMH0sZS5wcm90b3R5cGUuY3VzdG9tU3R5bGU9ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4gYiYmdGhpcy5jYWNoZUFuaW1hdGlvbk5hbWUoYSksYS5zdHlsZS52aXNpYmlsaXR5PWI/XCJoaWRkZW5cIjpcInZpc2libGVcIixjJiZ0aGlzLnZlbmRvclNldChhLnN0eWxlLHthbmltYXRpb25EdXJhdGlvbjpjfSksZCYmdGhpcy52ZW5kb3JTZXQoYS5zdHlsZSx7YW5pbWF0aW9uRGVsYXk6ZH0pLGUmJnRoaXMudmVuZG9yU2V0KGEuc3R5bGUse2FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OmV9KSx0aGlzLnZlbmRvclNldChhLnN0eWxlLHthbmltYXRpb25OYW1lOmI/XCJub25lXCI6dGhpcy5jYWNoZWRBbmltYXRpb25OYW1lKGEpfSksYX0sZS5wcm90b3R5cGUudmVuZG9ycz1bXCJtb3pcIixcIndlYmtpdFwiXSxlLnByb3RvdHlwZS52ZW5kb3JTZXQ9ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGUsZjtkPVtdO2ZvcihjIGluIGIpZT1iW2NdLGFbXCJcIitjXT1lLGQucHVzaChmdW5jdGlvbigpe3ZhciBiLGQsZyxoO2ZvcihnPXRoaXMudmVuZG9ycyxoPVtdLGI9MCxkPWcubGVuZ3RoO2Q+YjtiKyspZj1nW2JdLGgucHVzaChhW1wiXCIrZitjLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Muc3Vic3RyKDEpXT1lKTtyZXR1cm4gaH0uY2FsbCh0aGlzKSk7cmV0dXJuIGR9LGUucHJvdG90eXBlLnZlbmRvckNTUz1mdW5jdGlvbihhLGIpe3ZhciBjLGUsZixnLGgsaTtmb3IoaD1kKGEpLGc9aC5nZXRQcm9wZXJ0eUNTU1ZhbHVlKGIpLGY9dGhpcy52ZW5kb3JzLGM9MCxlPWYubGVuZ3RoO2U+YztjKyspaT1mW2NdLGc9Z3x8aC5nZXRQcm9wZXJ0eUNTU1ZhbHVlKFwiLVwiK2krXCItXCIrYik7cmV0dXJuIGd9LGUucHJvdG90eXBlLmFuaW1hdGlvbk5hbWU9ZnVuY3Rpb24oYSl7dmFyIGI7dHJ5e2I9dGhpcy52ZW5kb3JDU1MoYSxcImFuaW1hdGlvbi1uYW1lXCIpLmNzc1RleHR9Y2F0Y2goYyl7Yj1kKGEpLmdldFByb3BlcnR5VmFsdWUoXCJhbmltYXRpb24tbmFtZVwiKX1yZXR1cm5cIm5vbmVcIj09PWI/XCJcIjpifSxlLnByb3RvdHlwZS5jYWNoZUFuaW1hdGlvbk5hbWU9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuYW5pbWF0aW9uTmFtZUNhY2hlLnNldChhLHRoaXMuYW5pbWF0aW9uTmFtZShhKSl9LGUucHJvdG90eXBlLmNhY2hlZEFuaW1hdGlvbk5hbWU9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuYW5pbWF0aW9uTmFtZUNhY2hlLmdldChhKX0sZS5wcm90b3R5cGUuc2Nyb2xsSGFuZGxlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNjcm9sbGVkPSEwfSxlLnByb3RvdHlwZS5zY3JvbGxDYWxsYmFjaz1mdW5jdGlvbigpe3ZhciBhO3JldHVybiF0aGlzLnNjcm9sbGVkfHwodGhpcy5zY3JvbGxlZD0hMSx0aGlzLmJveGVzPWZ1bmN0aW9uKCl7dmFyIGIsYyxkLGU7Zm9yKGQ9dGhpcy5ib3hlcyxlPVtdLGI9MCxjPWQubGVuZ3RoO2M+YjtiKyspYT1kW2JdLGEmJih0aGlzLmlzVmlzaWJsZShhKT90aGlzLnNob3coYSk6ZS5wdXNoKGEpKTtyZXR1cm4gZX0uY2FsbCh0aGlzKSx0aGlzLmJveGVzLmxlbmd0aHx8dGhpcy5jb25maWcubGl2ZSk/dm9pZCAwOnRoaXMuc3RvcCgpfSxlLnByb3RvdHlwZS5vZmZzZXRUb3A9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiO3ZvaWQgMD09PWEub2Zmc2V0VG9wOylhPWEucGFyZW50Tm9kZTtmb3IoYj1hLm9mZnNldFRvcDthPWEub2Zmc2V0UGFyZW50OyliKz1hLm9mZnNldFRvcDtyZXR1cm4gYn0sZS5wcm90b3R5cGUuaXNWaXNpYmxlPWZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlLGY7cmV0dXJuIGM9YS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXdvdy1vZmZzZXRcIil8fHRoaXMuY29uZmlnLm9mZnNldCxmPXRoaXMuY29uZmlnLnNjcm9sbENvbnRhaW5lciYmdGhpcy5jb25maWcuc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcHx8d2luZG93LnBhZ2VZT2Zmc2V0LGU9ZitNYXRoLm1pbih0aGlzLmVsZW1lbnQuY2xpZW50SGVpZ2h0LHRoaXMudXRpbCgpLmlubmVySGVpZ2h0KCkpLWMsZD10aGlzLm9mZnNldFRvcChhKSxiPWQrYS5jbGllbnRIZWlnaHQsZT49ZCYmYj49Zn0sZS5wcm90b3R5cGUudXRpbD1mdW5jdGlvbigpe3JldHVybiBudWxsIT10aGlzLl91dGlsP3RoaXMuX3V0aWw6dGhpcy5fdXRpbD1uZXcgYn0sZS5wcm90b3R5cGUuZGlzYWJsZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5jb25maWcubW9iaWxlJiZ0aGlzLnV0aWwoKS5pc01vYmlsZShuYXZpZ2F0b3IudXNlckFnZW50KX0sZX0oKX0pLmNhbGwodGhpcyk7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogcmV0aW5hLXJlcGxhY2UubWluLmpzIHYxLjBcbiAqIGh0dHA6Ly9naXRodWIuY29tL2xlb25zbWl0aC9yZXRpbmEtcmVwbGFjZS1qc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBBdXRob3I6IExlb24gU21pdGhcbiAqIFR3aXR0ZXI6IEBudWxsVUtcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuKGZ1bmN0aW9uKGEpe3ZhciBlPWZ1bmN0aW9uKGQsYyl7dGhpcy5vcHRpb25zPWM7dmFyIGI9YShkKSxnPWIuaXMoXCJpbWdcIiksZj1nP2IuYXR0cihcInNyY1wiKTpiLmJhY2tncm91bmRJbWFnZVVybCgpLGY9dGhpcy5vcHRpb25zLmdlbmVyYXRlVXJsKGIsZik7YShcIjxpbWcvPlwiKS5hdHRyKFwic3JjXCIsZikub24oJ2xvYWQnLGZ1bmN0aW9uKCl7Zz9iLmF0dHIoXCJzcmNcIixhKHRoaXMpLmF0dHIoXCJzcmNcIikpOihiLmJhY2tncm91bmRJbWFnZVVybChhKHRoaXMpLmF0dHIoXCJzcmNcIikpLGIuYmFja2dyb3VuZFNpemUoYSh0aGlzKVswXS53aWR0aCxhKHRoaXMpWzBdLmhlaWdodCkpO2IuYXR0cihcImRhdGEtcmV0aW5hXCIsXCJjb21wbGV0ZVwiKX0pfTtlLnByb3RvdHlwZT17Y29uc3RydWN0b3I6ZX07YS5mbi5yZXRpbmFSZXBsYWNlPWZ1bmN0aW9uKGQpe3ZhciBjO2M9dm9pZCAwPT09d2luZG93LmRldmljZVBpeGVsUmF0aW8/MTp3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztyZXR1cm4gMT49Yz90aGlzOnRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBiPVxuYSh0aGlzKSxjPWIuZGF0YShcInJldGluYVJlcGxhY2VcIiksZj1hLmV4dGVuZCh7fSxhLmZuLnJldGluYVJlcGxhY2UuZGVmYXVsdHMsYi5kYXRhKCksXCJvYmplY3RcIj09dHlwZW9mIGQmJmQpO2N8fGIuZGF0YShcInJldGluYVJlcGxhY2VcIixjPW5ldyBlKHRoaXMsZikpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBkKWNbZF0oKX0pfTthLmZuLnJldGluYVJlcGxhY2UuZGVmYXVsdHM9e3N1ZmZpeDpcIl8yeFwiLGdlbmVyYXRlVXJsOmZ1bmN0aW9uKGEsYyl7dmFyIGI9Yy5sYXN0SW5kZXhPZihcIi5cIiksZT1jLnN1YnN0cihiKzEpO3JldHVybiBjLnN1YnN0cigwLGIpK3RoaXMuc3VmZml4K1wiLlwiK2V9fTthLmZuLnJldGluYVJlcGxhY2UuQ29uc3RydWN0b3I9ZTthLmZuLmJhY2tncm91bmRJbWFnZVVybD1mdW5jdGlvbihkKXtyZXR1cm4gZD90aGlzLmVhY2goZnVuY3Rpb24oKXthKHRoaXMpLmNzcyhcImJhY2tncm91bmQtaW1hZ2VcIiwndXJsKFwiJytkKydcIiknKX0pOmEodGhpcykuY3NzKFwiYmFja2dyb3VuZC1pbWFnZVwiKS5yZXBsYWNlKC91cmxcXCh8XFwpfFwifCcvZyxcblwiXCIpfTthLmZuLmJhY2tncm91bmRTaXplPWZ1bmN0aW9uKGQsYyl7dmFyIGI9TWF0aC5mbG9vcihkLzIpK1wicHggXCIrTWF0aC5mbG9vcihjLzIpK1wicHhcIjthKHRoaXMpLmNzcyhcImJhY2tncm91bmQtc2l6ZVwiLGIpO2EodGhpcykuY3NzKFwiLXdlYmtpdC1iYWNrZ3JvdW5kLXNpemVcIixiKX07YShmdW5jdGlvbigpe2EoXCJbZGF0YS1yZXRpbmE9J3RydWUnXVwiKS5yZXRpbmFSZXBsYWNlKCl9KX0pKHdpbmRvdy5qUXVlcnkpO1xuXG4vKipcbiAqIE93bCBDYXJvdXNlbCB2Mi4yLjFcbiAqIENvcHlyaWdodCAyMDEzLTIwMTcgRGF2aWQgRGV1dHNjaFxuICogTGljZW5zZWQgdW5kZXIgICgpXG4gKi9cbiFmdW5jdGlvbihhLGIsYyxkKXtmdW5jdGlvbiBlKGIsYyl7dGhpcy5zZXR0aW5ncz1udWxsLHRoaXMub3B0aW9ucz1hLmV4dGVuZCh7fSxlLkRlZmF1bHRzLGMpLHRoaXMuJGVsZW1lbnQ9YShiKSx0aGlzLl9oYW5kbGVycz17fSx0aGlzLl9wbHVnaW5zPXt9LHRoaXMuX3N1cHJlc3M9e30sdGhpcy5fY3VycmVudD1udWxsLHRoaXMuX3NwZWVkPW51bGwsdGhpcy5fY29vcmRpbmF0ZXM9W10sdGhpcy5fYnJlYWtwb2ludD1udWxsLHRoaXMuX3dpZHRoPW51bGwsdGhpcy5faXRlbXM9W10sdGhpcy5fY2xvbmVzPVtdLHRoaXMuX21lcmdlcnM9W10sdGhpcy5fd2lkdGhzPVtdLHRoaXMuX2ludmFsaWRhdGVkPXt9LHRoaXMuX3BpcGU9W10sdGhpcy5fZHJhZz17dGltZTpudWxsLHRhcmdldDpudWxsLHBvaW50ZXI6bnVsbCxzdGFnZTp7c3RhcnQ6bnVsbCxjdXJyZW50Om51bGx9LGRpcmVjdGlvbjpudWxsfSx0aGlzLl9zdGF0ZXM9e2N1cnJlbnQ6e30sdGFnczp7aW5pdGlhbGl6aW5nOltcImJ1c3lcIl0sYW5pbWF0aW5nOltcImJ1c3lcIl0sZHJhZ2dpbmc6W1wiaW50ZXJhY3RpbmdcIl19fSxhLmVhY2goW1wib25SZXNpemVcIixcIm9uVGhyb3R0bGVkUmVzaXplXCJdLGEucHJveHkoZnVuY3Rpb24oYixjKXt0aGlzLl9oYW5kbGVyc1tjXT1hLnByb3h5KHRoaXNbY10sdGhpcyl9LHRoaXMpKSxhLmVhY2goZS5QbHVnaW5zLGEucHJveHkoZnVuY3Rpb24oYSxiKXt0aGlzLl9wbHVnaW5zW2EuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkrYS5zbGljZSgxKV09bmV3IGIodGhpcyl9LHRoaXMpKSxhLmVhY2goZS5Xb3JrZXJzLGEucHJveHkoZnVuY3Rpb24oYixjKXt0aGlzLl9waXBlLnB1c2goe2ZpbHRlcjpjLmZpbHRlcixydW46YS5wcm94eShjLnJ1bix0aGlzKX0pfSx0aGlzKSksdGhpcy5zZXR1cCgpLHRoaXMuaW5pdGlhbGl6ZSgpfWUuRGVmYXVsdHM9e2l0ZW1zOjMsbG9vcDohMSxjZW50ZXI6ITEscmV3aW5kOiExLG1vdXNlRHJhZzohMCx0b3VjaERyYWc6ITAscHVsbERyYWc6ITAsZnJlZURyYWc6ITEsbWFyZ2luOjAsc3RhZ2VQYWRkaW5nOjAsbWVyZ2U6ITEsbWVyZ2VGaXQ6ITAsYXV0b1dpZHRoOiExLHN0YXJ0UG9zaXRpb246MCxydGw6ITEsc21hcnRTcGVlZDoyNTAsZmx1aWRTcGVlZDohMSxkcmFnRW5kU3BlZWQ6ITEscmVzcG9uc2l2ZTp7fSxyZXNwb25zaXZlUmVmcmVzaFJhdGU6MjAwLHJlc3BvbnNpdmVCYXNlRWxlbWVudDpiLGZhbGxiYWNrRWFzaW5nOlwic3dpbmdcIixpbmZvOiExLG5lc3RlZEl0ZW1TZWxlY3RvcjohMSxpdGVtRWxlbWVudDpcImRpdlwiLHN0YWdlRWxlbWVudDpcImRpdlwiLHJlZnJlc2hDbGFzczpcIm93bC1yZWZyZXNoXCIsbG9hZGVkQ2xhc3M6XCJvd2wtbG9hZGVkXCIsbG9hZGluZ0NsYXNzOlwib3dsLWxvYWRpbmdcIixydGxDbGFzczpcIm93bC1ydGxcIixyZXNwb25zaXZlQ2xhc3M6XCJvd2wtcmVzcG9uc2l2ZVwiLGRyYWdDbGFzczpcIm93bC1kcmFnXCIsaXRlbUNsYXNzOlwib3dsLWl0ZW1cIixzdGFnZUNsYXNzOlwib3dsLXN0YWdlXCIsc3RhZ2VPdXRlckNsYXNzOlwib3dsLXN0YWdlLW91dGVyXCIsZ3JhYkNsYXNzOlwib3dsLWdyYWJcIn0sZS5XaWR0aD17RGVmYXVsdDpcImRlZmF1bHRcIixJbm5lcjpcImlubmVyXCIsT3V0ZXI6XCJvdXRlclwifSxlLlR5cGU9e0V2ZW50OlwiZXZlbnRcIixTdGF0ZTpcInN0YXRlXCJ9LGUuUGx1Z2lucz17fSxlLldvcmtlcnM9W3tmaWx0ZXI6W1wid2lkdGhcIixcInNldHRpbmdzXCJdLHJ1bjpmdW5jdGlvbigpe3RoaXMuX3dpZHRoPXRoaXMuJGVsZW1lbnQud2lkdGgoKX19LHtmaWx0ZXI6W1wid2lkdGhcIixcIml0ZW1zXCIsXCJzZXR0aW5nc1wiXSxydW46ZnVuY3Rpb24oYSl7YS5jdXJyZW50PXRoaXMuX2l0ZW1zJiZ0aGlzLl9pdGVtc1t0aGlzLnJlbGF0aXZlKHRoaXMuX2N1cnJlbnQpXX19LHtmaWx0ZXI6W1wiaXRlbXNcIixcInNldHRpbmdzXCJdLHJ1bjpmdW5jdGlvbigpe3RoaXMuJHN0YWdlLmNoaWxkcmVuKFwiLmNsb25lZFwiKS5yZW1vdmUoKX19LHtmaWx0ZXI6W1wid2lkdGhcIixcIml0ZW1zXCIsXCJzZXR0aW5nc1wiXSxydW46ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5zZXR0aW5ncy5tYXJnaW58fFwiXCIsYz0hdGhpcy5zZXR0aW5ncy5hdXRvV2lkdGgsZD10aGlzLnNldHRpbmdzLnJ0bCxlPXt3aWR0aDpcImF1dG9cIixcIm1hcmdpbi1sZWZ0XCI6ZD9iOlwiXCIsXCJtYXJnaW4tcmlnaHRcIjpkP1wiXCI6Yn07IWMmJnRoaXMuJHN0YWdlLmNoaWxkcmVuKCkuY3NzKGUpLGEuY3NzPWV9fSx7ZmlsdGVyOltcIndpZHRoXCIsXCJpdGVtc1wiLFwic2V0dGluZ3NcIl0scnVuOmZ1bmN0aW9uKGEpe3ZhciBiPSh0aGlzLndpZHRoKCkvdGhpcy5zZXR0aW5ncy5pdGVtcykudG9GaXhlZCgzKS10aGlzLnNldHRpbmdzLm1hcmdpbixjPW51bGwsZD10aGlzLl9pdGVtcy5sZW5ndGgsZT0hdGhpcy5zZXR0aW5ncy5hdXRvV2lkdGgsZj1bXTtmb3IoYS5pdGVtcz17bWVyZ2U6ITEsd2lkdGg6Yn07ZC0tOyljPXRoaXMuX21lcmdlcnNbZF0sYz10aGlzLnNldHRpbmdzLm1lcmdlRml0JiZNYXRoLm1pbihjLHRoaXMuc2V0dGluZ3MuaXRlbXMpfHxjLGEuaXRlbXMubWVyZ2U9Yz4xfHxhLml0ZW1zLm1lcmdlLGZbZF09ZT9iKmM6dGhpcy5faXRlbXNbZF0ud2lkdGgoKTt0aGlzLl93aWR0aHM9Zn19LHtmaWx0ZXI6W1wiaXRlbXNcIixcInNldHRpbmdzXCJdLHJ1bjpmdW5jdGlvbigpe3ZhciBiPVtdLGM9dGhpcy5faXRlbXMsZD10aGlzLnNldHRpbmdzLGU9TWF0aC5tYXgoMipkLml0ZW1zLDQpLGY9MipNYXRoLmNlaWwoYy5sZW5ndGgvMiksZz1kLmxvb3AmJmMubGVuZ3RoP2QucmV3aW5kP2U6TWF0aC5tYXgoZSxmKTowLGg9XCJcIixpPVwiXCI7Zm9yKGcvPTI7Zy0tOyliLnB1c2godGhpcy5ub3JtYWxpemUoYi5sZW5ndGgvMiwhMCkpLGgrPWNbYltiLmxlbmd0aC0xXV1bMF0ub3V0ZXJIVE1MLGIucHVzaCh0aGlzLm5vcm1hbGl6ZShjLmxlbmd0aC0xLShiLmxlbmd0aC0xKS8yLCEwKSksaT1jW2JbYi5sZW5ndGgtMV1dWzBdLm91dGVySFRNTCtpO3RoaXMuX2Nsb25lcz1iLGEoaCkuYWRkQ2xhc3MoXCJjbG9uZWRcIikuYXBwZW5kVG8odGhpcy4kc3RhZ2UpLGEoaSkuYWRkQ2xhc3MoXCJjbG9uZWRcIikucHJlcGVuZFRvKHRoaXMuJHN0YWdlKX19LHtmaWx0ZXI6W1wid2lkdGhcIixcIml0ZW1zXCIsXCJzZXR0aW5nc1wiXSxydW46ZnVuY3Rpb24oKXtmb3IodmFyIGE9dGhpcy5zZXR0aW5ncy5ydGw/MTotMSxiPXRoaXMuX2Nsb25lcy5sZW5ndGgrdGhpcy5faXRlbXMubGVuZ3RoLGM9LTEsZD0wLGU9MCxmPVtdOysrYzxiOylkPWZbYy0xXXx8MCxlPXRoaXMuX3dpZHRoc1t0aGlzLnJlbGF0aXZlKGMpXSt0aGlzLnNldHRpbmdzLm1hcmdpbixmLnB1c2goZCtlKmEpO3RoaXMuX2Nvb3JkaW5hdGVzPWZ9fSx7ZmlsdGVyOltcIndpZHRoXCIsXCJpdGVtc1wiLFwic2V0dGluZ3NcIl0scnVuOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5zZXR0aW5ncy5zdGFnZVBhZGRpbmcsYj10aGlzLl9jb29yZGluYXRlcyxjPXt3aWR0aDpNYXRoLmNlaWwoTWF0aC5hYnMoYltiLmxlbmd0aC0xXSkpKzIqYSxcInBhZGRpbmctbGVmdFwiOmF8fFwiXCIsXCJwYWRkaW5nLXJpZ2h0XCI6YXx8XCJcIn07dGhpcy4kc3RhZ2UuY3NzKGMpfX0se2ZpbHRlcjpbXCJ3aWR0aFwiLFwiaXRlbXNcIixcInNldHRpbmdzXCJdLHJ1bjpmdW5jdGlvbihhKXt2YXIgYj10aGlzLl9jb29yZGluYXRlcy5sZW5ndGgsYz0hdGhpcy5zZXR0aW5ncy5hdXRvV2lkdGgsZD10aGlzLiRzdGFnZS5jaGlsZHJlbigpO2lmKGMmJmEuaXRlbXMubWVyZ2UpZm9yKDtiLS07KWEuY3NzLndpZHRoPXRoaXMuX3dpZHRoc1t0aGlzLnJlbGF0aXZlKGIpXSxkLmVxKGIpLmNzcyhhLmNzcyk7ZWxzZSBjJiYoYS5jc3Mud2lkdGg9YS5pdGVtcy53aWR0aCxkLmNzcyhhLmNzcykpfX0se2ZpbHRlcjpbXCJpdGVtc1wiXSxydW46ZnVuY3Rpb24oKXt0aGlzLl9jb29yZGluYXRlcy5sZW5ndGg8MSYmdGhpcy4kc3RhZ2UucmVtb3ZlQXR0cihcInN0eWxlXCIpfX0se2ZpbHRlcjpbXCJ3aWR0aFwiLFwiaXRlbXNcIixcInNldHRpbmdzXCJdLHJ1bjpmdW5jdGlvbihhKXthLmN1cnJlbnQ9YS5jdXJyZW50P3RoaXMuJHN0YWdlLmNoaWxkcmVuKCkuaW5kZXgoYS5jdXJyZW50KTowLGEuY3VycmVudD1NYXRoLm1heCh0aGlzLm1pbmltdW0oKSxNYXRoLm1pbih0aGlzLm1heGltdW0oKSxhLmN1cnJlbnQpKSx0aGlzLnJlc2V0KGEuY3VycmVudCl9fSx7ZmlsdGVyOltcInBvc2l0aW9uXCJdLHJ1bjpmdW5jdGlvbigpe3RoaXMuYW5pbWF0ZSh0aGlzLmNvb3JkaW5hdGVzKHRoaXMuX2N1cnJlbnQpKX19LHtmaWx0ZXI6W1wid2lkdGhcIixcInBvc2l0aW9uXCIsXCJpdGVtc1wiLFwic2V0dGluZ3NcIl0scnVuOmZ1bmN0aW9uKCl7dmFyIGEsYixjLGQsZT10aGlzLnNldHRpbmdzLnJ0bD8xOi0xLGY9Mip0aGlzLnNldHRpbmdzLnN0YWdlUGFkZGluZyxnPXRoaXMuY29vcmRpbmF0ZXModGhpcy5jdXJyZW50KCkpK2YsaD1nK3RoaXMud2lkdGgoKSplLGk9W107Zm9yKGM9MCxkPXRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aDtjPGQ7YysrKWE9dGhpcy5fY29vcmRpbmF0ZXNbYy0xXXx8MCxiPU1hdGguYWJzKHRoaXMuX2Nvb3JkaW5hdGVzW2NdKStmKmUsKHRoaXMub3AoYSxcIjw9XCIsZykmJnRoaXMub3AoYSxcIj5cIixoKXx8dGhpcy5vcChiLFwiPFwiLGcpJiZ0aGlzLm9wKGIsXCI+XCIsaCkpJiZpLnB1c2goYyk7dGhpcy4kc3RhZ2UuY2hpbGRyZW4oXCIuYWN0aXZlXCIpLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpLHRoaXMuJHN0YWdlLmNoaWxkcmVuKFwiOmVxKFwiK2kuam9pbihcIiksIDplcShcIikrXCIpXCIpLmFkZENsYXNzKFwiYWN0aXZlXCIpLHRoaXMuc2V0dGluZ3MuY2VudGVyJiYodGhpcy4kc3RhZ2UuY2hpbGRyZW4oXCIuY2VudGVyXCIpLnJlbW92ZUNsYXNzKFwiY2VudGVyXCIpLHRoaXMuJHN0YWdlLmNoaWxkcmVuKCkuZXEodGhpcy5jdXJyZW50KCkpLmFkZENsYXNzKFwiY2VudGVyXCIpKX19XSxlLnByb3RvdHlwZS5pbml0aWFsaXplPWZ1bmN0aW9uKCl7aWYodGhpcy5lbnRlcihcImluaXRpYWxpemluZ1wiKSx0aGlzLnRyaWdnZXIoXCJpbml0aWFsaXplXCIpLHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3ModGhpcy5zZXR0aW5ncy5ydGxDbGFzcyx0aGlzLnNldHRpbmdzLnJ0bCksdGhpcy5zZXR0aW5ncy5hdXRvV2lkdGgmJiF0aGlzLmlzKFwicHJlLWxvYWRpbmdcIikpe3ZhciBiLGMsZTtiPXRoaXMuJGVsZW1lbnQuZmluZChcImltZ1wiKSxjPXRoaXMuc2V0dGluZ3MubmVzdGVkSXRlbVNlbGVjdG9yP1wiLlwiK3RoaXMuc2V0dGluZ3MubmVzdGVkSXRlbVNlbGVjdG9yOmQsZT10aGlzLiRlbGVtZW50LmNoaWxkcmVuKGMpLndpZHRoKCksYi5sZW5ndGgmJmU8PTAmJnRoaXMucHJlbG9hZEF1dG9XaWR0aEltYWdlcyhiKX10aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5sb2FkaW5nQ2xhc3MpLHRoaXMuJHN0YWdlPWEoXCI8XCIrdGhpcy5zZXR0aW5ncy5zdGFnZUVsZW1lbnQrJyBjbGFzcz1cIicrdGhpcy5zZXR0aW5ncy5zdGFnZUNsYXNzKydcIi8+Jykud3JhcCgnPGRpdiBjbGFzcz1cIicrdGhpcy5zZXR0aW5ncy5zdGFnZU91dGVyQ2xhc3MrJ1wiLz4nKSx0aGlzLiRlbGVtZW50LmFwcGVuZCh0aGlzLiRzdGFnZS5wYXJlbnQoKSksdGhpcy5yZXBsYWNlKHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oKS5ub3QodGhpcy4kc3RhZ2UucGFyZW50KCkpKSx0aGlzLiRlbGVtZW50LmlzKFwiOnZpc2libGVcIik/dGhpcy5yZWZyZXNoKCk6dGhpcy5pbnZhbGlkYXRlKFwid2lkdGhcIiksdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMubG9hZGluZ0NsYXNzKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMubG9hZGVkQ2xhc3MpLHRoaXMucmVnaXN0ZXJFdmVudEhhbmRsZXJzKCksdGhpcy5sZWF2ZShcImluaXRpYWxpemluZ1wiKSx0aGlzLnRyaWdnZXIoXCJpbml0aWFsaXplZFwiKX0sZS5wcm90b3R5cGUuc2V0dXA9ZnVuY3Rpb24oKXt2YXIgYj10aGlzLnZpZXdwb3J0KCksYz10aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSxkPS0xLGU9bnVsbDtjPyhhLmVhY2goYyxmdW5jdGlvbihhKXthPD1iJiZhPmQmJihkPU51bWJlcihhKSl9KSxlPWEuZXh0ZW5kKHt9LHRoaXMub3B0aW9ucyxjW2RdKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnN0YWdlUGFkZGluZyYmKGUuc3RhZ2VQYWRkaW5nPWUuc3RhZ2VQYWRkaW5nKCkpLGRlbGV0ZSBlLnJlc3BvbnNpdmUsZS5yZXNwb25zaXZlQ2xhc3MmJnRoaXMuJGVsZW1lbnQuYXR0cihcImNsYXNzXCIsdGhpcy4kZWxlbWVudC5hdHRyKFwiY2xhc3NcIikucmVwbGFjZShuZXcgUmVnRXhwKFwiKFwiK3RoaXMub3B0aW9ucy5yZXNwb25zaXZlQ2xhc3MrXCItKVxcXFxTK1xcXFxzXCIsXCJnXCIpLFwiJDFcIitkKSkpOmU9YS5leHRlbmQoe30sdGhpcy5vcHRpb25zKSx0aGlzLnRyaWdnZXIoXCJjaGFuZ2VcIix7cHJvcGVydHk6e25hbWU6XCJzZXR0aW5nc1wiLHZhbHVlOmV9fSksdGhpcy5fYnJlYWtwb2ludD1kLHRoaXMuc2V0dGluZ3M9ZSx0aGlzLmludmFsaWRhdGUoXCJzZXR0aW5nc1wiKSx0aGlzLnRyaWdnZXIoXCJjaGFuZ2VkXCIse3Byb3BlcnR5OntuYW1lOlwic2V0dGluZ3NcIix2YWx1ZTp0aGlzLnNldHRpbmdzfX0pfSxlLnByb3RvdHlwZS5vcHRpb25zTG9naWM9ZnVuY3Rpb24oKXt0aGlzLnNldHRpbmdzLmF1dG9XaWR0aCYmKHRoaXMuc2V0dGluZ3Muc3RhZ2VQYWRkaW5nPSExLHRoaXMuc2V0dGluZ3MubWVyZ2U9ITEpfSxlLnByb3RvdHlwZS5wcmVwYXJlPWZ1bmN0aW9uKGIpe3ZhciBjPXRoaXMudHJpZ2dlcihcInByZXBhcmVcIix7Y29udGVudDpifSk7cmV0dXJuIGMuZGF0YXx8KGMuZGF0YT1hKFwiPFwiK3RoaXMuc2V0dGluZ3MuaXRlbUVsZW1lbnQrXCIvPlwiKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuaXRlbUNsYXNzKS5hcHBlbmQoYikpLHRoaXMudHJpZ2dlcihcInByZXBhcmVkXCIse2NvbnRlbnQ6Yy5kYXRhfSksYy5kYXRhfSxlLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oKXtmb3IodmFyIGI9MCxjPXRoaXMuX3BpcGUubGVuZ3RoLGQ9YS5wcm94eShmdW5jdGlvbihhKXtyZXR1cm4gdGhpc1thXX0sdGhpcy5faW52YWxpZGF0ZWQpLGU9e307YjxjOykodGhpcy5faW52YWxpZGF0ZWQuYWxsfHxhLmdyZXAodGhpcy5fcGlwZVtiXS5maWx0ZXIsZCkubGVuZ3RoPjApJiZ0aGlzLl9waXBlW2JdLnJ1bihlKSxiKys7dGhpcy5faW52YWxpZGF0ZWQ9e30sIXRoaXMuaXMoXCJ2YWxpZFwiKSYmdGhpcy5lbnRlcihcInZhbGlkXCIpfSxlLnByb3RvdHlwZS53aWR0aD1mdW5jdGlvbihhKXtzd2l0Y2goYT1hfHxlLldpZHRoLkRlZmF1bHQpe2Nhc2UgZS5XaWR0aC5Jbm5lcjpjYXNlIGUuV2lkdGguT3V0ZXI6cmV0dXJuIHRoaXMuX3dpZHRoO2RlZmF1bHQ6cmV0dXJuIHRoaXMuX3dpZHRoLTIqdGhpcy5zZXR0aW5ncy5zdGFnZVBhZGRpbmcrdGhpcy5zZXR0aW5ncy5tYXJnaW59fSxlLnByb3RvdHlwZS5yZWZyZXNoPWZ1bmN0aW9uKCl7dGhpcy5lbnRlcihcInJlZnJlc2hpbmdcIiksdGhpcy50cmlnZ2VyKFwicmVmcmVzaFwiKSx0aGlzLnNldHVwKCksdGhpcy5vcHRpb25zTG9naWMoKSx0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5yZWZyZXNoQ2xhc3MpLHRoaXMudXBkYXRlKCksdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMucmVmcmVzaENsYXNzKSx0aGlzLmxlYXZlKFwicmVmcmVzaGluZ1wiKSx0aGlzLnRyaWdnZXIoXCJyZWZyZXNoZWRcIil9LGUucHJvdG90eXBlLm9uVGhyb3R0bGVkUmVzaXplPWZ1bmN0aW9uKCl7Yi5jbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lciksdGhpcy5yZXNpemVUaW1lcj1iLnNldFRpbWVvdXQodGhpcy5faGFuZGxlcnMub25SZXNpemUsdGhpcy5zZXR0aW5ncy5yZXNwb25zaXZlUmVmcmVzaFJhdGUpfSxlLnByb3RvdHlwZS5vblJlc2l6ZT1mdW5jdGlvbigpe3JldHVybiEhdGhpcy5faXRlbXMubGVuZ3RoJiYodGhpcy5fd2lkdGghPT10aGlzLiRlbGVtZW50LndpZHRoKCkmJighIXRoaXMuJGVsZW1lbnQuaXMoXCI6dmlzaWJsZVwiKSYmKHRoaXMuZW50ZXIoXCJyZXNpemluZ1wiKSx0aGlzLnRyaWdnZXIoXCJyZXNpemVcIikuaXNEZWZhdWx0UHJldmVudGVkKCk/KHRoaXMubGVhdmUoXCJyZXNpemluZ1wiKSwhMSk6KHRoaXMuaW52YWxpZGF0ZShcIndpZHRoXCIpLHRoaXMucmVmcmVzaCgpLHRoaXMubGVhdmUoXCJyZXNpemluZ1wiKSx2b2lkIHRoaXMudHJpZ2dlcihcInJlc2l6ZWRcIikpKSkpfSxlLnByb3RvdHlwZS5yZWdpc3RlckV2ZW50SGFuZGxlcnM9ZnVuY3Rpb24oKXthLnN1cHBvcnQudHJhbnNpdGlvbiYmdGhpcy4kc3RhZ2Uub24oYS5zdXBwb3J0LnRyYW5zaXRpb24uZW5kK1wiLm93bC5jb3JlXCIsYS5wcm94eSh0aGlzLm9uVHJhbnNpdGlvbkVuZCx0aGlzKSksdGhpcy5zZXR0aW5ncy5yZXNwb25zaXZlIT09ITEmJnRoaXMub24oYixcInJlc2l6ZVwiLHRoaXMuX2hhbmRsZXJzLm9uVGhyb3R0bGVkUmVzaXplKSx0aGlzLnNldHRpbmdzLm1vdXNlRHJhZyYmKHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmRyYWdDbGFzcyksdGhpcy4kc3RhZ2Uub24oXCJtb3VzZWRvd24ub3dsLmNvcmVcIixhLnByb3h5KHRoaXMub25EcmFnU3RhcnQsdGhpcykpLHRoaXMuJHN0YWdlLm9uKFwiZHJhZ3N0YXJ0Lm93bC5jb3JlIHNlbGVjdHN0YXJ0Lm93bC5jb3JlXCIsZnVuY3Rpb24oKXtyZXR1cm4hMX0pKSx0aGlzLnNldHRpbmdzLnRvdWNoRHJhZyYmKHRoaXMuJHN0YWdlLm9uKFwidG91Y2hzdGFydC5vd2wuY29yZVwiLGEucHJveHkodGhpcy5vbkRyYWdTdGFydCx0aGlzKSksdGhpcy4kc3RhZ2Uub24oXCJ0b3VjaGNhbmNlbC5vd2wuY29yZVwiLGEucHJveHkodGhpcy5vbkRyYWdFbmQsdGhpcykpKX0sZS5wcm90b3R5cGUub25EcmFnU3RhcnQ9ZnVuY3Rpb24oYil7dmFyIGQ9bnVsbDszIT09Yi53aGljaCYmKGEuc3VwcG9ydC50cmFuc2Zvcm0/KGQ9dGhpcy4kc3RhZ2UuY3NzKFwidHJhbnNmb3JtXCIpLnJlcGxhY2UoLy4qXFwofFxcKXwgL2csXCJcIikuc3BsaXQoXCIsXCIpLGQ9e3g6ZFsxNj09PWQubGVuZ3RoPzEyOjRdLHk6ZFsxNj09PWQubGVuZ3RoPzEzOjVdfSk6KGQ9dGhpcy4kc3RhZ2UucG9zaXRpb24oKSxkPXt4OnRoaXMuc2V0dGluZ3MucnRsP2QubGVmdCt0aGlzLiRzdGFnZS53aWR0aCgpLXRoaXMud2lkdGgoKSt0aGlzLnNldHRpbmdzLm1hcmdpbjpkLmxlZnQseTpkLnRvcH0pLHRoaXMuaXMoXCJhbmltYXRpbmdcIikmJihhLnN1cHBvcnQudHJhbnNmb3JtP3RoaXMuYW5pbWF0ZShkLngpOnRoaXMuJHN0YWdlLnN0b3AoKSx0aGlzLmludmFsaWRhdGUoXCJwb3NpdGlvblwiKSksdGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLm9wdGlvbnMuZ3JhYkNsYXNzLFwibW91c2Vkb3duXCI9PT1iLnR5cGUpLHRoaXMuc3BlZWQoMCksdGhpcy5fZHJhZy50aW1lPShuZXcgRGF0ZSkuZ2V0VGltZSgpLHRoaXMuX2RyYWcudGFyZ2V0PWEoYi50YXJnZXQpLHRoaXMuX2RyYWcuc3RhZ2Uuc3RhcnQ9ZCx0aGlzLl9kcmFnLnN0YWdlLmN1cnJlbnQ9ZCx0aGlzLl9kcmFnLnBvaW50ZXI9dGhpcy5wb2ludGVyKGIpLGEoYykub24oXCJtb3VzZXVwLm93bC5jb3JlIHRvdWNoZW5kLm93bC5jb3JlXCIsYS5wcm94eSh0aGlzLm9uRHJhZ0VuZCx0aGlzKSksYShjKS5vbmUoXCJtb3VzZW1vdmUub3dsLmNvcmUgdG91Y2htb3ZlLm93bC5jb3JlXCIsYS5wcm94eShmdW5jdGlvbihiKXt2YXIgZD10aGlzLmRpZmZlcmVuY2UodGhpcy5fZHJhZy5wb2ludGVyLHRoaXMucG9pbnRlcihiKSk7YShjKS5vbihcIm1vdXNlbW92ZS5vd2wuY29yZSB0b3VjaG1vdmUub3dsLmNvcmVcIixhLnByb3h5KHRoaXMub25EcmFnTW92ZSx0aGlzKSksTWF0aC5hYnMoZC54KTxNYXRoLmFicyhkLnkpJiZ0aGlzLmlzKFwidmFsaWRcIil8fChiLnByZXZlbnREZWZhdWx0KCksdGhpcy5lbnRlcihcImRyYWdnaW5nXCIpLHRoaXMudHJpZ2dlcihcImRyYWdcIikpfSx0aGlzKSkpfSxlLnByb3RvdHlwZS5vbkRyYWdNb3ZlPWZ1bmN0aW9uKGEpe3ZhciBiPW51bGwsYz1udWxsLGQ9bnVsbCxlPXRoaXMuZGlmZmVyZW5jZSh0aGlzLl9kcmFnLnBvaW50ZXIsdGhpcy5wb2ludGVyKGEpKSxmPXRoaXMuZGlmZmVyZW5jZSh0aGlzLl9kcmFnLnN0YWdlLnN0YXJ0LGUpO3RoaXMuaXMoXCJkcmFnZ2luZ1wiKSYmKGEucHJldmVudERlZmF1bHQoKSx0aGlzLnNldHRpbmdzLmxvb3A/KGI9dGhpcy5jb29yZGluYXRlcyh0aGlzLm1pbmltdW0oKSksYz10aGlzLmNvb3JkaW5hdGVzKHRoaXMubWF4aW11bSgpKzEpLWIsZi54PSgoZi54LWIpJWMrYyklYytiKTooYj10aGlzLnNldHRpbmdzLnJ0bD90aGlzLmNvb3JkaW5hdGVzKHRoaXMubWF4aW11bSgpKTp0aGlzLmNvb3JkaW5hdGVzKHRoaXMubWluaW11bSgpKSxjPXRoaXMuc2V0dGluZ3MucnRsP3RoaXMuY29vcmRpbmF0ZXModGhpcy5taW5pbXVtKCkpOnRoaXMuY29vcmRpbmF0ZXModGhpcy5tYXhpbXVtKCkpLGQ9dGhpcy5zZXR0aW5ncy5wdWxsRHJhZz8tMSplLngvNTowLGYueD1NYXRoLm1heChNYXRoLm1pbihmLngsYitkKSxjK2QpKSx0aGlzLl9kcmFnLnN0YWdlLmN1cnJlbnQ9Zix0aGlzLmFuaW1hdGUoZi54KSl9LGUucHJvdG90eXBlLm9uRHJhZ0VuZD1mdW5jdGlvbihiKXt2YXIgZD10aGlzLmRpZmZlcmVuY2UodGhpcy5fZHJhZy5wb2ludGVyLHRoaXMucG9pbnRlcihiKSksZT10aGlzLl9kcmFnLnN0YWdlLmN1cnJlbnQsZj1kLng+MF50aGlzLnNldHRpbmdzLnJ0bD9cImxlZnRcIjpcInJpZ2h0XCI7YShjKS5vZmYoXCIub3dsLmNvcmVcIiksdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZ3JhYkNsYXNzKSwoMCE9PWQueCYmdGhpcy5pcyhcImRyYWdnaW5nXCIpfHwhdGhpcy5pcyhcInZhbGlkXCIpKSYmKHRoaXMuc3BlZWQodGhpcy5zZXR0aW5ncy5kcmFnRW5kU3BlZWR8fHRoaXMuc2V0dGluZ3Muc21hcnRTcGVlZCksdGhpcy5jdXJyZW50KHRoaXMuY2xvc2VzdChlLngsMCE9PWQueD9mOnRoaXMuX2RyYWcuZGlyZWN0aW9uKSksdGhpcy5pbnZhbGlkYXRlKFwicG9zaXRpb25cIiksdGhpcy51cGRhdGUoKSx0aGlzLl9kcmFnLmRpcmVjdGlvbj1mLChNYXRoLmFicyhkLngpPjN8fChuZXcgRGF0ZSkuZ2V0VGltZSgpLXRoaXMuX2RyYWcudGltZT4zMDApJiZ0aGlzLl9kcmFnLnRhcmdldC5vbmUoXCJjbGljay5vd2wuY29yZVwiLGZ1bmN0aW9uKCl7cmV0dXJuITF9KSksdGhpcy5pcyhcImRyYWdnaW5nXCIpJiYodGhpcy5sZWF2ZShcImRyYWdnaW5nXCIpLHRoaXMudHJpZ2dlcihcImRyYWdnZWRcIikpfSxlLnByb3RvdHlwZS5jbG9zZXN0PWZ1bmN0aW9uKGIsYyl7dmFyIGQ9LTEsZT0zMCxmPXRoaXMud2lkdGgoKSxnPXRoaXMuY29vcmRpbmF0ZXMoKTtyZXR1cm4gdGhpcy5zZXR0aW5ncy5mcmVlRHJhZ3x8YS5lYWNoKGcsYS5wcm94eShmdW5jdGlvbihhLGgpe3JldHVyblwibGVmdFwiPT09YyYmYj5oLWUmJmI8aCtlP2Q9YTpcInJpZ2h0XCI9PT1jJiZiPmgtZi1lJiZiPGgtZitlP2Q9YSsxOnRoaXMub3AoYixcIjxcIixoKSYmdGhpcy5vcChiLFwiPlwiLGdbYSsxXXx8aC1mKSYmKGQ9XCJsZWZ0XCI9PT1jP2ErMTphKSxkPT09LTF9LHRoaXMpKSx0aGlzLnNldHRpbmdzLmxvb3B8fCh0aGlzLm9wKGIsXCI+XCIsZ1t0aGlzLm1pbmltdW0oKV0pP2Q9Yj10aGlzLm1pbmltdW0oKTp0aGlzLm9wKGIsXCI8XCIsZ1t0aGlzLm1heGltdW0oKV0pJiYoZD1iPXRoaXMubWF4aW11bSgpKSksZH0sZS5wcm90b3R5cGUuYW5pbWF0ZT1mdW5jdGlvbihiKXt2YXIgYz10aGlzLnNwZWVkKCk+MDt0aGlzLmlzKFwiYW5pbWF0aW5nXCIpJiZ0aGlzLm9uVHJhbnNpdGlvbkVuZCgpLGMmJih0aGlzLmVudGVyKFwiYW5pbWF0aW5nXCIpLHRoaXMudHJpZ2dlcihcInRyYW5zbGF0ZVwiKSksYS5zdXBwb3J0LnRyYW5zZm9ybTNkJiZhLnN1cHBvcnQudHJhbnNpdGlvbj90aGlzLiRzdGFnZS5jc3Moe3RyYW5zZm9ybTpcInRyYW5zbGF0ZTNkKFwiK2IrXCJweCwwcHgsMHB4KVwiLHRyYW5zaXRpb246dGhpcy5zcGVlZCgpLzFlMytcInNcIn0pOmM/dGhpcy4kc3RhZ2UuYW5pbWF0ZSh7bGVmdDpiK1wicHhcIn0sdGhpcy5zcGVlZCgpLHRoaXMuc2V0dGluZ3MuZmFsbGJhY2tFYXNpbmcsYS5wcm94eSh0aGlzLm9uVHJhbnNpdGlvbkVuZCx0aGlzKSk6dGhpcy4kc3RhZ2UuY3NzKHtsZWZ0OmIrXCJweFwifSl9LGUucHJvdG90eXBlLmlzPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLl9zdGF0ZXMuY3VycmVudFthXSYmdGhpcy5fc3RhdGVzLmN1cnJlbnRbYV0+MH0sZS5wcm90b3R5cGUuY3VycmVudD1mdW5jdGlvbihhKXtpZihhPT09ZClyZXR1cm4gdGhpcy5fY3VycmVudDtpZigwPT09dGhpcy5faXRlbXMubGVuZ3RoKXJldHVybiBkO2lmKGE9dGhpcy5ub3JtYWxpemUoYSksdGhpcy5fY3VycmVudCE9PWEpe3ZhciBiPXRoaXMudHJpZ2dlcihcImNoYW5nZVwiLHtwcm9wZXJ0eTp7bmFtZTpcInBvc2l0aW9uXCIsdmFsdWU6YX19KTtiLmRhdGEhPT1kJiYoYT10aGlzLm5vcm1hbGl6ZShiLmRhdGEpKSx0aGlzLl9jdXJyZW50PWEsdGhpcy5pbnZhbGlkYXRlKFwicG9zaXRpb25cIiksdGhpcy50cmlnZ2VyKFwiY2hhbmdlZFwiLHtwcm9wZXJ0eTp7bmFtZTpcInBvc2l0aW9uXCIsdmFsdWU6dGhpcy5fY3VycmVudH19KX1yZXR1cm4gdGhpcy5fY3VycmVudH0sZS5wcm90b3R5cGUuaW52YWxpZGF0ZT1mdW5jdGlvbihiKXtyZXR1cm5cInN0cmluZ1wiPT09YS50eXBlKGIpJiYodGhpcy5faW52YWxpZGF0ZWRbYl09ITAsdGhpcy5pcyhcInZhbGlkXCIpJiZ0aGlzLmxlYXZlKFwidmFsaWRcIikpLGEubWFwKHRoaXMuX2ludmFsaWRhdGVkLGZ1bmN0aW9uKGEsYil7cmV0dXJuIGJ9KX0sZS5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oYSl7YT10aGlzLm5vcm1hbGl6ZShhKSxhIT09ZCYmKHRoaXMuX3NwZWVkPTAsdGhpcy5fY3VycmVudD1hLHRoaXMuc3VwcHJlc3MoW1widHJhbnNsYXRlXCIsXCJ0cmFuc2xhdGVkXCJdKSx0aGlzLmFuaW1hdGUodGhpcy5jb29yZGluYXRlcyhhKSksdGhpcy5yZWxlYXNlKFtcInRyYW5zbGF0ZVwiLFwidHJhbnNsYXRlZFwiXSkpfSxlLnByb3RvdHlwZS5ub3JtYWxpemU9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLl9pdGVtcy5sZW5ndGgsZT1iPzA6dGhpcy5fY2xvbmVzLmxlbmd0aDtyZXR1cm4hdGhpcy5pc051bWVyaWMoYSl8fGM8MT9hPWQ6KGE8MHx8YT49YytlKSYmKGE9KChhLWUvMiklYytjKSVjK2UvMiksYX0sZS5wcm90b3R5cGUucmVsYXRpdmU9ZnVuY3Rpb24oYSl7cmV0dXJuIGEtPXRoaXMuX2Nsb25lcy5sZW5ndGgvMix0aGlzLm5vcm1hbGl6ZShhLCEwKX0sZS5wcm90b3R5cGUubWF4aW11bT1mdW5jdGlvbihhKXt2YXIgYixjLGQsZT10aGlzLnNldHRpbmdzLGY9dGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoO2lmKGUubG9vcClmPXRoaXMuX2Nsb25lcy5sZW5ndGgvMit0aGlzLl9pdGVtcy5sZW5ndGgtMTtlbHNlIGlmKGUuYXV0b1dpZHRofHxlLm1lcmdlKXtmb3IoYj10aGlzLl9pdGVtcy5sZW5ndGgsYz10aGlzLl9pdGVtc1stLWJdLndpZHRoKCksZD10aGlzLiRlbGVtZW50LndpZHRoKCk7Yi0tJiYoYys9dGhpcy5faXRlbXNbYl0ud2lkdGgoKSt0aGlzLnNldHRpbmdzLm1hcmdpbiwhKGM+ZCkpOyk7Zj1iKzF9ZWxzZSBmPWUuY2VudGVyP3RoaXMuX2l0ZW1zLmxlbmd0aC0xOnRoaXMuX2l0ZW1zLmxlbmd0aC1lLml0ZW1zO3JldHVybiBhJiYoZi09dGhpcy5fY2xvbmVzLmxlbmd0aC8yKSxNYXRoLm1heChmLDApfSxlLnByb3RvdHlwZS5taW5pbXVtPWZ1bmN0aW9uKGEpe3JldHVybiBhPzA6dGhpcy5fY2xvbmVzLmxlbmd0aC8yfSxlLnByb3RvdHlwZS5pdGVtcz1mdW5jdGlvbihhKXtyZXR1cm4gYT09PWQ/dGhpcy5faXRlbXMuc2xpY2UoKTooYT10aGlzLm5vcm1hbGl6ZShhLCEwKSx0aGlzLl9pdGVtc1thXSl9LGUucHJvdG90eXBlLm1lcmdlcnM9ZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT1kP3RoaXMuX21lcmdlcnMuc2xpY2UoKTooYT10aGlzLm5vcm1hbGl6ZShhLCEwKSx0aGlzLl9tZXJnZXJzW2FdKX0sZS5wcm90b3R5cGUuY2xvbmVzPWZ1bmN0aW9uKGIpe3ZhciBjPXRoaXMuX2Nsb25lcy5sZW5ndGgvMixlPWMrdGhpcy5faXRlbXMubGVuZ3RoLGY9ZnVuY3Rpb24oYSl7cmV0dXJuIGElMj09PTA/ZSthLzI6Yy0oYSsxKS8yfTtyZXR1cm4gYj09PWQ/YS5tYXAodGhpcy5fY2xvbmVzLGZ1bmN0aW9uKGEsYil7cmV0dXJuIGYoYil9KTphLm1hcCh0aGlzLl9jbG9uZXMsZnVuY3Rpb24oYSxjKXtyZXR1cm4gYT09PWI/ZihjKTpudWxsfSl9LGUucHJvdG90eXBlLnNwZWVkPWZ1bmN0aW9uKGEpe3JldHVybiBhIT09ZCYmKHRoaXMuX3NwZWVkPWEpLHRoaXMuX3NwZWVkfSxlLnByb3RvdHlwZS5jb29yZGluYXRlcz1mdW5jdGlvbihiKXt2YXIgYyxlPTEsZj1iLTE7cmV0dXJuIGI9PT1kP2EubWFwKHRoaXMuX2Nvb3JkaW5hdGVzLGEucHJveHkoZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5jb29yZGluYXRlcyhiKX0sdGhpcykpOih0aGlzLnNldHRpbmdzLmNlbnRlcj8odGhpcy5zZXR0aW5ncy5ydGwmJihlPS0xLGY9YisxKSxjPXRoaXMuX2Nvb3JkaW5hdGVzW2JdLGMrPSh0aGlzLndpZHRoKCktYysodGhpcy5fY29vcmRpbmF0ZXNbZl18fDApKS8yKmUpOmM9dGhpcy5fY29vcmRpbmF0ZXNbZl18fDAsYz1NYXRoLmNlaWwoYykpfSxlLnByb3RvdHlwZS5kdXJhdGlvbj1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIDA9PT1jPzA6TWF0aC5taW4oTWF0aC5tYXgoTWF0aC5hYnMoYi1hKSwxKSw2KSpNYXRoLmFicyhjfHx0aGlzLnNldHRpbmdzLnNtYXJ0U3BlZWQpfSxlLnByb3RvdHlwZS50bz1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuY3VycmVudCgpLGQ9bnVsbCxlPWEtdGhpcy5yZWxhdGl2ZShjKSxmPShlPjApLShlPDApLGc9dGhpcy5faXRlbXMubGVuZ3RoLGg9dGhpcy5taW5pbXVtKCksaT10aGlzLm1heGltdW0oKTt0aGlzLnNldHRpbmdzLmxvb3A/KCF0aGlzLnNldHRpbmdzLnJld2luZCYmTWF0aC5hYnMoZSk+Zy8yJiYoZSs9ZiotMSpnKSxhPWMrZSxkPSgoYS1oKSVnK2cpJWcraCxkIT09YSYmZC1lPD1pJiZkLWU+MCYmKGM9ZC1lLGE9ZCx0aGlzLnJlc2V0KGMpKSk6dGhpcy5zZXR0aW5ncy5yZXdpbmQ/KGkrPTEsYT0oYSVpK2kpJWkpOmE9TWF0aC5tYXgoaCxNYXRoLm1pbihpLGEpKSx0aGlzLnNwZWVkKHRoaXMuZHVyYXRpb24oYyxhLGIpKSx0aGlzLmN1cnJlbnQoYSksdGhpcy4kZWxlbWVudC5pcyhcIjp2aXNpYmxlXCIpJiZ0aGlzLnVwZGF0ZSgpfSxlLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKGEpe2E9YXx8ITEsdGhpcy50byh0aGlzLnJlbGF0aXZlKHRoaXMuY3VycmVudCgpKSsxLGEpfSxlLnByb3RvdHlwZS5wcmV2PWZ1bmN0aW9uKGEpe2E9YXx8ITEsdGhpcy50byh0aGlzLnJlbGF0aXZlKHRoaXMuY3VycmVudCgpKS0xLGEpfSxlLnByb3RvdHlwZS5vblRyYW5zaXRpb25FbmQ9ZnVuY3Rpb24oYSl7aWYoYSE9PWQmJihhLnN0b3BQcm9wYWdhdGlvbigpLChhLnRhcmdldHx8YS5zcmNFbGVtZW50fHxhLm9yaWdpbmFsVGFyZ2V0KSE9PXRoaXMuJHN0YWdlLmdldCgwKSkpcmV0dXJuITE7dGhpcy5sZWF2ZShcImFuaW1hdGluZ1wiKSx0aGlzLnRyaWdnZXIoXCJ0cmFuc2xhdGVkXCIpfSxlLnByb3RvdHlwZS52aWV3cG9ydD1mdW5jdGlvbigpe3ZhciBkO3JldHVybiB0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZUJhc2VFbGVtZW50IT09Yj9kPWEodGhpcy5vcHRpb25zLnJlc3BvbnNpdmVCYXNlRWxlbWVudCkud2lkdGgoKTpiLmlubmVyV2lkdGg/ZD1iLmlubmVyV2lkdGg6Yy5kb2N1bWVudEVsZW1lbnQmJmMuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoP2Q9Yy5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg6Y29uc29sZS53YXJuKFwiQ2FuIG5vdCBkZXRlY3Qgdmlld3BvcnQgd2lkdGguXCIpLGR9LGUucHJvdG90eXBlLnJlcGxhY2U9ZnVuY3Rpb24oYil7dGhpcy4kc3RhZ2UuZW1wdHkoKSx0aGlzLl9pdGVtcz1bXSxiJiYoYj1iIGluc3RhbmNlb2YgalF1ZXJ5P2I6YShiKSksdGhpcy5zZXR0aW5ncy5uZXN0ZWRJdGVtU2VsZWN0b3ImJihiPWIuZmluZChcIi5cIit0aGlzLnNldHRpbmdzLm5lc3RlZEl0ZW1TZWxlY3RvcikpLGIuZmlsdGVyKGZ1bmN0aW9uKCl7cmV0dXJuIDE9PT10aGlzLm5vZGVUeXBlfSkuZWFjaChhLnByb3h5KGZ1bmN0aW9uKGEsYil7Yj10aGlzLnByZXBhcmUoYiksdGhpcy4kc3RhZ2UuYXBwZW5kKGIpLHRoaXMuX2l0ZW1zLnB1c2goYiksdGhpcy5fbWVyZ2Vycy5wdXNoKDEqYi5maW5kKFwiW2RhdGEtbWVyZ2VdXCIpLmFkZEJhY2soXCJbZGF0YS1tZXJnZV1cIikuYXR0cihcImRhdGEtbWVyZ2VcIil8fDEpfSx0aGlzKSksdGhpcy5yZXNldCh0aGlzLmlzTnVtZXJpYyh0aGlzLnNldHRpbmdzLnN0YXJ0UG9zaXRpb24pP3RoaXMuc2V0dGluZ3Muc3RhcnRQb3NpdGlvbjowKSx0aGlzLmludmFsaWRhdGUoXCJpdGVtc1wiKX0sZS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKGIsYyl7dmFyIGU9dGhpcy5yZWxhdGl2ZSh0aGlzLl9jdXJyZW50KTtjPWM9PT1kP3RoaXMuX2l0ZW1zLmxlbmd0aDp0aGlzLm5vcm1hbGl6ZShjLCEwKSxiPWIgaW5zdGFuY2VvZiBqUXVlcnk/YjphKGIpLHRoaXMudHJpZ2dlcihcImFkZFwiLHtjb250ZW50OmIscG9zaXRpb246Y30pLGI9dGhpcy5wcmVwYXJlKGIpLDA9PT10aGlzLl9pdGVtcy5sZW5ndGh8fGM9PT10aGlzLl9pdGVtcy5sZW5ndGg/KDA9PT10aGlzLl9pdGVtcy5sZW5ndGgmJnRoaXMuJHN0YWdlLmFwcGVuZChiKSwwIT09dGhpcy5faXRlbXMubGVuZ3RoJiZ0aGlzLl9pdGVtc1tjLTFdLmFmdGVyKGIpLHRoaXMuX2l0ZW1zLnB1c2goYiksdGhpcy5fbWVyZ2Vycy5wdXNoKDEqYi5maW5kKFwiW2RhdGEtbWVyZ2VdXCIpLmFkZEJhY2soXCJbZGF0YS1tZXJnZV1cIikuYXR0cihcImRhdGEtbWVyZ2VcIil8fDEpKToodGhpcy5faXRlbXNbY10uYmVmb3JlKGIpLHRoaXMuX2l0ZW1zLnNwbGljZShjLDAsYiksdGhpcy5fbWVyZ2Vycy5zcGxpY2UoYywwLDEqYi5maW5kKFwiW2RhdGEtbWVyZ2VdXCIpLmFkZEJhY2soXCJbZGF0YS1tZXJnZV1cIikuYXR0cihcImRhdGEtbWVyZ2VcIil8fDEpKSx0aGlzLl9pdGVtc1tlXSYmdGhpcy5yZXNldCh0aGlzLl9pdGVtc1tlXS5pbmRleCgpKSx0aGlzLmludmFsaWRhdGUoXCJpdGVtc1wiKSx0aGlzLnRyaWdnZXIoXCJhZGRlZFwiLHtjb250ZW50OmIscG9zaXRpb246Y30pfSxlLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oYSl7YT10aGlzLm5vcm1hbGl6ZShhLCEwKSxhIT09ZCYmKHRoaXMudHJpZ2dlcihcInJlbW92ZVwiLHtjb250ZW50OnRoaXMuX2l0ZW1zW2FdLHBvc2l0aW9uOmF9KSx0aGlzLl9pdGVtc1thXS5yZW1vdmUoKSx0aGlzLl9pdGVtcy5zcGxpY2UoYSwxKSx0aGlzLl9tZXJnZXJzLnNwbGljZShhLDEpLHRoaXMuaW52YWxpZGF0ZShcIml0ZW1zXCIpLHRoaXMudHJpZ2dlcihcInJlbW92ZWRcIix7Y29udGVudDpudWxsLHBvc2l0aW9uOmF9KSl9LGUucHJvdG90eXBlLnByZWxvYWRBdXRvV2lkdGhJbWFnZXM9ZnVuY3Rpb24oYil7Yi5lYWNoKGEucHJveHkoZnVuY3Rpb24oYixjKXt0aGlzLmVudGVyKFwicHJlLWxvYWRpbmdcIiksYz1hKGMpLGEobmV3IEltYWdlKS5vbmUoXCJsb2FkXCIsYS5wcm94eShmdW5jdGlvbihhKXtjLmF0dHIoXCJzcmNcIixhLnRhcmdldC5zcmMpLGMuY3NzKFwib3BhY2l0eVwiLDEpLHRoaXMubGVhdmUoXCJwcmUtbG9hZGluZ1wiKSwhdGhpcy5pcyhcInByZS1sb2FkaW5nXCIpJiYhdGhpcy5pcyhcImluaXRpYWxpemluZ1wiKSYmdGhpcy5yZWZyZXNoKCl9LHRoaXMpKS5hdHRyKFwic3JjXCIsYy5hdHRyKFwic3JjXCIpfHxjLmF0dHIoXCJkYXRhLXNyY1wiKXx8Yy5hdHRyKFwiZGF0YS1zcmMtcmV0aW5hXCIpKX0sdGhpcykpfSxlLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy4kZWxlbWVudC5vZmYoXCIub3dsLmNvcmVcIiksdGhpcy4kc3RhZ2Uub2ZmKFwiLm93bC5jb3JlXCIpLGEoYykub2ZmKFwiLm93bC5jb3JlXCIpLHRoaXMuc2V0dGluZ3MucmVzcG9uc2l2ZSE9PSExJiYoYi5jbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lciksdGhpcy5vZmYoYixcInJlc2l6ZVwiLHRoaXMuX2hhbmRsZXJzLm9uVGhyb3R0bGVkUmVzaXplKSk7Zm9yKHZhciBkIGluIHRoaXMuX3BsdWdpbnMpdGhpcy5fcGx1Z2luc1tkXS5kZXN0cm95KCk7dGhpcy4kc3RhZ2UuY2hpbGRyZW4oXCIuY2xvbmVkXCIpLnJlbW92ZSgpLHRoaXMuJHN0YWdlLnVud3JhcCgpLHRoaXMuJHN0YWdlLmNoaWxkcmVuKCkuY29udGVudHMoKS51bndyYXAoKSx0aGlzLiRzdGFnZS5jaGlsZHJlbigpLnVud3JhcCgpLHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLnJlZnJlc2hDbGFzcykucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmxvYWRpbmdDbGFzcykucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmxvYWRlZENsYXNzKS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMucnRsQ2xhc3MpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5kcmFnQ2xhc3MpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5ncmFiQ2xhc3MpLmF0dHIoXCJjbGFzc1wiLHRoaXMuJGVsZW1lbnQuYXR0cihcImNsYXNzXCIpLnJlcGxhY2UobmV3IFJlZ0V4cCh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZUNsYXNzK1wiLVxcXFxTK1xcXFxzXCIsXCJnXCIpLFwiXCIpKS5yZW1vdmVEYXRhKFwib3dsLmNhcm91c2VsXCIpfSxlLnByb3RvdHlwZS5vcD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpcy5zZXR0aW5ncy5ydGw7c3dpdGNoKGIpe2Nhc2VcIjxcIjpyZXR1cm4gZD9hPmM6YTxjO2Nhc2VcIj5cIjpyZXR1cm4gZD9hPGM6YT5jO2Nhc2VcIj49XCI6cmV0dXJuIGQ/YTw9YzphPj1jO2Nhc2VcIjw9XCI6cmV0dXJuIGQ/YT49YzphPD1jfX0sZS5wcm90b3R5cGUub249ZnVuY3Rpb24oYSxiLGMsZCl7YS5hZGRFdmVudExpc3RlbmVyP2EuYWRkRXZlbnRMaXN0ZW5lcihiLGMsZCk6YS5hdHRhY2hFdmVudCYmYS5hdHRhY2hFdmVudChcIm9uXCIrYixjKX0sZS5wcm90b3R5cGUub2ZmPWZ1bmN0aW9uKGEsYixjLGQpe2EucmVtb3ZlRXZlbnRMaXN0ZW5lcj9hLnJlbW92ZUV2ZW50TGlzdGVuZXIoYixjLGQpOmEuZGV0YWNoRXZlbnQmJmEuZGV0YWNoRXZlbnQoXCJvblwiK2IsYyl9LGUucHJvdG90eXBlLnRyaWdnZXI9ZnVuY3Rpb24oYixjLGQsZixnKXt2YXIgaD17aXRlbTp7Y291bnQ6dGhpcy5faXRlbXMubGVuZ3RoLGluZGV4OnRoaXMuY3VycmVudCgpfX0saT1hLmNhbWVsQ2FzZShhLmdyZXAoW1wib25cIixiLGRdLGZ1bmN0aW9uKGEpe3JldHVybiBhfSkuam9pbihcIi1cIikudG9Mb3dlckNhc2UoKSksaj1hLkV2ZW50KFtiLFwib3dsXCIsZHx8XCJjYXJvdXNlbFwiXS5qb2luKFwiLlwiKS50b0xvd2VyQ2FzZSgpLGEuZXh0ZW5kKHtyZWxhdGVkVGFyZ2V0OnRoaXN9LGgsYykpO3JldHVybiB0aGlzLl9zdXByZXNzW2JdfHwoYS5lYWNoKHRoaXMuX3BsdWdpbnMsZnVuY3Rpb24oYSxiKXtiLm9uVHJpZ2dlciYmYi5vblRyaWdnZXIoail9KSx0aGlzLnJlZ2lzdGVyKHt0eXBlOmUuVHlwZS5FdmVudCxuYW1lOmJ9KSx0aGlzLiRlbGVtZW50LnRyaWdnZXIoaiksdGhpcy5zZXR0aW5ncyYmXCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5zZXR0aW5nc1tpXSYmdGhpcy5zZXR0aW5nc1tpXS5jYWxsKHRoaXMsaikpLGp9LGUucHJvdG90eXBlLmVudGVyPWZ1bmN0aW9uKGIpe2EuZWFjaChbYl0uY29uY2F0KHRoaXMuX3N0YXRlcy50YWdzW2JdfHxbXSksYS5wcm94eShmdW5jdGlvbihhLGIpe3RoaXMuX3N0YXRlcy5jdXJyZW50W2JdPT09ZCYmKHRoaXMuX3N0YXRlcy5jdXJyZW50W2JdPTApLHRoaXMuX3N0YXRlcy5jdXJyZW50W2JdKyt9LHRoaXMpKX0sZS5wcm90b3R5cGUubGVhdmU9ZnVuY3Rpb24oYil7YS5lYWNoKFtiXS5jb25jYXQodGhpcy5fc3RhdGVzLnRhZ3NbYl18fFtdKSxhLnByb3h5KGZ1bmN0aW9uKGEsYil7dGhpcy5fc3RhdGVzLmN1cnJlbnRbYl0tLX0sdGhpcykpfSxlLnByb3RvdHlwZS5yZWdpc3Rlcj1mdW5jdGlvbihiKXtpZihiLnR5cGU9PT1lLlR5cGUuRXZlbnQpe2lmKGEuZXZlbnQuc3BlY2lhbFtiLm5hbWVdfHwoYS5ldmVudC5zcGVjaWFsW2IubmFtZV09e30pLCFhLmV2ZW50LnNwZWNpYWxbYi5uYW1lXS5vd2wpe3ZhciBjPWEuZXZlbnQuc3BlY2lhbFtiLm5hbWVdLl9kZWZhdWx0O2EuZXZlbnQuc3BlY2lhbFtiLm5hbWVdLl9kZWZhdWx0PWZ1bmN0aW9uKGEpe3JldHVybiFjfHwhYy5hcHBseXx8YS5uYW1lc3BhY2UmJmEubmFtZXNwYWNlLmluZGV4T2YoXCJvd2xcIikhPT0tMT9hLm5hbWVzcGFjZSYmYS5uYW1lc3BhY2UuaW5kZXhPZihcIm93bFwiKT4tMTpjLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sYS5ldmVudC5zcGVjaWFsW2IubmFtZV0ub3dsPSEwfX1lbHNlIGIudHlwZT09PWUuVHlwZS5TdGF0ZSYmKHRoaXMuX3N0YXRlcy50YWdzW2IubmFtZV0/dGhpcy5fc3RhdGVzLnRhZ3NbYi5uYW1lXT10aGlzLl9zdGF0ZXMudGFnc1tiLm5hbWVdLmNvbmNhdChiLnRhZ3MpOnRoaXMuX3N0YXRlcy50YWdzW2IubmFtZV09Yi50YWdzLHRoaXMuX3N0YXRlcy50YWdzW2IubmFtZV09YS5ncmVwKHRoaXMuX3N0YXRlcy50YWdzW2IubmFtZV0sYS5wcm94eShmdW5jdGlvbihjLGQpe3JldHVybiBhLmluQXJyYXkoYyx0aGlzLl9zdGF0ZXMudGFnc1tiLm5hbWVdKT09PWR9LHRoaXMpKSl9LGUucHJvdG90eXBlLnN1cHByZXNzPWZ1bmN0aW9uKGIpe2EuZWFjaChiLGEucHJveHkoZnVuY3Rpb24oYSxiKXt0aGlzLl9zdXByZXNzW2JdPSEwfSx0aGlzKSl9LGUucHJvdG90eXBlLnJlbGVhc2U9ZnVuY3Rpb24oYil7YS5lYWNoKGIsYS5wcm94eShmdW5jdGlvbihhLGIpe2RlbGV0ZSB0aGlzLl9zdXByZXNzW2JdfSx0aGlzKSl9LGUucHJvdG90eXBlLnBvaW50ZXI9ZnVuY3Rpb24oYSl7dmFyIGM9e3g6bnVsbCx5Om51bGx9O3JldHVybiBhPWEub3JpZ2luYWxFdmVudHx8YXx8Yi5ldmVudCxhPWEudG91Y2hlcyYmYS50b3VjaGVzLmxlbmd0aD9hLnRvdWNoZXNbMF06YS5jaGFuZ2VkVG91Y2hlcyYmYS5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg/YS5jaGFuZ2VkVG91Y2hlc1swXTphLGEucGFnZVg/KGMueD1hLnBhZ2VYLGMueT1hLnBhZ2VZKTooYy54PWEuY2xpZW50WCxjLnk9YS5jbGllbnRZKSxjfSxlLnByb3RvdHlwZS5pc051bWVyaWM9ZnVuY3Rpb24oYSl7cmV0dXJuIWlzTmFOKHBhcnNlRmxvYXQoYSkpfSxlLnByb3RvdHlwZS5kaWZmZXJlbmNlPWZ1bmN0aW9uKGEsYil7cmV0dXJue3g6YS54LWIueCx5OmEueS1iLnl9fSxhLmZuLm93bENhcm91c2VsPWZ1bmN0aW9uKGIpe3ZhciBjPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGQ9YSh0aGlzKSxmPWQuZGF0YShcIm93bC5jYXJvdXNlbFwiKTtmfHwoZj1uZXcgZSh0aGlzLFwib2JqZWN0XCI9PXR5cGVvZiBiJiZiKSxkLmRhdGEoXCJvd2wuY2Fyb3VzZWxcIixmKSxhLmVhY2goW1wibmV4dFwiLFwicHJldlwiLFwidG9cIixcImRlc3Ryb3lcIixcInJlZnJlc2hcIixcInJlcGxhY2VcIixcImFkZFwiLFwicmVtb3ZlXCJdLGZ1bmN0aW9uKGIsYyl7Zi5yZWdpc3Rlcih7dHlwZTplLlR5cGUuRXZlbnQsbmFtZTpjfSksZi4kZWxlbWVudC5vbihjK1wiLm93bC5jYXJvdXNlbC5jb3JlXCIsYS5wcm94eShmdW5jdGlvbihhKXthLm5hbWVzcGFjZSYmYS5yZWxhdGVkVGFyZ2V0IT09dGhpcyYmKHRoaXMuc3VwcHJlc3MoW2NdKSxmW2NdLmFwcGx5KHRoaXMsW10uc2xpY2UuY2FsbChhcmd1bWVudHMsMSkpLHRoaXMucmVsZWFzZShbY10pKX0sZikpfSkpLFwic3RyaW5nXCI9PXR5cGVvZiBiJiZcIl9cIiE9PWIuY2hhckF0KDApJiZmW2JdLmFwcGx5KGYsYyl9KX0sYS5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvcj1lfSh3aW5kb3cuWmVwdG98fHdpbmRvdy5qUXVlcnksd2luZG93LGRvY3VtZW50KSxmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1mdW5jdGlvbihiKXt0aGlzLl9jb3JlPWIsdGhpcy5faW50ZXJ2YWw9bnVsbCx0aGlzLl92aXNpYmxlPW51bGwsdGhpcy5faGFuZGxlcnM9e1wiaW5pdGlhbGl6ZWQub3dsLmNhcm91c2VsXCI6YS5wcm94eShmdW5jdGlvbihhKXthLm5hbWVzcGFjZSYmdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvUmVmcmVzaCYmdGhpcy53YXRjaCgpfSx0aGlzKX0sdGhpcy5fY29yZS5vcHRpb25zPWEuZXh0ZW5kKHt9LGUuRGVmYXVsdHMsdGhpcy5fY29yZS5vcHRpb25zKSx0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKX07ZS5EZWZhdWx0cz17YXV0b1JlZnJlc2g6ITAsYXV0b1JlZnJlc2hJbnRlcnZhbDo1MDB9LGUucHJvdG90eXBlLndhdGNoPWZ1bmN0aW9uKCl7dGhpcy5faW50ZXJ2YWx8fCh0aGlzLl92aXNpYmxlPXRoaXMuX2NvcmUuJGVsZW1lbnQuaXMoXCI6dmlzaWJsZVwiKSx0aGlzLl9pbnRlcnZhbD1iLnNldEludGVydmFsKGEucHJveHkodGhpcy5yZWZyZXNoLHRoaXMpLHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b1JlZnJlc2hJbnRlcnZhbCkpfSxlLnByb3RvdHlwZS5yZWZyZXNoPWZ1bmN0aW9uKCl7dGhpcy5fY29yZS4kZWxlbWVudC5pcyhcIjp2aXNpYmxlXCIpIT09dGhpcy5fdmlzaWJsZSYmKHRoaXMuX3Zpc2libGU9IXRoaXMuX3Zpc2libGUsdGhpcy5fY29yZS4kZWxlbWVudC50b2dnbGVDbGFzcyhcIm93bC1oaWRkZW5cIiwhdGhpcy5fdmlzaWJsZSksdGhpcy5fdmlzaWJsZSYmdGhpcy5fY29yZS5pbnZhbGlkYXRlKFwid2lkdGhcIikmJnRoaXMuX2NvcmUucmVmcmVzaCgpKX0sZS5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3ZhciBhLGM7Yi5jbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKTtmb3IoYSBpbiB0aGlzLl9oYW5kbGVycyl0aGlzLl9jb3JlLiRlbGVtZW50Lm9mZihhLHRoaXMuX2hhbmRsZXJzW2FdKTtmb3IoYyBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSlcImZ1bmN0aW9uXCIhPXR5cGVvZiB0aGlzW2NdJiYodGhpc1tjXT1udWxsKX0sYS5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLkF1dG9SZWZyZXNoPWV9KHdpbmRvdy5aZXB0b3x8d2luZG93LmpRdWVyeSx3aW5kb3csZG9jdW1lbnQpLGZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWZ1bmN0aW9uKGIpe3RoaXMuX2NvcmU9Yix0aGlzLl9sb2FkZWQ9W10sdGhpcy5faGFuZGxlcnM9e1wiaW5pdGlhbGl6ZWQub3dsLmNhcm91c2VsIGNoYW5nZS5vd2wuY2Fyb3VzZWwgcmVzaXplZC5vd2wuY2Fyb3VzZWxcIjphLnByb3h5KGZ1bmN0aW9uKGIpe2lmKGIubmFtZXNwYWNlJiZ0aGlzLl9jb3JlLnNldHRpbmdzJiZ0aGlzLl9jb3JlLnNldHRpbmdzLmxhenlMb2FkJiYoYi5wcm9wZXJ0eSYmXCJwb3NpdGlvblwiPT1iLnByb3BlcnR5Lm5hbWV8fFwiaW5pdGlhbGl6ZWRcIj09Yi50eXBlKSlmb3IodmFyIGM9dGhpcy5fY29yZS5zZXR0aW5ncyxlPWMuY2VudGVyJiZNYXRoLmNlaWwoYy5pdGVtcy8yKXx8Yy5pdGVtcyxmPWMuY2VudGVyJiZlKi0xfHwwLGc9KGIucHJvcGVydHkmJmIucHJvcGVydHkudmFsdWUhPT1kP2IucHJvcGVydHkudmFsdWU6dGhpcy5fY29yZS5jdXJyZW50KCkpK2YsaD10aGlzLl9jb3JlLmNsb25lcygpLmxlbmd0aCxpPWEucHJveHkoZnVuY3Rpb24oYSxiKXt0aGlzLmxvYWQoYil9LHRoaXMpO2YrKzxlOyl0aGlzLmxvYWQoaC8yK3RoaXMuX2NvcmUucmVsYXRpdmUoZykpLGgmJmEuZWFjaCh0aGlzLl9jb3JlLmNsb25lcyh0aGlzLl9jb3JlLnJlbGF0aXZlKGcpKSxpKSxnKyt9LHRoaXMpfSx0aGlzLl9jb3JlLm9wdGlvbnM9YS5leHRlbmQoe30sZS5EZWZhdWx0cyx0aGlzLl9jb3JlLm9wdGlvbnMpLHRoaXMuX2NvcmUuJGVsZW1lbnQub24odGhpcy5faGFuZGxlcnMpfTtlLkRlZmF1bHRzPXtsYXp5TG9hZDohMX0sZS5wcm90b3R5cGUubG9hZD1mdW5jdGlvbihjKXt2YXIgZD10aGlzLl9jb3JlLiRzdGFnZS5jaGlsZHJlbigpLmVxKGMpLGU9ZCYmZC5maW5kKFwiLm93bC1sYXp5XCIpOyFlfHxhLmluQXJyYXkoZC5nZXQoMCksdGhpcy5fbG9hZGVkKT4tMXx8KGUuZWFjaChhLnByb3h5KGZ1bmN0aW9uKGMsZCl7dmFyIGUsZj1hKGQpLGc9Yi5kZXZpY2VQaXhlbFJhdGlvPjEmJmYuYXR0cihcImRhdGEtc3JjLXJldGluYVwiKXx8Zi5hdHRyKFwiZGF0YS1zcmNcIik7dGhpcy5fY29yZS50cmlnZ2VyKFwibG9hZFwiLHtlbGVtZW50OmYsdXJsOmd9LFwibGF6eVwiKSxmLmlzKFwiaW1nXCIpP2Yub25lKFwibG9hZC5vd2wubGF6eVwiLGEucHJveHkoZnVuY3Rpb24oKXtmLmNzcyhcIm9wYWNpdHlcIiwxKSx0aGlzLl9jb3JlLnRyaWdnZXIoXCJsb2FkZWRcIix7ZWxlbWVudDpmLHVybDpnfSxcImxhenlcIil9LHRoaXMpKS5hdHRyKFwic3JjXCIsZyk6KGU9bmV3IEltYWdlLGUub25sb2FkPWEucHJveHkoZnVuY3Rpb24oKXtmLmNzcyh7XCJiYWNrZ3JvdW5kLWltYWdlXCI6J3VybChcIicrZysnXCIpJyxvcGFjaXR5OlwiMVwifSksdGhpcy5fY29yZS50cmlnZ2VyKFwibG9hZGVkXCIse2VsZW1lbnQ6Zix1cmw6Z30sXCJsYXp5XCIpfSx0aGlzKSxlLnNyYz1nKX0sdGhpcykpLHRoaXMuX2xvYWRlZC5wdXNoKGQuZ2V0KDApKSl9LGUucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt2YXIgYSxiO2ZvcihhIGluIHRoaXMuaGFuZGxlcnMpdGhpcy5fY29yZS4kZWxlbWVudC5vZmYoYSx0aGlzLmhhbmRsZXJzW2FdKTtmb3IoYiBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSlcImZ1bmN0aW9uXCIhPXR5cGVvZiB0aGlzW2JdJiYodGhpc1tiXT1udWxsKX0sYS5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLkxhenk9ZX0od2luZG93LlplcHRvfHx3aW5kb3cualF1ZXJ5LHdpbmRvdyxkb2N1bWVudCksZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9ZnVuY3Rpb24oYil7dGhpcy5fY29yZT1iLHRoaXMuX2hhbmRsZXJzPXtcImluaXRpYWxpemVkLm93bC5jYXJvdXNlbCByZWZyZXNoZWQub3dsLmNhcm91c2VsXCI6YS5wcm94eShmdW5jdGlvbihhKXthLm5hbWVzcGFjZSYmdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvSGVpZ2h0JiZ0aGlzLnVwZGF0ZSgpfSx0aGlzKSxcImNoYW5nZWQub3dsLmNhcm91c2VsXCI6YS5wcm94eShmdW5jdGlvbihhKXthLm5hbWVzcGFjZSYmdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvSGVpZ2h0JiZcInBvc2l0aW9uXCI9PWEucHJvcGVydHkubmFtZSYmdGhpcy51cGRhdGUoKX0sdGhpcyksXCJsb2FkZWQub3dsLmxhenlcIjphLnByb3h5KGZ1bmN0aW9uKGEpe2EubmFtZXNwYWNlJiZ0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9IZWlnaHQmJmEuZWxlbWVudC5jbG9zZXN0KFwiLlwiK3RoaXMuX2NvcmUuc2V0dGluZ3MuaXRlbUNsYXNzKS5pbmRleCgpPT09dGhpcy5fY29yZS5jdXJyZW50KCkmJnRoaXMudXBkYXRlKCl9LHRoaXMpfSx0aGlzLl9jb3JlLm9wdGlvbnM9YS5leHRlbmQoe30sZS5EZWZhdWx0cyx0aGlzLl9jb3JlLm9wdGlvbnMpLHRoaXMuX2NvcmUuJGVsZW1lbnQub24odGhpcy5faGFuZGxlcnMpfTtlLkRlZmF1bHRzPXthdXRvSGVpZ2h0OiExLGF1dG9IZWlnaHRDbGFzczpcIm93bC1oZWlnaHRcIn0sZS5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcy5fY29yZS5fY3VycmVudCxjPWIrdGhpcy5fY29yZS5zZXR0aW5ncy5pdGVtcyxkPXRoaXMuX2NvcmUuJHN0YWdlLmNoaWxkcmVuKCkudG9BcnJheSgpLnNsaWNlKGIsYyksZT1bXSxmPTA7YS5lYWNoKGQsZnVuY3Rpb24oYixjKXtlLnB1c2goYShjKS5oZWlnaHQoKSl9KSxmPU1hdGgubWF4LmFwcGx5KG51bGwsZSksdGhpcy5fY29yZS4kc3RhZ2UucGFyZW50KCkuaGVpZ2h0KGYpLmFkZENsYXNzKHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b0hlaWdodENsYXNzKX0sZS5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3ZhciBhLGI7Zm9yKGEgaW4gdGhpcy5faGFuZGxlcnMpdGhpcy5fY29yZS4kZWxlbWVudC5vZmYoYSx0aGlzLl9oYW5kbGVyc1thXSk7Zm9yKGIgaW4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpXCJmdW5jdGlvblwiIT10eXBlb2YgdGhpc1tiXSYmKHRoaXNbYl09bnVsbCl9LGEuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IuUGx1Z2lucy5BdXRvSGVpZ2h0PWV9KHdpbmRvdy5aZXB0b3x8d2luZG93LmpRdWVyeSx3aW5kb3csZG9jdW1lbnQpLGZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWZ1bmN0aW9uKGIpe3RoaXMuX2NvcmU9Yix0aGlzLl92aWRlb3M9e30sdGhpcy5fcGxheWluZz1udWxsLHRoaXMuX2hhbmRsZXJzPXtcImluaXRpYWxpemVkLm93bC5jYXJvdXNlbFwiOmEucHJveHkoZnVuY3Rpb24oYSl7YS5uYW1lc3BhY2UmJnRoaXMuX2NvcmUucmVnaXN0ZXIoe3R5cGU6XCJzdGF0ZVwiLG5hbWU6XCJwbGF5aW5nXCIsdGFnczpbXCJpbnRlcmFjdGluZ1wiXX0pfSx0aGlzKSxcInJlc2l6ZS5vd2wuY2Fyb3VzZWxcIjphLnByb3h5KGZ1bmN0aW9uKGEpe2EubmFtZXNwYWNlJiZ0aGlzLl9jb3JlLnNldHRpbmdzLnZpZGVvJiZ0aGlzLmlzSW5GdWxsU2NyZWVuKCkmJmEucHJldmVudERlZmF1bHQoKX0sdGhpcyksXCJyZWZyZXNoZWQub3dsLmNhcm91c2VsXCI6YS5wcm94eShmdW5jdGlvbihhKXthLm5hbWVzcGFjZSYmdGhpcy5fY29yZS5pcyhcInJlc2l6aW5nXCIpJiZ0aGlzLl9jb3JlLiRzdGFnZS5maW5kKFwiLmNsb25lZCAub3dsLXZpZGVvLWZyYW1lXCIpLnJlbW92ZSgpfSx0aGlzKSxcImNoYW5nZWQub3dsLmNhcm91c2VsXCI6YS5wcm94eShmdW5jdGlvbihhKXthLm5hbWVzcGFjZSYmXCJwb3NpdGlvblwiPT09YS5wcm9wZXJ0eS5uYW1lJiZ0aGlzLl9wbGF5aW5nJiZ0aGlzLnN0b3AoKX0sdGhpcyksXCJwcmVwYXJlZC5vd2wuY2Fyb3VzZWxcIjphLnByb3h5KGZ1bmN0aW9uKGIpe2lmKGIubmFtZXNwYWNlKXt2YXIgYz1hKGIuY29udGVudCkuZmluZChcIi5vd2wtdmlkZW9cIik7Yy5sZW5ndGgmJihjLmNzcyhcImRpc3BsYXlcIixcIm5vbmVcIiksdGhpcy5mZXRjaChjLGEoYi5jb250ZW50KSkpfX0sdGhpcyl9LHRoaXMuX2NvcmUub3B0aW9ucz1hLmV4dGVuZCh7fSxlLkRlZmF1bHRzLHRoaXMuX2NvcmUub3B0aW9ucyksdGhpcy5fY29yZS4kZWxlbWVudC5vbih0aGlzLl9oYW5kbGVycyksdGhpcy5fY29yZS4kZWxlbWVudC5vbihcImNsaWNrLm93bC52aWRlb1wiLFwiLm93bC12aWRlby1wbGF5LWljb25cIixhLnByb3h5KGZ1bmN0aW9uKGEpe3RoaXMucGxheShhKX0sdGhpcykpfTtlLkRlZmF1bHRzPXt2aWRlbzohMSx2aWRlb0hlaWdodDohMSx2aWRlb1dpZHRoOiExfSxlLnByb3RvdHlwZS5mZXRjaD1mdW5jdGlvbihhLGIpe3ZhciBjPWZ1bmN0aW9uKCl7cmV0dXJuIGEuYXR0cihcImRhdGEtdmltZW8taWRcIik/XCJ2aW1lb1wiOmEuYXR0cihcImRhdGEtdnphYXItaWRcIik/XCJ2emFhclwiOlwieW91dHViZVwifSgpLGQ9YS5hdHRyKFwiZGF0YS12aW1lby1pZFwiKXx8YS5hdHRyKFwiZGF0YS15b3V0dWJlLWlkXCIpfHxhLmF0dHIoXCJkYXRhLXZ6YWFyLWlkXCIpLGU9YS5hdHRyKFwiZGF0YS13aWR0aFwiKXx8dGhpcy5fY29yZS5zZXR0aW5ncy52aWRlb1dpZHRoLGY9YS5hdHRyKFwiZGF0YS1oZWlnaHRcIil8fHRoaXMuX2NvcmUuc2V0dGluZ3MudmlkZW9IZWlnaHQsZz1hLmF0dHIoXCJocmVmXCIpO2lmKCFnKXRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmlkZW8gVVJMLlwiKTtpZihkPWcubWF0Y2goLyhodHRwOnxodHRwczp8KVxcL1xcLyhwbGF5ZXIufHd3dy58YXBwLik/KHZpbWVvXFwuY29tfHlvdXR1KGJlXFwuY29tfFxcLmJlfGJlXFwuZ29vZ2xlYXBpc1xcLmNvbSl8dnphYXJcXC5jb20pXFwvKHZpZGVvXFwvfHZpZGVvc1xcL3xlbWJlZFxcL3xjaGFubmVsc1xcLy4rXFwvfGdyb3Vwc1xcLy4rXFwvfHdhdGNoXFw/dj18dlxcLyk/KFtBLVphLXowLTkuXyUtXSopKFxcJlxcUyspPy8pLGRbM10uaW5kZXhPZihcInlvdXR1XCIpPi0xKWM9XCJ5b3V0dWJlXCI7ZWxzZSBpZihkWzNdLmluZGV4T2YoXCJ2aW1lb1wiKT4tMSljPVwidmltZW9cIjtlbHNle2lmKCEoZFszXS5pbmRleE9mKFwidnphYXJcIik+LTEpKXRocm93IG5ldyBFcnJvcihcIlZpZGVvIFVSTCBub3Qgc3VwcG9ydGVkLlwiKTtjPVwidnphYXJcIn1kPWRbNl0sdGhpcy5fdmlkZW9zW2ddPXt0eXBlOmMsaWQ6ZCx3aWR0aDplLGhlaWdodDpmfSxiLmF0dHIoXCJkYXRhLXZpZGVvXCIsZyksdGhpcy50aHVtYm5haWwoYSx0aGlzLl92aWRlb3NbZ10pfSxlLnByb3RvdHlwZS50aHVtYm5haWw9ZnVuY3Rpb24oYixjKXt2YXIgZCxlLGYsZz1jLndpZHRoJiZjLmhlaWdodD8nc3R5bGU9XCJ3aWR0aDonK2Mud2lkdGgrXCJweDtoZWlnaHQ6XCIrYy5oZWlnaHQrJ3B4O1wiJzpcIlwiLGg9Yi5maW5kKFwiaW1nXCIpLGk9XCJzcmNcIixqPVwiXCIsaz10aGlzLl9jb3JlLnNldHRpbmdzLGw9ZnVuY3Rpb24oYSl7ZT0nPGRpdiBjbGFzcz1cIm93bC12aWRlby1wbGF5LWljb25cIj48L2Rpdj4nLGQ9ay5sYXp5TG9hZD8nPGRpdiBjbGFzcz1cIm93bC12aWRlby10biAnK2orJ1wiICcraSsnPVwiJythKydcIj48L2Rpdj4nOic8ZGl2IGNsYXNzPVwib3dsLXZpZGVvLXRuXCIgc3R5bGU9XCJvcGFjaXR5OjE7YmFja2dyb3VuZC1pbWFnZTp1cmwoJythKycpXCI+PC9kaXY+JyxiLmFmdGVyKGQpLGIuYWZ0ZXIoZSl9O2lmKGIud3JhcCgnPGRpdiBjbGFzcz1cIm93bC12aWRlby13cmFwcGVyXCInK2crXCI+PC9kaXY+XCIpLHRoaXMuX2NvcmUuc2V0dGluZ3MubGF6eUxvYWQmJihpPVwiZGF0YS1zcmNcIixqPVwib3dsLWxhenlcIiksaC5sZW5ndGgpcmV0dXJuIGwoaC5hdHRyKGkpKSxoLnJlbW92ZSgpLCExO1wieW91dHViZVwiPT09Yy50eXBlPyhmPVwiLy9pbWcueW91dHViZS5jb20vdmkvXCIrYy5pZCtcIi9ocWRlZmF1bHQuanBnXCIsbChmKSk6XCJ2aW1lb1wiPT09Yy50eXBlP2EuYWpheCh7dHlwZTpcIkdFVFwiLHVybDpcIi8vdmltZW8uY29tL2FwaS92Mi92aWRlby9cIitjLmlkK1wiLmpzb25cIixqc29ucDpcImNhbGxiYWNrXCIsZGF0YVR5cGU6XCJqc29ucFwiLHN1Y2Nlc3M6ZnVuY3Rpb24oYSl7Zj1hWzBdLnRodW1ibmFpbF9sYXJnZSxsKGYpfX0pOlwidnphYXJcIj09PWMudHlwZSYmYS5hamF4KHt0eXBlOlwiR0VUXCIsdXJsOlwiLy92emFhci5jb20vYXBpL3ZpZGVvcy9cIitjLmlkK1wiLmpzb25cIixqc29ucDpcImNhbGxiYWNrXCIsZGF0YVR5cGU6XCJqc29ucFwiLHN1Y2Nlc3M6ZnVuY3Rpb24oYSl7Zj1hLmZyYW1lZ3JhYl91cmwsbChmKX19KX0sZS5wcm90b3R5cGUuc3RvcD1mdW5jdGlvbigpe3RoaXMuX2NvcmUudHJpZ2dlcihcInN0b3BcIixudWxsLFwidmlkZW9cIiksdGhpcy5fcGxheWluZy5maW5kKFwiLm93bC12aWRlby1mcmFtZVwiKS5yZW1vdmUoKSx0aGlzLl9wbGF5aW5nLnJlbW92ZUNsYXNzKFwib3dsLXZpZGVvLXBsYXlpbmdcIiksdGhpcy5fcGxheWluZz1udWxsLHRoaXMuX2NvcmUubGVhdmUoXCJwbGF5aW5nXCIpLHRoaXMuX2NvcmUudHJpZ2dlcihcInN0b3BwZWRcIixudWxsLFwidmlkZW9cIil9LGUucHJvdG90eXBlLnBsYXk9ZnVuY3Rpb24oYil7dmFyIGMsZD1hKGIudGFyZ2V0KSxlPWQuY2xvc2VzdChcIi5cIit0aGlzLl9jb3JlLnNldHRpbmdzLml0ZW1DbGFzcyksZj10aGlzLl92aWRlb3NbZS5hdHRyKFwiZGF0YS12aWRlb1wiKV0sZz1mLndpZHRofHxcIjEwMCVcIixoPWYuaGVpZ2h0fHx0aGlzLl9jb3JlLiRzdGFnZS5oZWlnaHQoKTt0aGlzLl9wbGF5aW5nfHwodGhpcy5fY29yZS5lbnRlcihcInBsYXlpbmdcIiksdGhpcy5fY29yZS50cmlnZ2VyKFwicGxheVwiLG51bGwsXCJ2aWRlb1wiKSxlPXRoaXMuX2NvcmUuaXRlbXModGhpcy5fY29yZS5yZWxhdGl2ZShlLmluZGV4KCkpKSx0aGlzLl9jb3JlLnJlc2V0KGUuaW5kZXgoKSksXCJ5b3V0dWJlXCI9PT1mLnR5cGU/Yz0nPGlmcmFtZSB3aWR0aD1cIicrZysnXCIgaGVpZ2h0PVwiJytoKydcIiBzcmM9XCIvL3d3dy55b3V0dWJlLmNvbS9lbWJlZC8nK2YuaWQrXCI/YXV0b3BsYXk9MSZyZWw9MCZ2PVwiK2YuaWQrJ1wiIGZyYW1lYm9yZGVyPVwiMFwiIGFsbG93ZnVsbHNjcmVlbj48L2lmcmFtZT4nOlwidmltZW9cIj09PWYudHlwZT9jPSc8aWZyYW1lIHNyYz1cIi8vcGxheWVyLnZpbWVvLmNvbS92aWRlby8nK2YuaWQrJz9hdXRvcGxheT0xXCIgd2lkdGg9XCInK2crJ1wiIGhlaWdodD1cIicraCsnXCIgZnJhbWVib3JkZXI9XCIwXCIgd2Via2l0YWxsb3dmdWxsc2NyZWVuIG1vemFsbG93ZnVsbHNjcmVlbiBhbGxvd2Z1bGxzY3JlZW4+PC9pZnJhbWU+JzpcInZ6YWFyXCI9PT1mLnR5cGUmJihjPSc8aWZyYW1lIGZyYW1lYm9yZGVyPVwiMFwiaGVpZ2h0PVwiJytoKydcIndpZHRoPVwiJytnKydcIiBhbGxvd2Z1bGxzY3JlZW4gbW96YWxsb3dmdWxsc2NyZWVuIHdlYmtpdEFsbG93RnVsbFNjcmVlbiBzcmM9XCIvL3ZpZXcudnphYXIuY29tLycrZi5pZCsnL3BsYXllcj9hdXRvcGxheT10cnVlXCI+PC9pZnJhbWU+JyksYSgnPGRpdiBjbGFzcz1cIm93bC12aWRlby1mcmFtZVwiPicrYytcIjwvZGl2PlwiKS5pbnNlcnRBZnRlcihlLmZpbmQoXCIub3dsLXZpZGVvXCIpKSx0aGlzLl9wbGF5aW5nPWUuYWRkQ2xhc3MoXCJvd2wtdmlkZW8tcGxheWluZ1wiKSl9LGUucHJvdG90eXBlLmlzSW5GdWxsU2NyZWVuPWZ1bmN0aW9uKCl7dmFyIGI9Yy5mdWxsc2NyZWVuRWxlbWVudHx8Yy5tb3pGdWxsU2NyZWVuRWxlbWVudHx8Yy53ZWJraXRGdWxsc2NyZWVuRWxlbWVudDtyZXR1cm4gYiYmYShiKS5wYXJlbnQoKS5oYXNDbGFzcyhcIm93bC12aWRlby1mcmFtZVwiKX0sZS5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3ZhciBhLGI7dGhpcy5fY29yZS4kZWxlbWVudC5vZmYoXCJjbGljay5vd2wudmlkZW9cIik7Zm9yKGEgaW4gdGhpcy5faGFuZGxlcnMpdGhpcy5fY29yZS4kZWxlbWVudC5vZmYoYSx0aGlzLl9oYW5kbGVyc1thXSk7Zm9yKGIgaW4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpXCJmdW5jdGlvblwiIT10eXBlb2YgdGhpc1tiXSYmKHRoaXNbYl09bnVsbCl9LGEuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IuUGx1Z2lucy5WaWRlbz1lfSh3aW5kb3cuWmVwdG98fHdpbmRvdy5qUXVlcnksd2luZG93LGRvY3VtZW50KSxmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1mdW5jdGlvbihiKXt0aGlzLmNvcmU9Yix0aGlzLmNvcmUub3B0aW9ucz1hLmV4dGVuZCh7fSxlLkRlZmF1bHRzLHRoaXMuY29yZS5vcHRpb25zKSx0aGlzLnN3YXBwaW5nPSEwLHRoaXMucHJldmlvdXM9ZCx0aGlzLm5leHQ9ZCx0aGlzLmhhbmRsZXJzPXtcImNoYW5nZS5vd2wuY2Fyb3VzZWxcIjphLnByb3h5KGZ1bmN0aW9uKGEpe2EubmFtZXNwYWNlJiZcInBvc2l0aW9uXCI9PWEucHJvcGVydHkubmFtZSYmKHRoaXMucHJldmlvdXM9dGhpcy5jb3JlLmN1cnJlbnQoKSx0aGlzLm5leHQ9YS5wcm9wZXJ0eS52YWx1ZSl9LHRoaXMpLFwiZHJhZy5vd2wuY2Fyb3VzZWwgZHJhZ2dlZC5vd2wuY2Fyb3VzZWwgdHJhbnNsYXRlZC5vd2wuY2Fyb3VzZWxcIjphLnByb3h5KGZ1bmN0aW9uKGEpe2EubmFtZXNwYWNlJiYodGhpcy5zd2FwcGluZz1cInRyYW5zbGF0ZWRcIj09YS50eXBlKX0sdGhpcyksXCJ0cmFuc2xhdGUub3dsLmNhcm91c2VsXCI6YS5wcm94eShmdW5jdGlvbihhKXthLm5hbWVzcGFjZSYmdGhpcy5zd2FwcGluZyYmKHRoaXMuY29yZS5vcHRpb25zLmFuaW1hdGVPdXR8fHRoaXMuY29yZS5vcHRpb25zLmFuaW1hdGVJbikmJnRoaXMuc3dhcCgpfSx0aGlzKX0sdGhpcy5jb3JlLiRlbGVtZW50Lm9uKHRoaXMuaGFuZGxlcnMpfTtlLkRlZmF1bHRzPXthbmltYXRlT3V0OiExLGFuaW1hdGVJbjohMX0sZS5wcm90b3R5cGUuc3dhcD1mdW5jdGlvbigpe2lmKDE9PT10aGlzLmNvcmUuc2V0dGluZ3MuaXRlbXMmJmEuc3VwcG9ydC5hbmltYXRpb24mJmEuc3VwcG9ydC50cmFuc2l0aW9uKXt0aGlzLmNvcmUuc3BlZWQoMCk7dmFyIGIsYz1hLnByb3h5KHRoaXMuY2xlYXIsdGhpcyksZD10aGlzLmNvcmUuJHN0YWdlLmNoaWxkcmVuKCkuZXEodGhpcy5wcmV2aW91cyksZT10aGlzLmNvcmUuJHN0YWdlLmNoaWxkcmVuKCkuZXEodGhpcy5uZXh0KSxmPXRoaXMuY29yZS5zZXR0aW5ncy5hbmltYXRlSW4sZz10aGlzLmNvcmUuc2V0dGluZ3MuYW5pbWF0ZU91dDt0aGlzLmNvcmUuY3VycmVudCgpIT09dGhpcy5wcmV2aW91cyYmKGcmJihiPXRoaXMuY29yZS5jb29yZGluYXRlcyh0aGlzLnByZXZpb3VzKS10aGlzLmNvcmUuY29vcmRpbmF0ZXModGhpcy5uZXh0KSxkLm9uZShhLnN1cHBvcnQuYW5pbWF0aW9uLmVuZCxjKS5jc3Moe2xlZnQ6YitcInB4XCJ9KS5hZGRDbGFzcyhcImFuaW1hdGVkIG93bC1hbmltYXRlZC1vdXRcIikuYWRkQ2xhc3MoZykpLGYmJmUub25lKGEuc3VwcG9ydC5hbmltYXRpb24uZW5kLGMpLmFkZENsYXNzKFwiYW5pbWF0ZWQgb3dsLWFuaW1hdGVkLWluXCIpLmFkZENsYXNzKGYpKX19LGUucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKGIpe2EoYi50YXJnZXQpLmNzcyh7bGVmdDpcIlwifSkucmVtb3ZlQ2xhc3MoXCJhbmltYXRlZCBvd2wtYW5pbWF0ZWQtb3V0IG93bC1hbmltYXRlZC1pblwiKS5yZW1vdmVDbGFzcyh0aGlzLmNvcmUuc2V0dGluZ3MuYW5pbWF0ZUluKS5yZW1vdmVDbGFzcyh0aGlzLmNvcmUuc2V0dGluZ3MuYW5pbWF0ZU91dCksdGhpcy5jb3JlLm9uVHJhbnNpdGlvbkVuZCgpfSxlLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dmFyIGEsYjtmb3IoYSBpbiB0aGlzLmhhbmRsZXJzKXRoaXMuY29yZS4kZWxlbWVudC5vZmYoYSx0aGlzLmhhbmRsZXJzW2FdKTtmb3IoYiBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSlcImZ1bmN0aW9uXCIhPXR5cGVvZiB0aGlzW2JdJiYodGhpc1tiXT1udWxsKX0sXG5hLmZuLm93bENhcm91c2VsLkNvbnN0cnVjdG9yLlBsdWdpbnMuQW5pbWF0ZT1lfSh3aW5kb3cuWmVwdG98fHdpbmRvdy5qUXVlcnksd2luZG93LGRvY3VtZW50KSxmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1mdW5jdGlvbihiKXt0aGlzLl9jb3JlPWIsdGhpcy5fdGltZW91dD1udWxsLHRoaXMuX3BhdXNlZD0hMSx0aGlzLl9oYW5kbGVycz17XCJjaGFuZ2VkLm93bC5jYXJvdXNlbFwiOmEucHJveHkoZnVuY3Rpb24oYSl7YS5uYW1lc3BhY2UmJlwic2V0dGluZ3NcIj09PWEucHJvcGVydHkubmFtZT90aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5P3RoaXMucGxheSgpOnRoaXMuc3RvcCgpOmEubmFtZXNwYWNlJiZcInBvc2l0aW9uXCI9PT1hLnByb3BlcnR5Lm5hbWUmJnRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXkmJnRoaXMuX3NldEF1dG9QbGF5SW50ZXJ2YWwoKX0sdGhpcyksXCJpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWxcIjphLnByb3h5KGZ1bmN0aW9uKGEpe2EubmFtZXNwYWNlJiZ0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5JiZ0aGlzLnBsYXkoKX0sdGhpcyksXCJwbGF5Lm93bC5hdXRvcGxheVwiOmEucHJveHkoZnVuY3Rpb24oYSxiLGMpe2EubmFtZXNwYWNlJiZ0aGlzLnBsYXkoYixjKX0sdGhpcyksXCJzdG9wLm93bC5hdXRvcGxheVwiOmEucHJveHkoZnVuY3Rpb24oYSl7YS5uYW1lc3BhY2UmJnRoaXMuc3RvcCgpfSx0aGlzKSxcIm1vdXNlb3Zlci5vd2wuYXV0b3BsYXlcIjphLnByb3h5KGZ1bmN0aW9uKCl7dGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheUhvdmVyUGF1c2UmJnRoaXMuX2NvcmUuaXMoXCJyb3RhdGluZ1wiKSYmdGhpcy5wYXVzZSgpfSx0aGlzKSxcIm1vdXNlbGVhdmUub3dsLmF1dG9wbGF5XCI6YS5wcm94eShmdW5jdGlvbigpe3RoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXlIb3ZlclBhdXNlJiZ0aGlzLl9jb3JlLmlzKFwicm90YXRpbmdcIikmJnRoaXMucGxheSgpfSx0aGlzKSxcInRvdWNoc3RhcnQub3dsLmNvcmVcIjphLnByb3h5KGZ1bmN0aW9uKCl7dGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheUhvdmVyUGF1c2UmJnRoaXMuX2NvcmUuaXMoXCJyb3RhdGluZ1wiKSYmdGhpcy5wYXVzZSgpfSx0aGlzKSxcInRvdWNoZW5kLm93bC5jb3JlXCI6YS5wcm94eShmdW5jdGlvbigpe3RoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXlIb3ZlclBhdXNlJiZ0aGlzLnBsYXkoKX0sdGhpcyl9LHRoaXMuX2NvcmUuJGVsZW1lbnQub24odGhpcy5faGFuZGxlcnMpLHRoaXMuX2NvcmUub3B0aW9ucz1hLmV4dGVuZCh7fSxlLkRlZmF1bHRzLHRoaXMuX2NvcmUub3B0aW9ucyl9O2UuRGVmYXVsdHM9e2F1dG9wbGF5OiExLGF1dG9wbGF5VGltZW91dDo1ZTMsYXV0b3BsYXlIb3ZlclBhdXNlOiExLGF1dG9wbGF5U3BlZWQ6ITF9LGUucHJvdG90eXBlLnBsYXk9ZnVuY3Rpb24oYSxiKXt0aGlzLl9wYXVzZWQ9ITEsdGhpcy5fY29yZS5pcyhcInJvdGF0aW5nXCIpfHwodGhpcy5fY29yZS5lbnRlcihcInJvdGF0aW5nXCIpLHRoaXMuX3NldEF1dG9QbGF5SW50ZXJ2YWwoKSl9LGUucHJvdG90eXBlLl9nZXROZXh0VGltZW91dD1mdW5jdGlvbihkLGUpe3JldHVybiB0aGlzLl90aW1lb3V0JiZiLmNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KSxiLnNldFRpbWVvdXQoYS5wcm94eShmdW5jdGlvbigpe3RoaXMuX3BhdXNlZHx8dGhpcy5fY29yZS5pcyhcImJ1c3lcIil8fHRoaXMuX2NvcmUuaXMoXCJpbnRlcmFjdGluZ1wiKXx8Yy5oaWRkZW58fHRoaXMuX2NvcmUubmV4dChlfHx0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5U3BlZWQpfSx0aGlzKSxkfHx0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5VGltZW91dCl9LGUucHJvdG90eXBlLl9zZXRBdXRvUGxheUludGVydmFsPWZ1bmN0aW9uKCl7dGhpcy5fdGltZW91dD10aGlzLl9nZXROZXh0VGltZW91dCgpfSxlLnByb3RvdHlwZS5zdG9wPWZ1bmN0aW9uKCl7dGhpcy5fY29yZS5pcyhcInJvdGF0aW5nXCIpJiYoYi5jbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCksdGhpcy5fY29yZS5sZWF2ZShcInJvdGF0aW5nXCIpKX0sZS5wcm90b3R5cGUucGF1c2U9ZnVuY3Rpb24oKXt0aGlzLl9jb3JlLmlzKFwicm90YXRpbmdcIikmJih0aGlzLl9wYXVzZWQ9ITApfSxlLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dmFyIGEsYjt0aGlzLnN0b3AoKTtmb3IoYSBpbiB0aGlzLl9oYW5kbGVycyl0aGlzLl9jb3JlLiRlbGVtZW50Lm9mZihhLHRoaXMuX2hhbmRsZXJzW2FdKTtmb3IoYiBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSlcImZ1bmN0aW9uXCIhPXR5cGVvZiB0aGlzW2JdJiYodGhpc1tiXT1udWxsKX0sYS5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLmF1dG9wbGF5PWV9KHdpbmRvdy5aZXB0b3x8d2luZG93LmpRdWVyeSx3aW5kb3csZG9jdW1lbnQpLGZ1bmN0aW9uKGEsYixjLGQpe1widXNlIHN0cmljdFwiO3ZhciBlPWZ1bmN0aW9uKGIpe3RoaXMuX2NvcmU9Yix0aGlzLl9pbml0aWFsaXplZD0hMSx0aGlzLl9wYWdlcz1bXSx0aGlzLl9jb250cm9scz17fSx0aGlzLl90ZW1wbGF0ZXM9W10sdGhpcy4kZWxlbWVudD10aGlzLl9jb3JlLiRlbGVtZW50LHRoaXMuX292ZXJyaWRlcz17bmV4dDp0aGlzLl9jb3JlLm5leHQscHJldjp0aGlzLl9jb3JlLnByZXYsdG86dGhpcy5fY29yZS50b30sdGhpcy5faGFuZGxlcnM9e1wicHJlcGFyZWQub3dsLmNhcm91c2VsXCI6YS5wcm94eShmdW5jdGlvbihiKXtiLm5hbWVzcGFjZSYmdGhpcy5fY29yZS5zZXR0aW5ncy5kb3RzRGF0YSYmdGhpcy5fdGVtcGxhdGVzLnB1c2goJzxkaXYgY2xhc3M9XCInK3RoaXMuX2NvcmUuc2V0dGluZ3MuZG90Q2xhc3MrJ1wiPicrYShiLmNvbnRlbnQpLmZpbmQoXCJbZGF0YS1kb3RdXCIpLmFkZEJhY2soXCJbZGF0YS1kb3RdXCIpLmF0dHIoXCJkYXRhLWRvdFwiKStcIjwvZGl2PlwiKX0sdGhpcyksXCJhZGRlZC5vd2wuY2Fyb3VzZWxcIjphLnByb3h5KGZ1bmN0aW9uKGEpe2EubmFtZXNwYWNlJiZ0aGlzLl9jb3JlLnNldHRpbmdzLmRvdHNEYXRhJiZ0aGlzLl90ZW1wbGF0ZXMuc3BsaWNlKGEucG9zaXRpb24sMCx0aGlzLl90ZW1wbGF0ZXMucG9wKCkpfSx0aGlzKSxcInJlbW92ZS5vd2wuY2Fyb3VzZWxcIjphLnByb3h5KGZ1bmN0aW9uKGEpe2EubmFtZXNwYWNlJiZ0aGlzLl9jb3JlLnNldHRpbmdzLmRvdHNEYXRhJiZ0aGlzLl90ZW1wbGF0ZXMuc3BsaWNlKGEucG9zaXRpb24sMSl9LHRoaXMpLFwiY2hhbmdlZC5vd2wuY2Fyb3VzZWxcIjphLnByb3h5KGZ1bmN0aW9uKGEpe2EubmFtZXNwYWNlJiZcInBvc2l0aW9uXCI9PWEucHJvcGVydHkubmFtZSYmdGhpcy5kcmF3KCl9LHRoaXMpLFwiaW5pdGlhbGl6ZWQub3dsLmNhcm91c2VsXCI6YS5wcm94eShmdW5jdGlvbihhKXthLm5hbWVzcGFjZSYmIXRoaXMuX2luaXRpYWxpemVkJiYodGhpcy5fY29yZS50cmlnZ2VyKFwiaW5pdGlhbGl6ZVwiLG51bGwsXCJuYXZpZ2F0aW9uXCIpLHRoaXMuaW5pdGlhbGl6ZSgpLHRoaXMudXBkYXRlKCksdGhpcy5kcmF3KCksdGhpcy5faW5pdGlhbGl6ZWQ9ITAsdGhpcy5fY29yZS50cmlnZ2VyKFwiaW5pdGlhbGl6ZWRcIixudWxsLFwibmF2aWdhdGlvblwiKSl9LHRoaXMpLFwicmVmcmVzaGVkLm93bC5jYXJvdXNlbFwiOmEucHJveHkoZnVuY3Rpb24oYSl7YS5uYW1lc3BhY2UmJnRoaXMuX2luaXRpYWxpemVkJiYodGhpcy5fY29yZS50cmlnZ2VyKFwicmVmcmVzaFwiLG51bGwsXCJuYXZpZ2F0aW9uXCIpLHRoaXMudXBkYXRlKCksdGhpcy5kcmF3KCksdGhpcy5fY29yZS50cmlnZ2VyKFwicmVmcmVzaGVkXCIsbnVsbCxcIm5hdmlnYXRpb25cIikpfSx0aGlzKX0sdGhpcy5fY29yZS5vcHRpb25zPWEuZXh0ZW5kKHt9LGUuRGVmYXVsdHMsdGhpcy5fY29yZS5vcHRpb25zKSx0aGlzLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKX07ZS5EZWZhdWx0cz17bmF2OiExLG5hdlRleHQ6W1wicHJldlwiLFwibmV4dFwiXSxuYXZTcGVlZDohMSxuYXZFbGVtZW50OlwiZGl2XCIsbmF2Q29udGFpbmVyOiExLG5hdkNvbnRhaW5lckNsYXNzOlwib3dsLW5hdlwiLG5hdkNsYXNzOltcIm93bC1wcmV2XCIsXCJvd2wtbmV4dFwiXSxzbGlkZUJ5OjEsZG90Q2xhc3M6XCJvd2wtZG90XCIsZG90c0NsYXNzOlwib3dsLWRvdHNcIixkb3RzOiEwLGRvdHNFYWNoOiExLGRvdHNEYXRhOiExLGRvdHNTcGVlZDohMSxkb3RzQ29udGFpbmVyOiExfSxlLnByb3RvdHlwZS5pbml0aWFsaXplPWZ1bmN0aW9uKCl7dmFyIGIsYz10aGlzLl9jb3JlLnNldHRpbmdzO3RoaXMuX2NvbnRyb2xzLiRyZWxhdGl2ZT0oYy5uYXZDb250YWluZXI/YShjLm5hdkNvbnRhaW5lcik6YShcIjxkaXY+XCIpLmFkZENsYXNzKGMubmF2Q29udGFpbmVyQ2xhc3MpLmFwcGVuZFRvKHRoaXMuJGVsZW1lbnQpKS5hZGRDbGFzcyhcImRpc2FibGVkXCIpLHRoaXMuX2NvbnRyb2xzLiRwcmV2aW91cz1hKFwiPFwiK2MubmF2RWxlbWVudCtcIj5cIikuYWRkQ2xhc3MoYy5uYXZDbGFzc1swXSkuaHRtbChjLm5hdlRleHRbMF0pLnByZXBlbmRUbyh0aGlzLl9jb250cm9scy4kcmVsYXRpdmUpLm9uKFwiY2xpY2tcIixhLnByb3h5KGZ1bmN0aW9uKGEpe3RoaXMucHJldihjLm5hdlNwZWVkKX0sdGhpcykpLHRoaXMuX2NvbnRyb2xzLiRuZXh0PWEoXCI8XCIrYy5uYXZFbGVtZW50K1wiPlwiKS5hZGRDbGFzcyhjLm5hdkNsYXNzWzFdKS5odG1sKGMubmF2VGV4dFsxXSkuYXBwZW5kVG8odGhpcy5fY29udHJvbHMuJHJlbGF0aXZlKS5vbihcImNsaWNrXCIsYS5wcm94eShmdW5jdGlvbihhKXt0aGlzLm5leHQoYy5uYXZTcGVlZCl9LHRoaXMpKSxjLmRvdHNEYXRhfHwodGhpcy5fdGVtcGxhdGVzPVthKFwiPGRpdj5cIikuYWRkQ2xhc3MoYy5kb3RDbGFzcykuYXBwZW5kKGEoXCI8c3Bhbj5cIikpLnByb3AoXCJvdXRlckhUTUxcIildKSx0aGlzLl9jb250cm9scy4kYWJzb2x1dGU9KGMuZG90c0NvbnRhaW5lcj9hKGMuZG90c0NvbnRhaW5lcik6YShcIjxkaXY+XCIpLmFkZENsYXNzKGMuZG90c0NsYXNzKS5hcHBlbmRUbyh0aGlzLiRlbGVtZW50KSkuYWRkQ2xhc3MoXCJkaXNhYmxlZFwiKSx0aGlzLl9jb250cm9scy4kYWJzb2x1dGUub24oXCJjbGlja1wiLFwiZGl2XCIsYS5wcm94eShmdW5jdGlvbihiKXt2YXIgZD1hKGIudGFyZ2V0KS5wYXJlbnQoKS5pcyh0aGlzLl9jb250cm9scy4kYWJzb2x1dGUpP2EoYi50YXJnZXQpLmluZGV4KCk6YShiLnRhcmdldCkucGFyZW50KCkuaW5kZXgoKTtiLnByZXZlbnREZWZhdWx0KCksdGhpcy50byhkLGMuZG90c1NwZWVkKX0sdGhpcykpO2ZvcihiIGluIHRoaXMuX292ZXJyaWRlcyl0aGlzLl9jb3JlW2JdPWEucHJveHkodGhpc1tiXSx0aGlzKX0sZS5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3ZhciBhLGIsYyxkO2ZvcihhIGluIHRoaXMuX2hhbmRsZXJzKXRoaXMuJGVsZW1lbnQub2ZmKGEsdGhpcy5faGFuZGxlcnNbYV0pO2ZvcihiIGluIHRoaXMuX2NvbnRyb2xzKXRoaXMuX2NvbnRyb2xzW2JdLnJlbW92ZSgpO2ZvcihkIGluIHRoaXMub3ZlcmlkZXMpdGhpcy5fY29yZVtkXT10aGlzLl9vdmVycmlkZXNbZF07Zm9yKGMgaW4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpXCJmdW5jdGlvblwiIT10eXBlb2YgdGhpc1tjXSYmKHRoaXNbY109bnVsbCl9LGUucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbigpe3ZhciBhLGIsYyxkPXRoaXMuX2NvcmUuY2xvbmVzKCkubGVuZ3RoLzIsZT1kK3RoaXMuX2NvcmUuaXRlbXMoKS5sZW5ndGgsZj10aGlzLl9jb3JlLm1heGltdW0oITApLGc9dGhpcy5fY29yZS5zZXR0aW5ncyxoPWcuY2VudGVyfHxnLmF1dG9XaWR0aHx8Zy5kb3RzRGF0YT8xOmcuZG90c0VhY2h8fGcuaXRlbXM7aWYoXCJwYWdlXCIhPT1nLnNsaWRlQnkmJihnLnNsaWRlQnk9TWF0aC5taW4oZy5zbGlkZUJ5LGcuaXRlbXMpKSxnLmRvdHN8fFwicGFnZVwiPT1nLnNsaWRlQnkpZm9yKHRoaXMuX3BhZ2VzPVtdLGE9ZCxiPTAsYz0wO2E8ZTthKyspe2lmKGI+PWh8fDA9PT1iKXtpZih0aGlzLl9wYWdlcy5wdXNoKHtzdGFydDpNYXRoLm1pbihmLGEtZCksZW5kOmEtZCtoLTF9KSxNYXRoLm1pbihmLGEtZCk9PT1mKWJyZWFrO2I9MCwrK2N9Yis9dGhpcy5fY29yZS5tZXJnZXJzKHRoaXMuX2NvcmUucmVsYXRpdmUoYSkpfX0sZS5wcm90b3R5cGUuZHJhdz1mdW5jdGlvbigpe3ZhciBiLGM9dGhpcy5fY29yZS5zZXR0aW5ncyxkPXRoaXMuX2NvcmUuaXRlbXMoKS5sZW5ndGg8PWMuaXRlbXMsZT10aGlzLl9jb3JlLnJlbGF0aXZlKHRoaXMuX2NvcmUuY3VycmVudCgpKSxmPWMubG9vcHx8Yy5yZXdpbmQ7dGhpcy5fY29udHJvbHMuJHJlbGF0aXZlLnRvZ2dsZUNsYXNzKFwiZGlzYWJsZWRcIiwhYy5uYXZ8fGQpLGMubmF2JiYodGhpcy5fY29udHJvbHMuJHByZXZpb3VzLnRvZ2dsZUNsYXNzKFwiZGlzYWJsZWRcIiwhZiYmZTw9dGhpcy5fY29yZS5taW5pbXVtKCEwKSksdGhpcy5fY29udHJvbHMuJG5leHQudG9nZ2xlQ2xhc3MoXCJkaXNhYmxlZFwiLCFmJiZlPj10aGlzLl9jb3JlLm1heGltdW0oITApKSksdGhpcy5fY29udHJvbHMuJGFic29sdXRlLnRvZ2dsZUNsYXNzKFwiZGlzYWJsZWRcIiwhYy5kb3RzfHxkKSxjLmRvdHMmJihiPXRoaXMuX3BhZ2VzLmxlbmd0aC10aGlzLl9jb250cm9scy4kYWJzb2x1dGUuY2hpbGRyZW4oKS5sZW5ndGgsYy5kb3RzRGF0YSYmMCE9PWI/dGhpcy5fY29udHJvbHMuJGFic29sdXRlLmh0bWwodGhpcy5fdGVtcGxhdGVzLmpvaW4oXCJcIikpOmI+MD90aGlzLl9jb250cm9scy4kYWJzb2x1dGUuYXBwZW5kKG5ldyBBcnJheShiKzEpLmpvaW4odGhpcy5fdGVtcGxhdGVzWzBdKSk6YjwwJiZ0aGlzLl9jb250cm9scy4kYWJzb2x1dGUuY2hpbGRyZW4oKS5zbGljZShiKS5yZW1vdmUoKSx0aGlzLl9jb250cm9scy4kYWJzb2x1dGUuZmluZChcIi5hY3RpdmVcIikucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIiksdGhpcy5fY29udHJvbHMuJGFic29sdXRlLmNoaWxkcmVuKCkuZXEoYS5pbkFycmF5KHRoaXMuY3VycmVudCgpLHRoaXMuX3BhZ2VzKSkuYWRkQ2xhc3MoXCJhY3RpdmVcIikpfSxlLnByb3RvdHlwZS5vblRyaWdnZXI9ZnVuY3Rpb24oYil7dmFyIGM9dGhpcy5fY29yZS5zZXR0aW5ncztiLnBhZ2U9e2luZGV4OmEuaW5BcnJheSh0aGlzLmN1cnJlbnQoKSx0aGlzLl9wYWdlcyksY291bnQ6dGhpcy5fcGFnZXMubGVuZ3RoLHNpemU6YyYmKGMuY2VudGVyfHxjLmF1dG9XaWR0aHx8Yy5kb3RzRGF0YT8xOmMuZG90c0VhY2h8fGMuaXRlbXMpfX0sZS5wcm90b3R5cGUuY3VycmVudD1mdW5jdGlvbigpe3ZhciBiPXRoaXMuX2NvcmUucmVsYXRpdmUodGhpcy5fY29yZS5jdXJyZW50KCkpO3JldHVybiBhLmdyZXAodGhpcy5fcGFnZXMsYS5wcm94eShmdW5jdGlvbihhLGMpe3JldHVybiBhLnN0YXJ0PD1iJiZhLmVuZD49Yn0sdGhpcykpLnBvcCgpfSxlLnByb3RvdHlwZS5nZXRQb3NpdGlvbj1mdW5jdGlvbihiKXt2YXIgYyxkLGU9dGhpcy5fY29yZS5zZXR0aW5ncztyZXR1cm5cInBhZ2VcIj09ZS5zbGlkZUJ5PyhjPWEuaW5BcnJheSh0aGlzLmN1cnJlbnQoKSx0aGlzLl9wYWdlcyksZD10aGlzLl9wYWdlcy5sZW5ndGgsYj8rK2M6LS1jLGM9dGhpcy5fcGFnZXNbKGMlZCtkKSVkXS5zdGFydCk6KGM9dGhpcy5fY29yZS5yZWxhdGl2ZSh0aGlzLl9jb3JlLmN1cnJlbnQoKSksZD10aGlzLl9jb3JlLml0ZW1zKCkubGVuZ3RoLGI/Yys9ZS5zbGlkZUJ5OmMtPWUuc2xpZGVCeSksY30sZS5wcm90b3R5cGUubmV4dD1mdW5jdGlvbihiKXthLnByb3h5KHRoaXMuX292ZXJyaWRlcy50byx0aGlzLl9jb3JlKSh0aGlzLmdldFBvc2l0aW9uKCEwKSxiKX0sZS5wcm90b3R5cGUucHJldj1mdW5jdGlvbihiKXthLnByb3h5KHRoaXMuX292ZXJyaWRlcy50byx0aGlzLl9jb3JlKSh0aGlzLmdldFBvc2l0aW9uKCExKSxiKX0sZS5wcm90b3R5cGUudG89ZnVuY3Rpb24oYixjLGQpe3ZhciBlOyFkJiZ0aGlzLl9wYWdlcy5sZW5ndGg/KGU9dGhpcy5fcGFnZXMubGVuZ3RoLGEucHJveHkodGhpcy5fb3ZlcnJpZGVzLnRvLHRoaXMuX2NvcmUpKHRoaXMuX3BhZ2VzWyhiJWUrZSklZV0uc3RhcnQsYykpOmEucHJveHkodGhpcy5fb3ZlcnJpZGVzLnRvLHRoaXMuX2NvcmUpKGIsYyl9LGEuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IuUGx1Z2lucy5OYXZpZ2F0aW9uPWV9KHdpbmRvdy5aZXB0b3x8d2luZG93LmpRdWVyeSx3aW5kb3csZG9jdW1lbnQpLGZ1bmN0aW9uKGEsYixjLGQpe1widXNlIHN0cmljdFwiO3ZhciBlPWZ1bmN0aW9uKGMpe3RoaXMuX2NvcmU9Yyx0aGlzLl9oYXNoZXM9e30sdGhpcy4kZWxlbWVudD10aGlzLl9jb3JlLiRlbGVtZW50LHRoaXMuX2hhbmRsZXJzPXtcImluaXRpYWxpemVkLm93bC5jYXJvdXNlbFwiOmEucHJveHkoZnVuY3Rpb24oYyl7Yy5uYW1lc3BhY2UmJlwiVVJMSGFzaFwiPT09dGhpcy5fY29yZS5zZXR0aW5ncy5zdGFydFBvc2l0aW9uJiZhKGIpLnRyaWdnZXIoXCJoYXNoY2hhbmdlLm93bC5uYXZpZ2F0aW9uXCIpfSx0aGlzKSxcInByZXBhcmVkLm93bC5jYXJvdXNlbFwiOmEucHJveHkoZnVuY3Rpb24oYil7aWYoYi5uYW1lc3BhY2Upe3ZhciBjPWEoYi5jb250ZW50KS5maW5kKFwiW2RhdGEtaGFzaF1cIikuYWRkQmFjayhcIltkYXRhLWhhc2hdXCIpLmF0dHIoXCJkYXRhLWhhc2hcIik7aWYoIWMpcmV0dXJuO3RoaXMuX2hhc2hlc1tjXT1iLmNvbnRlbnR9fSx0aGlzKSxcImNoYW5nZWQub3dsLmNhcm91c2VsXCI6YS5wcm94eShmdW5jdGlvbihjKXtpZihjLm5hbWVzcGFjZSYmXCJwb3NpdGlvblwiPT09Yy5wcm9wZXJ0eS5uYW1lKXt2YXIgZD10aGlzLl9jb3JlLml0ZW1zKHRoaXMuX2NvcmUucmVsYXRpdmUodGhpcy5fY29yZS5jdXJyZW50KCkpKSxlPWEubWFwKHRoaXMuX2hhc2hlcyxmdW5jdGlvbihhLGIpe3JldHVybiBhPT09ZD9iOm51bGx9KS5qb2luKCk7aWYoIWV8fGIubG9jYXRpb24uaGFzaC5zbGljZSgxKT09PWUpcmV0dXJuO2IubG9jYXRpb24uaGFzaD1lfX0sdGhpcyl9LHRoaXMuX2NvcmUub3B0aW9ucz1hLmV4dGVuZCh7fSxlLkRlZmF1bHRzLHRoaXMuX2NvcmUub3B0aW9ucyksdGhpcy4kZWxlbWVudC5vbih0aGlzLl9oYW5kbGVycyksYShiKS5vbihcImhhc2hjaGFuZ2Uub3dsLm5hdmlnYXRpb25cIixhLnByb3h5KGZ1bmN0aW9uKGEpe3ZhciBjPWIubG9jYXRpb24uaGFzaC5zdWJzdHJpbmcoMSksZT10aGlzLl9jb3JlLiRzdGFnZS5jaGlsZHJlbigpLGY9dGhpcy5faGFzaGVzW2NdJiZlLmluZGV4KHRoaXMuX2hhc2hlc1tjXSk7ZiE9PWQmJmYhPT10aGlzLl9jb3JlLmN1cnJlbnQoKSYmdGhpcy5fY29yZS50byh0aGlzLl9jb3JlLnJlbGF0aXZlKGYpLCExLCEwKX0sdGhpcykpfTtlLkRlZmF1bHRzPXtVUkxoYXNoTGlzdGVuZXI6ITF9LGUucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt2YXIgYyxkO2EoYikub2ZmKFwiaGFzaGNoYW5nZS5vd2wubmF2aWdhdGlvblwiKTtmb3IoYyBpbiB0aGlzLl9oYW5kbGVycyl0aGlzLl9jb3JlLiRlbGVtZW50Lm9mZihjLHRoaXMuX2hhbmRsZXJzW2NdKTtmb3IoZCBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSlcImZ1bmN0aW9uXCIhPXR5cGVvZiB0aGlzW2RdJiYodGhpc1tkXT1udWxsKX0sYS5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLkhhc2g9ZX0od2luZG93LlplcHRvfHx3aW5kb3cualF1ZXJ5LHdpbmRvdyxkb2N1bWVudCksZnVuY3Rpb24oYSxiLGMsZCl7ZnVuY3Rpb24gZShiLGMpe3ZhciBlPSExLGY9Yi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStiLnNsaWNlKDEpO3JldHVybiBhLmVhY2goKGIrXCIgXCIraC5qb2luKGYrXCIgXCIpK2YpLnNwbGl0KFwiIFwiKSxmdW5jdGlvbihhLGIpe2lmKGdbYl0hPT1kKXJldHVybiBlPSFjfHxiLCExfSksZX1mdW5jdGlvbiBmKGEpe3JldHVybiBlKGEsITApfXZhciBnPWEoXCI8c3VwcG9ydD5cIikuZ2V0KDApLnN0eWxlLGg9XCJXZWJraXQgTW96IE8gbXNcIi5zcGxpdChcIiBcIiksaT17dHJhbnNpdGlvbjp7ZW5kOntXZWJraXRUcmFuc2l0aW9uOlwid2Via2l0VHJhbnNpdGlvbkVuZFwiLE1velRyYW5zaXRpb246XCJ0cmFuc2l0aW9uZW5kXCIsT1RyYW5zaXRpb246XCJvVHJhbnNpdGlvbkVuZFwiLHRyYW5zaXRpb246XCJ0cmFuc2l0aW9uZW5kXCJ9fSxhbmltYXRpb246e2VuZDp7V2Via2l0QW5pbWF0aW9uOlwid2Via2l0QW5pbWF0aW9uRW5kXCIsTW96QW5pbWF0aW9uOlwiYW5pbWF0aW9uZW5kXCIsT0FuaW1hdGlvbjpcIm9BbmltYXRpb25FbmRcIixhbmltYXRpb246XCJhbmltYXRpb25lbmRcIn19fSxqPXtjc3N0cmFuc2Zvcm1zOmZ1bmN0aW9uKCl7cmV0dXJuISFlKFwidHJhbnNmb3JtXCIpfSxjc3N0cmFuc2Zvcm1zM2Q6ZnVuY3Rpb24oKXtyZXR1cm4hIWUoXCJwZXJzcGVjdGl2ZVwiKX0sY3NzdHJhbnNpdGlvbnM6ZnVuY3Rpb24oKXtyZXR1cm4hIWUoXCJ0cmFuc2l0aW9uXCIpfSxjc3NhbmltYXRpb25zOmZ1bmN0aW9uKCl7cmV0dXJuISFlKFwiYW5pbWF0aW9uXCIpfX07ai5jc3N0cmFuc2l0aW9ucygpJiYoYS5zdXBwb3J0LnRyYW5zaXRpb249bmV3IFN0cmluZyhmKFwidHJhbnNpdGlvblwiKSksYS5zdXBwb3J0LnRyYW5zaXRpb24uZW5kPWkudHJhbnNpdGlvbi5lbmRbYS5zdXBwb3J0LnRyYW5zaXRpb25dKSxqLmNzc2FuaW1hdGlvbnMoKSYmKGEuc3VwcG9ydC5hbmltYXRpb249bmV3IFN0cmluZyhmKFwiYW5pbWF0aW9uXCIpKSxhLnN1cHBvcnQuYW5pbWF0aW9uLmVuZD1pLmFuaW1hdGlvbi5lbmRbYS5zdXBwb3J0LmFuaW1hdGlvbl0pLGouY3NzdHJhbnNmb3JtcygpJiYoYS5zdXBwb3J0LnRyYW5zZm9ybT1uZXcgU3RyaW5nKGYoXCJ0cmFuc2Zvcm1cIikpLGEuc3VwcG9ydC50cmFuc2Zvcm0zZD1qLmNzc3RyYW5zZm9ybXMzZCgpKX0od2luZG93LlplcHRvfHx3aW5kb3cualF1ZXJ5LHdpbmRvdyxkb2N1bWVudCk7XG5cbi8qIVxuICogY2xhc3NpZSAtIGNsYXNzIGhlbHBlciBmdW5jdGlvbnNcbiAqIGZyb20gYm9uem8gaHR0cHM6Ly9naXRodWIuY29tL2RlZC9ib256b1xuICogXG4gKiBjbGFzc2llLmhhcyggZWxlbSwgJ215LWNsYXNzJyApIC0+IHRydWUvZmFsc2VcbiAqIGNsYXNzaWUuYWRkKCBlbGVtLCAnbXktbmV3LWNsYXNzJyApXG4gKiBjbGFzc2llLnJlbW92ZSggZWxlbSwgJ215LXVud2FudGVkLWNsYXNzJyApXG4gKiBjbGFzc2llLnRvZ2dsZSggZWxlbSwgJ215LWNsYXNzJyApXG4gKi9cblxuLypqc2hpbnQgYnJvd3NlcjogdHJ1ZSwgc3RyaWN0OiB0cnVlLCB1bmRlZjogdHJ1ZSAqL1xuLypnbG9iYWwgZGVmaW5lOiBmYWxzZSAqL1xuIWZ1bmN0aW9uKHMpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGUocyl7cmV0dXJuIG5ldyBSZWdFeHAoXCIoXnxcXFxccyspXCIrcytcIihcXFxccyt8JClcIil9ZnVuY3Rpb24gbihzLGUpeyhhKHMsZSk/Yzp0KShzLGUpfXZhciBhLHQsYztcImNsYXNzTGlzdFwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50PyhhPWZ1bmN0aW9uKHMsZSl7cmV0dXJuIHMuY2xhc3NMaXN0LmNvbnRhaW5zKGUpfSx0PWZ1bmN0aW9uKHMsZSl7cy5jbGFzc0xpc3QuYWRkKGUpfSxjPWZ1bmN0aW9uKHMsZSl7cy5jbGFzc0xpc3QucmVtb3ZlKGUpfSk6KGE9ZnVuY3Rpb24ocyxuKXtyZXR1cm4gZShuKS50ZXN0KHMuY2xhc3NOYW1lKX0sdD1mdW5jdGlvbihzLGUpe2EocyxlKXx8KHMuY2xhc3NOYW1lPXMuY2xhc3NOYW1lK1wiIFwiK2UpfSxjPWZ1bmN0aW9uKHMsbil7cy5jbGFzc05hbWU9cy5jbGFzc05hbWUucmVwbGFjZShlKG4pLFwiIFwiKX0pO3ZhciBpPXtoYXNDbGFzczphLGFkZENsYXNzOnQscmVtb3ZlQ2xhc3M6Yyx0b2dnbGVDbGFzczpuLGhhczphLGFkZDp0LHJlbW92ZTpjLHRvZ2dsZTpufTtcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKGkpOnMuY2xhc3NpZT1pfSh3aW5kb3cpO1xuXG4vKiEgTWFnbmlmaWMgUG9wdXAgLSB2MS4xLjAgLSAyMDE2LTAyLTIwXG4qIGh0dHA6Ly9kaW1zZW1lbm92LmNvbS9wbHVnaW5zL21hZ25pZmljLXBvcHVwL1xuKiBDb3B5cmlnaHQgKGMpIDIwMTYgRG1pdHJ5IFNlbWVub3Y7ICovXG4hZnVuY3Rpb24oYSl7XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJqcXVlcnlcIl0sYSk6YShcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9yZXF1aXJlKFwianF1ZXJ5XCIpOndpbmRvdy5qUXVlcnl8fHdpbmRvdy5aZXB0byl9KGZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlLGYsZyxoPVwiQ2xvc2VcIixpPVwiQmVmb3JlQ2xvc2VcIixqPVwiQWZ0ZXJDbG9zZVwiLGs9XCJCZWZvcmVBcHBlbmRcIixsPVwiTWFya3VwUGFyc2VcIixtPVwiT3BlblwiLG49XCJDaGFuZ2VcIixvPVwibWZwXCIscD1cIi5cIitvLHE9XCJtZnAtcmVhZHlcIixyPVwibWZwLXJlbW92aW5nXCIscz1cIm1mcC1wcmV2ZW50LWNsb3NlXCIsdD1mdW5jdGlvbigpe30sdT0hIXdpbmRvdy5qUXVlcnksdj1hKHdpbmRvdyksdz1mdW5jdGlvbihhLGMpe2IuZXYub24obythK3AsYyl9LHg9ZnVuY3Rpb24oYixjLGQsZSl7dmFyIGY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtyZXR1cm4gZi5jbGFzc05hbWU9XCJtZnAtXCIrYixkJiYoZi5pbm5lckhUTUw9ZCksZT9jJiZjLmFwcGVuZENoaWxkKGYpOihmPWEoZiksYyYmZi5hcHBlbmRUbyhjKSksZn0seT1mdW5jdGlvbihjLGQpe2IuZXYudHJpZ2dlckhhbmRsZXIobytjLGQpLGIuc3QuY2FsbGJhY2tzJiYoYz1jLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpK2Muc2xpY2UoMSksYi5zdC5jYWxsYmFja3NbY10mJmIuc3QuY2FsbGJhY2tzW2NdLmFwcGx5KGIsYS5pc0FycmF5KGQpP2Q6W2RdKSl9LHo9ZnVuY3Rpb24oYyl7cmV0dXJuIGM9PT1nJiZiLmN1cnJUZW1wbGF0ZS5jbG9zZUJ0bnx8KGIuY3VyclRlbXBsYXRlLmNsb3NlQnRuPWEoYi5zdC5jbG9zZU1hcmt1cC5yZXBsYWNlKFwiJXRpdGxlJVwiLGIuc3QudENsb3NlKSksZz1jKSxiLmN1cnJUZW1wbGF0ZS5jbG9zZUJ0bn0sQT1mdW5jdGlvbigpe2EubWFnbmlmaWNQb3B1cC5pbnN0YW5jZXx8KGI9bmV3IHQsYi5pbml0KCksYS5tYWduaWZpY1BvcHVwLmluc3RhbmNlPWIpfSxCPWZ1bmN0aW9uKCl7dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIikuc3R5bGUsYj1bXCJtc1wiLFwiT1wiLFwiTW96XCIsXCJXZWJraXRcIl07aWYodm9pZCAwIT09YS50cmFuc2l0aW9uKXJldHVybiEwO2Zvcig7Yi5sZW5ndGg7KWlmKGIucG9wKCkrXCJUcmFuc2l0aW9uXCJpbiBhKXJldHVybiEwO3JldHVybiExfTt0LnByb3RvdHlwZT17Y29uc3RydWN0b3I6dCxpbml0OmZ1bmN0aW9uKCl7dmFyIGM9bmF2aWdhdG9yLmFwcFZlcnNpb247Yi5pc0xvd0lFPWIuaXNJRTg9ZG9jdW1lbnQuYWxsJiYhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcixiLmlzQW5kcm9pZD0vYW5kcm9pZC9naS50ZXN0KGMpLGIuaXNJT1M9L2lwaG9uZXxpcGFkfGlwb2QvZ2kudGVzdChjKSxiLnN1cHBvcnRzVHJhbnNpdGlvbj1CKCksYi5wcm9iYWJseU1vYmlsZT1iLmlzQW5kcm9pZHx8Yi5pc0lPU3x8LyhPcGVyYSBNaW5pKXxLaW5kbGV8d2ViT1N8QmxhY2tCZXJyeXwoT3BlcmEgTW9iaSl8KFdpbmRvd3MgUGhvbmUpfElFTW9iaWxlL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSxkPWEoZG9jdW1lbnQpLGIucG9wdXBzQ2FjaGU9e319LG9wZW46ZnVuY3Rpb24oYyl7dmFyIGU7aWYoYy5pc09iaj09PSExKXtiLml0ZW1zPWMuaXRlbXMudG9BcnJheSgpLGIuaW5kZXg9MDt2YXIgZyxoPWMuaXRlbXM7Zm9yKGU9MDtlPGgubGVuZ3RoO2UrKylpZihnPWhbZV0sZy5wYXJzZWQmJihnPWcuZWxbMF0pLGc9PT1jLmVsWzBdKXtiLmluZGV4PWU7YnJlYWt9fWVsc2UgYi5pdGVtcz1hLmlzQXJyYXkoYy5pdGVtcyk/Yy5pdGVtczpbYy5pdGVtc10sYi5pbmRleD1jLmluZGV4fHwwO2lmKGIuaXNPcGVuKXJldHVybiB2b2lkIGIudXBkYXRlSXRlbUhUTUwoKTtiLnR5cGVzPVtdLGY9XCJcIixjLm1haW5FbCYmYy5tYWluRWwubGVuZ3RoP2IuZXY9Yy5tYWluRWwuZXEoMCk6Yi5ldj1kLGMua2V5PyhiLnBvcHVwc0NhY2hlW2Mua2V5XXx8KGIucG9wdXBzQ2FjaGVbYy5rZXldPXt9KSxiLmN1cnJUZW1wbGF0ZT1iLnBvcHVwc0NhY2hlW2Mua2V5XSk6Yi5jdXJyVGVtcGxhdGU9e30sYi5zdD1hLmV4dGVuZCghMCx7fSxhLm1hZ25pZmljUG9wdXAuZGVmYXVsdHMsYyksYi5maXhlZENvbnRlbnRQb3M9XCJhdXRvXCI9PT1iLnN0LmZpeGVkQ29udGVudFBvcz8hYi5wcm9iYWJseU1vYmlsZTpiLnN0LmZpeGVkQ29udGVudFBvcyxiLnN0Lm1vZGFsJiYoYi5zdC5jbG9zZU9uQ29udGVudENsaWNrPSExLGIuc3QuY2xvc2VPbkJnQ2xpY2s9ITEsYi5zdC5zaG93Q2xvc2VCdG49ITEsYi5zdC5lbmFibGVFc2NhcGVLZXk9ITEpLGIuYmdPdmVybGF5fHwoYi5iZ092ZXJsYXk9eChcImJnXCIpLm9uKFwiY2xpY2tcIitwLGZ1bmN0aW9uKCl7Yi5jbG9zZSgpfSksYi53cmFwPXgoXCJ3cmFwXCIpLmF0dHIoXCJ0YWJpbmRleFwiLC0xKS5vbihcImNsaWNrXCIrcCxmdW5jdGlvbihhKXtiLl9jaGVja0lmQ2xvc2UoYS50YXJnZXQpJiZiLmNsb3NlKCl9KSxiLmNvbnRhaW5lcj14KFwiY29udGFpbmVyXCIsYi53cmFwKSksYi5jb250ZW50Q29udGFpbmVyPXgoXCJjb250ZW50XCIpLGIuc3QucHJlbG9hZGVyJiYoYi5wcmVsb2FkZXI9eChcInByZWxvYWRlclwiLGIuY29udGFpbmVyLGIuc3QudExvYWRpbmcpKTt2YXIgaT1hLm1hZ25pZmljUG9wdXAubW9kdWxlcztmb3IoZT0wO2U8aS5sZW5ndGg7ZSsrKXt2YXIgaj1pW2VdO2o9ai5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStqLnNsaWNlKDEpLGJbXCJpbml0XCIral0uY2FsbChiKX15KFwiQmVmb3JlT3BlblwiKSxiLnN0LnNob3dDbG9zZUJ0biYmKGIuc3QuY2xvc2VCdG5JbnNpZGU/KHcobCxmdW5jdGlvbihhLGIsYyxkKXtjLmNsb3NlX3JlcGxhY2VXaXRoPXooZC50eXBlKX0pLGYrPVwiIG1mcC1jbG9zZS1idG4taW5cIik6Yi53cmFwLmFwcGVuZCh6KCkpKSxiLnN0LmFsaWduVG9wJiYoZis9XCIgbWZwLWFsaWduLXRvcFwiKSxiLmZpeGVkQ29udGVudFBvcz9iLndyYXAuY3NzKHtvdmVyZmxvdzpiLnN0Lm92ZXJmbG93WSxvdmVyZmxvd1g6XCJoaWRkZW5cIixvdmVyZmxvd1k6Yi5zdC5vdmVyZmxvd1l9KTpiLndyYXAuY3NzKHt0b3A6di5zY3JvbGxUb3AoKSxwb3NpdGlvbjpcImFic29sdXRlXCJ9KSwoYi5zdC5maXhlZEJnUG9zPT09ITF8fFwiYXV0b1wiPT09Yi5zdC5maXhlZEJnUG9zJiYhYi5maXhlZENvbnRlbnRQb3MpJiZiLmJnT3ZlcmxheS5jc3Moe2hlaWdodDpkLmhlaWdodCgpLHBvc2l0aW9uOlwiYWJzb2x1dGVcIn0pLGIuc3QuZW5hYmxlRXNjYXBlS2V5JiZkLm9uKFwia2V5dXBcIitwLGZ1bmN0aW9uKGEpezI3PT09YS5rZXlDb2RlJiZiLmNsb3NlKCl9KSx2Lm9uKFwicmVzaXplXCIrcCxmdW5jdGlvbigpe2IudXBkYXRlU2l6ZSgpfSksYi5zdC5jbG9zZU9uQ29udGVudENsaWNrfHwoZis9XCIgbWZwLWF1dG8tY3Vyc29yXCIpLGYmJmIud3JhcC5hZGRDbGFzcyhmKTt2YXIgaz1iLndIPXYuaGVpZ2h0KCksbj17fTtpZihiLmZpeGVkQ29udGVudFBvcyYmYi5faGFzU2Nyb2xsQmFyKGspKXt2YXIgbz1iLl9nZXRTY3JvbGxiYXJTaXplKCk7byYmKG4ubWFyZ2luUmlnaHQ9byl9Yi5maXhlZENvbnRlbnRQb3MmJihiLmlzSUU3P2EoXCJib2R5LCBodG1sXCIpLmNzcyhcIm92ZXJmbG93XCIsXCJoaWRkZW5cIik6bi5vdmVyZmxvdz1cImhpZGRlblwiKTt2YXIgcj1iLnN0Lm1haW5DbGFzcztyZXR1cm4gYi5pc0lFNyYmKHIrPVwiIG1mcC1pZTdcIiksciYmYi5fYWRkQ2xhc3NUb01GUChyKSxiLnVwZGF0ZUl0ZW1IVE1MKCkseShcIkJ1aWxkQ29udHJvbHNcIiksYShcImh0bWxcIikuY3NzKG4pLGIuYmdPdmVybGF5LmFkZChiLndyYXApLnByZXBlbmRUbyhiLnN0LnByZXBlbmRUb3x8YShkb2N1bWVudC5ib2R5KSksYi5fbGFzdEZvY3VzZWRFbD1kb2N1bWVudC5hY3RpdmVFbGVtZW50LHNldFRpbWVvdXQoZnVuY3Rpb24oKXtiLmNvbnRlbnQ/KGIuX2FkZENsYXNzVG9NRlAocSksYi5fc2V0Rm9jdXMoKSk6Yi5iZ092ZXJsYXkuYWRkQ2xhc3MocSksZC5vbihcImZvY3VzaW5cIitwLGIuX29uRm9jdXNJbil9LDE2KSxiLmlzT3Blbj0hMCxiLnVwZGF0ZVNpemUoaykseShtKSxjfSxjbG9zZTpmdW5jdGlvbigpe2IuaXNPcGVuJiYoeShpKSxiLmlzT3Blbj0hMSxiLnN0LnJlbW92YWxEZWxheSYmIWIuaXNMb3dJRSYmYi5zdXBwb3J0c1RyYW5zaXRpb24/KGIuX2FkZENsYXNzVG9NRlAociksc2V0VGltZW91dChmdW5jdGlvbigpe2IuX2Nsb3NlKCl9LGIuc3QucmVtb3ZhbERlbGF5KSk6Yi5fY2xvc2UoKSl9LF9jbG9zZTpmdW5jdGlvbigpe3koaCk7dmFyIGM9citcIiBcIitxK1wiIFwiO2lmKGIuYmdPdmVybGF5LmRldGFjaCgpLGIud3JhcC5kZXRhY2goKSxiLmNvbnRhaW5lci5lbXB0eSgpLGIuc3QubWFpbkNsYXNzJiYoYys9Yi5zdC5tYWluQ2xhc3MrXCIgXCIpLGIuX3JlbW92ZUNsYXNzRnJvbU1GUChjKSxiLmZpeGVkQ29udGVudFBvcyl7dmFyIGU9e21hcmdpblJpZ2h0OlwiXCJ9O2IuaXNJRTc/YShcImJvZHksIGh0bWxcIikuY3NzKFwib3ZlcmZsb3dcIixcIlwiKTplLm92ZXJmbG93PVwiXCIsYShcImh0bWxcIikuY3NzKGUpfWQub2ZmKFwia2V5dXBcIitwK1wiIGZvY3VzaW5cIitwKSxiLmV2Lm9mZihwKSxiLndyYXAuYXR0cihcImNsYXNzXCIsXCJtZnAtd3JhcFwiKS5yZW1vdmVBdHRyKFwic3R5bGVcIiksYi5iZ092ZXJsYXkuYXR0cihcImNsYXNzXCIsXCJtZnAtYmdcIiksYi5jb250YWluZXIuYXR0cihcImNsYXNzXCIsXCJtZnAtY29udGFpbmVyXCIpLCFiLnN0LnNob3dDbG9zZUJ0bnx8Yi5zdC5jbG9zZUJ0bkluc2lkZSYmYi5jdXJyVGVtcGxhdGVbYi5jdXJySXRlbS50eXBlXSE9PSEwfHxiLmN1cnJUZW1wbGF0ZS5jbG9zZUJ0biYmYi5jdXJyVGVtcGxhdGUuY2xvc2VCdG4uZGV0YWNoKCksYi5zdC5hdXRvRm9jdXNMYXN0JiZiLl9sYXN0Rm9jdXNlZEVsJiZhKGIuX2xhc3RGb2N1c2VkRWwpLmZvY3VzKCksYi5jdXJySXRlbT1udWxsLGIuY29udGVudD1udWxsLGIuY3VyclRlbXBsYXRlPW51bGwsYi5wcmV2SGVpZ2h0PTAseShqKX0sdXBkYXRlU2l6ZTpmdW5jdGlvbihhKXtpZihiLmlzSU9TKXt2YXIgYz1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgvd2luZG93LmlubmVyV2lkdGgsZD13aW5kb3cuaW5uZXJIZWlnaHQqYztiLndyYXAuY3NzKFwiaGVpZ2h0XCIsZCksYi53SD1kfWVsc2UgYi53SD1hfHx2LmhlaWdodCgpO2IuZml4ZWRDb250ZW50UG9zfHxiLndyYXAuY3NzKFwiaGVpZ2h0XCIsYi53SCkseShcIlJlc2l6ZVwiKX0sdXBkYXRlSXRlbUhUTUw6ZnVuY3Rpb24oKXt2YXIgYz1iLml0ZW1zW2IuaW5kZXhdO2IuY29udGVudENvbnRhaW5lci5kZXRhY2goKSxiLmNvbnRlbnQmJmIuY29udGVudC5kZXRhY2goKSxjLnBhcnNlZHx8KGM9Yi5wYXJzZUVsKGIuaW5kZXgpKTt2YXIgZD1jLnR5cGU7aWYoeShcIkJlZm9yZUNoYW5nZVwiLFtiLmN1cnJJdGVtP2IuY3Vyckl0ZW0udHlwZTpcIlwiLGRdKSxiLmN1cnJJdGVtPWMsIWIuY3VyclRlbXBsYXRlW2RdKXt2YXIgZj1iLnN0W2RdP2Iuc3RbZF0ubWFya3VwOiExO3koXCJGaXJzdE1hcmt1cFBhcnNlXCIsZiksZj9iLmN1cnJUZW1wbGF0ZVtkXT1hKGYpOmIuY3VyclRlbXBsYXRlW2RdPSEwfWUmJmUhPT1jLnR5cGUmJmIuY29udGFpbmVyLnJlbW92ZUNsYXNzKFwibWZwLVwiK2UrXCItaG9sZGVyXCIpO3ZhciBnPWJbXCJnZXRcIitkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Quc2xpY2UoMSldKGMsYi5jdXJyVGVtcGxhdGVbZF0pO2IuYXBwZW5kQ29udGVudChnLGQpLGMucHJlbG9hZGVkPSEwLHkobixjKSxlPWMudHlwZSxiLmNvbnRhaW5lci5wcmVwZW5kKGIuY29udGVudENvbnRhaW5lcikseShcIkFmdGVyQ2hhbmdlXCIpfSxhcHBlbmRDb250ZW50OmZ1bmN0aW9uKGEsYyl7Yi5jb250ZW50PWEsYT9iLnN0LnNob3dDbG9zZUJ0biYmYi5zdC5jbG9zZUJ0bkluc2lkZSYmYi5jdXJyVGVtcGxhdGVbY109PT0hMD9iLmNvbnRlbnQuZmluZChcIi5tZnAtY2xvc2VcIikubGVuZ3RofHxiLmNvbnRlbnQuYXBwZW5kKHooKSk6Yi5jb250ZW50PWE6Yi5jb250ZW50PVwiXCIseShrKSxiLmNvbnRhaW5lci5hZGRDbGFzcyhcIm1mcC1cIitjK1wiLWhvbGRlclwiKSxiLmNvbnRlbnRDb250YWluZXIuYXBwZW5kKGIuY29udGVudCl9LHBhcnNlRWw6ZnVuY3Rpb24oYyl7dmFyIGQsZT1iLml0ZW1zW2NdO2lmKGUudGFnTmFtZT9lPXtlbDphKGUpfTooZD1lLnR5cGUsZT17ZGF0YTplLHNyYzplLnNyY30pLGUuZWwpe2Zvcih2YXIgZj1iLnR5cGVzLGc9MDtnPGYubGVuZ3RoO2crKylpZihlLmVsLmhhc0NsYXNzKFwibWZwLVwiK2ZbZ10pKXtkPWZbZ107YnJlYWt9ZS5zcmM9ZS5lbC5hdHRyKFwiZGF0YS1tZnAtc3JjXCIpLGUuc3JjfHwoZS5zcmM9ZS5lbC5hdHRyKFwiaHJlZlwiKSl9cmV0dXJuIGUudHlwZT1kfHxiLnN0LnR5cGV8fFwiaW5saW5lXCIsZS5pbmRleD1jLGUucGFyc2VkPSEwLGIuaXRlbXNbY109ZSx5KFwiRWxlbWVudFBhcnNlXCIsZSksYi5pdGVtc1tjXX0sYWRkR3JvdXA6ZnVuY3Rpb24oYSxjKXt2YXIgZD1mdW5jdGlvbihkKXtkLm1mcEVsPXRoaXMsYi5fb3BlbkNsaWNrKGQsYSxjKX07Y3x8KGM9e30pO3ZhciBlPVwiY2xpY2subWFnbmlmaWNQb3B1cFwiO2MubWFpbkVsPWEsYy5pdGVtcz8oYy5pc09iaj0hMCxhLm9mZihlKS5vbihlLGQpKTooYy5pc09iaj0hMSxjLmRlbGVnYXRlP2Eub2ZmKGUpLm9uKGUsYy5kZWxlZ2F0ZSxkKTooYy5pdGVtcz1hLGEub2ZmKGUpLm9uKGUsZCkpKX0sX29wZW5DbGljazpmdW5jdGlvbihjLGQsZSl7dmFyIGY9dm9pZCAwIT09ZS5taWRDbGljaz9lLm1pZENsaWNrOmEubWFnbmlmaWNQb3B1cC5kZWZhdWx0cy5taWRDbGljaztpZihmfHwhKDI9PT1jLndoaWNofHxjLmN0cmxLZXl8fGMubWV0YUtleXx8Yy5hbHRLZXl8fGMuc2hpZnRLZXkpKXt2YXIgZz12b2lkIDAhPT1lLmRpc2FibGVPbj9lLmRpc2FibGVPbjphLm1hZ25pZmljUG9wdXAuZGVmYXVsdHMuZGlzYWJsZU9uO2lmKGcpaWYoYS5pc0Z1bmN0aW9uKGcpKXtpZighZy5jYWxsKGIpKXJldHVybiEwfWVsc2UgaWYodi53aWR0aCgpPGcpcmV0dXJuITA7Yy50eXBlJiYoYy5wcmV2ZW50RGVmYXVsdCgpLGIuaXNPcGVuJiZjLnN0b3BQcm9wYWdhdGlvbigpKSxlLmVsPWEoYy5tZnBFbCksZS5kZWxlZ2F0ZSYmKGUuaXRlbXM9ZC5maW5kKGUuZGVsZWdhdGUpKSxiLm9wZW4oZSl9fSx1cGRhdGVTdGF0dXM6ZnVuY3Rpb24oYSxkKXtpZihiLnByZWxvYWRlcil7YyE9PWEmJmIuY29udGFpbmVyLnJlbW92ZUNsYXNzKFwibWZwLXMtXCIrYyksZHx8XCJsb2FkaW5nXCIhPT1hfHwoZD1iLnN0LnRMb2FkaW5nKTt2YXIgZT17c3RhdHVzOmEsdGV4dDpkfTt5KFwiVXBkYXRlU3RhdHVzXCIsZSksYT1lLnN0YXR1cyxkPWUudGV4dCxiLnByZWxvYWRlci5odG1sKGQpLGIucHJlbG9hZGVyLmZpbmQoXCJhXCIpLm9uKFwiY2xpY2tcIixmdW5jdGlvbihhKXthLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpfSksYi5jb250YWluZXIuYWRkQ2xhc3MoXCJtZnAtcy1cIithKSxjPWF9fSxfY2hlY2tJZkNsb3NlOmZ1bmN0aW9uKGMpe2lmKCFhKGMpLmhhc0NsYXNzKHMpKXt2YXIgZD1iLnN0LmNsb3NlT25Db250ZW50Q2xpY2ssZT1iLnN0LmNsb3NlT25CZ0NsaWNrO2lmKGQmJmUpcmV0dXJuITA7aWYoIWIuY29udGVudHx8YShjKS5oYXNDbGFzcyhcIm1mcC1jbG9zZVwiKXx8Yi5wcmVsb2FkZXImJmM9PT1iLnByZWxvYWRlclswXSlyZXR1cm4hMDtpZihjPT09Yi5jb250ZW50WzBdfHxhLmNvbnRhaW5zKGIuY29udGVudFswXSxjKSl7aWYoZClyZXR1cm4hMH1lbHNlIGlmKGUmJmEuY29udGFpbnMoZG9jdW1lbnQsYykpcmV0dXJuITA7cmV0dXJuITF9fSxfYWRkQ2xhc3NUb01GUDpmdW5jdGlvbihhKXtiLmJnT3ZlcmxheS5hZGRDbGFzcyhhKSxiLndyYXAuYWRkQ2xhc3MoYSl9LF9yZW1vdmVDbGFzc0Zyb21NRlA6ZnVuY3Rpb24oYSl7dGhpcy5iZ092ZXJsYXkucmVtb3ZlQ2xhc3MoYSksYi53cmFwLnJlbW92ZUNsYXNzKGEpfSxfaGFzU2Nyb2xsQmFyOmZ1bmN0aW9uKGEpe3JldHVybihiLmlzSUU3P2QuaGVpZ2h0KCk6ZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQpPihhfHx2LmhlaWdodCgpKX0sX3NldEZvY3VzOmZ1bmN0aW9uKCl7KGIuc3QuZm9jdXM/Yi5jb250ZW50LmZpbmQoYi5zdC5mb2N1cykuZXEoMCk6Yi53cmFwKS5mb2N1cygpfSxfb25Gb2N1c0luOmZ1bmN0aW9uKGMpe3JldHVybiBjLnRhcmdldD09PWIud3JhcFswXXx8YS5jb250YWlucyhiLndyYXBbMF0sYy50YXJnZXQpP3ZvaWQgMDooYi5fc2V0Rm9jdXMoKSwhMSl9LF9wYXJzZU1hcmt1cDpmdW5jdGlvbihiLGMsZCl7dmFyIGU7ZC5kYXRhJiYoYz1hLmV4dGVuZChkLmRhdGEsYykpLHkobCxbYixjLGRdKSxhLmVhY2goYyxmdW5jdGlvbihjLGQpe2lmKHZvaWQgMD09PWR8fGQ9PT0hMSlyZXR1cm4hMDtpZihlPWMuc3BsaXQoXCJfXCIpLGUubGVuZ3RoPjEpe3ZhciBmPWIuZmluZChwK1wiLVwiK2VbMF0pO2lmKGYubGVuZ3RoPjApe3ZhciBnPWVbMV07XCJyZXBsYWNlV2l0aFwiPT09Zz9mWzBdIT09ZFswXSYmZi5yZXBsYWNlV2l0aChkKTpcImltZ1wiPT09Zz9mLmlzKFwiaW1nXCIpP2YuYXR0cihcInNyY1wiLGQpOmYucmVwbGFjZVdpdGgoYShcIjxpbWc+XCIpLmF0dHIoXCJzcmNcIixkKS5hdHRyKFwiY2xhc3NcIixmLmF0dHIoXCJjbGFzc1wiKSkpOmYuYXR0cihlWzFdLGQpfX1lbHNlIGIuZmluZChwK1wiLVwiK2MpLmh0bWwoZCl9KX0sX2dldFNjcm9sbGJhclNpemU6ZnVuY3Rpb24oKXtpZih2b2lkIDA9PT1iLnNjcm9sbGJhclNpemUpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7YS5zdHlsZS5jc3NUZXh0PVwid2lkdGg6IDk5cHg7IGhlaWdodDogOTlweDsgb3ZlcmZsb3c6IHNjcm9sbDsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IC05OTk5cHg7XCIsZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKSxiLnNjcm9sbGJhclNpemU9YS5vZmZzZXRXaWR0aC1hLmNsaWVudFdpZHRoLGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoYSl9cmV0dXJuIGIuc2Nyb2xsYmFyU2l6ZX19LGEubWFnbmlmaWNQb3B1cD17aW5zdGFuY2U6bnVsbCxwcm90bzp0LnByb3RvdHlwZSxtb2R1bGVzOltdLG9wZW46ZnVuY3Rpb24oYixjKXtyZXR1cm4gQSgpLGI9Yj9hLmV4dGVuZCghMCx7fSxiKTp7fSxiLmlzT2JqPSEwLGIuaW5kZXg9Y3x8MCx0aGlzLmluc3RhbmNlLm9wZW4oYil9LGNsb3NlOmZ1bmN0aW9uKCl7cmV0dXJuIGEubWFnbmlmaWNQb3B1cC5pbnN0YW5jZSYmYS5tYWduaWZpY1BvcHVwLmluc3RhbmNlLmNsb3NlKCl9LHJlZ2lzdGVyTW9kdWxlOmZ1bmN0aW9uKGIsYyl7Yy5vcHRpb25zJiYoYS5tYWduaWZpY1BvcHVwLmRlZmF1bHRzW2JdPWMub3B0aW9ucyksYS5leHRlbmQodGhpcy5wcm90byxjLnByb3RvKSx0aGlzLm1vZHVsZXMucHVzaChiKX0sZGVmYXVsdHM6e2Rpc2FibGVPbjowLGtleTpudWxsLG1pZENsaWNrOiExLG1haW5DbGFzczpcIlwiLHByZWxvYWRlcjohMCxmb2N1czpcIlwiLGNsb3NlT25Db250ZW50Q2xpY2s6ITEsY2xvc2VPbkJnQ2xpY2s6ITAsY2xvc2VCdG5JbnNpZGU6ITAsc2hvd0Nsb3NlQnRuOiEwLGVuYWJsZUVzY2FwZUtleTohMCxtb2RhbDohMSxhbGlnblRvcDohMSxyZW1vdmFsRGVsYXk6MCxwcmVwZW5kVG86bnVsbCxmaXhlZENvbnRlbnRQb3M6XCJhdXRvXCIsZml4ZWRCZ1BvczpcImF1dG9cIixvdmVyZmxvd1k6XCJhdXRvXCIsY2xvc2VNYXJrdXA6JzxidXR0b24gdGl0bGU9XCIldGl0bGUlXCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwibWZwLWNsb3NlXCI+JiMyMTU7PC9idXR0b24+Jyx0Q2xvc2U6XCJDbG9zZSAoRXNjKVwiLHRMb2FkaW5nOlwiTG9hZGluZy4uLlwiLGF1dG9Gb2N1c0xhc3Q6ITB9fSxhLmZuLm1hZ25pZmljUG9wdXA9ZnVuY3Rpb24oYyl7QSgpO3ZhciBkPWEodGhpcyk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGMpaWYoXCJvcGVuXCI9PT1jKXt2YXIgZSxmPXU/ZC5kYXRhKFwibWFnbmlmaWNQb3B1cFwiKTpkWzBdLm1hZ25pZmljUG9wdXAsZz1wYXJzZUludChhcmd1bWVudHNbMV0sMTApfHwwO2YuaXRlbXM/ZT1mLml0ZW1zW2ddOihlPWQsZi5kZWxlZ2F0ZSYmKGU9ZS5maW5kKGYuZGVsZWdhdGUpKSxlPWUuZXEoZykpLGIuX29wZW5DbGljayh7bWZwRWw6ZX0sZCxmKX1lbHNlIGIuaXNPcGVuJiZiW2NdLmFwcGx5KGIsQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpKTtlbHNlIGM9YS5leHRlbmQoITAse30sYyksdT9kLmRhdGEoXCJtYWduaWZpY1BvcHVwXCIsYyk6ZFswXS5tYWduaWZpY1BvcHVwPWMsYi5hZGRHcm91cChkLGMpO3JldHVybiBkfTt2YXIgQyxELEUsRj1cImlubGluZVwiLEc9ZnVuY3Rpb24oKXtFJiYoRC5hZnRlcihFLmFkZENsYXNzKEMpKS5kZXRhY2goKSxFPW51bGwpfTthLm1hZ25pZmljUG9wdXAucmVnaXN0ZXJNb2R1bGUoRix7b3B0aW9uczp7aGlkZGVuQ2xhc3M6XCJoaWRlXCIsbWFya3VwOlwiXCIsdE5vdEZvdW5kOlwiQ29udGVudCBub3QgZm91bmRcIn0scHJvdG86e2luaXRJbmxpbmU6ZnVuY3Rpb24oKXtiLnR5cGVzLnB1c2goRiksdyhoK1wiLlwiK0YsZnVuY3Rpb24oKXtHKCl9KX0sZ2V0SW5saW5lOmZ1bmN0aW9uKGMsZCl7aWYoRygpLGMuc3JjKXt2YXIgZT1iLnN0LmlubGluZSxmPWEoYy5zcmMpO2lmKGYubGVuZ3RoKXt2YXIgZz1mWzBdLnBhcmVudE5vZGU7ZyYmZy50YWdOYW1lJiYoRHx8KEM9ZS5oaWRkZW5DbGFzcyxEPXgoQyksQz1cIm1mcC1cIitDKSxFPWYuYWZ0ZXIoRCkuZGV0YWNoKCkucmVtb3ZlQ2xhc3MoQykpLGIudXBkYXRlU3RhdHVzKFwicmVhZHlcIil9ZWxzZSBiLnVwZGF0ZVN0YXR1cyhcImVycm9yXCIsZS50Tm90Rm91bmQpLGY9YShcIjxkaXY+XCIpO3JldHVybiBjLmlubGluZUVsZW1lbnQ9ZixmfXJldHVybiBiLnVwZGF0ZVN0YXR1cyhcInJlYWR5XCIpLGIuX3BhcnNlTWFya3VwKGQse30sYyksZH19fSk7dmFyIEgsST1cImFqYXhcIixKPWZ1bmN0aW9uKCl7SCYmYShkb2N1bWVudC5ib2R5KS5yZW1vdmVDbGFzcyhIKX0sSz1mdW5jdGlvbigpe0ooKSxiLnJlcSYmYi5yZXEuYWJvcnQoKX07YS5tYWduaWZpY1BvcHVwLnJlZ2lzdGVyTW9kdWxlKEkse29wdGlvbnM6e3NldHRpbmdzOm51bGwsY3Vyc29yOlwibWZwLWFqYXgtY3VyXCIsdEVycm9yOic8YSBocmVmPVwiJXVybCVcIj5UaGUgY29udGVudDwvYT4gY291bGQgbm90IGJlIGxvYWRlZC4nfSxwcm90bzp7aW5pdEFqYXg6ZnVuY3Rpb24oKXtiLnR5cGVzLnB1c2goSSksSD1iLnN0LmFqYXguY3Vyc29yLHcoaCtcIi5cIitJLEspLHcoXCJCZWZvcmVDaGFuZ2UuXCIrSSxLKX0sZ2V0QWpheDpmdW5jdGlvbihjKXtIJiZhKGRvY3VtZW50LmJvZHkpLmFkZENsYXNzKEgpLGIudXBkYXRlU3RhdHVzKFwibG9hZGluZ1wiKTt2YXIgZD1hLmV4dGVuZCh7dXJsOmMuc3JjLHN1Y2Nlc3M6ZnVuY3Rpb24oZCxlLGYpe3ZhciBnPXtkYXRhOmQseGhyOmZ9O3koXCJQYXJzZUFqYXhcIixnKSxiLmFwcGVuZENvbnRlbnQoYShnLmRhdGEpLEkpLGMuZmluaXNoZWQ9ITAsSigpLGIuX3NldEZvY3VzKCksc2V0VGltZW91dChmdW5jdGlvbigpe2Iud3JhcC5hZGRDbGFzcyhxKX0sMTYpLGIudXBkYXRlU3RhdHVzKFwicmVhZHlcIikseShcIkFqYXhDb250ZW50QWRkZWRcIil9LGVycm9yOmZ1bmN0aW9uKCl7SigpLGMuZmluaXNoZWQ9Yy5sb2FkRXJyb3I9ITAsYi51cGRhdGVTdGF0dXMoXCJlcnJvclwiLGIuc3QuYWpheC50RXJyb3IucmVwbGFjZShcIiV1cmwlXCIsYy5zcmMpKX19LGIuc3QuYWpheC5zZXR0aW5ncyk7cmV0dXJuIGIucmVxPWEuYWpheChkKSxcIlwifX19KTt2YXIgTCxNPWZ1bmN0aW9uKGMpe2lmKGMuZGF0YSYmdm9pZCAwIT09Yy5kYXRhLnRpdGxlKXJldHVybiBjLmRhdGEudGl0bGU7dmFyIGQ9Yi5zdC5pbWFnZS50aXRsZVNyYztpZihkKXtpZihhLmlzRnVuY3Rpb24oZCkpcmV0dXJuIGQuY2FsbChiLGMpO2lmKGMuZWwpcmV0dXJuIGMuZWwuYXR0cihkKXx8XCJcIn1yZXR1cm5cIlwifTthLm1hZ25pZmljUG9wdXAucmVnaXN0ZXJNb2R1bGUoXCJpbWFnZVwiLHtvcHRpb25zOnttYXJrdXA6JzxkaXYgY2xhc3M9XCJtZnAtZmlndXJlXCI+PGRpdiBjbGFzcz1cIm1mcC1jbG9zZVwiPjwvZGl2PjxmaWd1cmU+PGRpdiBjbGFzcz1cIm1mcC1pbWdcIj48L2Rpdj48ZmlnY2FwdGlvbj48ZGl2IGNsYXNzPVwibWZwLWJvdHRvbS1iYXJcIj48ZGl2IGNsYXNzPVwibWZwLXRpdGxlXCI+PC9kaXY+PGRpdiBjbGFzcz1cIm1mcC1jb3VudGVyXCI+PC9kaXY+PC9kaXY+PC9maWdjYXB0aW9uPjwvZmlndXJlPjwvZGl2PicsY3Vyc29yOlwibWZwLXpvb20tb3V0LWN1clwiLHRpdGxlU3JjOlwidGl0bGVcIix2ZXJ0aWNhbEZpdDohMCx0RXJyb3I6JzxhIGhyZWY9XCIldXJsJVwiPlRoZSBpbWFnZTwvYT4gY291bGQgbm90IGJlIGxvYWRlZC4nfSxwcm90bzp7aW5pdEltYWdlOmZ1bmN0aW9uKCl7dmFyIGM9Yi5zdC5pbWFnZSxkPVwiLmltYWdlXCI7Yi50eXBlcy5wdXNoKFwiaW1hZ2VcIiksdyhtK2QsZnVuY3Rpb24oKXtcImltYWdlXCI9PT1iLmN1cnJJdGVtLnR5cGUmJmMuY3Vyc29yJiZhKGRvY3VtZW50LmJvZHkpLmFkZENsYXNzKGMuY3Vyc29yKX0pLHcoaCtkLGZ1bmN0aW9uKCl7Yy5jdXJzb3ImJmEoZG9jdW1lbnQuYm9keSkucmVtb3ZlQ2xhc3MoYy5jdXJzb3IpLHYub2ZmKFwicmVzaXplXCIrcCl9KSx3KFwiUmVzaXplXCIrZCxiLnJlc2l6ZUltYWdlKSxiLmlzTG93SUUmJncoXCJBZnRlckNoYW5nZVwiLGIucmVzaXplSW1hZ2UpfSxyZXNpemVJbWFnZTpmdW5jdGlvbigpe3ZhciBhPWIuY3Vyckl0ZW07aWYoYSYmYS5pbWcmJmIuc3QuaW1hZ2UudmVydGljYWxGaXQpe3ZhciBjPTA7Yi5pc0xvd0lFJiYoYz1wYXJzZUludChhLmltZy5jc3MoXCJwYWRkaW5nLXRvcFwiKSwxMCkrcGFyc2VJbnQoYS5pbWcuY3NzKFwicGFkZGluZy1ib3R0b21cIiksMTApKSxhLmltZy5jc3MoXCJtYXgtaGVpZ2h0XCIsYi53SC1jKX19LF9vbkltYWdlSGFzU2l6ZTpmdW5jdGlvbihhKXthLmltZyYmKGEuaGFzU2l6ZT0hMCxMJiZjbGVhckludGVydmFsKEwpLGEuaXNDaGVja2luZ0ltZ1NpemU9ITEseShcIkltYWdlSGFzU2l6ZVwiLGEpLGEuaW1nSGlkZGVuJiYoYi5jb250ZW50JiZiLmNvbnRlbnQucmVtb3ZlQ2xhc3MoXCJtZnAtbG9hZGluZ1wiKSxhLmltZ0hpZGRlbj0hMSkpfSxmaW5kSW1hZ2VTaXplOmZ1bmN0aW9uKGEpe3ZhciBjPTAsZD1hLmltZ1swXSxlPWZ1bmN0aW9uKGYpe0wmJmNsZWFySW50ZXJ2YWwoTCksTD1zZXRJbnRlcnZhbChmdW5jdGlvbigpe3JldHVybiBkLm5hdHVyYWxXaWR0aD4wP3ZvaWQgYi5fb25JbWFnZUhhc1NpemUoYSk6KGM+MjAwJiZjbGVhckludGVydmFsKEwpLGMrKyx2b2lkKDM9PT1jP2UoMTApOjQwPT09Yz9lKDUwKToxMDA9PT1jJiZlKDUwMCkpKX0sZil9O2UoMSl9LGdldEltYWdlOmZ1bmN0aW9uKGMsZCl7dmFyIGU9MCxmPWZ1bmN0aW9uKCl7YyYmKGMuaW1nWzBdLmNvbXBsZXRlPyhjLmltZy5vZmYoXCIubWZwbG9hZGVyXCIpLGM9PT1iLmN1cnJJdGVtJiYoYi5fb25JbWFnZUhhc1NpemUoYyksYi51cGRhdGVTdGF0dXMoXCJyZWFkeVwiKSksYy5oYXNTaXplPSEwLGMubG9hZGVkPSEwLHkoXCJJbWFnZUxvYWRDb21wbGV0ZVwiKSk6KGUrKywyMDA+ZT9zZXRUaW1lb3V0KGYsMTAwKTpnKCkpKX0sZz1mdW5jdGlvbigpe2MmJihjLmltZy5vZmYoXCIubWZwbG9hZGVyXCIpLGM9PT1iLmN1cnJJdGVtJiYoYi5fb25JbWFnZUhhc1NpemUoYyksYi51cGRhdGVTdGF0dXMoXCJlcnJvclwiLGgudEVycm9yLnJlcGxhY2UoXCIldXJsJVwiLGMuc3JjKSkpLGMuaGFzU2l6ZT0hMCxjLmxvYWRlZD0hMCxjLmxvYWRFcnJvcj0hMCl9LGg9Yi5zdC5pbWFnZSxpPWQuZmluZChcIi5tZnAtaW1nXCIpO2lmKGkubGVuZ3RoKXt2YXIgaj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO2ouY2xhc3NOYW1lPVwibWZwLWltZ1wiLGMuZWwmJmMuZWwuZmluZChcImltZ1wiKS5sZW5ndGgmJihqLmFsdD1jLmVsLmZpbmQoXCJpbWdcIikuYXR0cihcImFsdFwiKSksYy5pbWc9YShqKS5vbihcImxvYWQubWZwbG9hZGVyXCIsZikub24oXCJlcnJvci5tZnBsb2FkZXJcIixnKSxqLnNyYz1jLnNyYyxpLmlzKFwiaW1nXCIpJiYoYy5pbWc9Yy5pbWcuY2xvbmUoKSksaj1jLmltZ1swXSxqLm5hdHVyYWxXaWR0aD4wP2MuaGFzU2l6ZT0hMDpqLndpZHRofHwoYy5oYXNTaXplPSExKX1yZXR1cm4gYi5fcGFyc2VNYXJrdXAoZCx7dGl0bGU6TShjKSxpbWdfcmVwbGFjZVdpdGg6Yy5pbWd9LGMpLGIucmVzaXplSW1hZ2UoKSxjLmhhc1NpemU/KEwmJmNsZWFySW50ZXJ2YWwoTCksYy5sb2FkRXJyb3I/KGQuYWRkQ2xhc3MoXCJtZnAtbG9hZGluZ1wiKSxiLnVwZGF0ZVN0YXR1cyhcImVycm9yXCIsaC50RXJyb3IucmVwbGFjZShcIiV1cmwlXCIsYy5zcmMpKSk6KGQucmVtb3ZlQ2xhc3MoXCJtZnAtbG9hZGluZ1wiKSxiLnVwZGF0ZVN0YXR1cyhcInJlYWR5XCIpKSxkKTooYi51cGRhdGVTdGF0dXMoXCJsb2FkaW5nXCIpLGMubG9hZGluZz0hMCxjLmhhc1NpemV8fChjLmltZ0hpZGRlbj0hMCxkLmFkZENsYXNzKFwibWZwLWxvYWRpbmdcIiksYi5maW5kSW1hZ2VTaXplKGMpKSxkKX19fSk7dmFyIE4sTz1mdW5jdGlvbigpe3JldHVybiB2b2lkIDA9PT1OJiYoTj12b2lkIDAhPT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKS5zdHlsZS5Nb3pUcmFuc2Zvcm0pLE59O2EubWFnbmlmaWNQb3B1cC5yZWdpc3Rlck1vZHVsZShcInpvb21cIix7b3B0aW9uczp7ZW5hYmxlZDohMSxlYXNpbmc6XCJlYXNlLWluLW91dFwiLGR1cmF0aW9uOjMwMCxvcGVuZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuaXMoXCJpbWdcIik/YTphLmZpbmQoXCJpbWdcIil9fSxwcm90bzp7aW5pdFpvb206ZnVuY3Rpb24oKXt2YXIgYSxjPWIuc3Quem9vbSxkPVwiLnpvb21cIjtpZihjLmVuYWJsZWQmJmIuc3VwcG9ydHNUcmFuc2l0aW9uKXt2YXIgZSxmLGc9Yy5kdXJhdGlvbixqPWZ1bmN0aW9uKGEpe3ZhciBiPWEuY2xvbmUoKS5yZW1vdmVBdHRyKFwic3R5bGVcIikucmVtb3ZlQXR0cihcImNsYXNzXCIpLmFkZENsYXNzKFwibWZwLWFuaW1hdGVkLWltYWdlXCIpLGQ9XCJhbGwgXCIrYy5kdXJhdGlvbi8xZTMrXCJzIFwiK2MuZWFzaW5nLGU9e3Bvc2l0aW9uOlwiZml4ZWRcIix6SW5kZXg6OTk5OSxsZWZ0OjAsdG9wOjAsXCItd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHlcIjpcImhpZGRlblwifSxmPVwidHJhbnNpdGlvblwiO3JldHVybiBlW1wiLXdlYmtpdC1cIitmXT1lW1wiLW1vei1cIitmXT1lW1wiLW8tXCIrZl09ZVtmXT1kLGIuY3NzKGUpLGJ9LGs9ZnVuY3Rpb24oKXtiLmNvbnRlbnQuY3NzKFwidmlzaWJpbGl0eVwiLFwidmlzaWJsZVwiKX07dyhcIkJ1aWxkQ29udHJvbHNcIitkLGZ1bmN0aW9uKCl7aWYoYi5fYWxsb3dab29tKCkpe2lmKGNsZWFyVGltZW91dChlKSxiLmNvbnRlbnQuY3NzKFwidmlzaWJpbGl0eVwiLFwiaGlkZGVuXCIpLGE9Yi5fZ2V0SXRlbVRvWm9vbSgpLCFhKXJldHVybiB2b2lkIGsoKTtmPWooYSksZi5jc3MoYi5fZ2V0T2Zmc2V0KCkpLGIud3JhcC5hcHBlbmQoZiksZT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Zi5jc3MoYi5fZ2V0T2Zmc2V0KCEwKSksZT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aygpLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtmLnJlbW92ZSgpLGE9Zj1udWxsLHkoXCJab29tQW5pbWF0aW9uRW5kZWRcIil9LDE2KX0sZyl9LDE2KX19KSx3KGkrZCxmdW5jdGlvbigpe2lmKGIuX2FsbG93Wm9vbSgpKXtpZihjbGVhclRpbWVvdXQoZSksYi5zdC5yZW1vdmFsRGVsYXk9ZywhYSl7aWYoYT1iLl9nZXRJdGVtVG9ab29tKCksIWEpcmV0dXJuO2Y9aihhKX1mLmNzcyhiLl9nZXRPZmZzZXQoITApKSxiLndyYXAuYXBwZW5kKGYpLGIuY29udGVudC5jc3MoXCJ2aXNpYmlsaXR5XCIsXCJoaWRkZW5cIiksc2V0VGltZW91dChmdW5jdGlvbigpe2YuY3NzKGIuX2dldE9mZnNldCgpKX0sMTYpfX0pLHcoaCtkLGZ1bmN0aW9uKCl7Yi5fYWxsb3dab29tKCkmJihrKCksZiYmZi5yZW1vdmUoKSxhPW51bGwpfSl9fSxfYWxsb3dab29tOmZ1bmN0aW9uKCl7cmV0dXJuXCJpbWFnZVwiPT09Yi5jdXJySXRlbS50eXBlfSxfZ2V0SXRlbVRvWm9vbTpmdW5jdGlvbigpe3JldHVybiBiLmN1cnJJdGVtLmhhc1NpemU/Yi5jdXJySXRlbS5pbWc6ITF9LF9nZXRPZmZzZXQ6ZnVuY3Rpb24oYyl7dmFyIGQ7ZD1jP2IuY3Vyckl0ZW0uaW1nOmIuc3Quem9vbS5vcGVuZXIoYi5jdXJySXRlbS5lbHx8Yi5jdXJySXRlbSk7dmFyIGU9ZC5vZmZzZXQoKSxmPXBhcnNlSW50KGQuY3NzKFwicGFkZGluZy10b3BcIiksMTApLGc9cGFyc2VJbnQoZC5jc3MoXCJwYWRkaW5nLWJvdHRvbVwiKSwxMCk7ZS50b3AtPWEod2luZG93KS5zY3JvbGxUb3AoKS1mO3ZhciBoPXt3aWR0aDpkLndpZHRoKCksaGVpZ2h0Oih1P2QuaW5uZXJIZWlnaHQoKTpkWzBdLm9mZnNldEhlaWdodCktZy1mfTtyZXR1cm4gTygpP2hbXCItbW96LXRyYW5zZm9ybVwiXT1oLnRyYW5zZm9ybT1cInRyYW5zbGF0ZShcIitlLmxlZnQrXCJweCxcIitlLnRvcCtcInB4KVwiOihoLmxlZnQ9ZS5sZWZ0LGgudG9wPWUudG9wKSxofX19KTt2YXIgUD1cImlmcmFtZVwiLFE9XCIvL2Fib3V0OmJsYW5rXCIsUj1mdW5jdGlvbihhKXtpZihiLmN1cnJUZW1wbGF0ZVtQXSl7dmFyIGM9Yi5jdXJyVGVtcGxhdGVbUF0uZmluZChcImlmcmFtZVwiKTtjLmxlbmd0aCYmKGF8fChjWzBdLnNyYz1RKSxiLmlzSUU4JiZjLmNzcyhcImRpc3BsYXlcIixhP1wiYmxvY2tcIjpcIm5vbmVcIikpfX07YS5tYWduaWZpY1BvcHVwLnJlZ2lzdGVyTW9kdWxlKFAse29wdGlvbnM6e21hcmt1cDonPGRpdiBjbGFzcz1cIm1mcC1pZnJhbWUtc2NhbGVyXCI+PGRpdiBjbGFzcz1cIm1mcC1jbG9zZVwiPjwvZGl2PjxpZnJhbWUgY2xhc3M9XCJtZnAtaWZyYW1lXCIgc3JjPVwiLy9hYm91dDpibGFua1wiIGZyYW1lYm9yZGVyPVwiMFwiIGFsbG93ZnVsbHNjcmVlbj48L2lmcmFtZT48L2Rpdj4nLHNyY0FjdGlvbjpcImlmcmFtZV9zcmNcIixwYXR0ZXJuczp7eW91dHViZTp7aW5kZXg6XCJ5b3V0dWJlLmNvbVwiLGlkOlwidj1cIixzcmM6XCIvL3d3dy55b3V0dWJlLmNvbS9lbWJlZC8laWQlP2F1dG9wbGF5PTFcIn0sdmltZW86e2luZGV4OlwidmltZW8uY29tL1wiLGlkOlwiL1wiLHNyYzpcIi8vcGxheWVyLnZpbWVvLmNvbS92aWRlby8laWQlP2F1dG9wbGF5PTFcIn0sZ21hcHM6e2luZGV4OlwiLy9tYXBzLmdvb2dsZS5cIixzcmM6XCIlaWQlJm91dHB1dD1lbWJlZFwifX19LHByb3RvOntpbml0SWZyYW1lOmZ1bmN0aW9uKCl7Yi50eXBlcy5wdXNoKFApLHcoXCJCZWZvcmVDaGFuZ2VcIixmdW5jdGlvbihhLGIsYyl7YiE9PWMmJihiPT09UD9SKCk6Yz09PVAmJlIoITApKX0pLHcoaCtcIi5cIitQLGZ1bmN0aW9uKCl7UigpfSl9LGdldElmcmFtZTpmdW5jdGlvbihjLGQpe3ZhciBlPWMuc3JjLGY9Yi5zdC5pZnJhbWU7YS5lYWNoKGYucGF0dGVybnMsZnVuY3Rpb24oKXtyZXR1cm4gZS5pbmRleE9mKHRoaXMuaW5kZXgpPi0xPyh0aGlzLmlkJiYoZT1cInN0cmluZ1wiPT10eXBlb2YgdGhpcy5pZD9lLnN1YnN0cihlLmxhc3RJbmRleE9mKHRoaXMuaWQpK3RoaXMuaWQubGVuZ3RoLGUubGVuZ3RoKTp0aGlzLmlkLmNhbGwodGhpcyxlKSksZT10aGlzLnNyYy5yZXBsYWNlKFwiJWlkJVwiLGUpLCExKTp2b2lkIDB9KTt2YXIgZz17fTtyZXR1cm4gZi5zcmNBY3Rpb24mJihnW2Yuc3JjQWN0aW9uXT1lKSxiLl9wYXJzZU1hcmt1cChkLGcsYyksYi51cGRhdGVTdGF0dXMoXCJyZWFkeVwiKSxkfX19KTt2YXIgUz1mdW5jdGlvbihhKXt2YXIgYz1iLml0ZW1zLmxlbmd0aDtyZXR1cm4gYT5jLTE/YS1jOjA+YT9jK2E6YX0sVD1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIGEucmVwbGFjZSgvJWN1cnIlL2dpLGIrMSkucmVwbGFjZSgvJXRvdGFsJS9naSxjKX07YS5tYWduaWZpY1BvcHVwLnJlZ2lzdGVyTW9kdWxlKFwiZ2FsbGVyeVwiLHtvcHRpb25zOntlbmFibGVkOiExLGFycm93TWFya3VwOic8YnV0dG9uIHRpdGxlPVwiJXRpdGxlJVwiIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIm1mcC1hcnJvdyBtZnAtYXJyb3ctJWRpciVcIj48L2J1dHRvbj4nLHByZWxvYWQ6WzAsMl0sbmF2aWdhdGVCeUltZ0NsaWNrOiEwLGFycm93czohMCx0UHJldjpcIlByZXZpb3VzIChMZWZ0IGFycm93IGtleSlcIix0TmV4dDpcIk5leHQgKFJpZ2h0IGFycm93IGtleSlcIix0Q291bnRlcjpcIiVjdXJyJSBvZiAldG90YWwlXCJ9LHByb3RvOntpbml0R2FsbGVyeTpmdW5jdGlvbigpe3ZhciBjPWIuc3QuZ2FsbGVyeSxlPVwiLm1mcC1nYWxsZXJ5XCI7cmV0dXJuIGIuZGlyZWN0aW9uPSEwLGMmJmMuZW5hYmxlZD8oZis9XCIgbWZwLWdhbGxlcnlcIix3KG0rZSxmdW5jdGlvbigpe2MubmF2aWdhdGVCeUltZ0NsaWNrJiZiLndyYXAub24oXCJjbGlja1wiK2UsXCIubWZwLWltZ1wiLGZ1bmN0aW9uKCl7cmV0dXJuIGIuaXRlbXMubGVuZ3RoPjE/KGIubmV4dCgpLCExKTp2b2lkIDB9KSxkLm9uKFwia2V5ZG93blwiK2UsZnVuY3Rpb24oYSl7Mzc9PT1hLmtleUNvZGU/Yi5wcmV2KCk6Mzk9PT1hLmtleUNvZGUmJmIubmV4dCgpfSl9KSx3KFwiVXBkYXRlU3RhdHVzXCIrZSxmdW5jdGlvbihhLGMpe2MudGV4dCYmKGMudGV4dD1UKGMudGV4dCxiLmN1cnJJdGVtLmluZGV4LGIuaXRlbXMubGVuZ3RoKSl9KSx3KGwrZSxmdW5jdGlvbihhLGQsZSxmKXt2YXIgZz1iLml0ZW1zLmxlbmd0aDtlLmNvdW50ZXI9Zz4xP1QoYy50Q291bnRlcixmLmluZGV4LGcpOlwiXCJ9KSx3KFwiQnVpbGRDb250cm9sc1wiK2UsZnVuY3Rpb24oKXtpZihiLml0ZW1zLmxlbmd0aD4xJiZjLmFycm93cyYmIWIuYXJyb3dMZWZ0KXt2YXIgZD1jLmFycm93TWFya3VwLGU9Yi5hcnJvd0xlZnQ9YShkLnJlcGxhY2UoLyV0aXRsZSUvZ2ksYy50UHJldikucmVwbGFjZSgvJWRpciUvZ2ksXCJsZWZ0XCIpKS5hZGRDbGFzcyhzKSxmPWIuYXJyb3dSaWdodD1hKGQucmVwbGFjZSgvJXRpdGxlJS9naSxjLnROZXh0KS5yZXBsYWNlKC8lZGlyJS9naSxcInJpZ2h0XCIpKS5hZGRDbGFzcyhzKTtlLmNsaWNrKGZ1bmN0aW9uKCl7Yi5wcmV2KCl9KSxmLmNsaWNrKGZ1bmN0aW9uKCl7Yi5uZXh0KCl9KSxiLmNvbnRhaW5lci5hcHBlbmQoZS5hZGQoZikpfX0pLHcobitlLGZ1bmN0aW9uKCl7Yi5fcHJlbG9hZFRpbWVvdXQmJmNsZWFyVGltZW91dChiLl9wcmVsb2FkVGltZW91dCksYi5fcHJlbG9hZFRpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe2IucHJlbG9hZE5lYXJieUltYWdlcygpLGIuX3ByZWxvYWRUaW1lb3V0PW51bGx9LDE2KX0pLHZvaWQgdyhoK2UsZnVuY3Rpb24oKXtkLm9mZihlKSxiLndyYXAub2ZmKFwiY2xpY2tcIitlKSxiLmFycm93UmlnaHQ9Yi5hcnJvd0xlZnQ9bnVsbH0pKTohMX0sbmV4dDpmdW5jdGlvbigpe2IuZGlyZWN0aW9uPSEwLGIuaW5kZXg9UyhiLmluZGV4KzEpLGIudXBkYXRlSXRlbUhUTUwoKX0scHJldjpmdW5jdGlvbigpe2IuZGlyZWN0aW9uPSExLGIuaW5kZXg9UyhiLmluZGV4LTEpLGIudXBkYXRlSXRlbUhUTUwoKX0sZ29UbzpmdW5jdGlvbihhKXtiLmRpcmVjdGlvbj1hPj1iLmluZGV4LGIuaW5kZXg9YSxiLnVwZGF0ZUl0ZW1IVE1MKCl9LHByZWxvYWROZWFyYnlJbWFnZXM6ZnVuY3Rpb24oKXt2YXIgYSxjPWIuc3QuZ2FsbGVyeS5wcmVsb2FkLGQ9TWF0aC5taW4oY1swXSxiLml0ZW1zLmxlbmd0aCksZT1NYXRoLm1pbihjWzFdLGIuaXRlbXMubGVuZ3RoKTtmb3IoYT0xO2E8PShiLmRpcmVjdGlvbj9lOmQpO2ErKyliLl9wcmVsb2FkSXRlbShiLmluZGV4K2EpO2ZvcihhPTE7YTw9KGIuZGlyZWN0aW9uP2Q6ZSk7YSsrKWIuX3ByZWxvYWRJdGVtKGIuaW5kZXgtYSl9LF9wcmVsb2FkSXRlbTpmdW5jdGlvbihjKXtpZihjPVMoYyksIWIuaXRlbXNbY10ucHJlbG9hZGVkKXt2YXIgZD1iLml0ZW1zW2NdO2QucGFyc2VkfHwoZD1iLnBhcnNlRWwoYykpLHkoXCJMYXp5TG9hZFwiLGQpLFwiaW1hZ2VcIj09PWQudHlwZSYmKGQuaW1nPWEoJzxpbWcgY2xhc3M9XCJtZnAtaW1nXCIgLz4nKS5vbihcImxvYWQubWZwbG9hZGVyXCIsZnVuY3Rpb24oKXtkLmhhc1NpemU9ITB9KS5vbihcImVycm9yLm1mcGxvYWRlclwiLGZ1bmN0aW9uKCl7ZC5oYXNTaXplPSEwLGQubG9hZEVycm9yPSEwLHkoXCJMYXp5TG9hZEVycm9yXCIsZCl9KS5hdHRyKFwic3JjXCIsZC5zcmMpKSxkLnByZWxvYWRlZD0hMH19fX0pO3ZhciBVPVwicmV0aW5hXCI7YS5tYWduaWZpY1BvcHVwLnJlZ2lzdGVyTW9kdWxlKFUse29wdGlvbnM6e3JlcGxhY2VTcmM6ZnVuY3Rpb24oYSl7cmV0dXJuIGEuc3JjLnJlcGxhY2UoL1xcLlxcdyskLyxmdW5jdGlvbihhKXtyZXR1cm5cIkAyeFwiK2F9KX0scmF0aW86MX0scHJvdG86e2luaXRSZXRpbmE6ZnVuY3Rpb24oKXtpZih3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbz4xKXt2YXIgYT1iLnN0LnJldGluYSxjPWEucmF0aW87Yz1pc05hTihjKT9jKCk6YyxjPjEmJih3KFwiSW1hZ2VIYXNTaXplLlwiK1UsZnVuY3Rpb24oYSxiKXtiLmltZy5jc3Moe1wibWF4LXdpZHRoXCI6Yi5pbWdbMF0ubmF0dXJhbFdpZHRoL2Msd2lkdGg6XCIxMDAlXCJ9KX0pLHcoXCJFbGVtZW50UGFyc2UuXCIrVSxmdW5jdGlvbihiLGQpe2Quc3JjPWEucmVwbGFjZVNyYyhkLGMpfSkpfX19fSksQSgpfSk7XG5cbi8qKlxuUkVTSVpFU0VOU09SLkpTXG4gKiBDb3B5cmlnaHQgTWFyYyBKLiBTY2htaWR0LiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBhdCB0aGUgdG9wLWxldmVsXG4gKiBkaXJlY3Rvcnkgb2YgdGhpcyBkaXN0cmlidXRpb24gYW5kIGF0XG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWFyY2ovY3NzLWVsZW1lbnQtcXVlcmllcy9ibG9iL21hc3Rlci9MSUNFTlNFLlxuICovXG4hZnVuY3Rpb24oKXt2YXIgZT1mdW5jdGlvbih0LGkpe2Z1bmN0aW9uIHMoKXt0aGlzLnE9W10sdGhpcy5hZGQ9ZnVuY3Rpb24oZSl7dGhpcy5xLnB1c2goZSl9O3ZhciBlLHQ7dGhpcy5jYWxsPWZ1bmN0aW9uKCl7Zm9yKGU9MCx0PXRoaXMucS5sZW5ndGg7ZTx0O2UrKyl0aGlzLnFbZV0uY2FsbCgpfX1mdW5jdGlvbiBvKGUsdCl7cmV0dXJuIGUuY3VycmVudFN0eWxlP2UuY3VycmVudFN0eWxlW3RdOndpbmRvdy5nZXRDb21wdXRlZFN0eWxlP3dpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUsbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZSh0KTplLnN0eWxlW3RdfWZ1bmN0aW9uIG4oZSx0KXtpZihlLnJlc2l6ZWRBdHRhY2hlZCl7aWYoZS5yZXNpemVkQXR0YWNoZWQpcmV0dXJuIHZvaWQgZS5yZXNpemVkQXR0YWNoZWQuYWRkKHQpfWVsc2UgZS5yZXNpemVkQXR0YWNoZWQ9bmV3IHMsZS5yZXNpemVkQXR0YWNoZWQuYWRkKHQpO2UucmVzaXplU2Vuc29yPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksZS5yZXNpemVTZW5zb3IuY2xhc3NOYW1lPVwicmVzaXplLXNlbnNvclwiO3ZhciBpPVwicG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAwOyB0b3A6IDA7IHJpZ2h0OiAwOyBib3R0b206IDA7IG92ZXJmbG93OiBoaWRkZW47IHotaW5kZXg6IC0xOyB2aXNpYmlsaXR5OiBoaWRkZW47XCIsbj1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogMDsgdG9wOiAwOyB0cmFuc2l0aW9uOiAwcztcIjtlLnJlc2l6ZVNlbnNvci5zdHlsZS5jc3NUZXh0PWksZS5yZXNpemVTZW5zb3IuaW5uZXJIVE1MPSc8ZGl2IGNsYXNzPVwicmVzaXplLXNlbnNvci1leHBhbmRcIiBzdHlsZT1cIicraSsnXCI+PGRpdiBzdHlsZT1cIicrbisnXCI+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz1cInJlc2l6ZS1zZW5zb3Itc2hyaW5rXCIgc3R5bGU9XCInK2krJ1wiPjxkaXYgc3R5bGU9XCInK24rJyB3aWR0aDogMjAwJTsgaGVpZ2h0OiAyMDAlXCI+PC9kaXY+PC9kaXY+JyxlLmFwcGVuZENoaWxkKGUucmVzaXplU2Vuc29yKSx7Zml4ZWQ6MSxhYnNvbHV0ZToxfVtvKGUsXCJwb3NpdGlvblwiKV18fChlLnN0eWxlLnBvc2l0aW9uPVwicmVsYXRpdmVcIik7dmFyIGQscixsPWUucmVzaXplU2Vuc29yLmNoaWxkTm9kZXNbMF0sYz1sLmNoaWxkTm9kZXNbMF0saD1lLnJlc2l6ZVNlbnNvci5jaGlsZE5vZGVzWzFdLGE9KGguY2hpbGROb2Rlc1swXSxmdW5jdGlvbigpe2Muc3R5bGUud2lkdGg9bC5vZmZzZXRXaWR0aCsxMCtcInB4XCIsYy5zdHlsZS5oZWlnaHQ9bC5vZmZzZXRIZWlnaHQrMTArXCJweFwiLGwuc2Nyb2xsTGVmdD1sLnNjcm9sbFdpZHRoLGwuc2Nyb2xsVG9wPWwuc2Nyb2xsSGVpZ2h0LGguc2Nyb2xsTGVmdD1oLnNjcm9sbFdpZHRoLGguc2Nyb2xsVG9wPWguc2Nyb2xsSGVpZ2h0LGQ9ZS5vZmZzZXRXaWR0aCxyPWUub2Zmc2V0SGVpZ2h0fSk7YSgpO3ZhciBmPWZ1bmN0aW9uKCl7ZS5yZXNpemVkQXR0YWNoZWQmJmUucmVzaXplZEF0dGFjaGVkLmNhbGwoKX0sdT1mdW5jdGlvbihlLHQsaSl7ZS5hdHRhY2hFdmVudD9lLmF0dGFjaEV2ZW50KFwib25cIit0LGkpOmUuYWRkRXZlbnRMaXN0ZW5lcih0LGkpfSxwPWZ1bmN0aW9uKCl7ZS5vZmZzZXRXaWR0aD09ZCYmZS5vZmZzZXRIZWlnaHQ9PXJ8fGYoKSxhKCl9O3UobCxcInNjcm9sbFwiLHApLHUoaCxcInNjcm9sbFwiLHApfXZhciBkPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSxyPVwiW29iamVjdCBBcnJheV1cIj09PWR8fFwiW29iamVjdCBOb2RlTGlzdF1cIj09PWR8fFwiW29iamVjdCBIVE1MQ29sbGVjdGlvbl1cIj09PWR8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBqUXVlcnkmJnQgaW5zdGFuY2VvZiBqUXVlcnl8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBFbGVtZW50cyYmdCBpbnN0YW5jZW9mIEVsZW1lbnRzO2lmKHIpZm9yKHZhciBsPTAsYz10Lmxlbmd0aDtsPGM7bCsrKW4odFtsXSxpKTtlbHNlIG4odCxpKTt0aGlzLmRldGFjaD1mdW5jdGlvbigpe2lmKHIpZm9yKHZhciBpPTAscz10Lmxlbmd0aDtpPHM7aSsrKWUuZGV0YWNoKHRbaV0pO2Vsc2UgZS5kZXRhY2godCl9fTtlLmRldGFjaD1mdW5jdGlvbihlKXtlLnJlc2l6ZVNlbnNvciYmKGUucmVtb3ZlQ2hpbGQoZS5yZXNpemVTZW5zb3IpLGRlbGV0ZSBlLnJlc2l6ZVNlbnNvcixkZWxldGUgZS5yZXNpemVkQXR0YWNoZWQpfSxcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9ZTp3aW5kb3cuUmVzaXplU2Vuc29yPWV9KCk7XG5cblxuLyohXG4gKiBUaGVpYSBTdGlja3kgU2lkZWJhciB2MS43LjBcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9XZUNvZGVQaXhlbHMvdGhlaWEtc3RpY2t5LXNpZGViYXJcbiAqXG4gKiBHbHVlcyB5b3VyIHdlYnNpdGUncyBzaWRlYmFycywgbWFraW5nIHRoZW0gcGVybWFuZW50bHkgdmlzaWJsZSB3aGlsZSBzY3JvbGxpbmcuXG4gKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNiBXZUNvZGVQaXhlbHMgYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbi8qIVxuICogVGhlaWEgU3RpY2t5IFNpZGViYXIgdjEuNy4wXG4gKiBodHRwczovL2dpdGh1Yi5jb20vV2VDb2RlUGl4ZWxzL3RoZWlhLXN0aWNreS1zaWRlYmFyXG4gKlxuICogR2x1ZXMgeW91ciB3ZWJzaXRlJ3Mgc2lkZWJhcnMsIG1ha2luZyB0aGVtIHBlcm1hbmVudGx5IHZpc2libGUgd2hpbGUgc2Nyb2xsaW5nLlxuICpcbiAqIENvcHlyaWdodCAyMDEzLTIwMTYgV2VDb2RlUGl4ZWxzIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cbiFmdW5jdGlvbihpKXtpLmZuLnRoZWlhU3RpY2t5U2lkZWJhcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQsZSl7cmV0dXJuITA9PT10LmluaXRpYWxpemVkfHwhKGkoXCJib2R5XCIpLndpZHRoKCk8dC5taW5XaWR0aCkmJihvKHQsZSksITApfWZ1bmN0aW9uIG8odCxlKXt0LmluaXRpYWxpemVkPSEwLDA9PT1pKFwiI3RoZWlhLXN0aWNreS1zaWRlYmFyLXN0eWxlc2hlZXQtXCIrdC5uYW1lc3BhY2UpLmxlbmd0aCYmaShcImhlYWRcIikuYXBwZW5kKGkoJzxzdHlsZSBpZD1cInRoZWlhLXN0aWNreS1zaWRlYmFyLXN0eWxlc2hlZXQtJyt0Lm5hbWVzcGFjZSsnXCI+LnRoZWlhU3RpY2t5U2lkZWJhcjphZnRlciB7Y29udGVudDogXCJcIjsgZGlzcGxheTogdGFibGU7IGNsZWFyOiBib3RoO308L3N0eWxlPicpKSxlLmVhY2goZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7bi5maXhlZFNjcm9sbFRvcD0wLG4uc2lkZWJhci5jc3Moe1wibWluLWhlaWdodFwiOlwiMXB4XCJ9KSxuLnN0aWNreVNpZGViYXIuY3NzKHtwb3NpdGlvbjpcInN0YXRpY1wiLHdpZHRoOlwiXCIsdHJhbnNmb3JtOlwibm9uZVwifSl9ZnVuY3Rpb24gbyh0KXt2YXIgZT10LmhlaWdodCgpO3JldHVybiB0LmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbigpe2U9TWF0aC5tYXgoZSxpKHRoaXMpLmhlaWdodCgpKX0pLGV9dmFyIG49e307aWYobi5zaWRlYmFyPWkodGhpcyksbi5vcHRpb25zPXR8fHt9LG4uY29udGFpbmVyPWkobi5vcHRpb25zLmNvbnRhaW5lclNlbGVjdG9yKSwwPT1uLmNvbnRhaW5lci5sZW5ndGgmJihuLmNvbnRhaW5lcj1uLnNpZGViYXIucGFyZW50KCkpLG4uc2lkZWJhci5wYXJlbnRzKFwiOm5vdCgudGhlaWEtZXhjZXB0aW9uKVwiKS5jc3MoXCItd2Via2l0LXRyYW5zZm9ybVwiLFwibm9uZVwiKSxuLnNpZGViYXIuY3NzKHtwb3NpdGlvbjpuLm9wdGlvbnMuZGVmYXVsdFBvc2l0aW9uLG92ZXJmbG93OlwidmlzaWJsZVwiLFwiLXdlYmtpdC1ib3gtc2l6aW5nXCI6XCJib3JkZXItYm94XCIsXCItbW96LWJveC1zaXppbmdcIjpcImJvcmRlci1ib3hcIixcImJveC1zaXppbmdcIjpcImJvcmRlci1ib3hcIn0pLG4uc3RpY2t5U2lkZWJhcj1uLnNpZGViYXIuZmluZChcIi50aGVpYVN0aWNreVNpZGViYXJcIiksMD09bi5zdGlja3lTaWRlYmFyLmxlbmd0aCl7dmFyIHM9Lyg/OnRleHR8YXBwbGljYXRpb24pXFwvKD86eC0pPyg/OmphdmFzY3JpcHR8ZWNtYXNjcmlwdCkvaTtuLnNpZGViYXIuZmluZChcInNjcmlwdFwiKS5maWx0ZXIoZnVuY3Rpb24oaSx0KXtyZXR1cm4gMD09PXQudHlwZS5sZW5ndGh8fHQudHlwZS5tYXRjaChzKX0pLnJlbW92ZSgpLG4uc3RpY2t5U2lkZWJhcj1pKFwiPGRpdj5cIikuYWRkQ2xhc3MoXCJ0aGVpYVN0aWNreVNpZGViYXJcIikuYXBwZW5kKG4uc2lkZWJhci5jaGlsZHJlbigpKSxuLnNpZGViYXIuYXBwZW5kKG4uc3RpY2t5U2lkZWJhcil9bi5tYXJnaW5Cb3R0b209cGFyc2VJbnQobi5zaWRlYmFyLmNzcyhcIm1hcmdpbi1ib3R0b21cIikpLG4ucGFkZGluZ1RvcD1wYXJzZUludChuLnNpZGViYXIuY3NzKFwicGFkZGluZy10b3BcIikpLG4ucGFkZGluZ0JvdHRvbT1wYXJzZUludChuLnNpZGViYXIuY3NzKFwicGFkZGluZy1ib3R0b21cIikpO3ZhciBkPW4uc3RpY2t5U2lkZWJhci5vZmZzZXQoKS50b3Ascj1uLnN0aWNreVNpZGViYXIub3V0ZXJIZWlnaHQoKTtuLnN0aWNreVNpZGViYXIuY3NzKFwicGFkZGluZy10b3BcIiwxKSxuLnN0aWNreVNpZGViYXIuY3NzKFwicGFkZGluZy1ib3R0b21cIiwxKSxkLT1uLnN0aWNreVNpZGViYXIub2Zmc2V0KCkudG9wLHI9bi5zdGlja3lTaWRlYmFyLm91dGVySGVpZ2h0KCktci1kLDA9PWQ/KG4uc3RpY2t5U2lkZWJhci5jc3MoXCJwYWRkaW5nLXRvcFwiLDApLG4uc3RpY2t5U2lkZWJhclBhZGRpbmdUb3A9MCk6bi5zdGlja3lTaWRlYmFyUGFkZGluZ1RvcD0xLDA9PXI/KG4uc3RpY2t5U2lkZWJhci5jc3MoXCJwYWRkaW5nLWJvdHRvbVwiLDApLG4uc3RpY2t5U2lkZWJhclBhZGRpbmdCb3R0b209MCk6bi5zdGlja3lTaWRlYmFyUGFkZGluZ0JvdHRvbT0xLG4ucHJldmlvdXNTY3JvbGxUb3A9bnVsbCxuLmZpeGVkU2Nyb2xsVG9wPTAsZSgpLG4ub25TY3JvbGw9ZnVuY3Rpb24obil7aWYobi5zdGlja3lTaWRlYmFyLmlzKFwiOnZpc2libGVcIikpaWYoaShcImJvZHlcIikud2lkdGgoKTxuLm9wdGlvbnMubWluV2lkdGgpZSgpO2Vsc2UgaWYobi5vcHRpb25zLmRpc2FibGVPblJlc3BvbnNpdmVMYXlvdXRzJiZuLnNpZGViYXIub3V0ZXJXaWR0aChcIm5vbmVcIj09bi5zaWRlYmFyLmNzcyhcImZsb2F0XCIpKSs1MD5uLmNvbnRhaW5lci53aWR0aCgpKWUoKTtlbHNle3ZhciBzPWkoZG9jdW1lbnQpLnNjcm9sbFRvcCgpLGQ9XCJzdGF0aWNcIjtpZihzPj1uLnNpZGViYXIub2Zmc2V0KCkudG9wKyhuLnBhZGRpbmdUb3Atbi5vcHRpb25zLmFkZGl0aW9uYWxNYXJnaW5Ub3ApKXt2YXIgcixjPW4ucGFkZGluZ1RvcCt0LmFkZGl0aW9uYWxNYXJnaW5Ub3AscD1uLnBhZGRpbmdCb3R0b20rbi5tYXJnaW5Cb3R0b20rdC5hZGRpdGlvbmFsTWFyZ2luQm90dG9tLGI9bi5zaWRlYmFyLm9mZnNldCgpLnRvcCxsPW4uc2lkZWJhci5vZmZzZXQoKS50b3ArbyhuLmNvbnRhaW5lciksZj0wK3QuYWRkaXRpb25hbE1hcmdpblRvcDtyPW4uc3RpY2t5U2lkZWJhci5vdXRlckhlaWdodCgpK2MrcDxpKHdpbmRvdykuaGVpZ2h0KCk/ZituLnN0aWNreVNpZGViYXIub3V0ZXJIZWlnaHQoKTppKHdpbmRvdykuaGVpZ2h0KCktbi5tYXJnaW5Cb3R0b20tbi5wYWRkaW5nQm90dG9tLXQuYWRkaXRpb25hbE1hcmdpbkJvdHRvbTt2YXIgaD1iLXMrbi5wYWRkaW5nVG9wLGc9bC1zLW4ucGFkZGluZ0JvdHRvbS1uLm1hcmdpbkJvdHRvbSx1PW4uc3RpY2t5U2lkZWJhci5vZmZzZXQoKS50b3AtcyxTPW4ucHJldmlvdXNTY3JvbGxUb3AtcztcImZpeGVkXCI9PW4uc3RpY2t5U2lkZWJhci5jc3MoXCJwb3NpdGlvblwiKSYmXCJtb2Rlcm5cIj09bi5vcHRpb25zLnNpZGViYXJCZWhhdmlvciYmKHUrPVMpLFwic3RpY2stdG8tdG9wXCI9PW4ub3B0aW9ucy5zaWRlYmFyQmVoYXZpb3ImJih1PXQuYWRkaXRpb25hbE1hcmdpblRvcCksXCJzdGljay10by1ib3R0b21cIj09bi5vcHRpb25zLnNpZGViYXJCZWhhdmlvciYmKHU9ci1uLnN0aWNreVNpZGViYXIub3V0ZXJIZWlnaHQoKSksdT1TPjA/TWF0aC5taW4odSxmKTpNYXRoLm1heCh1LHItbi5zdGlja3lTaWRlYmFyLm91dGVySGVpZ2h0KCkpLHU9TWF0aC5tYXgodSxoKSx1PU1hdGgubWluKHUsZy1uLnN0aWNreVNpZGViYXIub3V0ZXJIZWlnaHQoKSk7dmFyIG09bi5jb250YWluZXIuaGVpZ2h0KCk9PW4uc3RpY2t5U2lkZWJhci5vdXRlckhlaWdodCgpO2Q9KG18fHUhPWYpJiYobXx8dSE9ci1uLnN0aWNreVNpZGViYXIub3V0ZXJIZWlnaHQoKSk/cyt1LW4uc2lkZWJhci5vZmZzZXQoKS50b3Atbi5wYWRkaW5nVG9wPD10LmFkZGl0aW9uYWxNYXJnaW5Ub3A/XCJzdGF0aWNcIjpcImFic29sdXRlXCI6XCJmaXhlZFwifWlmKFwiZml4ZWRcIj09ZCl7dmFyIHk9aShkb2N1bWVudCkuc2Nyb2xsTGVmdCgpO24uc3RpY2t5U2lkZWJhci5jc3Moe3Bvc2l0aW9uOlwiZml4ZWRcIix3aWR0aDphKG4uc3RpY2t5U2lkZWJhcikrXCJweFwiLHRyYW5zZm9ybTpcInRyYW5zbGF0ZVkoXCIrdStcInB4KVwiLGxlZnQ6bi5zaWRlYmFyLm9mZnNldCgpLmxlZnQrcGFyc2VJbnQobi5zaWRlYmFyLmNzcyhcInBhZGRpbmctbGVmdFwiKSkteStcInB4XCIsdG9wOlwiMHB4XCJ9KX1lbHNlIGlmKFwiYWJzb2x1dGVcIj09ZCl7dmFyIGs9e307XCJhYnNvbHV0ZVwiIT1uLnN0aWNreVNpZGViYXIuY3NzKFwicG9zaXRpb25cIikmJihrLnBvc2l0aW9uPVwiYWJzb2x1dGVcIixrLnRyYW5zZm9ybT1cInRyYW5zbGF0ZVkoXCIrKHMrdS1uLnNpZGViYXIub2Zmc2V0KCkudG9wLW4uc3RpY2t5U2lkZWJhclBhZGRpbmdUb3Atbi5zdGlja3lTaWRlYmFyUGFkZGluZ0JvdHRvbSkrXCJweClcIixrLnRvcD1cIjBweFwiKSxrLndpZHRoPWEobi5zdGlja3lTaWRlYmFyKStcInB4XCIsay5sZWZ0PVwiXCIsbi5zdGlja3lTaWRlYmFyLmNzcyhrKX1lbHNlXCJzdGF0aWNcIj09ZCYmZSgpO1wic3RhdGljXCIhPWQmJjE9PW4ub3B0aW9ucy51cGRhdGVTaWRlYmFySGVpZ2h0JiZuLnNpZGViYXIuY3NzKHtcIm1pbi1oZWlnaHRcIjpuLnN0aWNreVNpZGViYXIub3V0ZXJIZWlnaHQoKStuLnN0aWNreVNpZGViYXIub2Zmc2V0KCkudG9wLW4uc2lkZWJhci5vZmZzZXQoKS50b3Arbi5wYWRkaW5nQm90dG9tfSksbi5wcmV2aW91c1Njcm9sbFRvcD1zfX0sbi5vblNjcm9sbChuKSxpKGRvY3VtZW50KS5vbihcInNjcm9sbC5cIituLm9wdGlvbnMubmFtZXNwYWNlLGZ1bmN0aW9uKGkpe3JldHVybiBmdW5jdGlvbigpe2kub25TY3JvbGwoaSl9fShuKSksaSh3aW5kb3cpLm9uKFwicmVzaXplLlwiK24ub3B0aW9ucy5uYW1lc3BhY2UsZnVuY3Rpb24oaSl7cmV0dXJuIGZ1bmN0aW9uKCl7aS5zdGlja3lTaWRlYmFyLmNzcyh7cG9zaXRpb246XCJzdGF0aWNcIn0pLGkub25TY3JvbGwoaSl9fShuKSksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFJlc2l6ZVNlbnNvciYmbmV3IFJlc2l6ZVNlbnNvcihuLnN0aWNreVNpZGViYXJbMF0sZnVuY3Rpb24oaSl7cmV0dXJuIGZ1bmN0aW9uKCl7aS5vblNjcm9sbChpKX19KG4pKX0pfWZ1bmN0aW9uIGEoaSl7dmFyIHQ7dHJ5e3Q9aVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aH1jYXRjaChpKXt9cmV0dXJuIHZvaWQgMD09PXQmJih0PWkud2lkdGgoKSksdH12YXIgbj17Y29udGFpbmVyU2VsZWN0b3I6XCJcIixhZGRpdGlvbmFsTWFyZ2luVG9wOjAsYWRkaXRpb25hbE1hcmdpbkJvdHRvbTowLHVwZGF0ZVNpZGViYXJIZWlnaHQ6ITAsbWluV2lkdGg6MCxkaXNhYmxlT25SZXNwb25zaXZlTGF5b3V0czohMCxzaWRlYmFyQmVoYXZpb3I6XCJtb2Rlcm5cIixkZWZhdWx0UG9zaXRpb246XCJyZWxhdGl2ZVwiLG5hbWVzcGFjZTpcIlRTU1wifTtyZXR1cm4gdD1pLmV4dGVuZChuLHQpLHQuYWRkaXRpb25hbE1hcmdpblRvcD1wYXJzZUludCh0LmFkZGl0aW9uYWxNYXJnaW5Ub3ApfHwwLHQuYWRkaXRpb25hbE1hcmdpbkJvdHRvbT1wYXJzZUludCh0LmFkZGl0aW9uYWxNYXJnaW5Cb3R0b20pfHwwLGZ1bmN0aW9uKHQsbyl7ZSh0LG8pfHwoY29uc29sZS5sb2coXCJUU1M6IEJvZHkgd2lkdGggc21hbGxlciB0aGFuIG9wdGlvbnMubWluV2lkdGguIEluaXQgaXMgZGVsYXllZC5cIiksaShkb2N1bWVudCkub24oXCJzY3JvbGwuXCIrdC5uYW1lc3BhY2UsZnVuY3Rpb24odCxvKXtyZXR1cm4gZnVuY3Rpb24oYSl7ZSh0LG8pJiZpKHRoaXMpLnVuYmluZChhKX19KHQsbykpLGkod2luZG93KS5vbihcInJlc2l6ZS5cIit0Lm5hbWVzcGFjZSxmdW5jdGlvbih0LG8pe3JldHVybiBmdW5jdGlvbihhKXtlKHQsbykmJmkodGhpcykudW5iaW5kKGEpfX0odCxvKSkpfSh0LHRoaXMpLHRoaXN9fShqUXVlcnkpO1xuXG5cbi8qIVxuICogalF1ZXJ5IFNlbGVjdGJveCBwbHVnaW4gMC4yXG4gKlxuICogQ29weXJpZ2h0IDIwMTEtMjAxMiwgRGltaXRhciBJdmFub3YgKGh0dHA6Ly93d3cuYnVsZ2FyaWEtd2ViLWRldmVsb3BlcnMuY29tL3Byb2plY3RzL2phdmFzY3JpcHQvc2VsZWN0Ym94LylcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgKGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwKSBsaWNlbnNlLlxuICpcbiAqIERhdGU6IFR1ZSBKdWwgMTcgMTk6NTg6MzYgMjAxMiArMDMwMFxuICovXG4hZnVuY3Rpb24oZSxzKXtmdW5jdGlvbiB0KCl7dGhpcy5fc3RhdGU9W10sdGhpcy5fZGVmYXVsdHM9e2NsYXNzSG9sZGVyOlwic2JIb2xkZXJcIixjbGFzc0hvbGRlckRpc2FibGVkOlwic2JIb2xkZXJEaXNhYmxlZFwiLGNsYXNzU2VsZWN0b3I6XCJzYlNlbGVjdG9yXCIsY2xhc3NPcHRpb25zOlwic2JPcHRpb25zXCIsY2xhc3NHcm91cDpcInNiR3JvdXBcIixjbGFzc1N1YjpcInNiU3ViXCIsY2xhc3NEaXNhYmxlZDpcInNiRGlzYWJsZWRcIixjbGFzc1RvZ2dsZU9wZW46XCJzYlRvZ2dsZU9wZW5cIixjbGFzc1RvZ2dsZTpcInNiVG9nZ2xlXCIsY2xhc3NGb2N1czpcInNiRm9jdXNcIixzcGVlZDoyMDAsZWZmZWN0Olwic2xpZGVcIixvbkNoYW5nZTpudWxsLG9uT3BlbjpudWxsLG9uQ2xvc2U6bnVsbH19dmFyIGk9ITA7ZS5leHRlbmQodC5wcm90b3R5cGUse19pc09wZW5TZWxlY3Rib3g6ZnVuY3Rpb24oZSl7cmV0dXJuISFlJiZ0aGlzLl9nZXRJbnN0KGUpLmlzT3Blbn0sX2lzRGlzYWJsZWRTZWxlY3Rib3g6ZnVuY3Rpb24oZSl7cmV0dXJuISFlJiZ0aGlzLl9nZXRJbnN0KGUpLmlzRGlzYWJsZWR9LF9hdHRhY2hTZWxlY3Rib3g6ZnVuY3Rpb24ocyx0KXtmdW5jdGlvbiBhKCl7dmFyIHMsdCxpPXRoaXMuYXR0cihcImlkXCIpLnNwbGl0KFwiX1wiKVsxXTtmb3IocyBpbiB1Ll9zdGF0ZSlzIT09aSYmdS5fc3RhdGUuaGFzT3duUHJvcGVydHkocykmJih0PWUoXCJzZWxlY3Rbc2I9J1wiK3MrXCInXVwiKVswXSkmJnUuX2Nsb3NlU2VsZWN0Ym94KHQpfWZ1bmN0aW9uIG4oKXt2YXIgdD0hKCFhcmd1bWVudHNbMV18fCFhcmd1bWVudHNbMV0uc3ViKSxhPSEoIWFyZ3VtZW50c1sxXXx8IWFyZ3VtZW50c1sxXS5kaXNhYmxlZCk7YXJndW1lbnRzWzBdLmVhY2goZnVuY3Rpb24obil7dmFyIGwscj1lKHRoaXMpLGc9ZShcIjxsaT5cIik7ci5pcyhcIjpzZWxlY3RlZFwiKSYmKG8udGV4dChyLnRleHQoKSkscD1pKSxuPT09Zi0xJiZnLmFkZENsYXNzKFwibGFzdFwiKSxyLmlzKFwiOmRpc2FibGVkXCIpfHxhPyhsPWUoXCI8c3Bhbj5cIix7dGV4dDpyLnRleHQoKX0pLmFkZENsYXNzKGIuc2V0dGluZ3MuY2xhc3NEaXNhYmxlZCksdCYmbC5hZGRDbGFzcyhiLnNldHRpbmdzLmNsYXNzU3ViKSxsLmFwcGVuZFRvKGcpKToobD1lKFwiPGE+XCIse2hyZWY6XCIjXCIrci52YWwoKSxyZWw6ci52YWwoKX0pLnRleHQoci50ZXh0KCkpLmJpbmQoXCJjbGljay5zYlwiLGZ1bmN0aW9uKHQpe3QmJnQucHJldmVudERlZmF1bHQmJnQucHJldmVudERlZmF1bHQoKTt2YXIgaT1jLGE9ZSh0aGlzKTtpLmF0dHIoXCJpZFwiKS5zcGxpdChcIl9cIilbMV07dS5fY2hhbmdlU2VsZWN0Ym94KHMsYS5hdHRyKFwicmVsXCIpLGEudGV4dCgpKSx1Ll9jbG9zZVNlbGVjdGJveChzKX0pLmJpbmQoXCJtb3VzZW92ZXIuc2JcIixmdW5jdGlvbigpe3ZhciBzPWUodGhpcyk7cy5wYXJlbnQoKS5zaWJsaW5ncygpLmZpbmQoXCJhXCIpLnJlbW92ZUNsYXNzKGIuc2V0dGluZ3MuY2xhc3NGb2N1cykscy5hZGRDbGFzcyhiLnNldHRpbmdzLmNsYXNzRm9jdXMpfSkuYmluZChcIm1vdXNlb3V0LnNiXCIsZnVuY3Rpb24oKXtlKHRoaXMpLnJlbW92ZUNsYXNzKGIuc2V0dGluZ3MuY2xhc3NGb2N1cyl9KSx0JiZsLmFkZENsYXNzKGIuc2V0dGluZ3MuY2xhc3NTdWIpLHIuaXMoXCI6c2VsZWN0ZWRcIikmJmwuYWRkQ2xhc3MoYi5zZXR0aW5ncy5jbGFzc0ZvY3VzKSxsLmFwcGVuZFRvKGcpKSxnLmFwcGVuZFRvKGQpfSl9aWYodGhpcy5fZ2V0SW5zdChzKSlyZXR1cm4hMTt2YXIgbCxvLGMsZCxyPWUocyksdT10aGlzLGI9dS5fbmV3SW5zdChyKSxwPSExLGc9KHIuZmluZChcIm9wdGdyb3VwXCIpLHIuZmluZChcIm9wdGlvblwiKSksZj1nLmxlbmd0aDtyLmF0dHIoXCJzYlwiLGIudWlkKSxlLmV4dGVuZChiLnNldHRpbmdzLHUuX2RlZmF1bHRzLHQpLHUuX3N0YXRlW2IudWlkXT0hMSxyLmhpZGUoKSxsPWUoXCI8ZGl2PlwiLHtpZDpcInNiSG9sZGVyX1wiK2IudWlkLGNsYXNzOmIuc2V0dGluZ3MuY2xhc3NIb2xkZXIsdGFiaW5kZXg6ci5hdHRyKFwidGFiaW5kZXhcIil9KSxvPWUoXCI8YT5cIix7aWQ6XCJzYlNlbGVjdG9yX1wiK2IudWlkLGhyZWY6XCIjXCIsY2xhc3M6Yi5zZXR0aW5ncy5jbGFzc1NlbGVjdG9yLGNsaWNrOmZ1bmN0aW9uKHQpe3QucHJldmVudERlZmF1bHQoKSxhLmFwcGx5KGUodGhpcyksW10pO3ZhciBpPWUodGhpcykuYXR0cihcImlkXCIpLnNwbGl0KFwiX1wiKVsxXTt1Ll9zdGF0ZVtpXT91Ll9jbG9zZVNlbGVjdGJveChzKTp1Ll9vcGVuU2VsZWN0Ym94KHMpfX0pLChjPWUoXCI8YT5cIix7aWQ6XCJzYlRvZ2dsZV9cIitiLnVpZCxocmVmOlwiI1wiLGNsYXNzOmIuc2V0dGluZ3MuY2xhc3NUb2dnbGUsY2xpY2s6ZnVuY3Rpb24odCl7dC5wcmV2ZW50RGVmYXVsdCgpLGEuYXBwbHkoZSh0aGlzKSxbXSk7dmFyIGk9ZSh0aGlzKS5hdHRyKFwiaWRcIikuc3BsaXQoXCJfXCIpWzFdO3UuX3N0YXRlW2ldP3UuX2Nsb3NlU2VsZWN0Ym94KHMpOnUuX29wZW5TZWxlY3Rib3gocyl9fSkpLmFwcGVuZFRvKGwpLGQ9ZShcIjx1bD5cIix7aWQ6XCJzYk9wdGlvbnNfXCIrYi51aWQsY2xhc3M6Yi5zZXR0aW5ncy5jbGFzc09wdGlvbnMsY3NzOntkaXNwbGF5Olwibm9uZVwifX0pLHIuY2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uKHMpe3ZhciB0LGk9ZSh0aGlzKSxhPXt9O2kuaXMoXCJvcHRpb25cIik/bihpKTppLmlzKFwib3B0Z3JvdXBcIikmJih0PWUoXCI8bGk+XCIpLGUoXCI8c3Bhbj5cIix7dGV4dDppLmF0dHIoXCJsYWJlbFwiKX0pLmFkZENsYXNzKGIuc2V0dGluZ3MuY2xhc3NHcm91cCkuYXBwZW5kVG8odCksdC5hcHBlbmRUbyhkKSxpLmlzKFwiOmRpc2FibGVkXCIpJiYoYS5kaXNhYmxlZD0hMCksYS5zdWI9ITAsbihpLmZpbmQoXCJvcHRpb25cIiksYSkpfSkscHx8by50ZXh0KGcuZmlyc3QoKS50ZXh0KCkpLGUuZGF0YShzLFwic2VsZWN0Ym94XCIsYiksbC5kYXRhKFwidWlkXCIsYi51aWQpLmJpbmQoXCJrZXlkb3duLnNiXCIsZnVuY3Rpb24ocyl7dmFyIHQ9cy5jaGFyQ29kZT9zLmNoYXJDb2RlOnMua2V5Q29kZT9zLmtleUNvZGU6MCxpPWUodGhpcyksYT1pLmRhdGEoXCJ1aWRcIiksbj1pLnNpYmxpbmdzKFwic2VsZWN0W3NiPSdcIithK1wiJ11cIikuZGF0YShcInNlbGVjdGJveFwiKSxsPWkuc2libGluZ3MoW1wic2VsZWN0W3NiPSdcIixhLFwiJ11cIl0uam9pbihcIlwiKSkuZ2V0KDApLG89aS5maW5kKFwidWxcIikuZmluZChcImEuXCIrbi5zZXR0aW5ncy5jbGFzc0ZvY3VzKTtzd2l0Y2godCl7Y2FzZSAzNzpjYXNlIDM4OmlmKG8ubGVuZ3RoPjApe2UoXCJhXCIsaSkucmVtb3ZlQ2xhc3Mobi5zZXR0aW5ncy5jbGFzc0ZvY3VzKSwoYz1vLnBhcmVudCgpLnByZXZBbGwoXCJsaTpoYXMoYSlcIikuZXEoMCkuZmluZChcImFcIikpLmxlbmd0aD4wJiYoYy5hZGRDbGFzcyhuLnNldHRpbmdzLmNsYXNzRm9jdXMpLmZvY3VzKCksZShcIiNzYlNlbGVjdG9yX1wiK2EpLnRleHQoYy50ZXh0KCkpKX1icmVhaztjYXNlIDM5OmNhc2UgNDA6dmFyIGM7ZShcImFcIixpKS5yZW1vdmVDbGFzcyhuLnNldHRpbmdzLmNsYXNzRm9jdXMpLChjPW8ubGVuZ3RoPjA/by5wYXJlbnQoKS5uZXh0QWxsKFwibGk6aGFzKGEpXCIpLmVxKDApLmZpbmQoXCJhXCIpOmkuZmluZChcInVsXCIpLmZpbmQoXCJhXCIpLmVxKDApKS5sZW5ndGg+MCYmKGMuYWRkQ2xhc3Mobi5zZXR0aW5ncy5jbGFzc0ZvY3VzKS5mb2N1cygpLGUoXCIjc2JTZWxlY3Rvcl9cIithKS50ZXh0KGMudGV4dCgpKSk7YnJlYWs7Y2FzZSAxMzpvLmxlbmd0aD4wJiZ1Ll9jaGFuZ2VTZWxlY3Rib3gobCxvLmF0dHIoXCJyZWxcIiksby50ZXh0KCkpLHUuX2Nsb3NlU2VsZWN0Ym94KGwpO2JyZWFrO2Nhc2UgOTpsJiYobj11Ll9nZXRJbnN0KGwpKSYmKG8ubGVuZ3RoPjAmJnUuX2NoYW5nZVNlbGVjdGJveChsLG8uYXR0cihcInJlbFwiKSxvLnRleHQoKSksdS5fY2xvc2VTZWxlY3Rib3gobCkpO3ZhciBkPXBhcnNlSW50KGkuYXR0cihcInRhYmluZGV4XCIpLDEwKTtzLnNoaWZ0S2V5P2QtLTpkKyssZShcIipbdGFiaW5kZXg9J1wiK2QrXCInXVwiKS5mb2N1cygpO2JyZWFrO2Nhc2UgMjc6dS5fY2xvc2VTZWxlY3Rib3gobCl9cmV0dXJuIHMuc3RvcFByb3BhZ2F0aW9uKCksITF9KS5kZWxlZ2F0ZShcImFcIixcIm1vdXNlb3ZlclwiLGZ1bmN0aW9uKHMpe2UodGhpcykuYWRkQ2xhc3MoYi5zZXR0aW5ncy5jbGFzc0ZvY3VzKX0pLmRlbGVnYXRlKFwiYVwiLFwibW91c2VvdXRcIixmdW5jdGlvbihzKXtlKHRoaXMpLnJlbW92ZUNsYXNzKGIuc2V0dGluZ3MuY2xhc3NGb2N1cyl9KSxvLmFwcGVuZFRvKGwpLGQuYXBwZW5kVG8obCksbC5pbnNlcnRBZnRlcihyKSxlKFtcIi5cIixiLnNldHRpbmdzLmNsYXNzSG9sZGVyLFwiLCAuXCIsYi5zZXR0aW5ncy5jbGFzc1NlbGVjdG9yXS5qb2luKFwiXCIpKS5tb3VzZWRvd24oZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24oKX0pfSxfZGV0YWNoU2VsZWN0Ym94OmZ1bmN0aW9uKHMpe3ZhciB0PXRoaXMuX2dldEluc3Qocyk7aWYoIXQpcmV0dXJuITE7ZShcIiNzYkhvbGRlcl9cIit0LnVpZCkucmVtb3ZlKCksZS5kYXRhKHMsXCJzZWxlY3Rib3hcIixudWxsKSxlKHMpLnNob3coKX0sX2NoYW5nZVNlbGVjdGJveDpmdW5jdGlvbihzLHQsYSl7dmFyIG4sbD10aGlzLl9nZXRJbnN0KHMpO2wmJihuPXRoaXMuX2dldChsLFwib25DaGFuZ2VcIiksZShcIiNzYlNlbGVjdG9yX1wiK2wudWlkKS50ZXh0KGEpKSx0PXQucmVwbGFjZSgvXFwnL2csXCJcXFxcJ1wiKSxlKHMpLmZpbmQoXCJvcHRpb25bdmFsdWU9J1wiK3QrXCInXVwiKS5hdHRyKFwic2VsZWN0ZWRcIixpKSxsJiZuP24uYXBwbHkobC5pbnB1dD9sLmlucHV0WzBdOm51bGwsW3QsbF0pOmwmJmwuaW5wdXQmJmwuaW5wdXQudHJpZ2dlcihcImNoYW5nZVwiKX0sX2VuYWJsZVNlbGVjdGJveDpmdW5jdGlvbihzKXt2YXIgdD10aGlzLl9nZXRJbnN0KHMpO2lmKCF0fHwhdC5pc0Rpc2FibGVkKXJldHVybiExO2UoXCIjc2JIb2xkZXJfXCIrdC51aWQpLnJlbW92ZUNsYXNzKHQuc2V0dGluZ3MuY2xhc3NIb2xkZXJEaXNhYmxlZCksdC5pc0Rpc2FibGVkPSExLGUuZGF0YShzLFwic2VsZWN0Ym94XCIsdCl9LF9kaXNhYmxlU2VsZWN0Ym94OmZ1bmN0aW9uKHMpe3ZhciB0PXRoaXMuX2dldEluc3Qocyk7aWYoIXR8fHQuaXNEaXNhYmxlZClyZXR1cm4hMTtlKFwiI3NiSG9sZGVyX1wiK3QudWlkKS5hZGRDbGFzcyh0LnNldHRpbmdzLmNsYXNzSG9sZGVyRGlzYWJsZWQpLHQuaXNEaXNhYmxlZD1pLGUuZGF0YShzLFwic2VsZWN0Ym94XCIsdCl9LF9vcHRpb25TZWxlY3Rib3g6ZnVuY3Rpb24ocyx0LGkpe3ZhciBhPXRoaXMuX2dldEluc3Qocyk7aWYoIWEpcmV0dXJuITE7YVt0XT1pLGUuZGF0YShzLFwic2VsZWN0Ym94XCIsYSl9LF9vcGVuU2VsZWN0Ym94OmZ1bmN0aW9uKHMpe3ZhciB0PXRoaXMuX2dldEluc3Qocyk7aWYodCYmIXQuaXNPcGVuJiYhdC5pc0Rpc2FibGVkKXt2YXIgYT1lKFwiI3NiT3B0aW9uc19cIit0LnVpZCksbj1wYXJzZUludChlKHdpbmRvdykuaGVpZ2h0KCksMTApLGw9ZShcIiNzYkhvbGRlcl9cIit0LnVpZCkub2Zmc2V0KCksbz1lKHdpbmRvdykuc2Nyb2xsVG9wKCksYz1hLnByZXYoKS5oZWlnaHQoKSxkPW4tKGwudG9wLW8pLWMvMixyPXRoaXMuX2dldCh0LFwib25PcGVuXCIpO2EuY3NzKHt0b3A6YytcInB4XCIsbWF4SGVpZ2h0OmQtYytcInB4XCJ9KSxcImZhZGVcIj09PXQuc2V0dGluZ3MuZWZmZWN0P2EuZmFkZUluKHQuc2V0dGluZ3Muc3BlZWQpOmEuc2xpZGVEb3duKHQuc2V0dGluZ3Muc3BlZWQpLGUoXCIjc2JUb2dnbGVfXCIrdC51aWQpLmFkZENsYXNzKHQuc2V0dGluZ3MuY2xhc3NUb2dnbGVPcGVuKSx0aGlzLl9zdGF0ZVt0LnVpZF09aSx0LmlzT3Blbj1pLHImJnIuYXBwbHkodC5pbnB1dD90LmlucHV0WzBdOm51bGwsW3RdKSxlLmRhdGEocyxcInNlbGVjdGJveFwiLHQpfX0sX2Nsb3NlU2VsZWN0Ym94OmZ1bmN0aW9uKHMpe3ZhciB0PXRoaXMuX2dldEluc3Qocyk7aWYodCYmdC5pc09wZW4pe3ZhciBpPXRoaXMuX2dldCh0LFwib25DbG9zZVwiKTtcImZhZGVcIj09PXQuc2V0dGluZ3MuZWZmZWN0P2UoXCIjc2JPcHRpb25zX1wiK3QudWlkKS5mYWRlT3V0KHQuc2V0dGluZ3Muc3BlZWQpOmUoXCIjc2JPcHRpb25zX1wiK3QudWlkKS5zbGlkZVVwKHQuc2V0dGluZ3Muc3BlZWQpLGUoXCIjc2JUb2dnbGVfXCIrdC51aWQpLnJlbW92ZUNsYXNzKHQuc2V0dGluZ3MuY2xhc3NUb2dnbGVPcGVuKSx0aGlzLl9zdGF0ZVt0LnVpZF09ITEsdC5pc09wZW49ITEsaSYmaS5hcHBseSh0LmlucHV0P3QuaW5wdXRbMF06bnVsbCxbdF0pLGUuZGF0YShzLFwic2VsZWN0Ym94XCIsdCl9fSxfbmV3SW5zdDpmdW5jdGlvbihlKXtyZXR1cm57aWQ6ZVswXS5pZC5yZXBsYWNlKC8oW15BLVphLXowLTlfLV0pL2csXCJcXFxcXFxcXCQxXCIpLGlucHV0OmUsdWlkOk1hdGguZmxvb3IoOTk5OTk5OTkqTWF0aC5yYW5kb20oKSksaXNPcGVuOiExLGlzRGlzYWJsZWQ6ITEsc2V0dGluZ3M6e319fSxfZ2V0SW5zdDpmdW5jdGlvbihzKXt0cnl7cmV0dXJuIGUuZGF0YShzLFwic2VsZWN0Ym94XCIpfWNhdGNoKGUpe3Rocm93XCJNaXNzaW5nIGluc3RhbmNlIGRhdGEgZm9yIHRoaXMgc2VsZWN0Ym94XCJ9fSxfZ2V0OmZ1bmN0aW9uKGUscyl7cmV0dXJuIHZvaWQgMCE9PWUuc2V0dGluZ3Nbc10/ZS5zZXR0aW5nc1tzXTp0aGlzLl9kZWZhdWx0c1tzXX19KSxlLmZuLnNlbGVjdGJveD1mdW5jdGlvbihzKXt2YXIgdD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSk7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHMmJlwiaXNEaXNhYmxlZFwiPT1zP2Uuc2VsZWN0Ym94W1wiX1wiK3MrXCJTZWxlY3Rib3hcIl0uYXBwbHkoZS5zZWxlY3Rib3gsW3RoaXNbMF1dLmNvbmNhdCh0KSk6XCJvcHRpb25cIj09cyYmMj09YXJndW1lbnRzLmxlbmd0aCYmXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1sxXT9lLnNlbGVjdGJveFtcIl9cIitzK1wiU2VsZWN0Ym94XCJdLmFwcGx5KGUuc2VsZWN0Ym94LFt0aGlzWzBdXS5jb25jYXQodCkpOnRoaXMuZWFjaChmdW5jdGlvbigpe1wic3RyaW5nXCI9PXR5cGVvZiBzP2Uuc2VsZWN0Ym94W1wiX1wiK3MrXCJTZWxlY3Rib3hcIl0uYXBwbHkoZS5zZWxlY3Rib3gsW3RoaXNdLmNvbmNhdCh0KSk6ZS5zZWxlY3Rib3guX2F0dGFjaFNlbGVjdGJveCh0aGlzLHMpfSl9LGUuc2VsZWN0Ym94PW5ldyB0LGUuc2VsZWN0Ym94LnZlcnNpb249XCIwLjJcIn0oalF1ZXJ5KTtcblxuLypcbiBTdGlja3kta2l0IHYxLjEuMyB8IE1JVCB8IExlYWYgQ29yY29yYW4gMjAxNSB8IGh0dHA6Ly9sZWFmby5uZXRcbiovXG4oZnVuY3Rpb24oKXt2YXIgYyxmO2M9d2luZG93LmpRdWVyeTtmPWMod2luZG93KTtjLmZuLnN0aWNrX2luX3BhcmVudD1mdW5jdGlvbihiKXt2YXIgQSx3LEosbixCLEsscCxxLEwsayxFLHQ7bnVsbD09YiYmKGI9e30pO3Q9Yi5zdGlja3lfY2xhc3M7Qj1iLmlubmVyX3Njcm9sbGluZztFPWIucmVjYWxjX2V2ZXJ5O2s9Yi5wYXJlbnQ7cT1iLm9mZnNldF90b3A7cD1iLnNwYWNlcjt3PWIuYm90dG9taW5nO251bGw9PXEmJihxPTApO251bGw9PWsmJihrPXZvaWQgMCk7bnVsbD09QiYmKEI9ITApO251bGw9PXQmJih0PVwiaXNfc3R1Y2tcIik7QT1jKGRvY3VtZW50KTtudWxsPT13JiYodz0hMCk7TD1mdW5jdGlvbihhKXt2YXIgYjtyZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGU/KGE9d2luZG93LmdldENvbXB1dGVkU3R5bGUoYVswXSksYj1wYXJzZUZsb2F0KGEuZ2V0UHJvcGVydHlWYWx1ZShcIndpZHRoXCIpKStwYXJzZUZsb2F0KGEuZ2V0UHJvcGVydHlWYWx1ZShcIm1hcmdpbi1sZWZ0XCIpKStcbnBhcnNlRmxvYXQoYS5nZXRQcm9wZXJ0eVZhbHVlKFwibWFyZ2luLXJpZ2h0XCIpKSxcImJvcmRlci1ib3hcIiE9PWEuZ2V0UHJvcGVydHlWYWx1ZShcImJveC1zaXppbmdcIikmJihiKz1wYXJzZUZsb2F0KGEuZ2V0UHJvcGVydHlWYWx1ZShcImJvcmRlci1sZWZ0LXdpZHRoXCIpKStwYXJzZUZsb2F0KGEuZ2V0UHJvcGVydHlWYWx1ZShcImJvcmRlci1yaWdodC13aWR0aFwiKSkrcGFyc2VGbG9hdChhLmdldFByb3BlcnR5VmFsdWUoXCJwYWRkaW5nLWxlZnRcIikpK3BhcnNlRmxvYXQoYS5nZXRQcm9wZXJ0eVZhbHVlKFwicGFkZGluZy1yaWdodFwiKSkpLGIpOmEub3V0ZXJXaWR0aCghMCl9O0o9ZnVuY3Rpb24oYSxiLG4sQyxGLHUscixHKXt2YXIgdixILG0sRCxJLGQsZyx4LHkseixoLGw7aWYoIWEuZGF0YShcInN0aWNreV9raXRcIikpe2EuZGF0YShcInN0aWNreV9raXRcIiwhMCk7ST1BLmhlaWdodCgpO2c9YS5wYXJlbnQoKTtudWxsIT1rJiYoZz1nLmNsb3Nlc3QoaykpO2lmKCFnLmxlbmd0aCl0aHJvd1wiZmFpbGVkIHRvIGZpbmQgc3RpY2sgcGFyZW50XCI7XG52PW09ITE7KGg9bnVsbCE9cD9wJiZhLmNsb3Nlc3QocCk6YyhcIjxkaXYgLz5cIikpJiZoLmNzcyhcInBvc2l0aW9uXCIsYS5jc3MoXCJwb3NpdGlvblwiKSk7eD1mdW5jdGlvbigpe3ZhciBkLGYsZTtpZighRyYmKEk9QS5oZWlnaHQoKSxkPXBhcnNlSW50KGcuY3NzKFwiYm9yZGVyLXRvcC13aWR0aFwiKSwxMCksZj1wYXJzZUludChnLmNzcyhcInBhZGRpbmctdG9wXCIpLDEwKSxiPXBhcnNlSW50KGcuY3NzKFwicGFkZGluZy1ib3R0b21cIiksMTApLG49Zy5vZmZzZXQoKS50b3ArZCtmLEM9Zy5oZWlnaHQoKSxtJiYodj1tPSExLG51bGw9PXAmJihhLmluc2VydEFmdGVyKGgpLGguZGV0YWNoKCkpLGEuY3NzKHtwb3NpdGlvbjpcIlwiLHRvcDpcIlwiLHdpZHRoOlwiXCIsYm90dG9tOlwiXCJ9KS5yZW1vdmVDbGFzcyh0KSxlPSEwKSxGPWEub2Zmc2V0KCkudG9wLShwYXJzZUludChhLmNzcyhcIm1hcmdpbi10b3BcIiksMTApfHwwKS1xLHU9YS5vdXRlckhlaWdodCghMCkscj1hLmNzcyhcImZsb2F0XCIpLGgmJmguY3NzKHt3aWR0aDpMKGEpLFxuaGVpZ2h0OnUsZGlzcGxheTphLmNzcyhcImRpc3BsYXlcIiksXCJ2ZXJ0aWNhbC1hbGlnblwiOmEuY3NzKFwidmVydGljYWwtYWxpZ25cIiksXCJmbG9hdFwiOnJ9KSxlKSlyZXR1cm4gbCgpfTt4KCk7aWYodSE9PUMpcmV0dXJuIEQ9dm9pZCAwLGQ9cSx6PUUsbD1mdW5jdGlvbigpe3ZhciBjLGwsZSxrO2lmKCFHJiYoZT0hMSxudWxsIT16JiYoLS16LDA+PXomJih6PUUseCgpLGU9ITApKSxlfHxBLmhlaWdodCgpPT09SXx8eCgpLGU9Zi5zY3JvbGxUb3AoKSxudWxsIT1EJiYobD1lLUQpLEQ9ZSxtPyh3JiYoaz1lK3UrZD5DK24sdiYmIWsmJih2PSExLGEuY3NzKHtwb3NpdGlvbjpcImZpeGVkXCIsYm90dG9tOlwiXCIsdG9wOmR9KS50cmlnZ2VyKFwic3RpY2t5X2tpdDp1bmJvdHRvbVwiKSkpLGU8RiYmKG09ITEsZD1xLG51bGw9PXAmJihcImxlZnRcIiE9PXImJlwicmlnaHRcIiE9PXJ8fGEuaW5zZXJ0QWZ0ZXIoaCksaC5kZXRhY2goKSksYz17cG9zaXRpb246XCJcIix3aWR0aDpcIlwiLHRvcDpcIlwifSxhLmNzcyhjKS5yZW1vdmVDbGFzcyh0KS50cmlnZ2VyKFwic3RpY2t5X2tpdDp1bnN0aWNrXCIpKSxcbkImJihjPWYuaGVpZ2h0KCksdStxPmMmJiF2JiYoZC09bCxkPU1hdGgubWF4KGMtdSxkKSxkPU1hdGgubWluKHEsZCksbSYmYS5jc3Moe3RvcDpkK1wicHhcIn0pKSkpOmU+RiYmKG09ITAsYz17cG9zaXRpb246XCJmaXhlZFwiLHRvcDpkfSxjLndpZHRoPVwiYm9yZGVyLWJveFwiPT09YS5jc3MoXCJib3gtc2l6aW5nXCIpP2Eub3V0ZXJXaWR0aCgpK1wicHhcIjphLndpZHRoKCkrXCJweFwiLGEuY3NzKGMpLmFkZENsYXNzKHQpLG51bGw9PXAmJihhLmFmdGVyKGgpLFwibGVmdFwiIT09ciYmXCJyaWdodFwiIT09cnx8aC5hcHBlbmQoYSkpLGEudHJpZ2dlcihcInN0aWNreV9raXQ6c3RpY2tcIikpLG0mJncmJihudWxsPT1rJiYoaz1lK3UrZD5DK24pLCF2JiZrKSkpcmV0dXJuIHY9ITAsXCJzdGF0aWNcIj09PWcuY3NzKFwicG9zaXRpb25cIikmJmcuY3NzKHtwb3NpdGlvbjpcInJlbGF0aXZlXCJ9KSxhLmNzcyh7cG9zaXRpb246XCJhYnNvbHV0ZVwiLGJvdHRvbTpiLHRvcDpcImF1dG9cIn0pLnRyaWdnZXIoXCJzdGlja3lfa2l0OmJvdHRvbVwiKX0sXG55PWZ1bmN0aW9uKCl7eCgpO3JldHVybiBsKCl9LEg9ZnVuY3Rpb24oKXtHPSEwO2Yub2ZmKFwidG91Y2htb3ZlXCIsbCk7Zi5vZmYoXCJzY3JvbGxcIixsKTtmLm9mZihcInJlc2l6ZVwiLHkpO2MoZG9jdW1lbnQuYm9keSkub2ZmKFwic3RpY2t5X2tpdDpyZWNhbGNcIix5KTthLm9mZihcInN0aWNreV9raXQ6ZGV0YWNoXCIsSCk7YS5yZW1vdmVEYXRhKFwic3RpY2t5X2tpdFwiKTthLmNzcyh7cG9zaXRpb246XCJcIixib3R0b206XCJcIix0b3A6XCJcIix3aWR0aDpcIlwifSk7Zy5wb3NpdGlvbihcInBvc2l0aW9uXCIsXCJcIik7aWYobSlyZXR1cm4gbnVsbD09cCYmKFwibGVmdFwiIT09ciYmXCJyaWdodFwiIT09cnx8YS5pbnNlcnRBZnRlcihoKSxoLnJlbW92ZSgpKSxhLnJlbW92ZUNsYXNzKHQpfSxmLm9uKFwidG91Y2htb3ZlXCIsbCksZi5vbihcInNjcm9sbFwiLGwpLGYub24oXCJyZXNpemVcIix5KSxjKGRvY3VtZW50LmJvZHkpLm9uKFwic3RpY2t5X2tpdDpyZWNhbGNcIix5KSxhLm9uKFwic3RpY2t5X2tpdDpkZXRhY2hcIixIKSxzZXRUaW1lb3V0KGwsXG4wKX19O249MDtmb3IoSz10aGlzLmxlbmd0aDtuPEs7bisrKWI9dGhpc1tuXSxKKGMoYikpO3JldHVybiB0aGlzfX0pLmNhbGwodGhpcyk7XG5cbi8qISBpQ2hlY2sgdjEuMC4yIGJ5IERhbWlyIFN1bHRhbm92LCBodHRwOi8vZ2l0LmlvL2FybHplQSwgTUlUIExpY2Vuc2VkICovXG4oZnVuY3Rpb24oZil7ZnVuY3Rpb24gQShhLGIsZCl7dmFyIGM9YVswXSxnPS9lci8udGVzdChkKT9faW5kZXRlcm1pbmF0ZTovYmwvLnRlc3QoZCk/bjprLGU9ZD09X3VwZGF0ZT97Y2hlY2tlZDpjW2tdLGRpc2FibGVkOmNbbl0saW5kZXRlcm1pbmF0ZTpcInRydWVcIj09YS5hdHRyKF9pbmRldGVybWluYXRlKXx8XCJmYWxzZVwiPT1hLmF0dHIoX2RldGVybWluYXRlKX06Y1tnXTtpZigvXihjaHxkaXxpbikvLnRlc3QoZCkmJiFlKXgoYSxnKTtlbHNlIGlmKC9eKHVufGVufGRlKS8udGVzdChkKSYmZSlxKGEsZyk7ZWxzZSBpZihkPT1fdXBkYXRlKWZvcih2YXIgZiBpbiBlKWVbZl0/eChhLGYsITApOnEoYSxmLCEwKTtlbHNlIGlmKCFifHxcInRvZ2dsZVwiPT1kKXtpZighYilhW19jYWxsYmFja10oXCJpZkNsaWNrZWRcIik7ZT9jW190eXBlXSE9PXImJnEoYSxnKTp4KGEsZyl9fWZ1bmN0aW9uIHgoYSxiLGQpe3ZhciBjPWFbMF0sZz1hLnBhcmVudCgpLGU9Yj09ayx1PWI9PV9pbmRldGVybWluYXRlLFxudj1iPT1uLHM9dT9fZGV0ZXJtaW5hdGU6ZT95OlwiZW5hYmxlZFwiLEY9bChhLHMrdChjW190eXBlXSkpLEI9bChhLGIrdChjW190eXBlXSkpO2lmKCEwIT09Y1tiXSl7aWYoIWQmJmI9PWsmJmNbX3R5cGVdPT1yJiZjLm5hbWUpe3ZhciB3PWEuY2xvc2VzdChcImZvcm1cIikscD0naW5wdXRbbmFtZT1cIicrYy5uYW1lKydcIl0nLHA9dy5sZW5ndGg/dy5maW5kKHApOmYocCk7cC5lYWNoKGZ1bmN0aW9uKCl7dGhpcyE9PWMmJmYodGhpcykuZGF0YShtKSYmcShmKHRoaXMpLGIpfSl9dT8oY1tiXT0hMCxjW2tdJiZxKGEsayxcImZvcmNlXCIpKTooZHx8KGNbYl09ITApLGUmJmNbX2luZGV0ZXJtaW5hdGVdJiZxKGEsX2luZGV0ZXJtaW5hdGUsITEpKTtEKGEsZSxiLGQpfWNbbl0mJmwoYSxfY3Vyc29yLCEwKSYmZy5maW5kKFwiLlwiK0MpLmNzcyhfY3Vyc29yLFwiZGVmYXVsdFwiKTtnW19hZGRdKEJ8fGwoYSxiKXx8XCJcIik7Zy5hdHRyKFwicm9sZVwiKSYmIXUmJmcuYXR0cihcImFyaWEtXCIrKHY/bjprKSxcInRydWVcIik7XG5nW19yZW1vdmVdKEZ8fGwoYSxzKXx8XCJcIil9ZnVuY3Rpb24gcShhLGIsZCl7dmFyIGM9YVswXSxnPWEucGFyZW50KCksZT1iPT1rLGY9Yj09X2luZGV0ZXJtaW5hdGUsbT1iPT1uLHM9Zj9fZGV0ZXJtaW5hdGU6ZT95OlwiZW5hYmxlZFwiLHE9bChhLHMrdChjW190eXBlXSkpLHI9bChhLGIrdChjW190eXBlXSkpO2lmKCExIT09Y1tiXSl7aWYoZnx8IWR8fFwiZm9yY2VcIj09ZCljW2JdPSExO0QoYSxlLHMsZCl9IWNbbl0mJmwoYSxfY3Vyc29yLCEwKSYmZy5maW5kKFwiLlwiK0MpLmNzcyhfY3Vyc29yLFwicG9pbnRlclwiKTtnW19yZW1vdmVdKHJ8fGwoYSxiKXx8XCJcIik7Zy5hdHRyKFwicm9sZVwiKSYmIWYmJmcuYXR0cihcImFyaWEtXCIrKG0/bjprKSxcImZhbHNlXCIpO2dbX2FkZF0ocXx8bChhLHMpfHxcIlwiKX1mdW5jdGlvbiBFKGEsYil7aWYoYS5kYXRhKG0pKXthLnBhcmVudCgpLmh0bWwoYS5hdHRyKFwic3R5bGVcIixhLmRhdGEobSkuc3x8XCJcIikpO2lmKGIpYVtfY2FsbGJhY2tdKGIpO2Eub2ZmKFwiLmlcIikudW53cmFwKCk7XG5mKF9sYWJlbCsnW2Zvcj1cIicrYVswXS5pZCsnXCJdJykuYWRkKGEuY2xvc2VzdChfbGFiZWwpKS5vZmYoXCIuaVwiKX19ZnVuY3Rpb24gbChhLGIsZil7aWYoYS5kYXRhKG0pKXJldHVybiBhLmRhdGEobSkub1tiKyhmP1wiXCI6XCJDbGFzc1wiKV19ZnVuY3Rpb24gdChhKXtyZXR1cm4gYS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSthLnNsaWNlKDEpfWZ1bmN0aW9uIEQoYSxiLGYsYyl7aWYoIWMpe2lmKGIpYVtfY2FsbGJhY2tdKFwiaWZUb2dnbGVkXCIpO2FbX2NhbGxiYWNrXShcImlmQ2hhbmdlZFwiKVtfY2FsbGJhY2tdKFwiaWZcIit0KGYpKX19dmFyIG09XCJpQ2hlY2tcIixDPW0rXCItaGVscGVyXCIscj1cInJhZGlvXCIsaz1cImNoZWNrZWRcIix5PVwidW5cIitrLG49XCJkaXNhYmxlZFwiO19kZXRlcm1pbmF0ZT1cImRldGVybWluYXRlXCI7X2luZGV0ZXJtaW5hdGU9XCJpblwiK19kZXRlcm1pbmF0ZTtfdXBkYXRlPVwidXBkYXRlXCI7X3R5cGU9XCJ0eXBlXCI7X2NsaWNrPVwiY2xpY2tcIjtfdG91Y2g9XCJ0b3VjaGJlZ2luLmkgdG91Y2hlbmQuaVwiO1xuX2FkZD1cImFkZENsYXNzXCI7X3JlbW92ZT1cInJlbW92ZUNsYXNzXCI7X2NhbGxiYWNrPVwidHJpZ2dlclwiO19sYWJlbD1cImxhYmVsXCI7X2N1cnNvcj1cImN1cnNvclwiO19tb2JpbGU9L2lwYWR8aXBob25lfGlwb2R8YW5kcm9pZHxibGFja2JlcnJ5fHdpbmRvd3MgcGhvbmV8b3BlcmEgbWluaXxzaWxrL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtmLmZuW21dPWZ1bmN0aW9uKGEsYil7dmFyIGQ9J2lucHV0W3R5cGU9XCJjaGVja2JveFwiXSwgaW5wdXRbdHlwZT1cIicrcisnXCJdJyxjPWYoKSxnPWZ1bmN0aW9uKGEpe2EuZWFjaChmdW5jdGlvbigpe3ZhciBhPWYodGhpcyk7Yz1hLmlzKGQpP2MuYWRkKGEpOmMuYWRkKGEuZmluZChkKSl9KX07aWYoL14oY2hlY2t8dW5jaGVja3x0b2dnbGV8aW5kZXRlcm1pbmF0ZXxkZXRlcm1pbmF0ZXxkaXNhYmxlfGVuYWJsZXx1cGRhdGV8ZGVzdHJveSkkL2kudGVzdChhKSlyZXR1cm4gYT1hLnRvTG93ZXJDYXNlKCksZyh0aGlzKSxjLmVhY2goZnVuY3Rpb24oKXt2YXIgYz1cbmYodGhpcyk7XCJkZXN0cm95XCI9PWE/RShjLFwiaWZEZXN0cm95ZWRcIik6QShjLCEwLGEpO2YuaXNGdW5jdGlvbihiKSYmYigpfSk7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGEmJmEpcmV0dXJuIHRoaXM7dmFyIGU9Zi5leHRlbmQoe2NoZWNrZWRDbGFzczprLGRpc2FibGVkQ2xhc3M6bixpbmRldGVybWluYXRlQ2xhc3M6X2luZGV0ZXJtaW5hdGUsbGFiZWxIb3ZlcjohMH0sYSksbD1lLmhhbmRsZSx2PWUuaG92ZXJDbGFzc3x8XCJob3ZlclwiLHM9ZS5mb2N1c0NsYXNzfHxcImZvY3VzXCIsdD1lLmFjdGl2ZUNsYXNzfHxcImFjdGl2ZVwiLEI9ISFlLmxhYmVsSG92ZXIsdz1lLmxhYmVsSG92ZXJDbGFzc3x8XCJob3ZlclwiLHA9KFwiXCIrZS5pbmNyZWFzZUFyZWEpLnJlcGxhY2UoXCIlXCIsXCJcIil8MDtpZihcImNoZWNrYm94XCI9PWx8fGw9PXIpZD0naW5wdXRbdHlwZT1cIicrbCsnXCJdJzstNTA+cCYmKHA9LTUwKTtnKHRoaXMpO3JldHVybiBjLmVhY2goZnVuY3Rpb24oKXt2YXIgYT1mKHRoaXMpO0UoYSk7dmFyIGM9dGhpcyxcbmI9Yy5pZCxnPS1wK1wiJVwiLGQ9MTAwKzIqcCtcIiVcIixkPXtwb3NpdGlvbjpcImFic29sdXRlXCIsdG9wOmcsbGVmdDpnLGRpc3BsYXk6XCJibG9ja1wiLHdpZHRoOmQsaGVpZ2h0OmQsbWFyZ2luOjAscGFkZGluZzowLGJhY2tncm91bmQ6XCIjZmZmXCIsYm9yZGVyOjAsb3BhY2l0eTowfSxnPV9tb2JpbGU/e3Bvc2l0aW9uOlwiYWJzb2x1dGVcIix2aXNpYmlsaXR5OlwiaGlkZGVuXCJ9OnA/ZDp7cG9zaXRpb246XCJhYnNvbHV0ZVwiLG9wYWNpdHk6MH0sbD1cImNoZWNrYm94XCI9PWNbX3R5cGVdP2UuY2hlY2tib3hDbGFzc3x8XCJpY2hlY2tib3hcIjplLnJhZGlvQ2xhc3N8fFwiaVwiK3Isej1mKF9sYWJlbCsnW2Zvcj1cIicrYisnXCJdJykuYWRkKGEuY2xvc2VzdChfbGFiZWwpKSx1PSEhZS5hcmlhLHk9bStcIi1cIitNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiw2KSxoPSc8ZGl2IGNsYXNzPVwiJytsKydcIiAnKyh1Pydyb2xlPVwiJytjW190eXBlXSsnXCIgJzpcIlwiKTt1JiZ6LmVhY2goZnVuY3Rpb24oKXtoKz1cbidhcmlhLWxhYmVsbGVkYnk9XCInO3RoaXMuaWQ/aCs9dGhpcy5pZDoodGhpcy5pZD15LGgrPXkpO2grPSdcIid9KTtoPWEud3JhcChoK1wiLz5cIilbX2NhbGxiYWNrXShcImlmQ3JlYXRlZFwiKS5wYXJlbnQoKS5hcHBlbmQoZS5pbnNlcnQpO2Q9ZignPGlucyBjbGFzcz1cIicrQysnXCIvPicpLmNzcyhkKS5hcHBlbmRUbyhoKTthLmRhdGEobSx7bzplLHM6YS5hdHRyKFwic3R5bGVcIil9KS5jc3MoZyk7ZS5pbmhlcml0Q2xhc3MmJmhbX2FkZF0oYy5jbGFzc05hbWV8fFwiXCIpO2UuaW5oZXJpdElEJiZiJiZoLmF0dHIoXCJpZFwiLG0rXCItXCIrYik7XCJzdGF0aWNcIj09aC5jc3MoXCJwb3NpdGlvblwiKSYmaC5jc3MoXCJwb3NpdGlvblwiLFwicmVsYXRpdmVcIik7QShhLCEwLF91cGRhdGUpO2lmKHoubGVuZ3RoKXoub24oX2NsaWNrK1wiLmkgbW91c2VvdmVyLmkgbW91c2VvdXQuaSBcIitfdG91Y2gsZnVuY3Rpb24oYil7dmFyIGQ9YltfdHlwZV0sZT1mKHRoaXMpO2lmKCFjW25dKXtpZihkPT1fY2xpY2spe2lmKGYoYi50YXJnZXQpLmlzKFwiYVwiKSlyZXR1cm47XG5BKGEsITEsITApfWVsc2UgQiYmKC91dHxuZC8udGVzdChkKT8oaFtfcmVtb3ZlXSh2KSxlW19yZW1vdmVdKHcpKTooaFtfYWRkXSh2KSxlW19hZGRdKHcpKSk7aWYoX21vYmlsZSliLnN0b3BQcm9wYWdhdGlvbigpO2Vsc2UgcmV0dXJuITF9fSk7YS5vbihfY2xpY2srXCIuaSBmb2N1cy5pIGJsdXIuaSBrZXl1cC5pIGtleWRvd24uaSBrZXlwcmVzcy5pXCIsZnVuY3Rpb24oYil7dmFyIGQ9YltfdHlwZV07Yj1iLmtleUNvZGU7aWYoZD09X2NsaWNrKXJldHVybiExO2lmKFwia2V5ZG93blwiPT1kJiYzMj09YilyZXR1cm4gY1tfdHlwZV09PXImJmNba118fChjW2tdP3EoYSxrKTp4KGEsaykpLCExO2lmKFwia2V5dXBcIj09ZCYmY1tfdHlwZV09PXIpIWNba10mJngoYSxrKTtlbHNlIGlmKC91c3x1ci8udGVzdChkKSloW1wiYmx1clwiPT1kP19yZW1vdmU6X2FkZF0ocyl9KTtkLm9uKF9jbGljaytcIiBtb3VzZWRvd24gbW91c2V1cCBtb3VzZW92ZXIgbW91c2VvdXQgXCIrX3RvdWNoLGZ1bmN0aW9uKGIpe3ZhciBkPVxuYltfdHlwZV0sZT0vd258dXAvLnRlc3QoZCk/dDp2O2lmKCFjW25dKXtpZihkPT1fY2xpY2spQShhLCExLCEwKTtlbHNle2lmKC93bnxlcnxpbi8udGVzdChkKSloW19hZGRdKGUpO2Vsc2UgaFtfcmVtb3ZlXShlK1wiIFwiK3QpO2lmKHoubGVuZ3RoJiZCJiZlPT12KXpbL3V0fG5kLy50ZXN0KGQpP19yZW1vdmU6X2FkZF0odyl9aWYoX21vYmlsZSliLnN0b3BQcm9wYWdhdGlvbigpO2Vsc2UgcmV0dXJuITF9fSl9KX19KSh3aW5kb3cualF1ZXJ5fHx3aW5kb3cuWmVwdG8pO1xuXG4vKlxuIFNlYXJjaCBvdmVybGF5XG4qL1xuJChcIi5zZWFyY2gtb3ZlcmxheS1tZW51LWJ0blwiKS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uIChhKSB7XG5cdCQoXCIuc2VhcmNoLW92ZXJsYXktbWVudVwiKS5hZGRDbGFzcyhcIm9wZW5cIiksIFxuXHQkKCcuc2VhcmNoLW92ZXJsYXktbWVudSA+IGZvcm0gPiBpbnB1dFt0eXBlPVwic2VhcmNoXCJdJykuZm9jdXMoKX0pLCBcblx0JChcIi5zZWFyY2gtb3ZlcmxheS1jbG9zZVwiKS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uIChhKSB7XG5cdCQoXCIuc2VhcmNoLW92ZXJsYXktbWVudVwiKS5yZW1vdmVDbGFzcyhcIm9wZW5cIil9KSxcblx0JChcIi5zZWFyY2gtb3ZlcmxheS1tZW51LCAuc2VhcmNoLW92ZXJsYXktbWVudSAuc2VhcmNoLW92ZXJsYXktY2xvc2VcIikub24oXCJjbGljayBrZXl1cFwiLCBmdW5jdGlvbiAoYSkge1xuXHQoYS50YXJnZXQgPT0gdGhpcyB8fCBcInNlYXJjaC1vdmVybGF5LWNsb3NlXCIgPT0gYS50YXJnZXQuY2xhc3NOYW1lIHx8IDI3ID09IGEua2V5Q29kZSkgJiYgJCh0aGlzKS5yZW1vdmVDbGFzcyhcIm9wZW5cIilcbn0pO1xuXG4vKlxuICogalF1ZXJ5IG1tZW51IHY2LjEuOFxuICogQHJlcXVpcmVzIGpRdWVyeSAxLjcuMCBvciBsYXRlclxuICpcbiAqIG1tZW51LmZyZWJzaXRlLm5sXG4gKlxuICogQ29weXJpZ2h0IChjKSBGcmVkIEhldXNzY2hlblxuICogd3d3LmZyZWJzaXRlLm5sXG4gKlxuICogTGljZW5zZTogQ0MtQlktTkMtNC4wXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy80LjAvXG4gKi9cbjsoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5qcXVlcnlfbW1lbnVfYWxsX2pzID0gZmFjdG9yeShyb290LmpRdWVyeSk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24oalF1ZXJ5KSB7XG5cbiFmdW5jdGlvbihlKXtmdW5jdGlvbiB0KCl7ZVtuXS5nbGJsfHwocj17JHduZHc6ZSh3aW5kb3cpLCRkb2N1OmUoZG9jdW1lbnQpLCRodG1sOmUoXCJodG1sXCIpLCRib2R5OmUoXCJib2R5XCIpfSxzPXt9LGE9e30sbz17fSxlLmVhY2goW3MsYSxvXSxmdW5jdGlvbihlLHQpe3QuYWRkPWZ1bmN0aW9uKGUpe2U9ZS5zcGxpdChcIiBcIik7Zm9yKHZhciBuPTAsaT1lLmxlbmd0aDtuPGk7bisrKXRbZVtuXV09dC5tbShlW25dKX19KSxzLm1tPWZ1bmN0aW9uKGUpe3JldHVyblwibW0tXCIrZX0scy5hZGQoXCJ3cmFwcGVyIG1lbnUgcGFuZWxzIHBhbmVsIG5vcGFuZWwgaGlnaGVzdCBvcGVuZWQgc3Vib3BlbmVkIG5hdmJhciBoYXNuYXZiYXIgdGl0bGUgYnRuIHByZXYgbmV4dCBsaXN0dmlldyBub2xpc3R2aWV3IGluc2V0IHZlcnRpY2FsIHNlbGVjdGVkIGRpdmlkZXIgc3BhY2VyIGhpZGRlbiBmdWxsc3Vib3BlbiBub2FuaW1hdGlvblwiKSxzLnVtbT1mdW5jdGlvbihlKXtyZXR1cm5cIm1tLVwiPT1lLnNsaWNlKDAsMykmJihlPWUuc2xpY2UoMykpLGV9LGEubW09ZnVuY3Rpb24oZSl7cmV0dXJuXCJtbS1cIitlfSxhLmFkZChcInBhcmVudCBjaGlsZFwiKSxvLm1tPWZ1bmN0aW9uKGUpe3JldHVybiBlK1wiLm1tXCJ9LG8uYWRkKFwidHJhbnNpdGlvbmVuZCB3ZWJraXRUcmFuc2l0aW9uRW5kIGNsaWNrIHNjcm9sbCByZXNpemUga2V5ZG93biBtb3VzZWRvd24gbW91c2V1cCB0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCBvcmllbnRhdGlvbmNoYW5nZVwiKSxlW25dLl9jPXMsZVtuXS5fZD1hLGVbbl0uX2U9byxlW25dLmdsYmw9cil9dmFyIG49XCJtbWVudVwiLGk9XCI2LjEuOFwiO2lmKCEoZVtuXSYmZVtuXS52ZXJzaW9uPmkpKXtlW25dPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdGhpcy4kbWVudT1lLHRoaXMuX2FwaT1bXCJiaW5kXCIsXCJnZXRJbnN0YW5jZVwiLFwiaW5pdFBhbmVsc1wiLFwib3BlblBhbmVsXCIsXCJjbG9zZVBhbmVsXCIsXCJjbG9zZUFsbFBhbmVsc1wiLFwic2V0U2VsZWN0ZWRcIl0sdGhpcy5vcHRzPXQsdGhpcy5jb25mPW4sdGhpcy52YXJzPXt9LHRoaXMuY2Jjaz17fSx0aGlzLm10Y2g9e30sXCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcy5fX19kZXByZWNhdGVkJiZ0aGlzLl9fX2RlcHJlY2F0ZWQoKSx0aGlzLl9pbml0QWRkb25zKCksdGhpcy5faW5pdEV4dGVuc2lvbnMoKSx0aGlzLl9pbml0TWVudSgpLHRoaXMuX2luaXRQYW5lbHMoKSx0aGlzLl9pbml0T3BlbmVkKCksdGhpcy5faW5pdEFuY2hvcnMoKSx0aGlzLl9pbml0TWF0Y2hNZWRpYSgpLFwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMuX19fZGVidWcmJnRoaXMuX19fZGVidWcoKSx0aGlzfSxlW25dLnZlcnNpb249aSxlW25dLmFkZG9ucz17fSxlW25dLnVuaXF1ZUlkPTAsZVtuXS5kZWZhdWx0cz17ZXh0ZW5zaW9uczpbXSxpbml0TWVudTpmdW5jdGlvbigpe30saW5pdFBhbmVsczpmdW5jdGlvbigpe30sbmF2YmFyOnthZGQ6ITAsdGl0bGU6XCJNZW51XCIsdGl0bGVMaW5rOlwicGFyZW50XCJ9LG9uQ2xpY2s6e3NldFNlbGVjdGVkOiEwfSxzbGlkaW5nU3VibWVudXM6ITB9LGVbbl0uY29uZmlndXJhdGlvbj17Y2xhc3NOYW1lczp7ZGl2aWRlcjpcIkRpdmlkZXJcIixpbnNldDpcIkluc2V0XCIsbm9saXN0dmlldzpcIk5vTGlzdHZpZXdcIixub3BhbmVsOlwiTm9QYW5lbFwiLHBhbmVsOlwiUGFuZWxcIixzZWxlY3RlZDpcIlNlbGVjdGVkXCIsc3BhY2VyOlwiU3BhY2VyXCIsdmVydGljYWw6XCJWZXJ0aWNhbFwifSxjbG9uZTohMSxvcGVuaW5nSW50ZXJ2YWw6MjUscGFuZWxOb2RldHlwZTpcInVsLCBvbCwgZGl2XCIsdHJhbnNpdGlvbkR1cmF0aW9uOjQwMH0sZVtuXS5wcm90b3R5cGU9e2dldEluc3RhbmNlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LGluaXRQYW5lbHM6ZnVuY3Rpb24oZSl7dGhpcy5faW5pdFBhbmVscyhlKX0sb3BlblBhbmVsOmZ1bmN0aW9uKHQsaSl7aWYodGhpcy50cmlnZ2VyKFwib3BlblBhbmVsOmJlZm9yZVwiLHQpLHQmJnQubGVuZ3RoJiYodC5pcyhcIi5cIitzLnBhbmVsKXx8KHQ9dC5jbG9zZXN0KFwiLlwiK3MucGFuZWwpKSx0LmlzKFwiLlwiK3MucGFuZWwpKSl7dmFyIG89dGhpcztpZihcImJvb2xlYW5cIiE9dHlwZW9mIGkmJihpPSEwKSx0Lmhhc0NsYXNzKHMudmVydGljYWwpKXQuYWRkKHQucGFyZW50cyhcIi5cIitzLnZlcnRpY2FsKSkucmVtb3ZlQ2xhc3Mocy5oaWRkZW4pLnBhcmVudChcImxpXCIpLmFkZENsYXNzKHMub3BlbmVkKSx0aGlzLm9wZW5QYW5lbCh0LnBhcmVudHMoXCIuXCIrcy5wYW5lbCkubm90KFwiLlwiK3MudmVydGljYWwpLmZpcnN0KCkpLHRoaXMudHJpZ2dlcihcIm9wZW5QYW5lbDpzdGFydFwiLHQpLHRoaXMudHJpZ2dlcihcIm9wZW5QYW5lbDpmaW5pc2hcIix0KTtlbHNle2lmKHQuaGFzQ2xhc3Mocy5vcGVuZWQpKXJldHVybjt2YXIgcj10aGlzLiRwbmxzLmNoaWxkcmVuKFwiLlwiK3MucGFuZWwpLGw9ci5maWx0ZXIoXCIuXCIrcy5vcGVuZWQpO2lmKCFlW25dLnN1cHBvcnQuY3NzdHJhbnNpdGlvbnMpcmV0dXJuIGwuYWRkQ2xhc3Mocy5oaWRkZW4pLnJlbW92ZUNsYXNzKHMub3BlbmVkKSx0LnJlbW92ZUNsYXNzKHMuaGlkZGVuKS5hZGRDbGFzcyhzLm9wZW5lZCksdGhpcy50cmlnZ2VyKFwib3BlblBhbmVsOnN0YXJ0XCIsdCksdm9pZCB0aGlzLnRyaWdnZXIoXCJvcGVuUGFuZWw6ZmluaXNoXCIsdCk7ci5ub3QodCkucmVtb3ZlQ2xhc3Mocy5zdWJvcGVuZWQpO2Zvcih2YXIgZD10LmRhdGEoYS5wYXJlbnQpO2Q7KWQ9ZC5jbG9zZXN0KFwiLlwiK3MucGFuZWwpLGQuaXMoXCIuXCIrcy52ZXJ0aWNhbCl8fGQuYWRkQ2xhc3Mocy5zdWJvcGVuZWQpLGQ9ZC5kYXRhKGEucGFyZW50KTtyLnJlbW92ZUNsYXNzKHMuaGlnaGVzdCkubm90KGwpLm5vdCh0KS5hZGRDbGFzcyhzLmhpZGRlbiksdC5yZW1vdmVDbGFzcyhzLmhpZGRlbiksdGhpcy5vcGVuUGFuZWxTdGFydD1mdW5jdGlvbigpe2wucmVtb3ZlQ2xhc3Mocy5vcGVuZWQpLHQuYWRkQ2xhc3Mocy5vcGVuZWQpLHQuaGFzQ2xhc3Mocy5zdWJvcGVuZWQpPyhsLmFkZENsYXNzKHMuaGlnaGVzdCksdC5yZW1vdmVDbGFzcyhzLnN1Ym9wZW5lZCkpOihsLmFkZENsYXNzKHMuc3Vib3BlbmVkKSx0LmFkZENsYXNzKHMuaGlnaGVzdCkpLHRoaXMudHJpZ2dlcihcIm9wZW5QYW5lbDpzdGFydFwiLHQpfSx0aGlzLm9wZW5QYW5lbEZpbmlzaD1mdW5jdGlvbigpe2wucmVtb3ZlQ2xhc3Mocy5oaWdoZXN0KS5hZGRDbGFzcyhzLmhpZGRlbiksdC5yZW1vdmVDbGFzcyhzLmhpZ2hlc3QpLHRoaXMudHJpZ2dlcihcIm9wZW5QYW5lbDpmaW5pc2hcIix0KX0saSYmIXQuaGFzQ2xhc3Mocy5ub2FuaW1hdGlvbik/c2V0VGltZW91dChmdW5jdGlvbigpe28uX190cmFuc2l0aW9uZW5kKHQsZnVuY3Rpb24oKXtvLm9wZW5QYW5lbEZpbmlzaC5jYWxsKG8pfSxvLmNvbmYudHJhbnNpdGlvbkR1cmF0aW9uKSxvLm9wZW5QYW5lbFN0YXJ0LmNhbGwobyl9LG8uY29uZi5vcGVuaW5nSW50ZXJ2YWwpOih0aGlzLm9wZW5QYW5lbFN0YXJ0LmNhbGwodGhpcyksdGhpcy5vcGVuUGFuZWxGaW5pc2guY2FsbCh0aGlzKSl9dGhpcy50cmlnZ2VyKFwib3BlblBhbmVsOmFmdGVyXCIsdCl9fSxjbG9zZVBhbmVsOmZ1bmN0aW9uKGUpe3RoaXMudHJpZ2dlcihcImNsb3NlUGFuZWw6YmVmb3JlXCIsZSk7dmFyIHQ9ZS5wYXJlbnQoKTt0Lmhhc0NsYXNzKHMudmVydGljYWwpJiYodC5yZW1vdmVDbGFzcyhzLm9wZW5lZCksdGhpcy50cmlnZ2VyKFwiY2xvc2VQYW5lbFwiLGUpKSx0aGlzLnRyaWdnZXIoXCJjbG9zZVBhbmVsOmFmdGVyXCIsZSl9LGNsb3NlQWxsUGFuZWxzOmZ1bmN0aW9uKGUpe3RoaXMudHJpZ2dlcihcImNsb3NlQWxsUGFuZWxzOmJlZm9yZVwiKSx0aGlzLiRwbmxzLmZpbmQoXCIuXCIrcy5saXN0dmlldykuY2hpbGRyZW4oKS5yZW1vdmVDbGFzcyhzLnNlbGVjdGVkKS5maWx0ZXIoXCIuXCIrcy52ZXJ0aWNhbCkucmVtb3ZlQ2xhc3Mocy5vcGVuZWQpO3ZhciB0PXRoaXMuJHBubHMuY2hpbGRyZW4oXCIuXCIrcy5wYW5lbCksbj1lJiZlLmxlbmd0aD9lOnQuZmlyc3QoKTt0aGlzLiRwbmxzLmNoaWxkcmVuKFwiLlwiK3MucGFuZWwpLm5vdChuKS5yZW1vdmVDbGFzcyhzLnN1Ym9wZW5lZCkucmVtb3ZlQ2xhc3Mocy5vcGVuZWQpLnJlbW92ZUNsYXNzKHMuaGlnaGVzdCkuYWRkQ2xhc3Mocy5oaWRkZW4pLHRoaXMub3BlblBhbmVsKG4sITEpLHRoaXMudHJpZ2dlcihcImNsb3NlQWxsUGFuZWxzOmFmdGVyXCIpfSx0b2dnbGVQYW5lbDpmdW5jdGlvbihlKXt2YXIgdD1lLnBhcmVudCgpO3QuaGFzQ2xhc3Mocy52ZXJ0aWNhbCkmJnRoaXNbdC5oYXNDbGFzcyhzLm9wZW5lZCk/XCJjbG9zZVBhbmVsXCI6XCJvcGVuUGFuZWxcIl0oZSl9LHNldFNlbGVjdGVkOmZ1bmN0aW9uKGUpe3RoaXMudHJpZ2dlcihcInNldFNlbGVjdGVkOmJlZm9yZVwiLGUpLHRoaXMuJG1lbnUuZmluZChcIi5cIitzLmxpc3R2aWV3KS5jaGlsZHJlbihcIi5cIitzLnNlbGVjdGVkKS5yZW1vdmVDbGFzcyhzLnNlbGVjdGVkKSxlLmFkZENsYXNzKHMuc2VsZWN0ZWQpLHRoaXMudHJpZ2dlcihcInNldFNlbGVjdGVkOmFmdGVyXCIsZSl9LGJpbmQ6ZnVuY3Rpb24oZSx0KXt0aGlzLmNiY2tbZV09dGhpcy5jYmNrW2VdfHxbXSx0aGlzLmNiY2tbZV0ucHVzaCh0KX0sdHJpZ2dlcjpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLG49dC5zaGlmdCgpO2lmKHRoaXMuY2Jja1tuXSlmb3IodmFyIGk9MCxzPXRoaXMuY2Jja1tuXS5sZW5ndGg7aTxzO2krKyl0aGlzLmNiY2tbbl1baV0uYXBwbHkoZSx0KX0sbWF0Y2hNZWRpYTpmdW5jdGlvbihlLHQsbil7dmFyIGk9e3llczp0LG5vOm59O3RoaXMubXRjaFtlXT10aGlzLm10Y2hbZV18fFtdLHRoaXMubXRjaFtlXS5wdXNoKGkpfSxfaW5pdEFkZG9uczpmdW5jdGlvbigpe3RoaXMudHJpZ2dlcihcImluaXRBZGRvbnM6YmVmb3JlXCIpO3ZhciB0O2Zvcih0IGluIGVbbl0uYWRkb25zKWVbbl0uYWRkb25zW3RdLmFkZC5jYWxsKHRoaXMpLGVbbl0uYWRkb25zW3RdLmFkZD1mdW5jdGlvbigpe307Zm9yKHQgaW4gZVtuXS5hZGRvbnMpZVtuXS5hZGRvbnNbdF0uc2V0dXAuY2FsbCh0aGlzKTt0aGlzLnRyaWdnZXIoXCJpbml0QWRkb25zOmFmdGVyXCIpfSxfaW5pdEV4dGVuc2lvbnM6ZnVuY3Rpb24oKXt0aGlzLnRyaWdnZXIoXCJpbml0RXh0ZW5zaW9uczpiZWZvcmVcIik7dmFyIGU9dGhpczt0aGlzLm9wdHMuZXh0ZW5zaW9ucy5jb25zdHJ1Y3Rvcj09PUFycmF5JiYodGhpcy5vcHRzLmV4dGVuc2lvbnM9e2FsbDp0aGlzLm9wdHMuZXh0ZW5zaW9uc30pO2Zvcih2YXIgdCBpbiB0aGlzLm9wdHMuZXh0ZW5zaW9ucyl0aGlzLm9wdHMuZXh0ZW5zaW9uc1t0XT10aGlzLm9wdHMuZXh0ZW5zaW9uc1t0XS5sZW5ndGg/XCJtbS1cIit0aGlzLm9wdHMuZXh0ZW5zaW9uc1t0XS5qb2luKFwiIG1tLVwiKTpcIlwiLHRoaXMub3B0cy5leHRlbnNpb25zW3RdJiYhZnVuY3Rpb24odCl7ZS5tYXRjaE1lZGlhKHQsZnVuY3Rpb24oKXt0aGlzLiRtZW51LmFkZENsYXNzKHRoaXMub3B0cy5leHRlbnNpb25zW3RdKX0sZnVuY3Rpb24oKXt0aGlzLiRtZW51LnJlbW92ZUNsYXNzKHRoaXMub3B0cy5leHRlbnNpb25zW3RdKX0pfSh0KTt0aGlzLnRyaWdnZXIoXCJpbml0RXh0ZW5zaW9uczphZnRlclwiKX0sX2luaXRNZW51OmZ1bmN0aW9uKCl7dGhpcy50cmlnZ2VyKFwiaW5pdE1lbnU6YmVmb3JlXCIpO3RoaXMuY29uZi5jbG9uZSYmKHRoaXMuJG9yaWc9dGhpcy4kbWVudSx0aGlzLiRtZW51PXRoaXMuJG9yaWcuY2xvbmUoKSx0aGlzLiRtZW51LmFkZCh0aGlzLiRtZW51LmZpbmQoXCJbaWRdXCIpKS5maWx0ZXIoXCJbaWRdXCIpLmVhY2goZnVuY3Rpb24oKXtlKHRoaXMpLmF0dHIoXCJpZFwiLHMubW0oZSh0aGlzKS5hdHRyKFwiaWRcIikpKX0pKSx0aGlzLm9wdHMuaW5pdE1lbnUuY2FsbCh0aGlzLHRoaXMuJG1lbnUsdGhpcy4kb3JpZyksdGhpcy4kbWVudS5hdHRyKFwiaWRcIix0aGlzLiRtZW51LmF0dHIoXCJpZFwiKXx8dGhpcy5fX2dldFVuaXF1ZUlkKCkpLHRoaXMuJHBubHM9ZSgnPGRpdiBjbGFzcz1cIicrcy5wYW5lbHMrJ1wiIC8+JykuYXBwZW5kKHRoaXMuJG1lbnUuY2hpbGRyZW4odGhpcy5jb25mLnBhbmVsTm9kZXR5cGUpKS5wcmVwZW5kVG8odGhpcy4kbWVudSk7dmFyIHQ9W3MubWVudV07dGhpcy5vcHRzLnNsaWRpbmdTdWJtZW51c3x8dC5wdXNoKHMudmVydGljYWwpLHRoaXMuJG1lbnUuYWRkQ2xhc3ModC5qb2luKFwiIFwiKSkucGFyZW50KCkuYWRkQ2xhc3Mocy53cmFwcGVyKSx0aGlzLnRyaWdnZXIoXCJpbml0TWVudTphZnRlclwiKX0sX2luaXRQYW5lbHM6ZnVuY3Rpb24odCl7dGhpcy50cmlnZ2VyKFwiaW5pdFBhbmVsczpiZWZvcmVcIix0KSx0PXR8fHRoaXMuJHBubHMuY2hpbGRyZW4odGhpcy5jb25mLnBhbmVsTm9kZXR5cGUpO3ZhciBuPWUoKSxpPXRoaXMsYT1mdW5jdGlvbih0KXt0LmZpbHRlcih0aGlzLmNvbmYucGFuZWxOb2RldHlwZSkuZWFjaChmdW5jdGlvbigpe3ZhciB0PWkuX2luaXRQYW5lbChlKHRoaXMpKTtpZih0KXtpLl9pbml0TmF2YmFyKHQpLGkuX2luaXRMaXN0dmlldyh0KSxuPW4uYWRkKHQpO3ZhciBvPXQuY2hpbGRyZW4oXCIuXCIrcy5saXN0dmlldykuY2hpbGRyZW4oXCJsaVwiKS5jaGlsZHJlbihpLmNvbmYucGFuZWxOb2RlVHlwZSkuYWRkKHQuY2hpbGRyZW4oXCIuXCIraS5jb25mLmNsYXNzTmFtZXMucGFuZWwpKTtvLmxlbmd0aCYmYS5jYWxsKGksbyl9fSl9O2EuY2FsbCh0aGlzLHQpLHRoaXMub3B0cy5pbml0UGFuZWxzLmNhbGwodGhpcyxuKSx0aGlzLnRyaWdnZXIoXCJpbml0UGFuZWxzOmFmdGVyXCIsbil9LF9pbml0UGFuZWw6ZnVuY3Rpb24oZSl7dGhpcy50cmlnZ2VyKFwiaW5pdFBhbmVsOmJlZm9yZVwiLGUpO2lmKGUuaGFzQ2xhc3Mocy5wYW5lbCkpcmV0dXJuIGU7aWYodGhpcy5fX3JlZmFjdG9yQ2xhc3MoZSx0aGlzLmNvbmYuY2xhc3NOYW1lcy5wYW5lbCxcInBhbmVsXCIpLHRoaXMuX19yZWZhY3RvckNsYXNzKGUsdGhpcy5jb25mLmNsYXNzTmFtZXMubm9wYW5lbCxcIm5vcGFuZWxcIiksdGhpcy5fX3JlZmFjdG9yQ2xhc3MoZSx0aGlzLmNvbmYuY2xhc3NOYW1lcy52ZXJ0aWNhbCxcInZlcnRpY2FsXCIpLHRoaXMuX19yZWZhY3RvckNsYXNzKGUsdGhpcy5jb25mLmNsYXNzTmFtZXMuaW5zZXQsXCJpbnNldFwiKSxlLmZpbHRlcihcIi5cIitzLmluc2V0KS5hZGRDbGFzcyhzLm5vcGFuZWwpLGUuaGFzQ2xhc3Mocy5ub3BhbmVsKSlyZXR1cm4hMTt2YXIgdD1lLmhhc0NsYXNzKHMudmVydGljYWwpfHwhdGhpcy5vcHRzLnNsaWRpbmdTdWJtZW51cztlLnJlbW92ZUNsYXNzKHMudmVydGljYWwpO3ZhciBuPWUuYXR0cihcImlkXCIpfHx0aGlzLl9fZ2V0VW5pcXVlSWQoKTtlLnJlbW92ZUF0dHIoXCJpZFwiKSxlLmlzKFwidWwsIG9sXCIpJiYoZS53cmFwKFwiPGRpdiAvPlwiKSxlPWUucGFyZW50KCkpLGUuYWRkQ2xhc3Mocy5wYW5lbCtcIiBcIitzLmhpZGRlbikuYXR0cihcImlkXCIsbik7dmFyIGk9ZS5wYXJlbnQoXCJsaVwiKTtyZXR1cm4gdD9lLmFkZChpKS5hZGRDbGFzcyhzLnZlcnRpY2FsKTplLmFwcGVuZFRvKHRoaXMuJHBubHMpLGkubGVuZ3RoJiYoaS5kYXRhKGEuY2hpbGQsZSksZS5kYXRhKGEucGFyZW50LGkpKSx0aGlzLnRyaWdnZXIoXCJpbml0UGFuZWw6YWZ0ZXJcIixlKSxlfSxfaW5pdE5hdmJhcjpmdW5jdGlvbih0KXtpZih0aGlzLnRyaWdnZXIoXCJpbml0TmF2YmFyOmJlZm9yZVwiLHQpLCF0LmNoaWxkcmVuKFwiLlwiK3MubmF2YmFyKS5sZW5ndGgpe3ZhciBpPXQuZGF0YShhLnBhcmVudCksbz1lKCc8ZGl2IGNsYXNzPVwiJytzLm5hdmJhcisnXCIgLz4nKSxyPWVbbl0uaTE4bih0aGlzLm9wdHMubmF2YmFyLnRpdGxlKSxsPVwiXCI7aWYoaSYmaS5sZW5ndGgpe2lmKGkuaGFzQ2xhc3Mocy52ZXJ0aWNhbCkpcmV0dXJuO2lmKGkucGFyZW50KCkuaXMoXCIuXCIrcy5saXN0dmlldykpdmFyIGQ9aS5jaGlsZHJlbihcImEsIHNwYW5cIikubm90KFwiLlwiK3MubmV4dCk7ZWxzZSB2YXIgZD1pLmNsb3Nlc3QoXCIuXCIrcy5wYW5lbCkuZmluZCgnYVtocmVmPVwiIycrdC5hdHRyKFwiaWRcIikrJ1wiXScpO2Q9ZC5maXJzdCgpLGk9ZC5jbG9zZXN0KFwiLlwiK3MucGFuZWwpO3ZhciBjPWkuYXR0cihcImlkXCIpO3N3aXRjaChyPWQudGV4dCgpLHRoaXMub3B0cy5uYXZiYXIudGl0bGVMaW5rKXtjYXNlXCJhbmNob3JcIjpsPWQuYXR0cihcImhyZWZcIik7YnJlYWs7Y2FzZVwicGFyZW50XCI6bD1cIiNcIitjfW8uYXBwZW5kKCc8YSBjbGFzcz1cIicrcy5idG4rXCIgXCIrcy5wcmV2KydcIiBocmVmPVwiIycrYysnXCIgLz4nKX1lbHNlIGlmKCF0aGlzLm9wdHMubmF2YmFyLnRpdGxlKXJldHVybjt0aGlzLm9wdHMubmF2YmFyLmFkZCYmdC5hZGRDbGFzcyhzLmhhc25hdmJhciksby5hcHBlbmQoJzxhIGNsYXNzPVwiJytzLnRpdGxlKydcIicrKGwubGVuZ3RoPycgaHJlZj1cIicrbCsnXCInOlwiXCIpK1wiPlwiK3IrXCI8L2E+XCIpLnByZXBlbmRUbyh0KSx0aGlzLnRyaWdnZXIoXCJpbml0TmF2YmFyOmFmdGVyXCIsdCl9fSxfaW5pdExpc3R2aWV3OmZ1bmN0aW9uKHQpe3RoaXMudHJpZ2dlcihcImluaXRMaXN0dmlldzpiZWZvcmVcIix0KTt2YXIgbj10aGlzLl9fY2hpbGRBZGRCYWNrKHQsXCJ1bCwgb2xcIik7dGhpcy5fX3JlZmFjdG9yQ2xhc3Mobix0aGlzLmNvbmYuY2xhc3NOYW1lcy5ub2xpc3R2aWV3LFwibm9saXN0dmlld1wiKSxuLmZpbHRlcihcIi5cIit0aGlzLmNvbmYuY2xhc3NOYW1lcy5pbnNldCkuYWRkQ2xhc3Mocy5ub2xpc3R2aWV3KTt2YXIgaT1uLm5vdChcIi5cIitzLm5vbGlzdHZpZXcpLmFkZENsYXNzKHMubGlzdHZpZXcpLmNoaWxkcmVuKCk7dGhpcy5fX3JlZmFjdG9yQ2xhc3MoaSx0aGlzLmNvbmYuY2xhc3NOYW1lcy5zZWxlY3RlZCxcInNlbGVjdGVkXCIpLHRoaXMuX19yZWZhY3RvckNsYXNzKGksdGhpcy5jb25mLmNsYXNzTmFtZXMuZGl2aWRlcixcImRpdmlkZXJcIiksdGhpcy5fX3JlZmFjdG9yQ2xhc3MoaSx0aGlzLmNvbmYuY2xhc3NOYW1lcy5zcGFjZXIsXCJzcGFjZXJcIik7dmFyIG89dC5kYXRhKGEucGFyZW50KTtpZihvJiZvLnBhcmVudCgpLmlzKFwiLlwiK3MubGlzdHZpZXcpJiYhby5jaGlsZHJlbihcIi5cIitzLm5leHQpLmxlbmd0aCl7dmFyIHI9by5jaGlsZHJlbihcImEsIHNwYW5cIikuZmlyc3QoKSxsPWUoJzxhIGNsYXNzPVwiJytzLm5leHQrJ1wiIGhyZWY9XCIjJyt0LmF0dHIoXCJpZFwiKSsnXCIgLz4nKS5pbnNlcnRCZWZvcmUocik7ci5pcyhcInNwYW5cIikmJmwuYWRkQ2xhc3Mocy5mdWxsc3Vib3Blbil9dGhpcy50cmlnZ2VyKFwiaW5pdExpc3R2aWV3OmFmdGVyXCIsdCl9LF9pbml0T3BlbmVkOmZ1bmN0aW9uKCl7dGhpcy50cmlnZ2VyKFwiaW5pdE9wZW5lZDpiZWZvcmVcIik7dmFyIGU9dGhpcy4kcG5scy5maW5kKFwiLlwiK3MubGlzdHZpZXcpLmNoaWxkcmVuKFwiLlwiK3Muc2VsZWN0ZWQpLnJlbW92ZUNsYXNzKHMuc2VsZWN0ZWQpLmxhc3QoKS5hZGRDbGFzcyhzLnNlbGVjdGVkKSx0PWUubGVuZ3RoP2UuY2xvc2VzdChcIi5cIitzLnBhbmVsKTp0aGlzLiRwbmxzLmNoaWxkcmVuKFwiLlwiK3MucGFuZWwpLmZpcnN0KCk7dGhpcy5vcGVuUGFuZWwodCwhMSksdGhpcy50cmlnZ2VyKFwiaW5pdE9wZW5lZDphZnRlclwiKX0sX2luaXRBbmNob3JzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztyLiRib2R5Lm9uKG8uY2xpY2srXCItb25jYW52YXNcIixcImFbaHJlZl1cIixmdW5jdGlvbihpKXt2YXIgYT1lKHRoaXMpLG89ITEscj10LiRtZW51LmZpbmQoYSkubGVuZ3RoO2Zvcih2YXIgbCBpbiBlW25dLmFkZG9ucylpZihlW25dLmFkZG9uc1tsXS5jbGlja0FuY2hvci5jYWxsKHQsYSxyKSl7bz0hMDticmVha312YXIgZD1hLmF0dHIoXCJocmVmXCIpO2lmKCFvJiZyJiZkLmxlbmd0aD4xJiZcIiNcIj09ZC5zbGljZSgwLDEpKXRyeXt2YXIgYz1lKGQsdC4kbWVudSk7Yy5pcyhcIi5cIitzLnBhbmVsKSYmKG89ITAsdFthLnBhcmVudCgpLmhhc0NsYXNzKHMudmVydGljYWwpP1widG9nZ2xlUGFuZWxcIjpcIm9wZW5QYW5lbFwiXShjKSl9Y2F0Y2goaCl7fWlmKG8mJmkucHJldmVudERlZmF1bHQoKSwhbyYmciYmYS5pcyhcIi5cIitzLmxpc3R2aWV3K1wiID4gbGkgPiBhXCIpJiYhYS5pcygnW3JlbD1cImV4dGVybmFsXCJdJykmJiFhLmlzKCdbdGFyZ2V0PVwiX2JsYW5rXCJdJykpe3QuX192YWx1ZU9yRm4odC5vcHRzLm9uQ2xpY2suc2V0U2VsZWN0ZWQsYSkmJnQuc2V0U2VsZWN0ZWQoZShpLnRhcmdldCkucGFyZW50KCkpO3ZhciBmPXQuX192YWx1ZU9yRm4odC5vcHRzLm9uQ2xpY2sucHJldmVudERlZmF1bHQsYSxcIiNcIj09ZC5zbGljZSgwLDEpKTtmJiZpLnByZXZlbnREZWZhdWx0KCksdC5fX3ZhbHVlT3JGbih0Lm9wdHMub25DbGljay5jbG9zZSxhLGYpJiZ0Lm9wdHMub2ZmQ2FudmFzJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LmNsb3NlJiZ0LmNsb3NlKCl9fSl9LF9pbml0TWF0Y2hNZWRpYTpmdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5fZmlyZU1hdGNoTWVkaWEoKSxyLiR3bmR3Lm9uKG8ucmVzaXplLGZ1bmN0aW9uKHQpe2UuX2ZpcmVNYXRjaE1lZGlhKCl9KX0sX2ZpcmVNYXRjaE1lZGlhOmZ1bmN0aW9uKCl7Zm9yKHZhciBlIGluIHRoaXMubXRjaClmb3IodmFyIHQ9d2luZG93Lm1hdGNoTWVkaWEmJndpbmRvdy5tYXRjaE1lZGlhKGUpLm1hdGNoZXM/XCJ5ZXNcIjpcIm5vXCIsbj0wO248dGhpcy5tdGNoW2VdLmxlbmd0aDtuKyspdGhpcy5tdGNoW2VdW25dW3RdLmNhbGwodGhpcyl9LF9nZXRPcmlnaW5hbE1lbnVJZDpmdW5jdGlvbigpe3ZhciBlPXRoaXMuJG1lbnUuYXR0cihcImlkXCIpO3JldHVybiB0aGlzLmNvbmYuY2xvbmUmJmUmJmUubGVuZ3RoJiYoZT1zLnVtbShlKSksZX0sX19hcGk6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLG49e307cmV0dXJuIGUuZWFjaCh0aGlzLl9hcGksZnVuY3Rpb24oZSl7dmFyIGk9dGhpcztuW2ldPWZ1bmN0aW9uKCl7dmFyIGU9dFtpXS5hcHBseSh0LGFyZ3VtZW50cyk7cmV0dXJuXCJ1bmRlZmluZWRcIj09dHlwZW9mIGU/bjplfX0pLG59LF9fdmFsdWVPckZuOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlP2UuY2FsbCh0WzBdKTpcInVuZGVmaW5lZFwiPT10eXBlb2YgZSYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG4/bjplfSxfX3JlZmFjdG9yQ2xhc3M6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlLmZpbHRlcihcIi5cIit0KS5yZW1vdmVDbGFzcyh0KS5hZGRDbGFzcyhzW25dKX0sX19maW5kQWRkQmFjazpmdW5jdGlvbihlLHQpe3JldHVybiBlLmZpbmQodCkuYWRkKGUuZmlsdGVyKHQpKX0sX19jaGlsZEFkZEJhY2s6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5jaGlsZHJlbih0KS5hZGQoZS5maWx0ZXIodCkpfSxfX2ZpbHRlckxpc3RJdGVtczpmdW5jdGlvbihlKXtyZXR1cm4gZS5ub3QoXCIuXCIrcy5kaXZpZGVyKS5ub3QoXCIuXCIrcy5oaWRkZW4pfSxfX2ZpbHRlckxpc3RJdGVtQW5jaG9yczpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fX2ZpbHRlckxpc3RJdGVtcyhlKS5jaGlsZHJlbihcImFcIikubm90KFwiLlwiK3MubmV4dCl9LF9fdHJhbnNpdGlvbmVuZDpmdW5jdGlvbihlLHQsbil7dmFyIGk9ITEscz1mdW5jdGlvbihuKXtcInVuZGVmaW5lZFwiIT10eXBlb2YgbiYmbi50YXJnZXQhPWVbMF18fChpfHwoZS5vZmYoby50cmFuc2l0aW9uZW5kKSxlLm9mZihvLndlYmtpdFRyYW5zaXRpb25FbmQpLHQuY2FsbChlWzBdKSksaT0hMCl9O2Uub24oby50cmFuc2l0aW9uZW5kLHMpLGUub24oby53ZWJraXRUcmFuc2l0aW9uRW5kLHMpLHNldFRpbWVvdXQocywxLjEqbil9LF9fZ2V0VW5pcXVlSWQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5tbShlW25dLnVuaXF1ZUlkKyspfX0sZS5mbltuXT1mdW5jdGlvbihpLHMpe3QoKSxpPWUuZXh0ZW5kKCEwLHt9LGVbbl0uZGVmYXVsdHMsaSkscz1lLmV4dGVuZCghMCx7fSxlW25dLmNvbmZpZ3VyYXRpb24scyk7dmFyIGE9ZSgpO3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgdD1lKHRoaXMpO2lmKCF0LmRhdGEobikpe3ZhciBvPW5ldyBlW25dKHQsaSxzKTtvLiRtZW51LmRhdGEobixvLl9fYXBpKCkpLGE9YS5hZGQoby4kbWVudSl9fSksYX0sZVtuXS5pMThuPWZ1bmN0aW9uKCl7dmFyIHQ9e307cmV0dXJuIGZ1bmN0aW9uKG4pe3N3aXRjaCh0eXBlb2Ygbil7Y2FzZVwib2JqZWN0XCI6cmV0dXJuIGUuZXh0ZW5kKHQsbiksdDtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gdFtuXXx8bjtjYXNlXCJ1bmRlZmluZWRcIjpkZWZhdWx0OnJldHVybiB0fX19KCksZVtuXS5zdXBwb3J0PXt0b3VjaDpcIm9udG91Y2hzdGFydFwiaW4gd2luZG93fHxuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50c3x8ITEsY3NzdHJhbnNpdGlvbnM6ZnVuY3Rpb24oKXtyZXR1cm5cInVuZGVmaW5lZFwiPT10eXBlb2YgTW9kZXJuaXpyfHxcInVuZGVmaW5lZFwiPT10eXBlb2YgTW9kZXJuaXpyLmNzc3RyYW5zaXRpb25zfHxNb2Rlcm5penIuY3NzdHJhbnNpdGlvbnN9KCksY3NzdHJhbnNmb3JtczpmdW5jdGlvbigpe3JldHVyblwidW5kZWZpbmVkXCI9PXR5cGVvZiBNb2Rlcm5penJ8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiBNb2Rlcm5penIuY3NzdHJhbnNmb3Jtc3x8TW9kZXJuaXpyLmNzc3RyYW5zZm9ybXN9KCksY3NzdHJhbnNmb3JtczNkOmZ1bmN0aW9uKCl7cmV0dXJuXCJ1bmRlZmluZWRcIj09dHlwZW9mIE1vZGVybml6cnx8XCJ1bmRlZmluZWRcIj09dHlwZW9mIE1vZGVybml6ci5jc3N0cmFuc2Zvcm1zM2R8fE1vZGVybml6ci5jc3N0cmFuc2Zvcm1zM2R9KCl9O3ZhciBzLGEsbyxyfX0oalF1ZXJ5KSwvKlxuICogalF1ZXJ5IG1tZW51IG9mZkNhbnZhcyBhZGQtb25cbiAqIG1tZW51LmZyZWJzaXRlLm5sXG4gKlxuICogQ29weXJpZ2h0IChjKSBGcmVkIEhldXNzY2hlblxuICovXG5mdW5jdGlvbihlKXt2YXIgdD1cIm1tZW51XCIsbj1cIm9mZkNhbnZhc1wiO2VbdF0uYWRkb25zW25dPXtzZXR1cDpmdW5jdGlvbigpe2lmKHRoaXMub3B0c1tuXSl7dmFyIHM9dGhpcyxhPXRoaXMub3B0c1tuXSxyPXRoaXMuY29uZltuXTtvPWVbdF0uZ2xibCx0aGlzLl9hcGk9ZS5tZXJnZSh0aGlzLl9hcGksW1wib3BlblwiLFwiY2xvc2VcIixcInNldFBhZ2VcIl0pLFwib2JqZWN0XCIhPXR5cGVvZiBhJiYoYT17fSksXCJ0b3BcIiE9YS5wb3NpdGlvbiYmXCJib3R0b21cIiE9YS5wb3NpdGlvbnx8KGEuenBvc2l0aW9uPVwiZnJvbnRcIiksYT10aGlzLm9wdHNbbl09ZS5leHRlbmQoITAse30sZVt0XS5kZWZhdWx0c1tuXSxhKSxcInN0cmluZ1wiIT10eXBlb2Ygci5wYWdlU2VsZWN0b3ImJihyLnBhZ2VTZWxlY3Rvcj1cIj4gXCIrci5wYWdlTm9kZXR5cGUpLHRoaXMudmFycy5vcGVuZWQ9ITE7dmFyIGw9W2kub2ZmY2FudmFzXTtcImxlZnRcIiE9YS5wb3NpdGlvbiYmbC5wdXNoKGkubW0oYS5wb3NpdGlvbikpLFwiYmFja1wiIT1hLnpwb3NpdGlvbiYmbC5wdXNoKGkubW0oYS56cG9zaXRpb24pKSxlW3RdLnN1cHBvcnQuY3NzdHJhbnNmb3Jtc3x8bC5wdXNoKGlbXCJuby1jc3N0cmFuc2Zvcm1zXCJdKSxlW3RdLnN1cHBvcnQuY3NzdHJhbnNmb3JtczNkfHxsLnB1c2goaVtcIm5vLWNzc3RyYW5zZm9ybXMzZFwiXSksdGhpcy5iaW5kKFwiaW5pdE1lbnU6YWZ0ZXJcIixmdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5zZXRQYWdlKG8uJHBhZ2UpLHRoaXMuX2luaXRCbG9ja2VyKCksdGhpc1tcIl9pbml0V2luZG93X1wiK25dKCksdGhpcy4kbWVudS5hZGRDbGFzcyhsLmpvaW4oXCIgXCIpKS5wYXJlbnQoXCIuXCIraS53cmFwcGVyKS5yZW1vdmVDbGFzcyhpLndyYXBwZXIpLHRoaXMuJG1lbnVbci5tZW51SW5zZXJ0TWV0aG9kXShyLm1lbnVJbnNlcnRTZWxlY3Rvcik7dmFyIHQ9d2luZG93LmxvY2F0aW9uLmhhc2g7aWYodCl7dmFyIHM9dGhpcy5fZ2V0T3JpZ2luYWxNZW51SWQoKTtzJiZzPT10LnNsaWNlKDEpJiZzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5vcGVuKCl9LDFlMyl9fSksdGhpcy5iaW5kKFwiaW5pdEV4dGVuc2lvbnM6YWZ0ZXJcIixmdW5jdGlvbigpe2Zvcih2YXIgZT1baS5tbShcIndpZGVzY3JlZW5cIiksaS5tbShcImljb25iYXJcIildLHQ9MDt0PGUubGVuZ3RoO3QrKylmb3IodmFyIG4gaW4gdGhpcy5vcHRzLmV4dGVuc2lvbnMpaWYodGhpcy5vcHRzLmV4dGVuc2lvbnNbbl0uaW5kZXhPZihlW3RdKT4tMSl7IWZ1bmN0aW9uKHQsbil7cy5tYXRjaE1lZGlhKHQsZnVuY3Rpb24oKXtvLiRodG1sLmFkZENsYXNzKGVbbl0pfSxmdW5jdGlvbigpe28uJGh0bWwucmVtb3ZlQ2xhc3MoZVtuXSl9KX0obix0KTticmVha319KSx0aGlzLmJpbmQoXCJvcGVuOnN0YXJ0OnNyLWFyaWFcIixmdW5jdGlvbigpe3RoaXMuX19zcl9hcmlhKHRoaXMuJG1lbnUsXCJoaWRkZW5cIiwhMSl9KSx0aGlzLmJpbmQoXCJjbG9zZTpmaW5pc2g6c3ItYXJpYVwiLGZ1bmN0aW9uKCl7dGhpcy5fX3NyX2FyaWEodGhpcy4kbWVudSxcImhpZGRlblwiLCEwKX0pLHRoaXMuYmluZChcImluaXRNZW51OmFmdGVyOnNyLWFyaWFcIixmdW5jdGlvbigpe3RoaXMuX19zcl9hcmlhKHRoaXMuJG1lbnUsXCJoaWRkZW5cIiwhMCl9KX19LGFkZDpmdW5jdGlvbigpe2k9ZVt0XS5fYyxzPWVbdF0uX2QsYT1lW3RdLl9lLGkuYWRkKFwib2ZmY2FudmFzIHNsaWRlb3V0IGJsb2NraW5nIG1vZGFsIGJhY2tncm91bmQgb3BlbmluZyBibG9ja2VyIHBhZ2Ugbm8tY3NzdHJhbnNmb3JtczNkXCIpLHMuYWRkKFwic3R5bGVcIil9LGNsaWNrQW5jaG9yOmZ1bmN0aW9uKGUsdCl7dmFyIHM9dGhpcztpZih0aGlzLm9wdHNbbl0pe3ZhciBhPXRoaXMuX2dldE9yaWdpbmFsTWVudUlkKCk7aWYoYSYmZS5pcygnW2hyZWY9XCIjJythKydcIl0nKSl7aWYodClyZXR1cm4hMDt2YXIgcj1lLmNsb3Nlc3QoXCIuXCIraS5tZW51KTtpZihyLmxlbmd0aCl7dmFyIGw9ci5kYXRhKFwibW1lbnVcIik7aWYobCYmbC5jbG9zZSlyZXR1cm4gbC5jbG9zZSgpLHMuX190cmFuc2l0aW9uZW5kKHIsZnVuY3Rpb24oKXtzLm9wZW4oKX0scy5jb25mLnRyYW5zaXRpb25EdXJhdGlvbiksITB9cmV0dXJuIHRoaXMub3BlbigpLCEwfWlmKG8uJHBhZ2UpcmV0dXJuIGE9by4kcGFnZS5maXJzdCgpLmF0dHIoXCJpZFwiKSxhJiZlLmlzKCdbaHJlZj1cIiMnK2ErJ1wiXScpPyh0aGlzLmNsb3NlKCksITApOnZvaWQgMH19fSxlW3RdLmRlZmF1bHRzW25dPXtwb3NpdGlvbjpcImxlZnRcIix6cG9zaXRpb246XCJiYWNrXCIsYmxvY2tVSTohMCxtb3ZlQmFja2dyb3VuZDohMH0sZVt0XS5jb25maWd1cmF0aW9uW25dPXtwYWdlTm9kZXR5cGU6XCJkaXZcIixwYWdlU2VsZWN0b3I6bnVsbCxub1BhZ2VTZWxlY3RvcjpbXSx3cmFwUGFnZUlmTmVlZGVkOiEwLG1lbnVJbnNlcnRNZXRob2Q6XCJwcmVwZW5kVG9cIixtZW51SW5zZXJ0U2VsZWN0b3I6XCJib2R5XCJ9LGVbdF0ucHJvdG90eXBlLm9wZW49ZnVuY3Rpb24oKXtpZih0aGlzLnRyaWdnZXIoXCJvcGVuOmJlZm9yZVwiKSwhdGhpcy52YXJzLm9wZW5lZCl7dmFyIGU9dGhpczt0aGlzLl9vcGVuU2V0dXAoKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5fb3BlbkZpbmlzaCgpfSx0aGlzLmNvbmYub3BlbmluZ0ludGVydmFsKSx0aGlzLnRyaWdnZXIoXCJvcGVuOmFmdGVyXCIpfX0sZVt0XS5wcm90b3R5cGUuX29wZW5TZXR1cD1mdW5jdGlvbigpe3ZhciB0PXRoaXMscj10aGlzLm9wdHNbbl07dGhpcy5jbG9zZUFsbE90aGVycygpLG8uJHBhZ2UuZWFjaChmdW5jdGlvbigpe2UodGhpcykuZGF0YShzLnN0eWxlLGUodGhpcykuYXR0cihcInN0eWxlXCIpfHxcIlwiKX0pLG8uJHduZHcudHJpZ2dlcihhLnJlc2l6ZStcIi1cIituLFshMF0pO3ZhciBsPVtpLm9wZW5lZF07ci5ibG9ja1VJJiZsLnB1c2goaS5ibG9ja2luZyksXCJtb2RhbFwiPT1yLmJsb2NrVUkmJmwucHVzaChpLm1vZGFsKSxyLm1vdmVCYWNrZ3JvdW5kJiZsLnB1c2goaS5iYWNrZ3JvdW5kKSxcImxlZnRcIiE9ci5wb3NpdGlvbiYmbC5wdXNoKGkubW0odGhpcy5vcHRzW25dLnBvc2l0aW9uKSksXCJiYWNrXCIhPXIuenBvc2l0aW9uJiZsLnB1c2goaS5tbSh0aGlzLm9wdHNbbl0uenBvc2l0aW9uKSksby4kaHRtbC5hZGRDbGFzcyhsLmpvaW4oXCIgXCIpKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dC52YXJzLm9wZW5lZD0hMH0sdGhpcy5jb25mLm9wZW5pbmdJbnRlcnZhbCksdGhpcy4kbWVudS5hZGRDbGFzcyhpLm9wZW5lZCl9LGVbdF0ucHJvdG90eXBlLl9vcGVuRmluaXNoPWZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLl9fdHJhbnNpdGlvbmVuZChvLiRwYWdlLmZpcnN0KCksZnVuY3Rpb24oKXtlLnRyaWdnZXIoXCJvcGVuOmZpbmlzaFwiKX0sdGhpcy5jb25mLnRyYW5zaXRpb25EdXJhdGlvbiksdGhpcy50cmlnZ2VyKFwib3BlbjpzdGFydFwiKSxvLiRodG1sLmFkZENsYXNzKGkub3BlbmluZyl9LGVbdF0ucHJvdG90eXBlLmNsb3NlPWZ1bmN0aW9uKCl7aWYodGhpcy50cmlnZ2VyKFwiY2xvc2U6YmVmb3JlXCIpLHRoaXMudmFycy5vcGVuZWQpe3ZhciB0PXRoaXM7dGhpcy5fX3RyYW5zaXRpb25lbmQoby4kcGFnZS5maXJzdCgpLGZ1bmN0aW9uKCl7dC4kbWVudS5yZW1vdmVDbGFzcyhpLm9wZW5lZCk7dmFyIGE9W2kub3BlbmVkLGkuYmxvY2tpbmcsaS5tb2RhbCxpLmJhY2tncm91bmQsaS5tbSh0Lm9wdHNbbl0ucG9zaXRpb24pLGkubW0odC5vcHRzW25dLnpwb3NpdGlvbildO28uJGh0bWwucmVtb3ZlQ2xhc3MoYS5qb2luKFwiIFwiKSksby4kcGFnZS5lYWNoKGZ1bmN0aW9uKCl7ZSh0aGlzKS5hdHRyKFwic3R5bGVcIixlKHRoaXMpLmRhdGEocy5zdHlsZSkpfSksdC52YXJzLm9wZW5lZD0hMSx0LnRyaWdnZXIoXCJjbG9zZTpmaW5pc2hcIil9LHRoaXMuY29uZi50cmFuc2l0aW9uRHVyYXRpb24pLHRoaXMudHJpZ2dlcihcImNsb3NlOnN0YXJ0XCIpLG8uJGh0bWwucmVtb3ZlQ2xhc3MoaS5vcGVuaW5nKSx0aGlzLnRyaWdnZXIoXCJjbG9zZTphZnRlclwiKX19LGVbdF0ucHJvdG90eXBlLmNsb3NlQWxsT3RoZXJzPWZ1bmN0aW9uKCl7by4kYm9keS5maW5kKFwiLlwiK2kubWVudStcIi5cIitpLm9mZmNhbnZhcykubm90KHRoaXMuJG1lbnUpLmVhY2goZnVuY3Rpb24oKXt2YXIgbj1lKHRoaXMpLmRhdGEodCk7biYmbi5jbG9zZSYmbi5jbG9zZSgpfSl9LGVbdF0ucHJvdG90eXBlLnNldFBhZ2U9ZnVuY3Rpb24odCl7dGhpcy50cmlnZ2VyKFwic2V0UGFnZTpiZWZvcmVcIix0KTt2YXIgcz10aGlzLGE9dGhpcy5jb25mW25dO3QmJnQubGVuZ3RofHwodD1vLiRib2R5LmZpbmQoYS5wYWdlU2VsZWN0b3IpLGEubm9QYWdlU2VsZWN0b3IubGVuZ3RoJiYodD10Lm5vdChhLm5vUGFnZVNlbGVjdG9yLmpvaW4oXCIsIFwiKSkpLHQubGVuZ3RoPjEmJmEud3JhcFBhZ2VJZk5lZWRlZCYmKHQ9dC53cmFwQWxsKFwiPFwiK3RoaXMuY29uZltuXS5wYWdlTm9kZXR5cGUrXCIgLz5cIikucGFyZW50KCkpKSx0LmVhY2goZnVuY3Rpb24oKXtlKHRoaXMpLmF0dHIoXCJpZFwiLGUodGhpcykuYXR0cihcImlkXCIpfHxzLl9fZ2V0VW5pcXVlSWQoKSl9KSx0LmFkZENsYXNzKGkucGFnZStcIiBcIitpLnNsaWRlb3V0KSxvLiRwYWdlPXQsdGhpcy50cmlnZ2VyKFwic2V0UGFnZTphZnRlclwiLHQpfSxlW3RdLnByb3RvdHlwZVtcIl9pbml0V2luZG93X1wiK25dPWZ1bmN0aW9uKCl7by4kd25kdy5vZmYoYS5rZXlkb3duK1wiLVwiK24pLm9uKGEua2V5ZG93bitcIi1cIituLGZ1bmN0aW9uKGUpe2lmKG8uJGh0bWwuaGFzQ2xhc3MoaS5vcGVuZWQpJiY5PT1lLmtleUNvZGUpcmV0dXJuIGUucHJldmVudERlZmF1bHQoKSwhMX0pO3ZhciBlPTA7by4kd25kdy5vZmYoYS5yZXNpemUrXCItXCIrbikub24oYS5yZXNpemUrXCItXCIrbixmdW5jdGlvbih0LG4pe2lmKDE9PW8uJHBhZ2UubGVuZ3RoJiYobnx8by4kaHRtbC5oYXNDbGFzcyhpLm9wZW5lZCkpKXt2YXIgcz1vLiR3bmR3LmhlaWdodCgpOyhufHxzIT1lKSYmKGU9cyxvLiRwYWdlLmNzcyhcIm1pbkhlaWdodFwiLHMpKX19KX0sZVt0XS5wcm90b3R5cGUuX2luaXRCbG9ja2VyPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLm9wdHNbbl0uYmxvY2tVSSYmKG8uJGJsY2t8fChvLiRibGNrPWUoJzxkaXYgaWQ9XCInK2kuYmxvY2tlcisnXCIgY2xhc3M9XCInK2kuc2xpZGVvdXQrJ1wiIC8+JykpLG8uJGJsY2suYXBwZW5kVG8oby4kYm9keSkub2ZmKGEudG91Y2hzdGFydCtcIi1cIituK1wiIFwiK2EudG91Y2htb3ZlK1wiLVwiK24pLm9uKGEudG91Y2hzdGFydCtcIi1cIituK1wiIFwiK2EudG91Y2htb3ZlK1wiLVwiK24sZnVuY3Rpb24oZSl7ZS5wcmV2ZW50RGVmYXVsdCgpLGUuc3RvcFByb3BhZ2F0aW9uKCksby4kYmxjay50cmlnZ2VyKGEubW91c2Vkb3duK1wiLVwiK24pfSkub2ZmKGEubW91c2Vkb3duK1wiLVwiK24pLm9uKGEubW91c2Vkb3duK1wiLVwiK24sZnVuY3Rpb24oZSl7ZS5wcmV2ZW50RGVmYXVsdCgpLG8uJGh0bWwuaGFzQ2xhc3MoaS5tb2RhbCl8fCh0LmNsb3NlQWxsT3RoZXJzKCksdC5jbG9zZSgpKX0pKX07dmFyIGkscyxhLG99KGpRdWVyeSksLypcbiAqIGpRdWVyeSBtbWVudSBzY3JvbGxCdWdGaXggYWRkLW9uXG4gKiBtbWVudS5mcmVic2l0ZS5ubFxuICpcbiAqIENvcHlyaWdodCAoYykgRnJlZCBIZXVzc2NoZW5cbiAqL1xuZnVuY3Rpb24oZSl7dmFyIHQ9XCJtbWVudVwiLG49XCJzY3JvbGxCdWdGaXhcIjtlW3RdLmFkZG9uc1tuXT17c2V0dXA6ZnVuY3Rpb24oKXt2YXIgcz10aGlzLm9wdHNbbl07dGhpcy5jb25mW25dO289ZVt0XS5nbGJsLGVbdF0uc3VwcG9ydC50b3VjaCYmdGhpcy5vcHRzLm9mZkNhbnZhcyYmdGhpcy5vcHRzLm9mZkNhbnZhcy5ibG9ja1VJJiYoXCJib29sZWFuXCI9PXR5cGVvZiBzJiYocz17Zml4OnN9KSxcIm9iamVjdFwiIT10eXBlb2YgcyYmKHM9e30pLHM9dGhpcy5vcHRzW25dPWUuZXh0ZW5kKCEwLHt9LGVbdF0uZGVmYXVsdHNbbl0scykscy5maXgmJih0aGlzLmJpbmQoXCJvcGVuOnN0YXJ0XCIsZnVuY3Rpb24oKXt0aGlzLiRwbmxzLmNoaWxkcmVuKFwiLlwiK2kub3BlbmVkKS5zY3JvbGxUb3AoMCl9KSx0aGlzLmJpbmQoXCJpbml0TWVudTphZnRlclwiLGZ1bmN0aW9uKCl7dGhpc1tcIl9pbml0V2luZG93X1wiK25dKCl9KSkpfSxhZGQ6ZnVuY3Rpb24oKXtpPWVbdF0uX2Mscz1lW3RdLl9kLGE9ZVt0XS5fZX0sY2xpY2tBbmNob3I6ZnVuY3Rpb24oZSx0KXt9fSxlW3RdLmRlZmF1bHRzW25dPXtmaXg6ITB9LGVbdF0ucHJvdG90eXBlW1wiX2luaXRXaW5kb3dfXCIrbl09ZnVuY3Rpb24oKXt2YXIgdD10aGlzO28uJGRvY3Uub2ZmKGEudG91Y2htb3ZlK1wiLVwiK24pLm9uKGEudG91Y2htb3ZlK1wiLVwiK24sZnVuY3Rpb24oZSl7by4kaHRtbC5oYXNDbGFzcyhpLm9wZW5lZCkmJmUucHJldmVudERlZmF1bHQoKX0pO3ZhciBzPSExO28uJGJvZHkub2ZmKGEudG91Y2hzdGFydCtcIi1cIituKS5vbihhLnRvdWNoc3RhcnQrXCItXCIrbixcIi5cIitpLnBhbmVscytcIj4gLlwiK2kucGFuZWwsZnVuY3Rpb24oZSl7by4kaHRtbC5oYXNDbGFzcyhpLm9wZW5lZCkmJihzfHwocz0hMCwwPT09ZS5jdXJyZW50VGFyZ2V0LnNjcm9sbFRvcD9lLmN1cnJlbnRUYXJnZXQuc2Nyb2xsVG9wPTE6ZS5jdXJyZW50VGFyZ2V0LnNjcm9sbEhlaWdodD09PWUuY3VycmVudFRhcmdldC5zY3JvbGxUb3ArZS5jdXJyZW50VGFyZ2V0Lm9mZnNldEhlaWdodCYmKGUuY3VycmVudFRhcmdldC5zY3JvbGxUb3AtPTEpLHM9ITEpKX0pLm9mZihhLnRvdWNobW92ZStcIi1cIituKS5vbihhLnRvdWNobW92ZStcIi1cIituLFwiLlwiK2kucGFuZWxzK1wiPiAuXCIraS5wYW5lbCxmdW5jdGlvbih0KXtvLiRodG1sLmhhc0NsYXNzKGkub3BlbmVkKSYmZSh0aGlzKVswXS5zY3JvbGxIZWlnaHQ+ZSh0aGlzKS5pbm5lckhlaWdodCgpJiZ0LnN0b3BQcm9wYWdhdGlvbigpfSksby4kd25kdy5vZmYoYS5vcmllbnRhdGlvbmNoYW5nZStcIi1cIituKS5vbihhLm9yaWVudGF0aW9uY2hhbmdlK1wiLVwiK24sZnVuY3Rpb24oKXt0LiRwbmxzLmNoaWxkcmVuKFwiLlwiK2kub3BlbmVkKS5zY3JvbGxUb3AoMCkuY3NzKHtcIi13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nXCI6XCJhdXRvXCJ9KS5jc3Moe1wiLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmdcIjpcInRvdWNoXCJ9KX0pfTt2YXIgaSxzLGEsb30oalF1ZXJ5KSwvKlxuICogalF1ZXJ5IG1tZW51IHNjcmVlblJlYWRlciBhZGQtb25cbiAqIG1tZW51LmZyZWJzaXRlLm5sXG4gKlxuICogQ29weXJpZ2h0IChjKSBGcmVkIEhldXNzY2hlblxuICovXG5mdW5jdGlvbihlKXt2YXIgdD1cIm1tZW51XCIsbj1cInNjcmVlblJlYWRlclwiO2VbdF0uYWRkb25zW25dPXtzZXR1cDpmdW5jdGlvbigpe3ZhciBhPXRoaXMscj10aGlzLm9wdHNbbl0sbD10aGlzLmNvbmZbbl07bz1lW3RdLmdsYmwsXCJib29sZWFuXCI9PXR5cGVvZiByJiYocj17YXJpYTpyLHRleHQ6cn0pLFwib2JqZWN0XCIhPXR5cGVvZiByJiYocj17fSkscj10aGlzLm9wdHNbbl09ZS5leHRlbmQoITAse30sZVt0XS5kZWZhdWx0c1tuXSxyKSxyLmFyaWEmJih0aGlzLmJpbmQoXCJpbml0QWRkb25zOmFmdGVyXCIsZnVuY3Rpb24oKXt0aGlzLmJpbmQoXCJpbml0TWVudTphZnRlclwiLGZ1bmN0aW9uKCl7dGhpcy50cmlnZ2VyKFwiaW5pdE1lbnU6YWZ0ZXI6c3ItYXJpYVwiKX0pLHRoaXMuYmluZChcImluaXROYXZiYXI6YWZ0ZXJcIixmdW5jdGlvbigpe3RoaXMudHJpZ2dlcihcImluaXROYXZiYXI6YWZ0ZXI6c3ItYXJpYVwiLGFyZ3VtZW50c1swXSl9KSx0aGlzLmJpbmQoXCJvcGVuUGFuZWw6c3RhcnRcIixmdW5jdGlvbigpe3RoaXMudHJpZ2dlcihcIm9wZW5QYW5lbDpzdGFydDpzci1hcmlhXCIsYXJndW1lbnRzWzBdKX0pLHRoaXMuYmluZChcImNsb3NlOnN0YXJ0XCIsZnVuY3Rpb24oKXt0aGlzLnRyaWdnZXIoXCJjbG9zZTpzdGFydDpzci1hcmlhXCIpfSksdGhpcy5iaW5kKFwiY2xvc2U6ZmluaXNoXCIsZnVuY3Rpb24oKXt0aGlzLnRyaWdnZXIoXCJjbG9zZTpmaW5pc2g6c3ItYXJpYVwiKX0pLHRoaXMuYmluZChcIm9wZW46c3RhcnRcIixmdW5jdGlvbigpe3RoaXMudHJpZ2dlcihcIm9wZW46c3RhcnQ6c3ItYXJpYVwiKX0pLHRoaXMuYmluZChcIm9wZW46ZmluaXNoXCIsZnVuY3Rpb24oKXt0aGlzLnRyaWdnZXIoXCJvcGVuOmZpbmlzaDpzci1hcmlhXCIpfSl9KSx0aGlzLmJpbmQoXCJ1cGRhdGVMaXN0dmlld1wiLGZ1bmN0aW9uKCl7dGhpcy4kcG5scy5maW5kKFwiLlwiK2kubGlzdHZpZXcpLmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbigpe2EuX19zcl9hcmlhKGUodGhpcyksXCJoaWRkZW5cIixlKHRoaXMpLmlzKFwiLlwiK2kuaGlkZGVuKSl9KX0pLHRoaXMuYmluZChcIm9wZW5QYW5lbDpzdGFydFwiLGZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuJG1lbnUuZmluZChcIi5cIitpLnBhbmVsKS5ub3QoZSkubm90KGUucGFyZW50cyhcIi5cIitpLnBhbmVsKSksbj1lLmFkZChlLmZpbmQoXCIuXCIraS52ZXJ0aWNhbCtcIi5cIitpLm9wZW5lZCkuY2hpbGRyZW4oXCIuXCIraS5wYW5lbCkpO3RoaXMuX19zcl9hcmlhKHQsXCJoaWRkZW5cIiwhMCksdGhpcy5fX3NyX2FyaWEobixcImhpZGRlblwiLCExKX0pLHRoaXMuYmluZChcImNsb3NlUGFuZWxcIixmdW5jdGlvbihlKXt0aGlzLl9fc3JfYXJpYShlLFwiaGlkZGVuXCIsITApfSksdGhpcy5iaW5kKFwiaW5pdFBhbmVsczphZnRlclwiLGZ1bmN0aW9uKHQpe3ZhciBuPXQuZmluZChcIi5cIitpLnByZXYrXCIsIC5cIitpLm5leHQpLmVhY2goZnVuY3Rpb24oKXthLl9fc3JfYXJpYShlKHRoaXMpLFwib3duc1wiLGUodGhpcykuYXR0cihcImhyZWZcIikucmVwbGFjZShcIiNcIixcIlwiKSl9KTt0aGlzLl9fc3JfYXJpYShuLFwiaGFzcG9wdXBcIiwhMCl9KSx0aGlzLmJpbmQoXCJpbml0TmF2YmFyOmFmdGVyXCIsZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jaGlsZHJlbihcIi5cIitpLm5hdmJhcik7dGhpcy5fX3NyX2FyaWEodCxcImhpZGRlblwiLCFlLmhhc0NsYXNzKGkuaGFzbmF2YmFyKSl9KSxyLnRleHQmJih0aGlzLmJpbmQoXCJpbml0bGlzdHZpZXc6YWZ0ZXJcIixmdW5jdGlvbihlKXt2YXIgdD1lLmZpbmQoXCIuXCIraS5saXN0dmlldykuZmluZChcIi5cIitpLmZ1bGxzdWJvcGVuKS5wYXJlbnQoKS5jaGlsZHJlbihcInNwYW5cIik7dGhpcy5fX3NyX2FyaWEodCxcImhpZGRlblwiLCEwKX0pLFwicGFyZW50XCI9PXRoaXMub3B0cy5uYXZiYXIudGl0bGVMaW5rJiZ0aGlzLmJpbmQoXCJpbml0TmF2YmFyOmFmdGVyXCIsZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jaGlsZHJlbihcIi5cIitpLm5hdmJhciksbj0hIXQuY2hpbGRyZW4oXCIuXCIraS5wcmV2KS5sZW5ndGg7dGhpcy5fX3NyX2FyaWEodC5jaGlsZHJlbihcIi5cIitpLnRpdGxlKSxcImhpZGRlblwiLG4pfSkpKSxyLnRleHQmJih0aGlzLmJpbmQoXCJpbml0QWRkb25zOmFmdGVyXCIsZnVuY3Rpb24oKXt0aGlzLmJpbmQoXCJzZXRQYWdlOmFmdGVyXCIsZnVuY3Rpb24oKXt0aGlzLnRyaWdnZXIoXCJzZXRQYWdlOmFmdGVyOnNyLXRleHRcIixhcmd1bWVudHNbMF0pfSl9KSx0aGlzLmJpbmQoXCJpbml0TmF2YmFyOmFmdGVyXCIsZnVuY3Rpb24obil7dmFyIHM9bi5jaGlsZHJlbihcIi5cIitpLm5hdmJhciksYT1zLmNoaWxkcmVuKFwiLlwiK2kudGl0bGUpLnRleHQoKSxvPWVbdF0uaTE4bihsLnRleHQuY2xvc2VTdWJtZW51KTthJiYobys9XCIgKFwiK2ErXCIpXCIpLHMuY2hpbGRyZW4oXCIuXCIraS5wcmV2KS5odG1sKHRoaXMuX19zcl90ZXh0KG8pKX0pLHRoaXMuYmluZChcImluaXRMaXN0dmlldzphZnRlclwiLGZ1bmN0aW9uKG4pe3ZhciBvPW4uZGF0YShzLnBhcmVudCk7aWYobyYmby5sZW5ndGgpe3ZhciByPW8uY2hpbGRyZW4oXCIuXCIraS5uZXh0KSxkPXIubmV4dEFsbChcInNwYW4sIGFcIikuZmlyc3QoKS50ZXh0KCksYz1lW3RdLmkxOG4obC50ZXh0W3IucGFyZW50KCkuaXMoXCIuXCIraS52ZXJ0aWNhbCk/XCJ0b2dnbGVTdWJtZW51XCI6XCJvcGVuU3VibWVudVwiXSk7ZCYmKGMrPVwiIChcIitkK1wiKVwiKSxyLmh0bWwoYS5fX3NyX3RleHQoYykpfX0pKX0sYWRkOmZ1bmN0aW9uKCl7aT1lW3RdLl9jLHM9ZVt0XS5fZCxhPWVbdF0uX2UsaS5hZGQoXCJzcm9ubHlcIil9LGNsaWNrQW5jaG9yOmZ1bmN0aW9uKGUsdCl7fX0sZVt0XS5kZWZhdWx0c1tuXT17YXJpYTohMCx0ZXh0OiEwfSxlW3RdLmNvbmZpZ3VyYXRpb25bbl09e3RleHQ6e2Nsb3NlTWVudTpcIkNsb3NlIG1lbnVcIixjbG9zZVN1Ym1lbnU6XCJDbG9zZSBzdWJtZW51XCIsb3BlblN1Ym1lbnU6XCJPcGVuIHN1Ym1lbnVcIix0b2dnbGVTdWJtZW51OlwiVG9nZ2xlIHN1Ym1lbnVcIn19LGVbdF0ucHJvdG90eXBlLl9fc3JfYXJpYT1mdW5jdGlvbihlLHQsbil7ZS5wcm9wKFwiYXJpYS1cIit0LG4pW24/XCJhdHRyXCI6XCJyZW1vdmVBdHRyXCJdKFwiYXJpYS1cIit0LG4pfSxlW3RdLnByb3RvdHlwZS5fX3NyX3RleHQ9ZnVuY3Rpb24oZSl7cmV0dXJuJzxzcGFuIGNsYXNzPVwiJytpLnNyb25seSsnXCI+JytlK1wiPC9zcGFuPlwifTt2YXIgaSxzLGEsb30oalF1ZXJ5KSwvKlxuICogalF1ZXJ5IG1tZW51IGF1dG9IZWlnaHQgYWRkLW9uXG4gKiBtbWVudS5mcmVic2l0ZS5ubFxuICpcbiAqIENvcHlyaWdodCAoYykgRnJlZCBIZXVzc2NoZW5cbiAqL1xuZnVuY3Rpb24oZSl7dmFyIHQ9XCJtbWVudVwiLG49XCJhdXRvSGVpZ2h0XCI7ZVt0XS5hZGRvbnNbbl09e3NldHVwOmZ1bmN0aW9uKCl7dmFyIHM9dGhpcy5vcHRzW25dO3RoaXMuY29uZltuXTtpZihvPWVbdF0uZ2xibCxcImJvb2xlYW5cIj09dHlwZW9mIHMmJnMmJihzPXtoZWlnaHQ6XCJhdXRvXCJ9KSxcInN0cmluZ1wiPT10eXBlb2YgcyYmKHM9e2hlaWdodDpzfSksXCJvYmplY3RcIiE9dHlwZW9mIHMmJihzPXt9KSxzPXRoaXMub3B0c1tuXT1lLmV4dGVuZCghMCx7fSxlW3RdLmRlZmF1bHRzW25dLHMpLFwiYXV0b1wiPT1zLmhlaWdodHx8XCJoaWdoZXN0XCI9PXMuaGVpZ2h0KXt0aGlzLmJpbmQoXCJpbml0TWVudTphZnRlclwiLGZ1bmN0aW9uKCl7dGhpcy4kbWVudS5hZGRDbGFzcyhpLmF1dG9oZWlnaHQpfSk7dmFyIGE9ZnVuY3Rpb24odCl7aWYoIXRoaXMub3B0cy5vZmZDYW52YXN8fHRoaXMudmFycy5vcGVuZWQpe3ZhciBuPU1hdGgubWF4KHBhcnNlSW50KHRoaXMuJHBubHMuY3NzKFwidG9wXCIpLDEwKSwwKXx8MCxhPU1hdGgubWF4KHBhcnNlSW50KHRoaXMuJHBubHMuY3NzKFwiYm90dG9tXCIpLDEwKSwwKXx8MCxvPTA7dGhpcy4kbWVudS5hZGRDbGFzcyhpLm1lYXN1cmVoZWlnaHQpLFwiYXV0b1wiPT1zLmhlaWdodD8odD10fHx0aGlzLiRwbmxzLmNoaWxkcmVuKFwiLlwiK2kub3BlbmVkKSx0LmlzKFwiLlwiK2kudmVydGljYWwpJiYodD10LnBhcmVudHMoXCIuXCIraS5wYW5lbCkubm90KFwiLlwiK2kudmVydGljYWwpKSx0Lmxlbmd0aHx8KHQ9dGhpcy4kcG5scy5jaGlsZHJlbihcIi5cIitpLnBhbmVsKSksbz10LmZpcnN0KCkub3V0ZXJIZWlnaHQoKSk6XCJoaWdoZXN0XCI9PXMuaGVpZ2h0JiZ0aGlzLiRwbmxzLmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbigpe3ZhciB0PWUodGhpcyk7dC5pcyhcIi5cIitpLnZlcnRpY2FsKSYmKHQ9dC5wYXJlbnRzKFwiLlwiK2kucGFuZWwpLm5vdChcIi5cIitpLnZlcnRpY2FsKS5maXJzdCgpKSxvPU1hdGgubWF4KG8sdC5vdXRlckhlaWdodCgpKX0pLHRoaXMuJG1lbnUuaGVpZ2h0KG8rbithKS5yZW1vdmVDbGFzcyhpLm1lYXN1cmVoZWlnaHQpfX07dGhpcy5vcHRzLm9mZkNhbnZhcyYmdGhpcy5iaW5kKFwib3BlbjpzdGFydFwiLGEpLFwiaGlnaGVzdFwiPT1zLmhlaWdodCYmdGhpcy5iaW5kKFwiaW5pdFBhbmVsczphZnRlclwiLGEpLFwiYXV0b1wiPT1zLmhlaWdodCYmKHRoaXMuYmluZChcInVwZGF0ZUxpc3R2aWV3XCIsYSksdGhpcy5iaW5kKFwib3BlblBhbmVsOnN0YXJ0XCIsYSksdGhpcy5iaW5kKFwiY2xvc2VQYW5lbFwiLGEpKX19LGFkZDpmdW5jdGlvbigpe2k9ZVt0XS5fYyxzPWVbdF0uX2QsYT1lW3RdLl9lLGkuYWRkKFwiYXV0b2hlaWdodCBtZWFzdXJlaGVpZ2h0XCIpLGEuYWRkKFwicmVzaXplXCIpfSxjbGlja0FuY2hvcjpmdW5jdGlvbihlLHQpe319LGVbdF0uZGVmYXVsdHNbbl09e2hlaWdodDpcImRlZmF1bHRcIn07dmFyIGkscyxhLG99KGpRdWVyeSksLypcbiAqIGpRdWVyeSBtbWVudSBiYWNrQnV0dG9uIGFkZC1vblxuICogbW1lbnUuZnJlYnNpdGUubmxcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZyZWQgSGV1c3NjaGVuXG4gKi9cbmZ1bmN0aW9uKGUpe3ZhciB0PVwibW1lbnVcIixuPVwiYmFja0J1dHRvblwiO2VbdF0uYWRkb25zW25dPXtzZXR1cDpmdW5jdGlvbigpe2lmKHRoaXMub3B0cy5vZmZDYW52YXMpe3ZhciBzPXRoaXMsYT10aGlzLm9wdHNbbl07dGhpcy5jb25mW25dO2lmKG89ZVt0XS5nbGJsLFwiYm9vbGVhblwiPT10eXBlb2YgYSYmKGE9e2Nsb3NlOmF9KSxcIm9iamVjdFwiIT10eXBlb2YgYSYmKGE9e30pLGE9ZS5leHRlbmQoITAse30sZVt0XS5kZWZhdWx0c1tuXSxhKSxhLmNsb3NlKXt2YXIgcj1cIiNcIitzLiRtZW51LmF0dHIoXCJpZFwiKTt0aGlzLmJpbmQoXCJvcGVuOmZpbmlzaFwiLGZ1bmN0aW9uKGUpe2xvY2F0aW9uLmhhc2ghPXImJmhpc3RvcnkucHVzaFN0YXRlKG51bGwsZG9jdW1lbnQudGl0bGUscil9KSxlKHdpbmRvdykub24oXCJwb3BzdGF0ZVwiLGZ1bmN0aW9uKGUpe28uJGh0bWwuaGFzQ2xhc3MoaS5vcGVuZWQpPyhlLnN0b3BQcm9wYWdhdGlvbigpLHMuY2xvc2UoKSk6bG9jYXRpb24uaGFzaD09ciYmKGUuc3RvcFByb3BhZ2F0aW9uKCkscy5vcGVuKCkpfSl9fX0sYWRkOmZ1bmN0aW9uKCl7cmV0dXJuIHdpbmRvdy5oaXN0b3J5JiZ3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGU/KGk9ZVt0XS5fYyxzPWVbdF0uX2Qsdm9pZChhPWVbdF0uX2UpKTp2b2lkKGVbdF0uYWRkb25zW25dLnNldHVwPWZ1bmN0aW9uKCl7fSl9LGNsaWNrQW5jaG9yOmZ1bmN0aW9uKGUsdCl7fX0sZVt0XS5kZWZhdWx0c1tuXT17Y2xvc2U6ITF9O3ZhciBpLHMsYSxvfShqUXVlcnkpLC8qXG4gKiBqUXVlcnkgbW1lbnUgY291bnRlcnMgYWRkLW9uXG4gKiBtbWVudS5mcmVic2l0ZS5ubFxuICpcbiAqIENvcHlyaWdodCAoYykgRnJlZCBIZXVzc2NoZW5cbiAqL1xuZnVuY3Rpb24oZSl7dmFyIHQ9XCJtbWVudVwiLG49XCJjb3VudGVyc1wiO2VbdF0uYWRkb25zW25dPXtzZXR1cDpmdW5jdGlvbigpe3ZhciBhPXRoaXMscj10aGlzLm9wdHNbbl07dGhpcy5jb25mW25dO2lmKG89ZVt0XS5nbGJsLFwiYm9vbGVhblwiPT10eXBlb2YgciYmKHI9e2FkZDpyLHVwZGF0ZTpyfSksXCJvYmplY3RcIiE9dHlwZW9mIHImJihyPXt9KSxyPXRoaXMub3B0c1tuXT1lLmV4dGVuZCghMCx7fSxlW3RdLmRlZmF1bHRzW25dLHIpLHRoaXMuYmluZChcImluaXRMaXN0dmlldzphZnRlclwiLGZ1bmN0aW9uKHQpe3RoaXMuX19yZWZhY3RvckNsYXNzKGUoXCJlbVwiLHQpLHRoaXMuY29uZi5jbGFzc05hbWVzW25dLmNvdW50ZXIsXCJjb3VudGVyXCIpfSksci5hZGQmJnRoaXMuYmluZChcImluaXRMaXN0dmlldzphZnRlclwiLGZ1bmN0aW9uKHQpe3ZhciBuO3N3aXRjaChyLmFkZFRvKXtjYXNlXCJwYW5lbHNcIjpuPXQ7YnJlYWs7ZGVmYXVsdDpuPXQuZmlsdGVyKHIuYWRkVG8pfW4uZWFjaChmdW5jdGlvbigpe3ZhciB0PWUodGhpcykuZGF0YShzLnBhcmVudCk7dCYmKHQuY2hpbGRyZW4oXCJlbS5cIitpLmNvdW50ZXIpLmxlbmd0aHx8dC5wcmVwZW5kKGUoJzxlbSBjbGFzcz1cIicraS5jb3VudGVyKydcIiAvPicpKSl9KX0pLHIudXBkYXRlKXt2YXIgbD1mdW5jdGlvbih0KXt0PXR8fHRoaXMuJHBubHMuY2hpbGRyZW4oXCIuXCIraS5wYW5lbCksdC5lYWNoKGZ1bmN0aW9uKCl7dmFyIHQ9ZSh0aGlzKSxuPXQuZGF0YShzLnBhcmVudCk7aWYobil7dmFyIG89bi5jaGlsZHJlbihcImVtLlwiK2kuY291bnRlcik7by5sZW5ndGgmJih0PXQuY2hpbGRyZW4oXCIuXCIraS5saXN0dmlldyksdC5sZW5ndGgmJm8uaHRtbChhLl9fZmlsdGVyTGlzdEl0ZW1zKHQuY2hpbGRyZW4oKSkubGVuZ3RoKSl9fSl9O3RoaXMuYmluZChcImluaXRMaXN0dmlldzphZnRlclwiLGwpLHRoaXMuYmluZChcInVwZGF0ZUxpc3R2aWV3XCIsbCl9fSxhZGQ6ZnVuY3Rpb24oKXtpPWVbdF0uX2Mscz1lW3RdLl9kLGE9ZVt0XS5fZSxpLmFkZChcImNvdW50ZXIgc2VhcmNoIG5vcmVzdWx0c21zZ1wiKX0sY2xpY2tBbmNob3I6ZnVuY3Rpb24oZSx0KXt9fSxlW3RdLmRlZmF1bHRzW25dPXthZGQ6ITEsYWRkVG86XCJwYW5lbHNcIixjb3VudDohMX0sZVt0XS5jb25maWd1cmF0aW9uLmNsYXNzTmFtZXNbbl09e2NvdW50ZXI6XCJDb3VudGVyXCJ9O3ZhciBpLHMsYSxvfShqUXVlcnkpLC8qXG4gKiBqUXVlcnkgbW1lbnUgY29sdW1ucyBhZGQtb25cbiAqIG1tZW51LmZyZWJzaXRlLm5sXG4gKlxuICogQ29weXJpZ2h0IChjKSBGcmVkIEhldXNzY2hlblxuICovXG5mdW5jdGlvbihlKXt2YXIgdD1cIm1tZW51XCIsbj1cImNvbHVtbnNcIjtlW3RdLmFkZG9uc1tuXT17c2V0dXA6ZnVuY3Rpb24oKXt2YXIgcz10aGlzLm9wdHNbbl07dGhpcy5jb25mW25dO2lmKG89ZVt0XS5nbGJsLFwiYm9vbGVhblwiPT10eXBlb2YgcyYmKHM9e2FkZDpzfSksXCJudW1iZXJcIj09dHlwZW9mIHMmJihzPXthZGQ6ITAsdmlzaWJsZTpzfSksXCJvYmplY3RcIiE9dHlwZW9mIHMmJihzPXt9KSxcIm51bWJlclwiPT10eXBlb2Ygcy52aXNpYmxlJiYocy52aXNpYmxlPXttaW46cy52aXNpYmxlLG1heDpzLnZpc2libGV9KSxzPXRoaXMub3B0c1tuXT1lLmV4dGVuZCghMCx7fSxlW3RdLmRlZmF1bHRzW25dLHMpLHMuYWRkKXtzLnZpc2libGUubWluPU1hdGgubWF4KDEsTWF0aC5taW4oNixzLnZpc2libGUubWluKSkscy52aXNpYmxlLm1heD1NYXRoLm1heChzLnZpc2libGUubWluLE1hdGgubWluKDYscy52aXNpYmxlLm1heCkpO2Zvcih2YXIgYT10aGlzLm9wdHMub2ZmQ2FudmFzP3RoaXMuJG1lbnUuYWRkKG8uJGh0bWwpOnRoaXMuJG1lbnUscj1cIlwiLGw9MDtsPD1zLnZpc2libGUubWF4O2wrKylyKz1cIiBcIitpLmNvbHVtbnMrXCItXCIrbDtyLmxlbmd0aCYmKHI9ci5zbGljZSgxKSk7dmFyIGQ9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy4kcG5scy5jaGlsZHJlbihcIi5cIitpLnN1Ym9wZW5lZCkubGVuZ3RoO2UmJiFlLmhhc0NsYXNzKGkuc3Vib3BlbmVkKSYmdCsrLHQ9TWF0aC5taW4ocy52aXNpYmxlLm1heCxNYXRoLm1heChzLnZpc2libGUubWluLHQpKSxhLnJlbW92ZUNsYXNzKHIpLmFkZENsYXNzKGkuY29sdW1ucytcIi1cIit0KX0sYz1mdW5jdGlvbih0KXt0PXR8fHRoaXMuJHBubHMuY2hpbGRyZW4oXCIuXCIraS5vcGVuZWQpLHRoaXMuJHBubHMuY2hpbGRyZW4oXCIuXCIraS5wYW5lbCkucmVtb3ZlQ2xhc3MocikuZmlsdGVyKFwiLlwiK2kuc3Vib3BlbmVkKS5hZGQodCkuc2xpY2UoLXMudmlzaWJsZS5tYXgpLmVhY2goZnVuY3Rpb24odCl7ZSh0aGlzKS5hZGRDbGFzcyhpLmNvbHVtbnMrXCItXCIrdCl9KX07dGhpcy5iaW5kKFwiaW5pdE1lbnU6YWZ0ZXJcIixmdW5jdGlvbigpe3RoaXMuJG1lbnUuYWRkQ2xhc3MoaS5jb2x1bW5zKX0pLHRoaXMuYmluZChcIm9wZW5QYW5lbDpzdGFydFwiLGQpLHRoaXMuYmluZChcIm9wZW5QYW5lbDpzdGFydFwiLGMpfX0sYWRkOmZ1bmN0aW9uKCl7aT1lW3RdLl9jLHM9ZVt0XS5fZCxhPWVbdF0uX2UsaS5hZGQoXCJjb2x1bW5zXCIpfSxjbGlja0FuY2hvcjpmdW5jdGlvbih0LHMpe2lmKCF0aGlzLm9wdHNbbl0uYWRkKXJldHVybiExO2lmKHMpe3ZhciBhPXQuYXR0cihcImhyZWZcIik7aWYoYS5sZW5ndGg+MSYmXCIjXCI9PWEuc2xpY2UoMCwxKSl0cnl7dmFyIG89ZShhLHRoaXMuJG1lbnUpO2lmKG8uaXMoXCIuXCIraS5wYW5lbCkpZm9yKHZhciByPXBhcnNlSW50KHQuY2xvc2VzdChcIi5cIitpLnBhbmVsKS5hdHRyKFwiY2xhc3NcIikuc3BsaXQoaS5jb2x1bW5zK1wiLVwiKVsxXS5zcGxpdChcIiBcIilbMF0sMTApKzE7cj4wOyl7dmFyIGw9dGhpcy4kcG5scy5jaGlsZHJlbihcIi5cIitpLmNvbHVtbnMrXCItXCIrcik7aWYoIWwubGVuZ3RoKXtyPS0xO2JyZWFrfXIrKyxsLnJlbW92ZUNsYXNzKGkuc3Vib3BlbmVkKS5yZW1vdmVDbGFzcyhpLm9wZW5lZCkucmVtb3ZlQ2xhc3MoaS5oaWdoZXN0KS5hZGRDbGFzcyhpLmhpZGRlbil9fWNhdGNoKGQpe319fX0sZVt0XS5kZWZhdWx0c1tuXT17YWRkOiExLHZpc2libGU6e21pbjoxLG1heDozfX07dmFyIGkscyxhLG99KGpRdWVyeSksLypcbiAqIGpRdWVyeSBtbWVudSBkaXZpZGVycyBhZGQtb25cbiAqIG1tZW51LmZyZWJzaXRlLm5sXG4gKlxuICogQ29weXJpZ2h0IChjKSBGcmVkIEhldXNzY2hlblxuICovXG5mdW5jdGlvbihlKXt2YXIgdD1cIm1tZW51XCIsbj1cImRpdmlkZXJzXCI7ZVt0XS5hZGRvbnNbbl09e3NldHVwOmZ1bmN0aW9uKCl7dmFyIHM9dGhpcyxyPXRoaXMub3B0c1tuXTt0aGlzLmNvbmZbbl07aWYobz1lW3RdLmdsYmwsXCJib29sZWFuXCI9PXR5cGVvZiByJiYocj17YWRkOnIsZml4ZWQ6cn0pLFwib2JqZWN0XCIhPXR5cGVvZiByJiYocj17fSkscj10aGlzLm9wdHNbbl09ZS5leHRlbmQoITAse30sZVt0XS5kZWZhdWx0c1tuXSxyKSx0aGlzLmJpbmQoXCJpbml0TGlzdHZpZXc6YWZ0ZXJcIixmdW5jdGlvbihlKXt0aGlzLl9fcmVmYWN0b3JDbGFzcyhlLmZpbmQoXCJsaVwiKSx0aGlzLmNvbmYuY2xhc3NOYW1lc1tuXS5jb2xsYXBzZWQsXCJjb2xsYXBzZWRcIil9KSxyLmFkZCYmdGhpcy5iaW5kKFwiaW5pdExpc3R2aWV3OmFmdGVyXCIsZnVuY3Rpb24odCl7dmFyIG47c3dpdGNoKHIuYWRkVG8pe2Nhc2VcInBhbmVsc1wiOm49dDticmVhaztkZWZhdWx0Om49dC5maWx0ZXIoci5hZGRUbyl9bi5sZW5ndGgmJm4uZmluZChcIi5cIitpLmxpc3R2aWV3KS5maW5kKFwiLlwiK2kuZGl2aWRlcikucmVtb3ZlKCkuZW5kKCkuZWFjaChmdW5jdGlvbigpe3ZhciB0PVwiXCI7cy5fX2ZpbHRlckxpc3RJdGVtcyhlKHRoaXMpLmNoaWxkcmVuKCkpLmVhY2goZnVuY3Rpb24oKXt2YXIgbj1lLnRyaW0oZSh0aGlzKS5jaGlsZHJlbihcImEsIHNwYW5cIikudGV4dCgpKS5zbGljZSgwLDEpLnRvTG93ZXJDYXNlKCk7biE9dCYmbi5sZW5ndGgmJih0PW4sZSgnPGxpIGNsYXNzPVwiJytpLmRpdmlkZXIrJ1wiPicrbitcIjwvbGk+XCIpLmluc2VydEJlZm9yZSh0aGlzKSl9KX0pfSksci5jb2xsYXBzZSYmdGhpcy5iaW5kKFwiaW5pdExpc3R2aWV3OmFmdGVyXCIsZnVuY3Rpb24odCl7dC5maW5kKFwiLlwiK2kuZGl2aWRlcikuZWFjaChmdW5jdGlvbigpe3ZhciB0PWUodGhpcyksbj10Lm5leHRVbnRpbChcIi5cIitpLmRpdmlkZXIsXCIuXCIraS5jb2xsYXBzZWQpO24ubGVuZ3RoJiYodC5jaGlsZHJlbihcIi5cIitpLm5leHQpLmxlbmd0aHx8KHQud3JhcElubmVyKFwiPHNwYW4gLz5cIiksdC5wcmVwZW5kKCc8YSBocmVmPVwiI1wiIGNsYXNzPVwiJytpLm5leHQrXCIgXCIraS5mdWxsc3Vib3BlbisnXCIgLz4nKSkpfSl9KSxyLmZpeGVkKXt0aGlzLmJpbmQoXCJpbml0UGFuZWxzOmFmdGVyXCIsZnVuY3Rpb24oKXtcInVuZGVmaW5lZFwiPT10eXBlb2YgdGhpcy4kZml4ZWRkaXZpZGVyJiYodGhpcy4kZml4ZWRkaXZpZGVyPWUoJzx1bCBjbGFzcz1cIicraS5saXN0dmlldytcIiBcIitpLmZpeGVkZGl2aWRlcisnXCI+PGxpIGNsYXNzPVwiJytpLmRpdmlkZXIrJ1wiPjwvbGk+PC91bD4nKS5wcmVwZW5kVG8odGhpcy4kcG5scykuY2hpbGRyZW4oKSl9KTt2YXIgbD1mdW5jdGlvbih0KXtpZih0PXR8fHRoaXMuJHBubHMuY2hpbGRyZW4oXCIuXCIraS5vcGVuZWQpLCF0LmlzKFwiOmhpZGRlblwiKSl7dmFyIG49dC5jaGlsZHJlbihcIi5cIitpLmxpc3R2aWV3KS5jaGlsZHJlbihcIi5cIitpLmRpdmlkZXIpLm5vdChcIi5cIitpLmhpZGRlbikscz10LnNjcm9sbFRvcCgpfHwwLGE9XCJcIjtuLmVhY2goZnVuY3Rpb24oKXtlKHRoaXMpLnBvc2l0aW9uKCkudG9wK3M8cysxJiYoYT1lKHRoaXMpLnRleHQoKSl9KSx0aGlzLiRmaXhlZGRpdmlkZXIudGV4dChhKSx0aGlzLiRwbmxzW2EubGVuZ3RoP1wiYWRkQ2xhc3NcIjpcInJlbW92ZUNsYXNzXCJdKGkuaGFzZGl2aWRlcnMpfX07dGhpcy5iaW5kKFwib3BlbjpzdGFydFwiLGwpLHRoaXMuYmluZChcIm9wZW5QYW5lbDpzdGFydFwiLGwpLHRoaXMuYmluZChcInVwZGF0ZUxpc3R2aWV3XCIsbCksdGhpcy5iaW5kKFwiaW5pdFBhbmVsOmFmdGVyXCIsZnVuY3Rpb24oZSl7ZS5vZmYoYS5zY3JvbGwrXCItXCIrbitcIiBcIithLnRvdWNobW92ZStcIi1cIituKS5vbihhLnNjcm9sbCtcIi1cIituK1wiIFwiK2EudG91Y2htb3ZlK1wiLVwiK24sZnVuY3Rpb24odCl7bC5jYWxsKHMsZSl9KX0pfX0sYWRkOmZ1bmN0aW9uKCl7aT1lW3RdLl9jLHM9ZVt0XS5fZCxhPWVbdF0uX2UsaS5hZGQoXCJjb2xsYXBzZWQgdW5jb2xsYXBzZWQgZml4ZWRkaXZpZGVyIGhhc2RpdmlkZXJzXCIpLGEuYWRkKFwic2Nyb2xsXCIpfSxjbGlja0FuY2hvcjpmdW5jdGlvbihlLHQpe2lmKHRoaXMub3B0c1tuXS5jb2xsYXBzZSYmdCl7dmFyIHM9ZS5wYXJlbnQoKTtpZihzLmlzKFwiLlwiK2kuZGl2aWRlcikpe3ZhciBhPXMubmV4dFVudGlsKFwiLlwiK2kuZGl2aWRlcixcIi5cIitpLmNvbGxhcHNlZCk7cmV0dXJuIHMudG9nZ2xlQ2xhc3MoaS5vcGVuZWQpLGFbcy5oYXNDbGFzcyhpLm9wZW5lZCk/XCJhZGRDbGFzc1wiOlwicmVtb3ZlQ2xhc3NcIl0oaS51bmNvbGxhcHNlZCksITB9fXJldHVybiExfX0sZVt0XS5kZWZhdWx0c1tuXT17YWRkOiExLGFkZFRvOlwicGFuZWxzXCIsZml4ZWQ6ITEsY29sbGFwc2U6ITF9LGVbdF0uY29uZmlndXJhdGlvbi5jbGFzc05hbWVzW25dPXtjb2xsYXBzZWQ6XCJDb2xsYXBzZWRcIn07dmFyIGkscyxhLG99KGpRdWVyeSksLypcbiAqIGpRdWVyeSBtbWVudSBkcmFnIGFkZC1vblxuICogbW1lbnUuZnJlYnNpdGUubmxcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZyZWQgSGV1c3NjaGVuXG4gKi9cbmZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoZSx0LG4pe3JldHVybiBlPHQmJihlPXQpLGU+biYmKGU9biksZX1mdW5jdGlvbiBuKG4saSxzKXt2YXIgcixsLGQsYz10aGlzLGg9e2V2ZW50czpcInBhbmxlZnQgcGFucmlnaHRcIix0eXBlTG93ZXI6XCJ4XCIsdHlwZVVwcGVyOlwiWFwiLG9wZW5fZGlyOlwicmlnaHRcIixjbG9zZV9kaXI6XCJsZWZ0XCIsbmVnYXRpdmU6ITF9LGY9XCJ3aWR0aFwiLHU9aC5vcGVuX2RpcixwPWZ1bmN0aW9uKGUpe2U8PW4ubWF4U3RhcnRQb3MmJihtPTEpfSx2PWZ1bmN0aW9uKCl7cmV0dXJuIGUoXCIuXCIrby5zbGlkZW91dCl9LG09MCxiPTAsZz0wO3N3aXRjaCh0aGlzLm9wdHMub2ZmQ2FudmFzLnBvc2l0aW9uKXtjYXNlXCJ0b3BcIjpjYXNlXCJib3R0b21cIjpoLmV2ZW50cz1cInBhbnVwIHBhbmRvd25cIixoLnR5cGVMb3dlcj1cInlcIixoLnR5cGVVcHBlcj1cIllcIixmPVwiaGVpZ2h0XCJ9c3dpdGNoKHRoaXMub3B0cy5vZmZDYW52YXMucG9zaXRpb24pe2Nhc2VcInJpZ2h0XCI6Y2FzZVwiYm90dG9tXCI6aC5uZWdhdGl2ZT0hMCxwPWZ1bmN0aW9uKGUpe2U+PXMuJHduZHdbZl0oKS1uLm1heFN0YXJ0UG9zJiYobT0xKX19c3dpdGNoKHRoaXMub3B0cy5vZmZDYW52YXMucG9zaXRpb24pe2Nhc2VcImxlZnRcIjpicmVhaztjYXNlXCJyaWdodFwiOmgub3Blbl9kaXI9XCJsZWZ0XCIsaC5jbG9zZV9kaXI9XCJyaWdodFwiO2JyZWFrO2Nhc2VcInRvcFwiOmgub3Blbl9kaXI9XCJkb3duXCIsaC5jbG9zZV9kaXI9XCJ1cFwiO2JyZWFrO2Nhc2VcImJvdHRvbVwiOmgub3Blbl9kaXI9XCJ1cFwiLGguY2xvc2VfZGlyPVwiZG93blwifXN3aXRjaCh0aGlzLm9wdHMub2ZmQ2FudmFzLnpwb3NpdGlvbil7Y2FzZVwiZnJvbnRcIjp2PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJG1lbnV9fXZhciBfPXRoaXMuX192YWx1ZU9yRm4obi5ub2RlLHRoaXMuJG1lbnUscy4kcGFnZSk7XCJzdHJpbmdcIj09dHlwZW9mIF8mJihfPWUoXykpO3ZhciB5PW5ldyBIYW1tZXIoX1swXSx0aGlzLm9wdHNbYV0udmVuZG9ycy5oYW1tZXIpO3kub24oXCJwYW5zdGFydFwiLGZ1bmN0aW9uKGUpe3AoZS5jZW50ZXJbaC50eXBlTG93ZXJdKSxzLiRzbGlkZU91dE5vZGVzPXYoKSx1PWgub3Blbl9kaXJ9KSx5Lm9uKGguZXZlbnRzK1wiIHBhbmVuZFwiLGZ1bmN0aW9uKGUpe20+MCYmZS5wcmV2ZW50RGVmYXVsdCgpfSkseS5vbihoLmV2ZW50cyxmdW5jdGlvbihlKXtpZihyPWVbXCJkZWx0YVwiK2gudHlwZVVwcGVyXSxoLm5lZ2F0aXZlJiYocj0tciksciE9YiYmKHU9cj49Yj9oLm9wZW5fZGlyOmguY2xvc2VfZGlyKSxiPXIsYj5uLnRocmVzaG9sZCYmMT09bSl7aWYocy4kaHRtbC5oYXNDbGFzcyhvLm9wZW5lZCkpcmV0dXJuO209MixjLl9vcGVuU2V0dXAoKSxjLnRyaWdnZXIoXCJvcGVuOnN0YXJ0XCIpLHMuJGh0bWwuYWRkQ2xhc3Moby5kcmFnZ2luZyksZz10KHMuJHduZHdbZl0oKSppW2ZdLnBlcmMsaVtmXS5taW4saVtmXS5tYXgpfTI9PW0mJihsPXQoYiwxMCxnKS0oXCJmcm9udFwiPT1jLm9wdHMub2ZmQ2FudmFzLnpwb3NpdGlvbj9nOjApLGgubmVnYXRpdmUmJihsPS1sKSxkPVwidHJhbnNsYXRlXCIraC50eXBlVXBwZXIrXCIoXCIrbCtcInB4IClcIixzLiRzbGlkZU91dE5vZGVzLmNzcyh7XCItd2Via2l0LXRyYW5zZm9ybVwiOlwiLXdlYmtpdC1cIitkLHRyYW5zZm9ybTpkfSkpfSkseS5vbihcInBhbmVuZFwiLGZ1bmN0aW9uKGUpezI9PW0mJihzLiRodG1sLnJlbW92ZUNsYXNzKG8uZHJhZ2dpbmcpLHMuJHNsaWRlT3V0Tm9kZXMuY3NzKFwidHJhbnNmb3JtXCIsXCJcIiksY1t1PT1oLm9wZW5fZGlyP1wiX29wZW5GaW5pc2hcIjpcImNsb3NlXCJdKCkpLG09MH0pfWZ1bmN0aW9uIGkoZSx0LG4saSl7dmFyIHM9dGhpcyxsPWUuZGF0YShyLnBhcmVudCk7aWYobCl7bD1sLmNsb3Nlc3QoXCIuXCIrby5wYW5lbCk7dmFyIGQ9bmV3IEhhbW1lcihlWzBdLHMub3B0c1thXS52ZW5kb3JzLmhhbW1lciksYz1udWxsO2Qub24oXCJwYW5yaWdodFwiLGZ1bmN0aW9uKGUpe2N8fChzLm9wZW5QYW5lbChsKSxjPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQoYyksYz1udWxsfSxzLmNvbmYub3BlbmluZ0ludGVydmFsK3MuY29uZi50cmFuc2l0aW9uRHVyYXRpb24pKX0pfX12YXIgcz1cIm1tZW51XCIsYT1cImRyYWdcIjtlW3NdLmFkZG9uc1thXT17c2V0dXA6ZnVuY3Rpb24oKXtpZih0aGlzLm9wdHMub2ZmQ2FudmFzKXt2YXIgdD10aGlzLm9wdHNbYV0sbz10aGlzLmNvbmZbYV07ZD1lW3NdLmdsYmwsXCJib29sZWFuXCI9PXR5cGVvZiB0JiYodD17bWVudTp0LHBhbmVsczp0fSksXCJvYmplY3RcIiE9dHlwZW9mIHQmJih0PXt9KSxcImJvb2xlYW5cIj09dHlwZW9mIHQubWVudSYmKHQubWVudT17b3Blbjp0Lm1lbnV9KSxcIm9iamVjdFwiIT10eXBlb2YgdC5tZW51JiYodC5tZW51PXt9KSxcImJvb2xlYW5cIj09dHlwZW9mIHQucGFuZWxzJiYodC5wYW5lbHM9e2Nsb3NlOnQucGFuZWxzfSksXCJvYmplY3RcIiE9dHlwZW9mIHQucGFuZWxzJiYodC5wYW5lbHM9e30pLHQ9dGhpcy5vcHRzW2FdPWUuZXh0ZW5kKCEwLHt9LGVbc10uZGVmYXVsdHNbYV0sdCksdC5tZW51Lm9wZW4mJnRoaXMuYmluZChcInNldFBhZ2U6YWZ0ZXJcIixmdW5jdGlvbigpe24uY2FsbCh0aGlzLHQubWVudSxvLm1lbnUsZCl9KSx0LnBhbmVscy5jbG9zZSYmdGhpcy5iaW5kKFwiaW5pdFBhbmVsOmFmdGVyXCIsZnVuY3Rpb24oZSl7aS5jYWxsKHRoaXMsZSx0LnBhbmVscyxvLnBhbmVscyxkKX0pfX0sYWRkOmZ1bmN0aW9uKCl7cmV0dXJuXCJmdW5jdGlvblwiIT10eXBlb2YgSGFtbWVyfHxIYW1tZXIuVkVSU0lPTjwyPyhlW3NdLmFkZG9uc1thXS5hZGQ9ZnVuY3Rpb24oKXt9LHZvaWQoZVtzXS5hZGRvbnNbYV0uc2V0dXA9ZnVuY3Rpb24oKXt9KSk6KG89ZVtzXS5fYyxyPWVbc10uX2QsbD1lW3NdLl9lLHZvaWQgby5hZGQoXCJkcmFnZ2luZ1wiKSl9LGNsaWNrQW5jaG9yOmZ1bmN0aW9uKGUsdCl7fX0sZVtzXS5kZWZhdWx0c1thXT17bWVudTp7b3BlbjohMSxtYXhTdGFydFBvczoxMDAsdGhyZXNob2xkOjUwfSxwYW5lbHM6e2Nsb3NlOiExfSx2ZW5kb3JzOntoYW1tZXI6e319fSxlW3NdLmNvbmZpZ3VyYXRpb25bYV09e21lbnU6e3dpZHRoOntwZXJjOi44LG1pbjoxNDAsbWF4OjQ0MH0saGVpZ2h0OntwZXJjOi44LG1pbjoxNDAsbWF4Ojg4MH19LHBhbmVsczp7fX07dmFyIG8scixsLGR9KGpRdWVyeSksLypcbiAqIGpRdWVyeSBtbWVudSBkcm9wZG93biBhZGQtb25cbiAqIG1tZW51LmZyZWJzaXRlLm5sXG4gKlxuICogQ29weXJpZ2h0IChjKSBGcmVkIEhldXNzY2hlblxuICovXG5mdW5jdGlvbihlKXt2YXIgdD1cIm1tZW51XCIsbj1cImRyb3Bkb3duXCI7ZVt0XS5hZGRvbnNbbl09e3NldHVwOmZ1bmN0aW9uKCl7aWYodGhpcy5vcHRzLm9mZkNhbnZhcyl7dmFyIHI9dGhpcyxsPXRoaXMub3B0c1tuXSxkPXRoaXMuY29uZltuXTtpZihvPWVbdF0uZ2xibCxcImJvb2xlYW5cIj09dHlwZW9mIGwmJmwmJihsPXtkcm9wOmx9KSxcIm9iamVjdFwiIT10eXBlb2YgbCYmKGw9e30pLFwic3RyaW5nXCI9PXR5cGVvZiBsLnBvc2l0aW9uJiYobC5wb3NpdGlvbj17b2Y6bC5wb3NpdGlvbn0pLGw9dGhpcy5vcHRzW25dPWUuZXh0ZW5kKCEwLHt9LGVbdF0uZGVmYXVsdHNbbl0sbCksbC5kcm9wKXt2YXIgYzt0aGlzLmJpbmQoXCJpbml0TWVudTphZnRlclwiLGZ1bmN0aW9uKCl7aWYodGhpcy4kbWVudS5hZGRDbGFzcyhpLmRyb3Bkb3duKSxsLnRpcCYmdGhpcy4kbWVudS5hZGRDbGFzcyhpLnRpcCksXCJzdHJpbmdcIiE9dHlwZW9mIGwucG9zaXRpb24ub2Ype3ZhciB0PXRoaXMuX2dldE9yaWdpbmFsTWVudUlkKCk7dCYmdC5sZW5ndGgmJihsLnBvc2l0aW9uLm9mPSdbaHJlZj1cIiMnK3QrJ1wiXScpfVwic3RyaW5nXCI9PXR5cGVvZiBsLnBvc2l0aW9uLm9mJiYoYz1lKGwucG9zaXRpb24ub2YpLGwuZXZlbnQ9bC5ldmVudC5zcGxpdChcIiBcIiksMT09bC5ldmVudC5sZW5ndGgmJihsLmV2ZW50WzFdPWwuZXZlbnRbMF0pLFwiaG92ZXJcIj09bC5ldmVudFswXSYmYy5vbihhLm1vdXNlZW50ZXIrXCItXCIrbixmdW5jdGlvbigpe3Iub3BlbigpfSksXCJob3ZlclwiPT1sLmV2ZW50WzFdJiZ0aGlzLiRtZW51Lm9uKGEubW91c2VsZWF2ZStcIi1cIituLGZ1bmN0aW9uKCl7ci5jbG9zZSgpfSkpfSksdGhpcy5iaW5kKFwib3BlbjpzdGFydFwiLGZ1bmN0aW9uKCl7dGhpcy4kbWVudS5kYXRhKHMuc3R5bGUsdGhpcy4kbWVudS5hdHRyKFwic3R5bGVcIil8fFwiXCIpLG8uJGh0bWwuYWRkQ2xhc3MoaS5kcm9wZG93bil9KSx0aGlzLmJpbmQoXCJjbG9zZTpmaW5pc2hcIixmdW5jdGlvbigpe3RoaXMuJG1lbnUuYXR0cihcInN0eWxlXCIsdGhpcy4kbWVudS5kYXRhKHMuc3R5bGUpKSxvLiRodG1sLnJlbW92ZUNsYXNzKGkuZHJvcGRvd24pfSk7dmFyIGg9ZnVuY3Rpb24oZSx0KXt2YXIgbj10WzBdLHM9dFsxXSxhPVwieFwiPT1lP1wic2Nyb2xsTGVmdFwiOlwic2Nyb2xsVG9wXCIscj1cInhcIj09ZT9cIm91dGVyV2lkdGhcIjpcIm91dGVySGVpZ2h0XCIsaD1cInhcIj09ZT9cImxlZnRcIjpcInRvcFwiLGY9XCJ4XCI9PWU/XCJyaWdodFwiOlwiYm90dG9tXCIsdT1cInhcIj09ZT9cIndpZHRoXCI6XCJoZWlnaHRcIixwPVwieFwiPT1lP1wibWF4V2lkdGhcIjpcIm1heEhlaWdodFwiLHY9bnVsbCxtPW8uJHduZHdbYV0oKSxiPWMub2Zmc2V0KClbaF0tPW0sZz1iK2Nbcl0oKSxfPW8uJHduZHdbdV0oKSx5PWQub2Zmc2V0LmJ1dHRvbltlXStkLm9mZnNldC52aWV3cG9ydFtlXTtpZihsLnBvc2l0aW9uW2VdKXN3aXRjaChsLnBvc2l0aW9uW2VdKXtjYXNlXCJsZWZ0XCI6Y2FzZVwiYm90dG9tXCI6dj1cImFmdGVyXCI7YnJlYWs7Y2FzZVwicmlnaHRcIjpjYXNlXCJ0b3BcIjp2PVwiYmVmb3JlXCJ9bnVsbD09PXYmJih2PWIrKGctYikvMjxfLzI/XCJhZnRlclwiOlwiYmVmb3JlXCIpO3ZhciBDLHc7cmV0dXJuXCJhZnRlclwiPT12PyhDPVwieFwiPT1lP2I6Zyx3PV8tKEMreSksbltoXT1DK2Qub2Zmc2V0LmJ1dHRvbltlXSxuW2ZdPVwiYXV0b1wiLHMucHVzaChpW1wieFwiPT1lP1widGlwbGVmdFwiOlwidGlwdG9wXCJdKSk6KEM9XCJ4XCI9PWU/ZzpiLHc9Qy15LG5bZl09XCJjYWxjKCAxMDAlIC0gXCIrKEMtZC5vZmZzZXQuYnV0dG9uW2VdKStcInB4IClcIixuW2hdPVwiYXV0b1wiLHMucHVzaChpW1wieFwiPT1lP1widGlwcmlnaHRcIjpcInRpcGJvdHRvbVwiXSkpLG5bcF09TWF0aC5taW4oZFt1XS5tYXgsdyksW24sc119LGY9ZnVuY3Rpb24oZSl7aWYodGhpcy52YXJzLm9wZW5lZCl7dGhpcy4kbWVudS5hdHRyKFwic3R5bGVcIix0aGlzLiRtZW51LmRhdGEocy5zdHlsZSkpO3ZhciB0PVt7fSxbXV07dD1oLmNhbGwodGhpcyxcInlcIix0KSx0PWguY2FsbCh0aGlzLFwieFwiLHQpLHRoaXMuJG1lbnUuY3NzKHRbMF0pLGwudGlwJiZ0aGlzLiRtZW51LnJlbW92ZUNsYXNzKGkudGlwbGVmdCtcIiBcIitpLnRpcHJpZ2h0K1wiIFwiK2kudGlwdG9wK1wiIFwiK2kudGlwYm90dG9tKS5hZGRDbGFzcyh0WzFdLmpvaW4oXCIgXCIpKX19O3RoaXMuYmluZChcIm9wZW46c3RhcnRcIixmKSxvLiR3bmR3Lm9uKGEucmVzaXplK1wiLVwiK24sZnVuY3Rpb24oZSl7Zi5jYWxsKHIpfSksdGhpcy5vcHRzLm9mZkNhbnZhcy5ibG9ja1VJfHxvLiR3bmR3Lm9uKGEuc2Nyb2xsK1wiLVwiK24sZnVuY3Rpb24oZSl7Zi5jYWxsKHIpfSl9fX0sYWRkOmZ1bmN0aW9uKCl7aT1lW3RdLl9jLHM9ZVt0XS5fZCxhPWVbdF0uX2UsaS5hZGQoXCJkcm9wZG93biB0aXAgdGlwbGVmdCB0aXByaWdodCB0aXB0b3AgdGlwYm90dG9tXCIpLGEuYWRkKFwibW91c2VlbnRlciBtb3VzZWxlYXZlIHJlc2l6ZSBzY3JvbGxcIil9LGNsaWNrQW5jaG9yOmZ1bmN0aW9uKGUsdCl7fX0sZVt0XS5kZWZhdWx0c1tuXT17ZHJvcDohMSxldmVudDpcImNsaWNrXCIscG9zaXRpb246e30sdGlwOiEwfSxlW3RdLmNvbmZpZ3VyYXRpb25bbl09e29mZnNldDp7YnV0dG9uOnt4Oi0xMCx5OjEwfSx2aWV3cG9ydDp7eDoyMCx5OjIwfX0saGVpZ2h0OnttYXg6ODgwfSx3aWR0aDp7bWF4OjQ0MH19O3ZhciBpLHMsYSxvfShqUXVlcnkpLC8qXG4gKiBqUXVlcnkgbW1lbnUgZml4ZWRFbGVtZW50cyBhZGQtb25cbiAqIG1tZW51LmZyZWJzaXRlLm5sXG4gKlxuICogQ29weXJpZ2h0IChjKSBGcmVkIEhldXNzY2hlblxuICovXG5mdW5jdGlvbihlKXt2YXIgdD1cIm1tZW51XCIsbj1cImZpeGVkRWxlbWVudHNcIjtlW3RdLmFkZG9uc1tuXT17c2V0dXA6ZnVuY3Rpb24oKXtpZih0aGlzLm9wdHMub2ZmQ2FudmFzKXt2YXIgcz0odGhpcy5vcHRzW25dLHRoaXMuY29uZltuXSk7bz1lW3RdLmdsYmw7dmFyIGE9ZnVuY3Rpb24odCl7dmFyIGE9dGhpcy5jb25mLmNsYXNzTmFtZXNbbl0uZml4ZWQscj10LmZpbmQoXCIuXCIrYSk7dGhpcy5fX3JlZmFjdG9yQ2xhc3MocixhLFwic2xpZGVvdXRcIikscltzLmVsZW1JbnNlcnRNZXRob2RdKHMuZWxlbUluc2VydFNlbGVjdG9yKTt2YXIgbD10aGlzLmNvbmYuY2xhc3NOYW1lc1tuXS5zdGlja3ksZD10LmZpbmQoXCIuXCIrbCk7dGhpcy5fX3JlZmFjdG9yQ2xhc3MoZCxsLFwic3RpY2t5XCIpLGQ9dC5maW5kKFwiLlwiK2kuc3RpY2t5KSxkLmxlbmd0aCYmKHRoaXMuYmluZChcIm9wZW46YmVmb3JlXCIsZnVuY3Rpb24oKXt2YXIgdD1vLiR3bmR3LnNjcm9sbFRvcCgpK3Muc3RpY2t5Lm9mZnNldDtkLmVhY2goZnVuY3Rpb24oKXtlKHRoaXMpLmNzcyhcInRvcFwiLHBhcnNlSW50KGUodGhpcykuY3NzKFwidG9wXCIpLDEwKSt0KX0pfSksdGhpcy5iaW5kKFwiY2xvc2U6ZmluaXNoXCIsZnVuY3Rpb24oKXtkLmNzcyhcInRvcFwiLFwiXCIpfSkpfTt0aGlzLmJpbmQoXCJzZXRQYWdlOmFmdGVyXCIsYSl9fSxhZGQ6ZnVuY3Rpb24oKXtpPWVbdF0uX2Mscz1lW3RdLl9kLGE9ZVt0XS5fZSxpLmFkZChcInN0aWNreVwiKX0sY2xpY2tBbmNob3I6ZnVuY3Rpb24oZSx0KXt9fSxlW3RdLmNvbmZpZ3VyYXRpb25bbl09e3N0aWNreTp7b2Zmc2V0OjB9LGVsZW1JbnNlcnRNZXRob2Q6XCJhcHBlbmRUb1wiLGVsZW1JbnNlcnRTZWxlY3RvcjpcImJvZHlcIn0sZVt0XS5jb25maWd1cmF0aW9uLmNsYXNzTmFtZXNbbl09e2ZpeGVkOlwiRml4ZWRcIixzdGlja3k6XCJTdGlja3lcIn07dmFyIGkscyxhLG99KGpRdWVyeSksLypcbiAqIGpRdWVyeSBtbWVudSBpY29uUGFuZWxzIGFkZC1vblxuICogbW1lbnUuZnJlYnNpdGUubmxcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZyZWQgSGV1c3NjaGVuXG4gKi9cbmZ1bmN0aW9uKGUpe3ZhciB0PVwibW1lbnVcIixuPVwiaWNvblBhbmVsc1wiO2VbdF0uYWRkb25zW25dPXtzZXR1cDpmdW5jdGlvbigpe3ZhciBzPXRoaXMsYT10aGlzLm9wdHNbbl07dGhpcy5jb25mW25dO2lmKG89ZVt0XS5nbGJsLFwiYm9vbGVhblwiPT10eXBlb2YgYSYmKGE9e2FkZDphfSksXCJudW1iZXJcIj09dHlwZW9mIGEmJihhPXthZGQ6ITAsdmlzaWJsZTphfSksXCJvYmplY3RcIiE9dHlwZW9mIGEmJihhPXt9KSxhPXRoaXMub3B0c1tuXT1lLmV4dGVuZCghMCx7fSxlW3RdLmRlZmF1bHRzW25dLGEpLGEudmlzaWJsZSsrLGEuYWRkKXtmb3IodmFyIHI9XCJcIixsPTA7bDw9YS52aXNpYmxlO2wrKylyKz1cIiBcIitpLmljb25wYW5lbCtcIi1cIitsO3IubGVuZ3RoJiYocj1yLnNsaWNlKDEpKTt2YXIgZD1mdW5jdGlvbih0KXt0Lmhhc0NsYXNzKGkudmVydGljYWwpfHxzLiRwbmxzLmNoaWxkcmVuKFwiLlwiK2kucGFuZWwpLnJlbW92ZUNsYXNzKHIpLmZpbHRlcihcIi5cIitpLnN1Ym9wZW5lZCkucmVtb3ZlQ2xhc3MoaS5oaWRkZW4pLmFkZCh0KS5ub3QoXCIuXCIraS52ZXJ0aWNhbCkuc2xpY2UoLWEudmlzaWJsZSkuZWFjaChmdW5jdGlvbih0KXtlKHRoaXMpLmFkZENsYXNzKGkuaWNvbnBhbmVsK1wiLVwiK3QpfSl9O3RoaXMuYmluZChcImluaXRNZW51OmFmdGVyXCIsZnVuY3Rpb24oKXt0aGlzLiRtZW51LmFkZENsYXNzKGkuaWNvbnBhbmVsKX0pLHRoaXMuYmluZChcIm9wZW5QYW5lbDpzdGFydFwiLGQpLHRoaXMuYmluZChcImluaXRQYW5lbHM6YWZ0ZXJcIixmdW5jdGlvbihlKXtkLmNhbGwocyxzLiRwbmxzLmNoaWxkcmVuKFwiLlwiK2kub3BlbmVkKSl9KSx0aGlzLmJpbmQoXCJpbml0TGlzdHZpZXc6YWZ0ZXJcIixmdW5jdGlvbihlKXtlLmhhc0NsYXNzKGkudmVydGljYWwpfHxlLmNoaWxkcmVuKFwiLlwiK2kuc3ViYmxvY2tlcikubGVuZ3RofHxlLnByZXBlbmQoJzxhIGhyZWY9XCIjJytlLmNsb3Nlc3QoXCIuXCIraS5wYW5lbCkuYXR0cihcImlkXCIpKydcIiBjbGFzcz1cIicraS5zdWJibG9ja2VyKydcIiAvPicpfSl9fSxhZGQ6ZnVuY3Rpb24oKXtpPWVbdF0uX2Mscz1lW3RdLl9kLGE9ZVt0XS5fZSxpLmFkZChcImljb25wYW5lbCBzdWJibG9ja2VyXCIpfSxjbGlja0FuY2hvcjpmdW5jdGlvbihlLHQpe319LGVbdF0uZGVmYXVsdHNbbl09e2FkZDohMSx2aXNpYmxlOjN9O3ZhciBpLHMsYSxvfShqUXVlcnkpLC8qXG4gKiBqUXVlcnkgbW1lbnUga2V5Ym9hcmROYXZpZ2F0aW9uIGFkZC1vblxuICogbW1lbnUuZnJlYnNpdGUubmxcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZyZWQgSGV1c3NjaGVuXG4gKi9cbmZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQodCxuKXt0PXR8fHRoaXMuJHBubHMuY2hpbGRyZW4oXCIuXCIrYS5vcGVuZWQpO3ZhciBpPWUoKSxzPXRoaXMuJG1lbnUuY2hpbGRyZW4oXCIuXCIrYS5tbShcIm5hdmJhcnMtdG9wXCIpK1wiLCAuXCIrYS5tbShcIm5hdmJhcnMtYm90dG9tXCIpKS5jaGlsZHJlbihcIi5cIithLm5hdmJhcik7cy5maW5kKGQpLmZpbHRlcihcIjpmb2N1c1wiKS5sZW5ndGh8fChcImRlZmF1bHRcIj09biYmKGk9dC5jaGlsZHJlbihcIi5cIithLmxpc3R2aWV3KS5maW5kKFwiYVtocmVmXVwiKS5ub3QoXCIuXCIrYS5oaWRkZW4pLGkubGVuZ3RofHwoaT10LmZpbmQoZCkubm90KFwiLlwiK2EuaGlkZGVuKSksaS5sZW5ndGh8fChpPXMuZmluZChkKS5ub3QoXCIuXCIrYS5oaWRkZW4pKSksaS5sZW5ndGh8fChpPXRoaXMuJG1lbnUuY2hpbGRyZW4oXCIuXCIrYS50YWJzdGFydCkpLGkuZmlyc3QoKS5mb2N1cygpKX1mdW5jdGlvbiBuKGUpe2V8fChlPXRoaXMuJHBubHMuY2hpbGRyZW4oXCIuXCIrYS5vcGVuZWQpKTt2YXIgdD10aGlzLiRwbmxzLmNoaWxkcmVuKFwiLlwiK2EucGFuZWwpLG49dC5ub3QoZSk7bi5maW5kKGQpLmF0dHIoXCJ0YWJpbmRleFwiLC0xKSxlLmZpbmQoZCkuYXR0cihcInRhYmluZGV4XCIsMCksZS5maW5kKFwiLlwiK2EubW0oXCJ0b2dnbGVcIikrXCIsIC5cIithLm1tKFwiY2hlY2tcIikpLmF0dHIoXCJ0YWJpbmRleFwiLC0xKSxlLmNoaWxkcmVuKFwiLlwiK2EubmF2YmFyKS5jaGlsZHJlbihcIi5cIithLnRpdGxlKS5hdHRyKFwidGFiaW5kZXhcIiwtMSl9dmFyIGk9XCJtbWVudVwiLHM9XCJrZXlib2FyZE5hdmlnYXRpb25cIjtlW2ldLmFkZG9uc1tzXT17c2V0dXA6ZnVuY3Rpb24oKXtpZighZVtpXS5zdXBwb3J0LnRvdWNoKXt2YXIgbz10aGlzLm9wdHNbc107dGhpcy5jb25mW3NdO2lmKGw9ZVtpXS5nbGJsLFwiYm9vbGVhblwiIT10eXBlb2YgbyYmXCJzdHJpbmdcIiE9dHlwZW9mIG98fChvPXtlbmFibGU6b30pLFwib2JqZWN0XCIhPXR5cGVvZiBvJiYobz17fSksbz10aGlzLm9wdHNbc109ZS5leHRlbmQoITAse30sZVtpXS5kZWZhdWx0c1tzXSxvKSxvLmVuYWJsZSl7dmFyIHI9ZSgnPGJ1dHRvbiBjbGFzcz1cIicrYS50YWJzdGFydCsnXCIgdGFiaW5kZXg9XCIwXCIgdHlwZT1cImJ1dHRvblwiIC8+JyksZD1lKCc8YnV0dG9uIGNsYXNzPVwiJythLnRhYmVuZCsnXCIgdGFiaW5kZXg9XCIwXCIgdHlwZT1cImJ1dHRvblwiIC8+Jyk7dGhpcy5iaW5kKFwiaW5pdE1lbnU6YWZ0ZXJcIixmdW5jdGlvbigpe28uZW5oYW5jZSYmdGhpcy4kbWVudS5hZGRDbGFzcyhhLmtleWJvYXJkZm9jdXMpLHRoaXNbXCJfaW5pdFdpbmRvd19cIitzXShvLmVuaGFuY2UpfSksdGhpcy5iaW5kKFwiaW5pdE9wZW5lZDpiZWZvcmVcIixmdW5jdGlvbigpe3RoaXMuJG1lbnUucHJlcGVuZChyKS5hcHBlbmQoZCkuY2hpbGRyZW4oXCIuXCIrYS5tbShcIm5hdmJhcnMtdG9wXCIpK1wiLCAuXCIrYS5tbShcIm5hdmJhcnMtYm90dG9tXCIpKS5jaGlsZHJlbihcIi5cIithLm5hdmJhcikuY2hpbGRyZW4oXCJhLlwiK2EudGl0bGUpLmF0dHIoXCJ0YWJpbmRleFwiLC0xKX0pLHRoaXMuYmluZChcIm9wZW46c3RhcnRcIixmdW5jdGlvbigpe24uY2FsbCh0aGlzKX0pLHRoaXMuYmluZChcIm9wZW46ZmluaXNoXCIsZnVuY3Rpb24oKXt0LmNhbGwodGhpcyxudWxsLG8uZW5hYmxlKX0pLHRoaXMuYmluZChcIm9wZW5QYW5lbDpzdGFydFwiLGZ1bmN0aW9uKGUpe24uY2FsbCh0aGlzLGUpfSksdGhpcy5iaW5kKFwib3BlblBhbmVsOmZpbmlzaFwiLGZ1bmN0aW9uKGUpe3QuY2FsbCh0aGlzLGUsby5lbmFibGUpfSksdGhpcy5iaW5kKFwiaW5pdE9wZW5lZDphZnRlclwiLGZ1bmN0aW9uKCl7dGhpcy5fX3NyX2FyaWEodGhpcy4kbWVudS5jaGlsZHJlbihcIi5cIithLm1tKFwidGFic3RhcnRcIikrXCIsIC5cIithLm1tKFwidGFiZW5kXCIpKSxcImhpZGRlblwiLCEwKX0pfX19LGFkZDpmdW5jdGlvbigpe2E9ZVtpXS5fYyxvPWVbaV0uX2Qscj1lW2ldLl9lLGEuYWRkKFwidGFic3RhcnQgdGFiZW5kIGtleWJvYXJkZm9jdXNcIiksci5hZGQoXCJmb2N1c2luIGtleWRvd25cIil9LGNsaWNrQW5jaG9yOmZ1bmN0aW9uKGUsdCl7fX0sZVtpXS5kZWZhdWx0c1tzXT17ZW5hYmxlOiExLGVuaGFuY2U6ITF9LGVbaV0uY29uZmlndXJhdGlvbltzXT17fSxlW2ldLnByb3RvdHlwZVtcIl9pbml0V2luZG93X1wiK3NdPWZ1bmN0aW9uKHQpe2wuJHduZHcub2ZmKHIua2V5ZG93bitcIi1vZmZDYW52YXNcIiksbC4kd25kdy5vZmYoci5mb2N1c2luK1wiLVwiK3MpLm9uKHIuZm9jdXNpbitcIi1cIitzLGZ1bmN0aW9uKHQpe2lmKGwuJGh0bWwuaGFzQ2xhc3MoYS5vcGVuZWQpKXt2YXIgbj1lKHQudGFyZ2V0KTtuLmlzKFwiLlwiK2EudGFiZW5kKSYmbi5wYXJlbnQoKS5maW5kKFwiLlwiK2EudGFic3RhcnQpLmZvY3VzKCl9fSksbC4kd25kdy5vZmYoci5rZXlkb3duK1wiLVwiK3MpLm9uKHIua2V5ZG93bitcIi1cIitzLGZ1bmN0aW9uKHQpe3ZhciBuPWUodC50YXJnZXQpLGk9bi5jbG9zZXN0KFwiLlwiK2EubWVudSk7aWYoaS5sZW5ndGgpe2kuZGF0YShcIm1tZW51XCIpO2lmKG4uaXMoXCJpbnB1dCwgdGV4dGFyZWFcIikpO2Vsc2Ugc3dpdGNoKHQua2V5Q29kZSl7Y2FzZSAxMzoobi5pcyhcIi5tbS10b2dnbGVcIil8fG4uaXMoXCIubW0tY2hlY2tcIikpJiZuLnRyaWdnZXIoci5jbGljayk7YnJlYWs7Y2FzZSAzMjpjYXNlIDM3OmNhc2UgMzg6Y2FzZSAzOTpjYXNlIDQwOnQucHJldmVudERlZmF1bHQoKX19fSksdCYmbC4kd25kdy5vZmYoci5rZXlkb3duK1wiLVwiK3MpLm9uKHIua2V5ZG93bitcIi1cIitzLGZ1bmN0aW9uKHQpe3ZhciBuPWUodC50YXJnZXQpLGk9bi5jbG9zZXN0KFwiLlwiK2EubWVudSk7aWYoaS5sZW5ndGgpe3ZhciBzPWkuZGF0YShcIm1tZW51XCIpO2lmKG4uaXMoXCJpbnB1dCwgdGV4dGFyZWFcIikpc3dpdGNoKHQua2V5Q29kZSl7Y2FzZSAyNzpuLnZhbChcIlwiKX1lbHNlIHN3aXRjaCh0LmtleUNvZGUpe2Nhc2UgODp2YXIgcj1uLmNsb3Nlc3QoXCIuXCIrYS5wYW5lbCkuZGF0YShvLnBhcmVudCk7ciYmci5sZW5ndGgmJnMub3BlblBhbmVsKHIuY2xvc2VzdChcIi5cIithLnBhbmVsKSk7YnJlYWs7Y2FzZSAyNzppLmhhc0NsYXNzKGEub2ZmY2FudmFzKSYmcy5jbG9zZSgpfX19KX07dmFyIGEsbyxyLGwsZD1cImlucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBidXR0b24sIGxhYmVsLCBhW2hyZWZdXCJ9KGpRdWVyeSksLypcbiAqIGpRdWVyeSBtbWVudSBsYXp5U3VibWVudXMgYWRkLW9uXG4gKiBtbWVudS5mcmVic2l0ZS5ubFxuICpcbiAqIENvcHlyaWdodCAoYykgRnJlZCBIZXVzc2NoZW5cbiAqL1xuZnVuY3Rpb24oZSl7dmFyIHQ9XCJtbWVudVwiLG49XCJsYXp5U3VibWVudXNcIjtlW3RdLmFkZG9uc1tuXT17c2V0dXA6ZnVuY3Rpb24oKXt2YXIgcz10aGlzLm9wdHNbbl07dGhpcy5jb25mW25dO289ZVt0XS5nbGJsLFwiYm9vbGVhblwiPT10eXBlb2YgcyYmKHM9e2xvYWQ6c30pLFwib2JqZWN0XCIhPXR5cGVvZiBzJiYocz17fSkscz10aGlzLm9wdHNbbl09ZS5leHRlbmQoITAse30sZVt0XS5kZWZhdWx0c1tuXSxzKSxzLmxvYWQmJih0aGlzLmJpbmQoXCJpbml0TWVudTphZnRlclwiLGZ1bmN0aW9uKCl7dGhpcy4kcG5scy5maW5kKFwibGlcIikuY2hpbGRyZW4odGhpcy5jb25mLnBhbmVsTm9kZXR5cGUpLm5vdChcIi5cIitpLmluc2V0KS5ub3QoXCIuXCIraS5ub2xpc3R2aWV3KS5ub3QoXCIuXCIraS5ub3BhbmVsKS5hZGRDbGFzcyhpLmxhenlzdWJtZW51K1wiIFwiK2kubm9saXN0dmlldytcIiBcIitpLm5vcGFuZWwpfSksdGhpcy5iaW5kKFwiaW5pdFBhbmVsczpiZWZvcmVcIixmdW5jdGlvbihlKXtlPWV8fHRoaXMuJHBubHMuY2hpbGRyZW4odGhpcy5jb25mLnBhbmVsTm9kZXR5cGUpLHRoaXMuX19maW5kQWRkQmFjayhlLFwiLlwiK2kubGF6eXN1Ym1lbnUpLm5vdChcIi5cIitpLmxhenlzdWJtZW51K1wiIC5cIitpLmxhenlzdWJtZW51KS5yZW1vdmVDbGFzcyhpLmxhenlzdWJtZW51K1wiIFwiK2kubm9saXN0dmlldytcIiBcIitpLm5vcGFuZWwpfSksdGhpcy5iaW5kKFwiaW5pdE9wZW5lZDpiZWZvcmVcIixmdW5jdGlvbigpe3ZhciBlPXRoaXMuJHBubHMuZmluZChcIi5cIit0aGlzLmNvbmYuY2xhc3NOYW1lcy5zZWxlY3RlZCkucGFyZW50cyhcIi5cIitpLmxhenlzdWJtZW51KTtlLmxlbmd0aCYmKGUucmVtb3ZlQ2xhc3MoaS5sYXp5c3VibWVudStcIiBcIitpLm5vbGlzdHZpZXcrXCIgXCIraS5ub3BhbmVsKSx0aGlzLmluaXRQYW5lbHMoZS5sYXN0KCkpKX0pLHRoaXMuYmluZChcIm9wZW5QYW5lbDpiZWZvcmVcIixmdW5jdGlvbihlKXt2YXIgdD10aGlzLl9fZmluZEFkZEJhY2soZSxcIi5cIitpLmxhenlzdWJtZW51KS5ub3QoXCIuXCIraS5sYXp5c3VibWVudStcIiAuXCIraS5sYXp5c3VibWVudSk7dC5sZW5ndGgmJnRoaXMuaW5pdFBhbmVscyh0KX0pKX0sYWRkOmZ1bmN0aW9uKCl7aT1lW3RdLl9jLHM9ZVt0XS5fZCxhPWVbdF0uX2UsaS5hZGQoXCJsYXp5c3VibWVudVwiKSxzLmFkZChcImxhenlzdWJtZW51XCIpfSxjbGlja0FuY2hvcjpmdW5jdGlvbihlLHQpe319LGVbdF0uZGVmYXVsdHNbbl09e2xvYWQ6ITF9LGVbdF0uY29uZmlndXJhdGlvbltuXT17fTt2YXIgaSxzLGEsb30oalF1ZXJ5KSwvKlxuICogalF1ZXJ5IG1tZW51IG5hdmJhciBhZGQtb25cbiAqIG1tZW51LmZyZWJzaXRlLm5sXG4gKlxuICogQ29weXJpZ2h0IChjKSBGcmVkIEhldXNzY2hlblxuICovXG5mdW5jdGlvbihlKXt2YXIgdD1cIm1tZW51XCIsbj1cIm5hdmJhcnNcIjtlW3RdLmFkZG9uc1tuXT17c2V0dXA6ZnVuY3Rpb24oKXt2YXIgcz10aGlzLGE9dGhpcy5vcHRzW25dLHI9dGhpcy5jb25mW25dO2lmKG89ZVt0XS5nbGJsLFwidW5kZWZpbmVkXCIhPXR5cGVvZiBhKXthIGluc3RhbmNlb2YgQXJyYXl8fChhPVthXSk7dmFyIGw9e30sZD17fTthLmxlbmd0aCYmKGUuZWFjaChhLGZ1bmN0aW9uKG8pe3ZhciBjPWFbb107XCJib29sZWFuXCI9PXR5cGVvZiBjJiZjJiYoYz17fSksXCJvYmplY3RcIiE9dHlwZW9mIGMmJihjPXt9KSxcInVuZGVmaW5lZFwiPT10eXBlb2YgYy5jb250ZW50JiYoYy5jb250ZW50PVtcInByZXZcIixcInRpdGxlXCJdKSxjLmNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheXx8KGMuY29udGVudD1bYy5jb250ZW50XSksYz1lLmV4dGVuZCghMCx7fSxzLm9wdHMubmF2YmFyLGMpO3ZhciBoPWUoJzxkaXYgY2xhc3M9XCInK2kubmF2YmFyKydcIiAvPicpLGY9Yy5oZWlnaHQ7XCJudW1iZXJcIiE9dHlwZW9mIGYmJihmPTEpLGY9TWF0aC5taW4oNCxNYXRoLm1heCgxLGYpKSxoLmFkZENsYXNzKGkubmF2YmFyK1wiLXNpemUtXCIrZik7dmFyIHU9Yy5wb3NpdGlvbjtcImJvdHRvbVwiIT11JiYodT1cInRvcFwiKSxsW3VdfHwobFt1XT0wKSxsW3VdKz1mLGRbdV18fChkW3VdPWUoJzxkaXYgY2xhc3M9XCInK2kubmF2YmFycytcIi1cIit1KydcIiAvPicpKSxkW3VdLmFwcGVuZChoKTtmb3IodmFyIHA9MCx2PTAsbT1jLmNvbnRlbnQubGVuZ3RoO3Y8bTt2Kyspe3ZhciBiPWVbdF0uYWRkb25zW25dW2MuY29udGVudFt2XV18fCExO2I/cCs9Yi5jYWxsKHMsaCxjLHIpOihiPWMuY29udGVudFt2XSxiIGluc3RhbmNlb2YgZXx8KGI9ZShjLmNvbnRlbnRbdl0pKSxoLmFwcGVuZChiKSl9cCs9TWF0aC5jZWlsKGguY2hpbGRyZW4oKS5ub3QoXCIuXCIraS5idG4pLmxlbmd0aC9mKSxwPjEmJmguYWRkQ2xhc3MoaS5uYXZiYXIrXCItY29udGVudC1cIitwKSxoLmNoaWxkcmVuKFwiLlwiK2kuYnRuKS5sZW5ndGgmJmguYWRkQ2xhc3MoaS5oYXNidG5zKX0pLHRoaXMuYmluZChcImluaXRNZW51OmFmdGVyXCIsZnVuY3Rpb24oKXtmb3IodmFyIGUgaW4gbCl0aGlzLiRtZW51LmFkZENsYXNzKGkuaGFzbmF2YmFyK1wiLVwiK2UrXCItXCIrbFtlXSksdGhpcy4kbWVudVtcImJvdHRvbVwiPT1lP1wiYXBwZW5kXCI6XCJwcmVwZW5kXCJdKGRbZV0pfSkpfX0sYWRkOmZ1bmN0aW9uKCl7aT1lW3RdLl9jLHM9ZVt0XS5fZCxhPWVbdF0uX2UsaS5hZGQoXCJuYXZiYXJzIGNsb3NlIGhhc2J0bnNcIil9LGNsaWNrQW5jaG9yOmZ1bmN0aW9uKGUsdCl7fX0sZVt0XS5jb25maWd1cmF0aW9uW25dPXticmVhZGNydW1iU2VwYXJhdG9yOlwiL1wifSxlW3RdLmNvbmZpZ3VyYXRpb24uY2xhc3NOYW1lc1tuXT17fTt2YXIgaSxzLGEsb30oalF1ZXJ5KSwvKlxuICogalF1ZXJ5IG1tZW51IG5hdmJhciBhZGQtb24gYnJlYWRjcnVtYnMgY29udGVudFxuICogbW1lbnUuZnJlYnNpdGUubmxcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZyZWQgSGV1c3NjaGVuXG4gKi9cbmZ1bmN0aW9uKGUpe3ZhciB0PVwibW1lbnVcIixuPVwibmF2YmFyc1wiLGk9XCJicmVhZGNydW1ic1wiO2VbdF0uYWRkb25zW25dW2ldPWZ1bmN0aW9uKG4saSxzKXt2YXIgYT10aGlzLG89ZVt0XS5fYyxyPWVbdF0uX2Q7by5hZGQoXCJicmVhZGNydW1icyBzZXBhcmF0b3JcIik7dmFyIGw9ZSgnPHNwYW4gY2xhc3M9XCInK28uYnJlYWRjcnVtYnMrJ1wiIC8+JykuYXBwZW5kVG8obik7cmV0dXJuIHRoaXMuYmluZChcImluaXROYXZiYXI6YWZ0ZXJcIixmdW5jdGlvbih0KXt0LnJlbW92ZUNsYXNzKG8uaGFzbmF2YmFyKTtmb3IodmFyIG49W10saT1lKCc8c3BhbiBjbGFzcz1cIicrby5icmVhZGNydW1icysnXCI+PC9zcGFuPicpLGE9dCxsPSEwO2EmJmEubGVuZ3RoOyl7aWYoYS5pcyhcIi5cIitvLnBhbmVsKXx8KGE9YS5jbG9zZXN0KFwiLlwiK28ucGFuZWwpKSwhYS5oYXNDbGFzcyhvLnZlcnRpY2FsKSl7dmFyIGQ9YS5jaGlsZHJlbihcIi5cIitvLm5hdmJhcikuY2hpbGRyZW4oXCIuXCIrby50aXRsZSkudGV4dCgpO24udW5zaGlmdChsP1wiPHNwYW4+XCIrZCtcIjwvc3Bhbj5cIjonPGEgaHJlZj1cIiMnK2EuYXR0cihcImlkXCIpKydcIj4nK2QrXCI8L2E+XCIpLGw9ITF9YT1hLmRhdGEoci5wYXJlbnQpfWkuYXBwZW5kKG4uam9pbignPHNwYW4gY2xhc3M9XCInK28uc2VwYXJhdG9yKydcIj4nK3MuYnJlYWRjcnVtYlNlcGFyYXRvcitcIjwvc3Bhbj5cIikpLmFwcGVuZFRvKHQuY2hpbGRyZW4oXCIuXCIrby5uYXZiYXIpKX0pLHRoaXMuYmluZChcIm9wZW5QYW5lbDpzdGFydFwiLGZ1bmN0aW9uKGUpe2wuaHRtbChlLmNoaWxkcmVuKFwiLlwiK28ubmF2YmFyKS5jaGlsZHJlbihcIi5cIitvLmJyZWFkY3J1bWJzKS5odG1sKCl8fFwiXCIpfSksdGhpcy5iaW5kKFwiaW5pdE5hdmJhcjphZnRlcjpzci1hcmlhXCIsZnVuY3Rpb24odCl7dC5jaGlsZHJlbihcIi5cIitvLm5hdmJhcikuY2hpbGRyZW4oXCIuXCIrby5icmVhZGNydW1icykuY2hpbGRyZW4oXCJhXCIpLmVhY2goZnVuY3Rpb24oKXthLl9fc3JfYXJpYShlKHRoaXMpLFwib3duc1wiLGUodGhpcykuYXR0cihcImhyZWZcIikuc2xpY2UoMSkpfSl9KSwwfX0oalF1ZXJ5KSwvKlxuICogalF1ZXJ5IG1tZW51IG5hdmJhciBhZGQtb24gY2xvc2UgY29udGVudFxuICogbW1lbnUuZnJlYnNpdGUubmxcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZyZWQgSGV1c3NjaGVuXG4gKi9cbmZ1bmN0aW9uKGUpe3ZhciB0PVwibW1lbnVcIixuPVwibmF2YmFyc1wiLGk9XCJjbG9zZVwiO2VbdF0uYWRkb25zW25dW2ldPWZ1bmN0aW9uKG4saSl7dmFyIHM9ZVt0XS5fYyxhPShlW3RdLmdsYmwsZSgnPGEgY2xhc3M9XCInK3MuY2xvc2UrXCIgXCIrcy5idG4rJ1wiIGhyZWY9XCIjXCIgLz4nKS5hcHBlbmRUbyhuKSk7cmV0dXJuIHRoaXMuYmluZChcInNldFBhZ2U6YWZ0ZXJcIixmdW5jdGlvbihlKXthLmF0dHIoXCJocmVmXCIsXCIjXCIrZS5hdHRyKFwiaWRcIikpfSksdGhpcy5iaW5kKFwic2V0UGFnZTphZnRlcjpzci10ZXh0XCIsZnVuY3Rpb24obil7YS5odG1sKHRoaXMuX19zcl90ZXh0KGVbdF0uaTE4bih0aGlzLmNvbmYuc2NyZWVuUmVhZGVyLnRleHQuY2xvc2VNZW51KSkpLHRoaXMuX19zcl9hcmlhKGEsXCJvd25zXCIsYS5hdHRyKFwiaHJlZlwiKS5zbGljZSgxKSl9KSwtMX19KGpRdWVyeSksLypcbiAqIGpRdWVyeSBtbWVudSBuYXZiYXIgYWRkLW9uIG5leHQgY29udGVudFxuICogbW1lbnUuZnJlYnNpdGUubmxcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZyZWQgSGV1c3NjaGVuXG4gKi9cbmZ1bmN0aW9uKGUpe3ZhciB0PVwibW1lbnVcIixuPVwibmF2YmFyc1wiLGk9XCJuZXh0XCI7ZVt0XS5hZGRvbnNbbl1baV09ZnVuY3Rpb24oaSxzKXt2YXIgYSxvLHIsbD1lW3RdLl9jLGQ9ZSgnPGEgY2xhc3M9XCInK2wubmV4dCtcIiBcIitsLmJ0bisnXCIgaHJlZj1cIiNcIiAvPicpLmFwcGVuZFRvKGkpO3JldHVybiB0aGlzLmJpbmQoXCJvcGVuUGFuZWw6c3RhcnRcIixmdW5jdGlvbihlKXthPWUuZmluZChcIi5cIit0aGlzLmNvbmYuY2xhc3NOYW1lc1tuXS5wYW5lbE5leHQpLG89YS5hdHRyKFwiaHJlZlwiKSxyPWEuaHRtbCgpLG8/ZC5hdHRyKFwiaHJlZlwiLG8pOmQucmVtb3ZlQXR0cihcImhyZWZcIiksZFtvfHxyP1wicmVtb3ZlQ2xhc3NcIjpcImFkZENsYXNzXCJdKGwuaGlkZGVuKSxkLmh0bWwocil9KSx0aGlzLmJpbmQoXCJvcGVuUGFuZWw6c3RhcnQ6c3ItYXJpYVwiLGZ1bmN0aW9uKGUpe3RoaXMuX19zcl9hcmlhKGQsXCJoaWRkZW5cIixkLmhhc0NsYXNzKGwuaGlkZGVuKSksdGhpcy5fX3NyX2FyaWEoZCxcIm93bnNcIiwoZC5hdHRyKFwiaHJlZlwiKXx8XCJcIikuc2xpY2UoMSkpfSksLTF9LGVbdF0uY29uZmlndXJhdGlvbi5jbGFzc05hbWVzW25dLnBhbmVsTmV4dD1cIk5leHRcIn0oalF1ZXJ5KSwvKlxuICogalF1ZXJ5IG1tZW51IG5hdmJhciBhZGQtb24gcHJldiBjb250ZW50XG4gKiBtbWVudS5mcmVic2l0ZS5ubFxuICpcbiAqIENvcHlyaWdodCAoYykgRnJlZCBIZXVzc2NoZW5cbiAqL1xuZnVuY3Rpb24oZSl7dmFyIHQ9XCJtbWVudVwiLG49XCJuYXZiYXJzXCIsaT1cInByZXZcIjtlW3RdLmFkZG9uc1tuXVtpXT1mdW5jdGlvbihpLHMpe3ZhciBhPWVbdF0uX2Msbz1lKCc8YSBjbGFzcz1cIicrYS5wcmV2K1wiIFwiK2EuYnRuKydcIiBocmVmPVwiI1wiIC8+JykuYXBwZW5kVG8oaSk7dGhpcy5iaW5kKFwiaW5pdE5hdmJhcjphZnRlclwiLGZ1bmN0aW9uKGUpe2UucmVtb3ZlQ2xhc3MoYS5oYXNuYXZiYXIpfSk7dmFyIHIsbCxkO3JldHVybiB0aGlzLmJpbmQoXCJvcGVuUGFuZWw6c3RhcnRcIixmdW5jdGlvbihlKXtlLmhhc0NsYXNzKGEudmVydGljYWwpfHwocj1lLmZpbmQoXCIuXCIrdGhpcy5jb25mLmNsYXNzTmFtZXNbbl0ucGFuZWxQcmV2KSxyLmxlbmd0aHx8KHI9ZS5jaGlsZHJlbihcIi5cIithLm5hdmJhcikuY2hpbGRyZW4oXCIuXCIrYS5wcmV2KSksbD1yLmF0dHIoXCJocmVmXCIpLGQ9ci5odG1sKCksbD9vLmF0dHIoXCJocmVmXCIsbCk6by5yZW1vdmVBdHRyKFwiaHJlZlwiKSxvW2x8fGQ/XCJyZW1vdmVDbGFzc1wiOlwiYWRkQ2xhc3NcIl0oYS5oaWRkZW4pLG8uaHRtbChkKSl9KSx0aGlzLmJpbmQoXCJpbml0TmF2YmFyOmFmdGVyOnNyLWFyaWFcIixmdW5jdGlvbihlKXt2YXIgdD1lLmNoaWxkcmVuKFwiLlwiK2EubmF2YmFyKTt0aGlzLl9fc3JfYXJpYSh0LFwiaGlkZGVuXCIsITApfSksdGhpcy5iaW5kKFwib3BlblBhbmVsOnN0YXJ0OnNyLWFyaWFcIixmdW5jdGlvbihlKXt0aGlzLl9fc3JfYXJpYShvLFwiaGlkZGVuXCIsby5oYXNDbGFzcyhhLmhpZGRlbikpLHRoaXMuX19zcl9hcmlhKG8sXCJvd25zXCIsKG8uYXR0cihcImhyZWZcIil8fFwiXCIpLnNsaWNlKDEpKX0pLC0xfSxlW3RdLmNvbmZpZ3VyYXRpb24uY2xhc3NOYW1lc1tuXS5wYW5lbFByZXY9XCJQcmV2XCJ9KGpRdWVyeSksLypcbiAqIGpRdWVyeSBtbWVudSBuYXZiYXIgYWRkLW9uIHNlYXJjaGZpZWxkIGNvbnRlbnRcbiAqIG1tZW51LmZyZWJzaXRlLm5sXG4gKlxuICogQ29weXJpZ2h0IChjKSBGcmVkIEhldXNzY2hlblxuICovXG5mdW5jdGlvbihlKXt2YXIgdD1cIm1tZW51XCIsbj1cIm5hdmJhcnNcIixpPVwic2VhcmNoZmllbGRcIjtlW3RdLmFkZG9uc1tuXVtpXT1mdW5jdGlvbihuLGkpe3ZhciBzPWVbdF0uX2MsYT1lKCc8ZGl2IGNsYXNzPVwiJytzLnNlYXJjaCsnXCIgLz4nKS5hcHBlbmRUbyhuKTtyZXR1cm5cIm9iamVjdFwiIT10eXBlb2YgdGhpcy5vcHRzLnNlYXJjaGZpZWxkJiYodGhpcy5vcHRzLnNlYXJjaGZpZWxkPXt9KSx0aGlzLm9wdHMuc2VhcmNoZmllbGQuYWRkPSEwLHRoaXMub3B0cy5zZWFyY2hmaWVsZC5hZGRUbz1hLDB9fShqUXVlcnkpLC8qXG4gKiBqUXVlcnkgbW1lbnUgbmF2YmFyIGFkZC1vbiB0aXRsZSBjb250ZW50XG4gKiBtbWVudS5mcmVic2l0ZS5ubFxuICpcbiAqIENvcHlyaWdodCAoYykgRnJlZCBIZXVzc2NoZW5cbiAqL1xuZnVuY3Rpb24oZSl7dmFyIHQ9XCJtbWVudVwiLG49XCJuYXZiYXJzXCIsaT1cInRpdGxlXCI7ZVt0XS5hZGRvbnNbbl1baV09ZnVuY3Rpb24oaSxzKXt2YXIgYSxvLHIsbD1lW3RdLl9jLGQ9ZSgnPGEgY2xhc3M9XCInK2wudGl0bGUrJ1wiIC8+JykuYXBwZW5kVG8oaSk7dGhpcy5iaW5kKFwib3BlblBhbmVsOnN0YXJ0XCIsZnVuY3Rpb24oZSl7ZS5oYXNDbGFzcyhsLnZlcnRpY2FsKXx8KHI9ZS5maW5kKFwiLlwiK3RoaXMuY29uZi5jbGFzc05hbWVzW25dLnBhbmVsVGl0bGUpLHIubGVuZ3RofHwocj1lLmNoaWxkcmVuKFwiLlwiK2wubmF2YmFyKS5jaGlsZHJlbihcIi5cIitsLnRpdGxlKSksYT1yLmF0dHIoXCJocmVmXCIpLG89ci5odG1sKCl8fHMudGl0bGUsYT9kLmF0dHIoXCJocmVmXCIsYSk6ZC5yZW1vdmVBdHRyKFwiaHJlZlwiKSxkW2F8fG8/XCJyZW1vdmVDbGFzc1wiOlwiYWRkQ2xhc3NcIl0obC5oaWRkZW4pLGQuaHRtbChvKSl9KTt2YXIgYztyZXR1cm4gdGhpcy5iaW5kKFwib3BlblBhbmVsOnN0YXJ0OnNyLWFyaWFcIixmdW5jdGlvbihlKXtpZih0aGlzLm9wdHMuc2NyZWVuUmVhZGVyLnRleHQmJihjfHwoYz10aGlzLiRtZW51LmNoaWxkcmVuKFwiLlwiK2wubmF2YmFycytcIi10b3AsIC5cIitsLm5hdmJhcnMrXCItYm90dG9tXCIpLmNoaWxkcmVuKFwiLlwiK2wubmF2YmFyKS5jaGlsZHJlbihcIi5cIitsLnByZXYpKSxjLmxlbmd0aCkpe3ZhciB0PSEwO1wicGFyZW50XCI9PXRoaXMub3B0cy5uYXZiYXIudGl0bGVMaW5rJiYodD0hYy5oYXNDbGFzcyhsLmhpZGRlbikpLHRoaXMuX19zcl9hcmlhKGQsXCJoaWRkZW5cIix0KX19KSwwfSxlW3RdLmNvbmZpZ3VyYXRpb24uY2xhc3NOYW1lc1tuXS5wYW5lbFRpdGxlPVwiVGl0bGVcIn0oalF1ZXJ5KSwvKlxuICogalF1ZXJ5IG1tZW51IHBhZ2VTY3JvbGwgYWRkLW9uXG4gKiBtbWVudS5mcmVic2l0ZS5ubFxuICpcbiAqIENvcHlyaWdodCAoYykgRnJlZCBIZXVzc2NoZW5cbiAqL1xuZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChlKXtkJiZkLmxlbmd0aCYmZC5pcyhcIjp2aXNpYmxlXCIpJiZsLiRodG1sLmFkZChsLiRib2R5KS5hbmltYXRlKHtzY3JvbGxUb3A6ZC5vZmZzZXQoKS50b3ArZX0pLGQ9ITF9ZnVuY3Rpb24gbihlKXt0cnl7cmV0dXJuIShcIiNcIj09ZXx8XCIjXCIhPWUuc2xpY2UoMCwxKXx8IWwuJHBhZ2UuZmluZChlKS5sZW5ndGgpfWNhdGNoKHQpe3JldHVybiExfX12YXIgaT1cIm1tZW51XCIscz1cInBhZ2VTY3JvbGxcIjtlW2ldLmFkZG9uc1tzXT17c2V0dXA6ZnVuY3Rpb24oKXt2YXIgbz10aGlzLGQ9dGhpcy5vcHRzW3NdLGM9dGhpcy5jb25mW3NdO2lmKGw9ZVtpXS5nbGJsLFwiYm9vbGVhblwiPT10eXBlb2YgZCYmKGQ9e3Njcm9sbDpkfSksZD10aGlzLm9wdHNbc109ZS5leHRlbmQoITAse30sZVtpXS5kZWZhdWx0c1tzXSxkKSxkLnNjcm9sbCYmdGhpcy5iaW5kKFwiY2xvc2U6ZmluaXNoXCIsZnVuY3Rpb24oKXt0KGMuc2Nyb2xsT2Zmc2V0KX0pLGQudXBkYXRlKXt2YXIgbz10aGlzLGg9W10sZj1bXTtvLmJpbmQoXCJpbml0TGlzdHZpZXc6YWZ0ZXJcIixmdW5jdGlvbih0KXtvLl9fZmlsdGVyTGlzdEl0ZW1BbmNob3JzKHQuZmluZChcIi5cIithLmxpc3R2aWV3KS5jaGlsZHJlbihcImxpXCIpKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIHQ9ZSh0aGlzKS5hdHRyKFwiaHJlZlwiKTtuKHQpJiZoLnB1c2godCl9KSxmPWgucmV2ZXJzZSgpfSk7dmFyIHU9LTE7bC4kd25kdy5vbihyLnNjcm9sbCtcIi1cIitzLGZ1bmN0aW9uKHQpe2Zvcih2YXIgbj1sLiR3bmR3LnNjcm9sbFRvcCgpLGk9MDtpPGYubGVuZ3RoO2krKylpZihlKGZbaV0pLm9mZnNldCgpLnRvcDxuK2MudXBkYXRlT2Zmc2V0KXt1IT09aSYmKHU9aSxvLnNldFNlbGVjdGVkKG8uX19maWx0ZXJMaXN0SXRlbUFuY2hvcnMoby4kcG5scy5jaGlsZHJlbihcIi5cIithLm9wZW5lZCkuZmluZChcIi5cIithLmxpc3R2aWV3KS5jaGlsZHJlbihcImxpXCIpKS5maWx0ZXIoJ1tocmVmPVwiJytmW2ldKydcIl0nKS5wYXJlbnQoKSkpO2JyZWFrfX0pfX0sYWRkOmZ1bmN0aW9uKCl7YT1lW2ldLl9jLG89ZVtpXS5fZCxyPWVbaV0uX2V9LGNsaWNrQW5jaG9yOmZ1bmN0aW9uKGksbyl7aWYoZD0hMSxvJiZ0aGlzLm9wdHNbc10uc2Nyb2xsJiZ0aGlzLm9wdHMub2ZmQ2FudmFzJiZsLiRwYWdlJiZsLiRwYWdlLmxlbmd0aCl7dmFyIHI9aS5hdHRyKFwiaHJlZlwiKTtuKHIpJiYoZD1lKHIpLGwuJGh0bWwuaGFzQ2xhc3MoYS5tbShcIndpZGVzY3JlZW5cIikpJiZ0KHRoaXMuY29uZltzXS5zY3JvbGxPZmZzZXQpKX19fSxlW2ldLmRlZmF1bHRzW3NdPXtzY3JvbGw6ITEsdXBkYXRlOiExfSxlW2ldLmNvbmZpZ3VyYXRpb25bc109e3Njcm9sbE9mZnNldDowLHVwZGF0ZU9mZnNldDo1MH07dmFyIGEsbyxyLGwsZD0hMX0oalF1ZXJ5KSwvKlxuICogalF1ZXJ5IG1tZW51IFJUTCBhZGQtb25cbiAqIG1tZW51LmZyZWJzaXRlLm5sXG4gKlxuICogQ29weXJpZ2h0IChjKSBGcmVkIEhldXNzY2hlblxuICovXG5mdW5jdGlvbihlKXt2YXIgdD1cIm1tZW51XCIsbj1cInJ0bFwiO2VbdF0uYWRkb25zW25dPXtzZXR1cDpmdW5jdGlvbigpe3ZhciBzPXRoaXMub3B0c1tuXTt0aGlzLmNvbmZbbl07bz1lW3RdLmdsYmwsXCJvYmplY3RcIiE9dHlwZW9mIHMmJihzPXt1c2U6c30pLHM9dGhpcy5vcHRzW25dPWUuZXh0ZW5kKCEwLHt9LGVbdF0uZGVmYXVsdHNbbl0scyksXCJib29sZWFuXCIhPXR5cGVvZiBzLnVzZSYmKHMudXNlPVwicnRsXCI9PShvLiRodG1sLmF0dHIoXCJkaXJcIil8fFwiXCIpLnRvTG93ZXJDYXNlKCkpLHMudXNlJiZ0aGlzLmJpbmQoXCJpbml0TWVudTphZnRlclwiLGZ1bmN0aW9uKCl7dGhpcy4kbWVudS5hZGRDbGFzcyhpLnJ0bCl9KX0sYWRkOmZ1bmN0aW9uKCl7aT1lW3RdLl9jLHM9ZVt0XS5fZCxhPWVbdF0uX2UsaS5hZGQoXCJydGxcIil9LGNsaWNrQW5jaG9yOmZ1bmN0aW9uKGUsdCl7fX0sZVt0XS5kZWZhdWx0c1tuXT17dXNlOlwiZGV0ZWN0XCJ9O3ZhciBpLHMsYSxvfShqUXVlcnkpLC8qXG4gKiBqUXVlcnkgbW1lbnUgc2VhcmNoZmllbGQgYWRkLW9uXG4gKiBtbWVudS5mcmVic2l0ZS5ubFxuICpcbiAqIENvcHlyaWdodCAoYykgRnJlZCBIZXVzc2NoZW5cbiAqL1xuZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChlKXtzd2l0Y2goZSl7Y2FzZSA5OmNhc2UgMTY6Y2FzZSAxNzpjYXNlIDE4OmNhc2UgMzc6Y2FzZSAzODpjYXNlIDM5OmNhc2UgNDA6cmV0dXJuITB9cmV0dXJuITF9dmFyIG49XCJtbWVudVwiLGk9XCJzZWFyY2hmaWVsZFwiO2Vbbl0uYWRkb25zW2ldPXtzZXR1cDpmdW5jdGlvbigpe3ZhciBsPXRoaXMsZD10aGlzLm9wdHNbaV0sYz10aGlzLmNvbmZbaV07cj1lW25dLmdsYmwsXCJib29sZWFuXCI9PXR5cGVvZiBkJiYoZD17YWRkOmR9KSxcIm9iamVjdFwiIT10eXBlb2YgZCYmKGQ9e30pLFwiYm9vbGVhblwiPT10eXBlb2YgZC5yZXN1bHRzUGFuZWwmJihkLnJlc3VsdHNQYW5lbD17YWRkOmQucmVzdWx0c1BhbmVsfSksZD10aGlzLm9wdHNbaV09ZS5leHRlbmQoITAse30sZVtuXS5kZWZhdWx0c1tpXSxkKSxjPXRoaXMuY29uZltpXT1lLmV4dGVuZCghMCx7fSxlW25dLmNvbmZpZ3VyYXRpb25baV0sYyksdGhpcy5iaW5kKFwiY2xvc2U6c3RhcnRcIixmdW5jdGlvbigpe3RoaXMuJG1lbnUuZmluZChcIi5cIitzLnNlYXJjaCkuZmluZChcImlucHV0XCIpLmJsdXIoKX0pLHRoaXMuYmluZChcImluaXRQYW5lbHM6YWZ0ZXJcIixmdW5jdGlvbihyKXtpZihkLmFkZCl7dmFyIGg7c3dpdGNoKGQuYWRkVG8pe2Nhc2VcInBhbmVsc1wiOmg9cjticmVhaztkZWZhdWx0Omg9dGhpcy4kbWVudS5maW5kKGQuYWRkVG8pfWlmKGguZWFjaChmdW5jdGlvbigpe3ZhciB0PWUodGhpcyk7aWYoIXQuaXMoXCIuXCIrcy5wYW5lbCl8fCF0LmlzKFwiLlwiK3MudmVydGljYWwpKXtpZighdC5jaGlsZHJlbihcIi5cIitzLnNlYXJjaCkubGVuZ3RoKXt2YXIgaT1sLl9fdmFsdWVPckZuKGMuY2xlYXIsdCksYT1sLl9fdmFsdWVPckZuKGMuZm9ybSx0KSxyPWwuX192YWx1ZU9yRm4oYy5pbnB1dCx0KSxoPWwuX192YWx1ZU9yRm4oYy5zdWJtaXQsdCksZj1lKFwiPFwiKyhhP1wiZm9ybVwiOlwiZGl2XCIpKycgY2xhc3M9XCInK3Muc2VhcmNoKydcIiAvPicpLHU9ZSgnPGlucHV0IHBsYWNlaG9sZGVyPVwiJytlW25dLmkxOG4oZC5wbGFjZWhvbGRlcikrJ1wiIHR5cGU9XCJ0ZXh0XCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgLz4nKTtmLmFwcGVuZCh1KTt2YXIgcDtpZihyKWZvcihwIGluIHIpdS5hdHRyKHAscltwXSk7aWYoaSYmZSgnPGEgY2xhc3M9XCInK3MuYnRuK1wiIFwiK3MuY2xlYXIrJ1wiIGhyZWY9XCIjXCIgLz4nKS5hcHBlbmRUbyhmKS5vbihvLmNsaWNrK1wiLXNlYXJjaGZpZWxkXCIsZnVuY3Rpb24oZSl7ZS5wcmV2ZW50RGVmYXVsdCgpLHUudmFsKFwiXCIpLnRyaWdnZXIoby5rZXl1cCtcIi1zZWFyY2hmaWVsZFwiKX0pLGEpe2ZvcihwIGluIGEpZi5hdHRyKHAsYVtwXSk7aCYmIWkmJmUoJzxhIGNsYXNzPVwiJytzLmJ0bitcIiBcIitzLm5leHQrJ1wiIGhyZWY9XCIjXCIgLz4nKS5hcHBlbmRUbyhmKS5vbihvLmNsaWNrK1wiLXNlYXJjaGZpZWxkXCIsZnVuY3Rpb24oZSl7ZS5wcmV2ZW50RGVmYXVsdCgpLGYuc3VibWl0KCl9KX10Lmhhc0NsYXNzKHMuc2VhcmNoKT90LnJlcGxhY2VXaXRoKGYpOnQucHJlcGVuZChmKS5hZGRDbGFzcyhzLmhhc3NlYXJjaCl9aWYoZC5ub1Jlc3VsdHMpe3ZhciB2PXQuY2xvc2VzdChcIi5cIitzLnBhbmVsKS5sZW5ndGg7aWYodnx8KHQ9bC4kcG5scy5jaGlsZHJlbihcIi5cIitzLnBhbmVsKS5maXJzdCgpKSwhdC5jaGlsZHJlbihcIi5cIitzLm5vcmVzdWx0c21zZykubGVuZ3RoKXt2YXIgbT10LmNoaWxkcmVuKFwiLlwiK3MubGlzdHZpZXcpLmZpcnN0KCksYj1lKCc8ZGl2IGNsYXNzPVwiJytzLm5vcmVzdWx0c21zZytcIiBcIitzLmhpZGRlbisnXCIgLz4nKTtiLmFwcGVuZChlW25dLmkxOG4oZC5ub1Jlc3VsdHMpKVttLmxlbmd0aD9cImluc2VydEFmdGVyXCI6XCJwcmVwZW5kVG9cIl0obS5sZW5ndGg/bTp0KX19fX0pLGQuc2VhcmNoKXtpZihkLnJlc3VsdHNQYW5lbC5hZGQpe2Quc2hvd1N1YlBhbmVscz0hMTt2YXIgZj10aGlzLiRwbmxzLmNoaWxkcmVuKFwiLlwiK3MucmVzdWx0c3BhbmVsKTtmLmxlbmd0aHx8KGY9ZSgnPGRpdiBjbGFzcz1cIicrcy5yZXN1bHRzcGFuZWwrXCIgXCIrcy5ub2FuaW1hdGlvbitcIiBcIitzLmhpZGRlbisnXCIgLz4nKS5hcHBlbmRUbyh0aGlzLiRwbmxzKS5hcHBlbmQoJzxkaXYgY2xhc3M9XCInK3MubmF2YmFyK1wiIFwiK3MuaGlkZGVuKydcIj48YSBjbGFzcz1cIicrcy50aXRsZSsnXCI+JytlW25dLmkxOG4oZC5yZXN1bHRzUGFuZWwudGl0bGUpK1wiPC9hPjwvZGl2PlwiKS5hcHBlbmQoJzx1bCBjbGFzcz1cIicrcy5saXN0dmlldysnXCIgLz4nKS5hcHBlbmQodGhpcy4kcG5scy5maW5kKFwiLlwiK3Mubm9yZXN1bHRzbXNnKS5maXJzdCgpLmNsb25lKCkpLHRoaXMuX2luaXRQYW5lbChmKSl9dGhpcy4kbWVudS5maW5kKFwiLlwiK3Muc2VhcmNoKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIG4scixjPWUodGhpcyksaD1jLmNsb3Nlc3QoXCIuXCIrcy5wYW5lbCkubGVuZ3RoO2g/KG49Yy5jbG9zZXN0KFwiLlwiK3MucGFuZWwpLHI9bik6KG49bC4kcG5scy5maW5kKFwiLlwiK3MucGFuZWwpLHI9bC4kbWVudSksZC5yZXN1bHRzUGFuZWwuYWRkJiYobj1uLm5vdChmKSk7dmFyIHU9Yy5jaGlsZHJlbihcImlucHV0XCIpLHA9bC5fX2ZpbmRBZGRCYWNrKG4sXCIuXCIrcy5saXN0dmlldykuY2hpbGRyZW4oXCJsaVwiKSx2PXAuZmlsdGVyKFwiLlwiK3MuZGl2aWRlciksbT1sLl9fZmlsdGVyTGlzdEl0ZW1zKHApLGI9XCJhXCIsZz1iK1wiLCBzcGFuXCIsXz1cIlwiLHk9ZnVuY3Rpb24oKXt2YXIgdD11LnZhbCgpLnRvTG93ZXJDYXNlKCk7aWYodCE9Xyl7aWYoXz10LGQucmVzdWx0c1BhbmVsLmFkZCYmZi5jaGlsZHJlbihcIi5cIitzLmxpc3R2aWV3KS5lbXB0eSgpLG4uc2Nyb2xsVG9wKDApLG0uYWRkKHYpLmFkZENsYXNzKHMuaGlkZGVuKS5maW5kKFwiLlwiK3MuZnVsbHN1Ym9wZW5zZWFyY2gpLnJlbW92ZUNsYXNzKHMuZnVsbHN1Ym9wZW4rXCIgXCIrcy5mdWxsc3Vib3BlbnNlYXJjaCksbS5lYWNoKGZ1bmN0aW9uKCl7dmFyIHQ9ZSh0aGlzKSxuPWI7KGQuc2hvd1RleHRJdGVtc3x8ZC5zaG93U3ViUGFuZWxzJiZ0LmZpbmQoXCIuXCIrcy5uZXh0KSkmJihuPWcpO3ZhciBpPXQuZGF0YShhLnNlYXJjaHRleHQpfHx0LmNoaWxkcmVuKG4pLm5vdChcIi5cIitzLm5leHQpLnRleHQoKTtpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihfKT4tMSYmdC5hZGQodC5wcmV2QWxsKFwiLlwiK3MuZGl2aWRlcikuZmlyc3QoKSkucmVtb3ZlQ2xhc3Mocy5oaWRkZW4pfSksZC5zaG93U3ViUGFuZWxzJiZuLmVhY2goZnVuY3Rpb24odCl7dmFyIG49ZSh0aGlzKTtsLl9fZmlsdGVyTGlzdEl0ZW1zKG4uZmluZChcIi5cIitzLmxpc3R2aWV3KS5jaGlsZHJlbigpKS5lYWNoKGZ1bmN0aW9uKCl7dmFyIHQ9ZSh0aGlzKSxuPXQuZGF0YShhLmNoaWxkKTt0LnJlbW92ZUNsYXNzKHMubm9zdWJyZXN1bHRzKSxuJiZuLmZpbmQoXCIuXCIrcy5saXN0dmlldykuY2hpbGRyZW4oKS5yZW1vdmVDbGFzcyhzLmhpZGRlbil9KX0pLGQucmVzdWx0c1BhbmVsLmFkZClpZihcIlwiPT09Xyl0aGlzLmNsb3NlQWxsUGFuZWxzKHRoaXMuJHBubHMuY2hpbGRyZW4oXCIuXCIrcy5zdWJvcGVuZWQpLmxhc3QoKSk7ZWxzZXt2YXIgaT1lKCk7bi5lYWNoKGZ1bmN0aW9uKCl7dmFyIHQ9bC5fX2ZpbHRlckxpc3RJdGVtcyhlKHRoaXMpLmZpbmQoXCIuXCIrcy5saXN0dmlldykuY2hpbGRyZW4oKSkubm90KFwiLlwiK3MuaGlkZGVuKS5jbG9uZSghMCk7dC5sZW5ndGgmJihkLnJlc3VsdHNQYW5lbC5kaXZpZGVycyYmKGk9aS5hZGQoJzxsaSBjbGFzcz1cIicrcy5kaXZpZGVyKydcIj4nK2UodGhpcykuY2hpbGRyZW4oXCIuXCIrcy5uYXZiYXIpLmNoaWxkcmVuKFwiLlwiK3MudGl0bGUpLnRleHQoKStcIjwvbGk+XCIpKSx0LmNoaWxkcmVuKFwiLlwiK3MubW0oXCJ0b2dnbGVcIikrXCIsIC5cIitzLm1tKFwiY2hlY2tcIikpLnJlbW92ZSgpLGk9aS5hZGQodCkpfSksaS5maW5kKFwiLlwiK3MubmV4dCkucmVtb3ZlKCksZi5jaGlsZHJlbihcIi5cIitzLmxpc3R2aWV3KS5hcHBlbmQoaSksdGhpcy5vcGVuUGFuZWwoZil9ZWxzZSBlKG4uZ2V0KCkucmV2ZXJzZSgpKS5lYWNoKGZ1bmN0aW9uKHQpe3ZhciBuPWUodGhpcyksaT1uLmRhdGEoYS5wYXJlbnQpO2kmJihsLl9fZmlsdGVyTGlzdEl0ZW1zKG4uZmluZChcIi5cIitzLmxpc3R2aWV3KS5jaGlsZHJlbigpKS5sZW5ndGg/KGkuaGFzQ2xhc3Mocy5oaWRkZW4pJiZpLmNoaWxkcmVuKFwiLlwiK3MubmV4dCkubm90KFwiLlwiK3MuZnVsbHN1Ym9wZW4pLmFkZENsYXNzKHMuZnVsbHN1Ym9wZW4pLmFkZENsYXNzKHMuZnVsbHN1Ym9wZW5zZWFyY2gpLGkucmVtb3ZlQ2xhc3Mocy5oaWRkZW4pLnJlbW92ZUNsYXNzKHMubm9zdWJyZXN1bHRzKS5wcmV2QWxsKFwiLlwiK3MuZGl2aWRlcikuZmlyc3QoKS5yZW1vdmVDbGFzcyhzLmhpZGRlbikpOmh8fCgobi5oYXNDbGFzcyhzLm9wZW5lZCl8fG4uaGFzQ2xhc3Mocy5zdWJvcGVuZWQpKSYmc2V0VGltZW91dChmdW5jdGlvbigpe2wub3BlblBhbmVsKGkuY2xvc2VzdChcIi5cIitzLnBhbmVsKSl9LCh0KzEpKigxLjUqbC5jb25mLm9wZW5pbmdJbnRlcnZhbCkpLGkuYWRkQ2xhc3Mocy5ub3N1YnJlc3VsdHMpKSl9KTtyLmZpbmQoXCIuXCIrcy5ub3Jlc3VsdHNtc2cpW20ubm90KFwiLlwiK3MuaGlkZGVuKS5sZW5ndGg/XCJhZGRDbGFzc1wiOlwicmVtb3ZlQ2xhc3NcIl0ocy5oaWRkZW4pLHRoaXMudHJpZ2dlcihcInVwZGF0ZUxpc3R2aWV3XCIpfX07dS5vZmYoby5rZXl1cCtcIi1cIitpK1wiIFwiK28uY2hhbmdlK1wiLVwiK2kpLm9uKG8ua2V5dXArXCItXCIraSxmdW5jdGlvbihlKXt0KGUua2V5Q29kZSl8fHkuY2FsbChsKX0pLm9uKG8uY2hhbmdlK1wiLVwiK2ksZnVuY3Rpb24oZSl7eS5jYWxsKGwpfSk7dmFyIEM9Yy5jaGlsZHJlbihcIi5cIitzLmJ0bik7Qy5sZW5ndGgmJnUub24oby5rZXl1cCtcIi1cIitpLGZ1bmN0aW9uKGUpe0NbdS52YWwoKS5sZW5ndGg/XCJyZW1vdmVDbGFzc1wiOlwiYWRkQ2xhc3NcIl0ocy5oaWRkZW4pfSksdS50cmlnZ2VyKG8ua2V5dXArXCItXCIraSl9KX19fSl9LGFkZDpmdW5jdGlvbigpe3M9ZVtuXS5fYyxhPWVbbl0uX2Qsbz1lW25dLl9lLHMuYWRkKFwiY2xlYXIgc2VhcmNoIGhhc3NlYXJjaCByZXN1bHRzcGFuZWwgbm9yZXN1bHRzbXNnIG5vcmVzdWx0cyBub3N1YnJlc3VsdHMgZnVsbHN1Ym9wZW5zZWFyY2hcIiksYS5hZGQoXCJzZWFyY2h0ZXh0XCIpLG8uYWRkKFwiY2hhbmdlIGtleXVwXCIpfSxjbGlja0FuY2hvcjpmdW5jdGlvbihlLHQpe319LGVbbl0uZGVmYXVsdHNbaV09e2FkZDohMSxhZGRUbzpcInBhbmVsc1wiLHBsYWNlaG9sZGVyOlwiU2VhcmNoXCIsbm9SZXN1bHRzOlwiTm8gcmVzdWx0cyBmb3VuZC5cIixyZXN1bHRzUGFuZWw6e2FkZDohMSxkaXZpZGVyczohMCx0aXRsZTpcIlNlYXJjaCByZXN1bHRzXCJ9LHNlYXJjaDohMCxzaG93VGV4dEl0ZW1zOiExLHNob3dTdWJQYW5lbHM6ITB9LGVbbl0uY29uZmlndXJhdGlvbltpXT17Y2xlYXI6ITEsZm9ybTohMSxpbnB1dDohMSxzdWJtaXQ6ITF9O3ZhciBzLGEsbyxyfShqUXVlcnkpLC8qXG4gKiBqUXVlcnkgbW1lbnUgc2VjdGlvbkluZGV4ZXIgYWRkLW9uXG4gKiBtbWVudS5mcmVic2l0ZS5ubFxuICpcbiAqIENvcHlyaWdodCAoYykgRnJlZCBIZXVzc2NoZW5cbiAqL1xuZnVuY3Rpb24oZSl7dmFyIHQ9XCJtbWVudVwiLG49XCJzZWN0aW9uSW5kZXhlclwiO2VbdF0uYWRkb25zW25dPXtzZXR1cDpmdW5jdGlvbigpe3ZhciBzPXRoaXMscj10aGlzLm9wdHNbbl07dGhpcy5jb25mW25dO289ZVt0XS5nbGJsLFwiYm9vbGVhblwiPT10eXBlb2YgciYmKHI9e2FkZDpyfSksXCJvYmplY3RcIiE9dHlwZW9mIHImJihyPXt9KSxyPXRoaXMub3B0c1tuXT1lLmV4dGVuZCghMCx7fSxlW3RdLmRlZmF1bHRzW25dLHIpLHRoaXMuYmluZChcImluaXRQYW5lbHM6YWZ0ZXJcIixmdW5jdGlvbih0KXtpZihyLmFkZCl7dmFyIG87c3dpdGNoKHIuYWRkVG8pe2Nhc2VcInBhbmVsc1wiOm89dDticmVhaztkZWZhdWx0Om89ZShyLmFkZFRvLHRoaXMuJG1lbnUpLmZpbHRlcihcIi5cIitpLnBhbmVsKX1vLmZpbmQoXCIuXCIraS5kaXZpZGVyKS5jbG9zZXN0KFwiLlwiK2kucGFuZWwpLmFkZENsYXNzKGkuaGFzaW5kZXhlciksdGhpcy4kaW5kZXhlcnx8KHRoaXMuJGluZGV4ZXI9ZSgnPGRpdiBjbGFzcz1cIicraS5pbmRleGVyKydcIiAvPicpLnByZXBlbmRUbyh0aGlzLiRwbmxzKS5hcHBlbmQoJzxhIGhyZWY9XCIjYVwiPmE8L2E+PGEgaHJlZj1cIiNiXCI+YjwvYT48YSBocmVmPVwiI2NcIj5jPC9hPjxhIGhyZWY9XCIjZFwiPmQ8L2E+PGEgaHJlZj1cIiNlXCI+ZTwvYT48YSBocmVmPVwiI2ZcIj5mPC9hPjxhIGhyZWY9XCIjZ1wiPmc8L2E+PGEgaHJlZj1cIiNoXCI+aDwvYT48YSBocmVmPVwiI2lcIj5pPC9hPjxhIGhyZWY9XCIjalwiPmo8L2E+PGEgaHJlZj1cIiNrXCI+azwvYT48YSBocmVmPVwiI2xcIj5sPC9hPjxhIGhyZWY9XCIjbVwiPm08L2E+PGEgaHJlZj1cIiNuXCI+bjwvYT48YSBocmVmPVwiI29cIj5vPC9hPjxhIGhyZWY9XCIjcFwiPnA8L2E+PGEgaHJlZj1cIiNxXCI+cTwvYT48YSBocmVmPVwiI3JcIj5yPC9hPjxhIGhyZWY9XCIjc1wiPnM8L2E+PGEgaHJlZj1cIiN0XCI+dDwvYT48YSBocmVmPVwiI3VcIj51PC9hPjxhIGhyZWY9XCIjdlwiPnY8L2E+PGEgaHJlZj1cIiN3XCI+dzwvYT48YSBocmVmPVwiI3hcIj54PC9hPjxhIGhyZWY9XCIjeVwiPnk8L2E+PGEgaHJlZj1cIiN6XCI+ejwvYT4nKSx0aGlzLiRpbmRleGVyLmNoaWxkcmVuKCkub24oYS5tb3VzZW92ZXIrXCItXCIrbitcIiBcIithLnRvdWNoc3RhcnQrXCItXCIrbixmdW5jdGlvbih0KXt2YXIgbj1lKHRoaXMpLmF0dHIoXCJocmVmXCIpLnNsaWNlKDEpLGE9cy4kcG5scy5jaGlsZHJlbihcIi5cIitpLm9wZW5lZCksbz1hLmZpbmQoXCIuXCIraS5saXN0dmlldykscj0tMSxsPWEuc2Nyb2xsVG9wKCk7YS5zY3JvbGxUb3AoMCksby5jaGlsZHJlbihcIi5cIitpLmRpdmlkZXIpLm5vdChcIi5cIitpLmhpZGRlbikuZWFjaChmdW5jdGlvbigpe3I8MCYmbj09ZSh0aGlzKS50ZXh0KCkuc2xpY2UoMCwxKS50b0xvd2VyQ2FzZSgpJiYocj1lKHRoaXMpLnBvc2l0aW9uKCkudG9wKX0pLGEuc2Nyb2xsVG9wKHI+LTE/cjpsKX0pKTt2YXIgbD1mdW5jdGlvbihlKXtlPWV8fHRoaXMuJHBubHMuY2hpbGRyZW4oXCIuXCIraS5vcGVuZWQpLHRoaXMuJG1lbnVbKGUuaGFzQ2xhc3MoaS5oYXNpbmRleGVyKT9cImFkZFwiOlwicmVtb3ZlXCIpK1wiQ2xhc3NcIl0oaS5oYXNpbmRleGVyKX07dGhpcy5iaW5kKFwib3BlblBhbmVsOnN0YXJ0XCIsbCksdGhpcy5iaW5kKFwiaW5pdFBhbmVsczphZnRlclwiLGwpfX0pfSxhZGQ6ZnVuY3Rpb24oKXtpPWVbdF0uX2Mscz1lW3RdLl9kLGE9ZVt0XS5fZSxpLmFkZChcImluZGV4ZXIgaGFzaW5kZXhlclwiKSxhLmFkZChcIm1vdXNlb3ZlclwiKX0sY2xpY2tBbmNob3I6ZnVuY3Rpb24oZSx0KXtpZihlLnBhcmVudCgpLmlzKFwiLlwiK2kuaW5kZXhlcikpcmV0dXJuITB9fSxlW3RdLmRlZmF1bHRzW25dPXthZGQ6ITEsYWRkVG86XCJwYW5lbHNcIn07dmFyIGkscyxhLG99KGpRdWVyeSksLypcbiAqIGpRdWVyeSBtbWVudSBzZXRTZWxlY3RlZCBhZGQtb25cbiAqIG1tZW51LmZyZWJzaXRlLm5sXG4gKlxuICogQ29weXJpZ2h0IChjKSBGcmVkIEhldXNzY2hlblxuICovXG5mdW5jdGlvbihlKXt2YXIgdD1cIm1tZW51XCIsbj1cInNldFNlbGVjdGVkXCI7ZVt0XS5hZGRvbnNbbl09e3NldHVwOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxyPXRoaXMub3B0c1tuXTt0aGlzLmNvbmZbbl07aWYobz1lW3RdLmdsYmwsXCJib29sZWFuXCI9PXR5cGVvZiByJiYocj17aG92ZXI6cixwYXJlbnQ6cn0pLFwib2JqZWN0XCIhPXR5cGVvZiByJiYocj17fSkscj10aGlzLm9wdHNbbl09ZS5leHRlbmQoITAse30sZVt0XS5kZWZhdWx0c1tuXSxyKSxcImRldGVjdFwiPT1yLmN1cnJlbnQpe3ZhciBsPWZ1bmN0aW9uKGUpe2U9ZS5zcGxpdChcIj9cIilbMF0uc3BsaXQoXCIjXCIpWzBdO3ZhciB0PWEuJG1lbnUuZmluZCgnYVtocmVmPVwiJytlKydcIl0sIGFbaHJlZj1cIicrZSsnL1wiXScpO3QubGVuZ3RoP2Euc2V0U2VsZWN0ZWQodC5wYXJlbnQoKSwhMCk6KGU9ZS5zcGxpdChcIi9cIikuc2xpY2UoMCwtMSksZS5sZW5ndGgmJmwoZS5qb2luKFwiL1wiKSkpfTt0aGlzLmJpbmQoXCJpbml0TWVudTphZnRlclwiLGZ1bmN0aW9uKCl7bCh3aW5kb3cubG9jYXRpb24uaHJlZil9KX1lbHNlIHIuY3VycmVudHx8dGhpcy5iaW5kKFwiaW5pdExpc3R2aWV3OmFmdGVyXCIsZnVuY3Rpb24oZSl7dGhpcy4kcG5scy5maW5kKFwiLlwiK2kubGlzdHZpZXcpLmNoaWxkcmVuKFwiLlwiK2kuc2VsZWN0ZWQpLnJlbW92ZUNsYXNzKGkuc2VsZWN0ZWQpfSk7ci5ob3ZlciYmdGhpcy5iaW5kKFwiaW5pdE1lbnU6YWZ0ZXJcIixmdW5jdGlvbigpe3RoaXMuJG1lbnUuYWRkQ2xhc3MoaS5ob3ZlcnNlbGVjdGVkKX0pLHIucGFyZW50JiYodGhpcy5iaW5kKFwib3BlblBhbmVsOmZpbmlzaFwiLGZ1bmN0aW9uKGUpe3RoaXMuJHBubHMuZmluZChcIi5cIitpLmxpc3R2aWV3KS5maW5kKFwiLlwiK2kubmV4dCkucmVtb3ZlQ2xhc3MoaS5zZWxlY3RlZCk7Zm9yKHZhciB0PWUuZGF0YShzLnBhcmVudCk7dDspdC5ub3QoXCIuXCIraS52ZXJ0aWNhbCkuY2hpbGRyZW4oXCIuXCIraS5uZXh0KS5hZGRDbGFzcyhpLnNlbGVjdGVkKSx0PXQuY2xvc2VzdChcIi5cIitpLnBhbmVsKS5kYXRhKHMucGFyZW50KX0pLHRoaXMuYmluZChcImluaXRNZW51OmFmdGVyXCIsZnVuY3Rpb24oKXt0aGlzLiRtZW51LmFkZENsYXNzKGkucGFyZW50c2VsZWN0ZWQpfSkpfSxhZGQ6ZnVuY3Rpb24oKXtpPWVbdF0uX2Mscz1lW3RdLl9kLGE9ZVt0XS5fZSxpLmFkZChcImhvdmVyc2VsZWN0ZWQgcGFyZW50c2VsZWN0ZWRcIil9LGNsaWNrQW5jaG9yOmZ1bmN0aW9uKGUsdCl7fX0sZVt0XS5kZWZhdWx0c1tuXT17Y3VycmVudDohMCxob3ZlcjohMSxwYXJlbnQ6ITF9O3ZhciBpLHMsYSxvfShqUXVlcnkpLC8qXG4gKiBqUXVlcnkgbW1lbnUgdG9nZ2xlcyBhZGQtb25cbiAqIG1tZW51LmZyZWJzaXRlLm5sXG4gKlxuICogQ29weXJpZ2h0IChjKSBGcmVkIEhldXNzY2hlblxuICovXG5mdW5jdGlvbihlKXt2YXIgdD1cIm1tZW51XCIsbj1cInRvZ2dsZXNcIjtlW3RdLmFkZG9uc1tuXT17c2V0dXA6ZnVuY3Rpb24oKXt2YXIgcz10aGlzO3RoaXMub3B0c1tuXSx0aGlzLmNvbmZbbl07bz1lW3RdLmdsYmwsdGhpcy5iaW5kKFwiaW5pdExpc3R2aWV3OmFmdGVyXCIsZnVuY3Rpb24odCl7dGhpcy5fX3JlZmFjdG9yQ2xhc3ModC5maW5kKFwiaW5wdXRcIiksdGhpcy5jb25mLmNsYXNzTmFtZXNbbl0udG9nZ2xlLFwidG9nZ2xlXCIpLHRoaXMuX19yZWZhY3RvckNsYXNzKHQuZmluZChcImlucHV0XCIpLHRoaXMuY29uZi5jbGFzc05hbWVzW25dLmNoZWNrLFwiY2hlY2tcIiksdC5maW5kKFwiaW5wdXQuXCIraS50b2dnbGUrXCIsIGlucHV0LlwiK2kuY2hlY2spLmVhY2goZnVuY3Rpb24oKXt2YXIgdD1lKHRoaXMpLG49dC5jbG9zZXN0KFwibGlcIiksYT10Lmhhc0NsYXNzKGkudG9nZ2xlKT9cInRvZ2dsZVwiOlwiY2hlY2tcIixvPXQuYXR0cihcImlkXCIpfHxzLl9fZ2V0VW5pcXVlSWQoKTtuLmNoaWxkcmVuKCdsYWJlbFtmb3I9XCInK28rJ1wiXScpLmxlbmd0aHx8KHQuYXR0cihcImlkXCIsbyksbi5wcmVwZW5kKHQpLGUoJzxsYWJlbCBmb3I9XCInK28rJ1wiIGNsYXNzPVwiJytpW2FdKydcIj48L2xhYmVsPicpLmluc2VydEJlZm9yZShuLmNoaWxkcmVuKFwiYSwgc3BhblwiKS5sYXN0KCkpKX0pfSl9LGFkZDpmdW5jdGlvbigpe2k9ZVt0XS5fYyxzPWVbdF0uX2QsYT1lW3RdLl9lLGkuYWRkKFwidG9nZ2xlIGNoZWNrXCIpfSxjbGlja0FuY2hvcjpmdW5jdGlvbihlLHQpe319LGVbdF0uY29uZmlndXJhdGlvbi5jbGFzc05hbWVzW25dPXt0b2dnbGU6XCJUb2dnbGVcIixjaGVjazpcIkNoZWNrXCJ9O3ZhciBpLHMsYSxvfShqUXVlcnkpO1xucmV0dXJuIHRydWU7XG59KSk7XG5cblxuXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/common_scripts.js\n");

/***/ }),

/***/ "./resources/js/components/ExampleComponent.vue":
/*!******************************************************!*\
  !*** ./resources/js/components/ExampleComponent.vue ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ExampleComponent_vue_vue_type_template_id_299e239e___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ExampleComponent.vue?vue&type=template&id=299e239e& */ \"./resources/js/components/ExampleComponent.vue?vue&type=template&id=299e239e&\");\n/* harmony import */ var _ExampleComponent_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ExampleComponent.vue?vue&type=script&lang=js& */ \"./resources/js/components/ExampleComponent.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport *//* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _ExampleComponent_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _ExampleComponent_vue_vue_type_template_id_299e239e___WEBPACK_IMPORTED_MODULE_0__[\"render\"],\n  _ExampleComponent_vue_vue_type_template_id_299e239e___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"],\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"resources/js/components/ExampleComponent.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9FeGFtcGxlQ29tcG9uZW50LnZ1ZT8zYTA5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQStGO0FBQzNCO0FBQ0w7OztBQUcvRDtBQUM2RjtBQUM3RixnQkFBZ0IsMkdBQVU7QUFDMUIsRUFBRSxzRkFBTTtBQUNSLEVBQUUsMkZBQU07QUFDUixFQUFFLG9HQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSSxLQUFVLEVBQUUsWUFpQmY7QUFDRDtBQUNlLGdGIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvRXhhbXBsZUNvbXBvbmVudC52dWUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL0V4YW1wbGVDb21wb25lbnQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTI5OWUyMzllJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0V4YW1wbGVDb21wb25lbnQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9FeGFtcGxlQ29tcG9uZW50LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIHZhciBhcGkgPSByZXF1aXJlKFwiQzpcXFxcd2FtcDY0XFxcXHd3d1xcXFxsZXRzdHV0ZVxcXFxub2RlX21vZHVsZXNcXFxcdnVlLWhvdC1yZWxvYWQtYXBpXFxcXGRpc3RcXFxcaW5kZXguanNcIilcbiAgYXBpLmluc3RhbGwocmVxdWlyZSgndnVlJykpXG4gIGlmIChhcGkuY29tcGF0aWJsZSkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnMjk5ZTIzOWUnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnMjk5ZTIzOWUnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL0V4YW1wbGVDb21wb25lbnQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTI5OWUyMzllJlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcGkucmVyZW5kZXIoJzI5OWUyMzllJywge1xuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnNcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJyZXNvdXJjZXMvanMvY29tcG9uZW50cy9FeGFtcGxlQ29tcG9uZW50LnZ1ZVwiXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components/ExampleComponent.vue\n");

/***/ }),

/***/ "./resources/js/components/ExampleComponent.vue?vue&type=script&lang=js&":
/*!*******************************************************************************!*\
  !*** ./resources/js/components/ExampleComponent.vue?vue&type=script&lang=js& ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_ref_4_0_node_modules_vue_loader_lib_index_js_vue_loader_options_ExampleComponent_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib??ref--4-0!../../../node_modules/vue-loader/lib??vue-loader-options!./ExampleComponent.vue?vue&type=script&lang=js& */ \"./node_modules/babel-loader/lib/index.js?!./node_modules/vue-loader/lib/index.js?!./resources/js/components/ExampleComponent.vue?vue&type=script&lang=js&\");\n/* empty/unused harmony star reexport */ /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_babel_loader_lib_index_js_ref_4_0_node_modules_vue_loader_lib_index_js_vue_loader_options_ExampleComponent_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9FeGFtcGxlQ29tcG9uZW50LnZ1ZT8xOWE0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQSx3Q0FBZ00sQ0FBZ0IsNFBBQUcsRUFBQyIsImZpbGUiOiIuL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0V4YW1wbGVDb21wb25lbnQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tNC0wIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vRXhhbXBsZUNvbXBvbmVudC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tNC0wIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vRXhhbXBsZUNvbXBvbmVudC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/ExampleComponent.vue?vue&type=script&lang=js&\n");

/***/ }),

/***/ "./resources/js/components/ExampleComponent.vue?vue&type=template&id=299e239e&":
/*!*************************************************************************************!*\
  !*** ./resources/js/components/ExampleComponent.vue?vue&type=template&id=299e239e& ***!
  \*************************************************************************************/
/*! exports provided: render, staticRenderFns */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_ExampleComponent_vue_vue_type_template_id_299e239e___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../node_modules/vue-loader/lib??vue-loader-options!./ExampleComponent.vue?vue&type=template&id=299e239e& */ \"./node_modules/vue-loader/lib/loaders/templateLoader.js?!./node_modules/vue-loader/lib/index.js?!./resources/js/components/ExampleComponent.vue?vue&type=template&id=299e239e&\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_ExampleComponent_vue_vue_type_template_id_299e239e___WEBPACK_IMPORTED_MODULE_0__[\"render\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"staticRenderFns\", function() { return _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_ExampleComponent_vue_vue_type_template_id_299e239e___WEBPACK_IMPORTED_MODULE_0__[\"staticRenderFns\"]; });\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9FeGFtcGxlQ29tcG9uZW50LnZ1ZT82YTNlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSIsImZpbGUiOiIuL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0V4YW1wbGVDb21wb25lbnQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTI5OWUyMzllJi5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9FeGFtcGxlQ29tcG9uZW50LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0yOTllMjM5ZSZcIiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components/ExampleComponent.vue?vue&type=template&id=299e239e&\n");

/***/ }),

/***/ "./resources/js/main.js":
/*!******************************!*\
  !*** ./resources/js/main.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function ($) {\n  \"use strict\";\n\n  $(window).on('load', function () {\n    $('[data-loader=\"circle-side\"]').fadeOut(); // will first fade out the loading animation\n\n    $('#preloader').delay(350).fadeOut('slow'); // will fade out the white DIV that covers the website.\n\n    $('body').delay(350);\n    $('#hero_in h1,#hero_in form').addClass('animated');\n    $('.hero_single, #hero_in').addClass('start_bg_zoom');\n    $(window).scroll();\n  }); // Sticky nav\n\n  $(window).on('scroll', function () {\n    if ($(this).scrollTop() > 1) {\n      $('.header').addClass(\"sticky\");\n    } else {\n      $('.header').removeClass(\"sticky\");\n    }\n  }); // Sticky sidebar\n\n  $('#sidebar').theiaStickySidebar({\n    additionalMarginTop: 150\n  }); // Mobile Mmenu\n\n  var $menu = $(\"nav#menu\").mmenu({\n    \"extensions\": [\"pagedim-black\"],\n    counters: false,\n    keyboardNavigation: {\n      enable: true,\n      enhance: true\n    },\n    navbar: {\n      title: 'MENU'\n    },\n    navbars: [{\n      position: 'bottom',\n      content: ['<a href=\"#0\"> 2019 letstute</a>']\n    }]\n  }, {\n    // configuration\n    clone: true,\n    classNames: {\n      fixedElements: {\n        fixed: \"menu_2\",\n        sticky: \"sticky\"\n      }\n    }\n  });\n  var $icon = $(\"#hamburger\");\n  var API = $menu.data(\"mmenu\");\n  $icon.on(\"click\", function () {\n    API.open();\n  });\n  API.bind(\"open:finish\", function () {\n    setTimeout(function () {\n      $icon.addClass(\"is-active\");\n    }, 100);\n  });\n  API.bind(\"close:finish\", function () {\n    setTimeout(function () {\n      $icon.removeClass(\"is-active\");\n    }, 100);\n  }); // Header button explore\n\n  $('a[href^=\"#\"].btn_explore').on('click', function (e) {\n    e.preventDefault();\n    var target = this.hash;\n    var $target = $(target);\n    $('html, body').stop().animate({\n      'scrollTop': $target.offset().top\n    }, 800, 'swing', function () {\n      window.location.hash = target;\n    });\n  }); // WoW - animation on scroll\n\n  var wow = new WOW({\n    boxClass: 'wow',\n    // animated element css class (default is wow)\n    animateClass: 'animated',\n    // animation css class (default is animated)\n    offset: 0,\n    // distance to the element when triggering the animation (default is 0)\n    mobile: true,\n    // trigger animations on mobile devices (default is true)\n    live: true,\n    // act on asynchronously loaded content (default is true)\n    callback: function callback(box) {// the callback is fired every time an animation is started\n      // the argument that is passed in is the DOM node being animated\n    },\n    scrollContainer: null // optional scroll container selector, otherwise use window\n\n  });\n  wow.init();\n  /*  video popups */\n\n  $('.video').magnificPopup({\n    type: 'iframe'\n  });\n  /* video modal*/\n\n  /*  Image popups */\n\n  $('.magnific-gallery').each(function () {\n    $(this).magnificPopup({\n      delegate: 'a',\n      type: 'image',\n      gallery: {\n        enabled: true\n      },\n      removalDelay: 500,\n      //delay removal by X to allow out-animation\n      callbacks: {\n        beforeOpen: function beforeOpen() {\n          // just a hack that adds mfp-anim class to markup\n          this.st.image.markup = this.st.image.markup.replace('mfp-figure', 'mfp-figure mfp-with-anim');\n          this.st.mainClass = this.st.el.attr('data-effect');\n        }\n      },\n      closeOnContentClick: true,\n      midClick: true // allow opening popup on middle mouse click. Always set it to true if you don't provide alternative source.\n\n    });\n  }); // tooltips\n\n  $('[data-toggle=\"tooltip\"]').tooltip(); // Accordion\n\n  function toggleChevron(e) {\n    $(e.target).prev('.card-header').find(\"i.indicator\").toggleClass('ti-minus ti-plus');\n  }\n\n  $('#accordion_lessons').on('hidden.bs.collapse shown.bs.collapse', toggleChevron);\n\n  function toggleIcon(e) {\n    $(e.target).prev('.panel-heading').find(\".indicator\").toggleClass('ti-minus ti-plus');\n  } // Accordion 2 (updated v1.2)\n\n\n  $('.accordion_2').on('hidden.bs.collapse shown.bs.collapse', toggleChevron);\n\n  function toggleIcon(e) {\n    $(e.target).prev('.panel-heading').find(\".indicator\").toggleClass('ti-minus ti-plus');\n  }\n\n  $('.panel-group').on('hidden.bs.collapse', toggleIcon);\n  $('.panel-group').on('shown.bs.collapse', toggleIcon); // Input field effect\n\n  (function () {\n    if (!String.prototype.trim) {\n      (function () {\n        // Make sure we trim BOM and NBSP\n        var rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\n        String.prototype.trim = function () {\n          return this.replace(rtrim, '');\n        };\n      })();\n    }\n\n    [].slice.call(document.querySelectorAll('input.input_field, textarea.input_field')).forEach(function (inputEl) {\n      // in case the input is already filled..\n      if (inputEl.value.trim() !== '') {\n        classie.add(inputEl.parentNode, 'input--filled');\n      } // events:\n\n\n      inputEl.addEventListener('focus', onInputFocus);\n      inputEl.addEventListener('blur', onInputBlur);\n    });\n\n    function onInputFocus(ev) {\n      classie.add(ev.target.parentNode, 'input--filled');\n    }\n\n    function onInputBlur(ev) {\n      if (ev.target.value.trim() === '') {\n        classie.remove(ev.target.parentNode, 'input--filled');\n      }\n    }\n  })(); // Selectbox\n\n\n  $(\".selectbox\").selectbox(); // Check and radio input styles\n\n  $('input.icheck').iCheck({\n    checkboxClass: 'icheckbox_square-grey',\n    radioClass: 'iradio_square-grey'\n  }); // Carousels\n\n  $('#carousel').owlCarousel({\n    center: true,\n    items: 2,\n    loop: true,\n    margin: 10,\n    responsive: {\n      0: {\n        items: 1,\n        dots: false\n      },\n      600: {\n        items: 2\n      },\n      1000: {\n        items: 4\n      }\n    }\n  });\n  $('#highlight_list').owlCarousel({\n    items: 1,\n    loop: true,\n    margin: 10,\n    responsive: {\n      0: {\n        items: 1,\n        dots: true,\n        loop: true,\n        autoplay: true\n      },\n      600: {\n        items: 2\n      },\n      1000: {\n        items: 7,\n        mouseDrag: false\n      }\n    }\n  });\n  $('#testimonails').owlCarousel({\n    items: 1,\n    loop: true,\n    margin: 10,\n    mouseDrag: false\n  });\n  $('#ourpartners').owlCarousel({\n    items: 1,\n    loop: true,\n    margin: 10,\n    responsive: {\n      0: {\n        items: 1,\n        dots: true,\n        loop: true,\n        autoplay: true\n      },\n      600: {\n        items: 2\n      },\n      1000: {\n        items: 7,\n        mouseDrag: false\n      }\n    }\n  });\n  $('#reccomended').owlCarousel({\n    center: true,\n    items: 2,\n    loop: true,\n    margin: 0,\n    responsive: {\n      0: {\n        items: 1\n      },\n      767: {\n        items: 2\n      },\n      1000: {\n        items: 3\n      },\n      1400: {\n        items: 4\n      }\n    }\n  }); // Sticky filters\n\n  $(window).bind('load resize', function () {\n    var width = $(window).width();\n\n    if (width <= 991) {\n      $('.sticky_horizontal').stick_in_parent({\n        offset_top: 50\n      });\n    } else {\n      $('.sticky_horizontal').stick_in_parent({\n        offset_top: 73\n      });\n    }\n  }); // Secondary nav scroll\n\n  var $sticky_nav = $('.secondary_nav');\n  $sticky_nav.find('a').on('click', function (e) {\n    e.preventDefault();\n    var target = this.hash;\n    var $target = $(target);\n    $('html, body').animate({\n      'scrollTop': $target.offset().top - 150\n    }, 800, 'swing');\n  });\n  $sticky_nav.find('ul li a').on('click', function () {\n    $sticky_nav.find('ul li a.active').removeClass('active');\n    $(this).addClass('active');\n  }); // Faq section (updated v1.2)\n\n  $('#faq_box a[href^=\"#\"]').on('click', function () {\n    if (location.pathname.replace(/^\\//, '') == this.pathname.replace(/^\\//, '') || location.hostname == this.hostname) {\n      var target = $(this.hash);\n      target = target.length ? target : $('[name=' + this.hash.slice(1) + ']');\n\n      if (target.length) {\n        $('html,body').animate({\n          scrollTop: target.offset().top - 185\n        }, 800);\n        return false;\n      }\n    }\n  });\n  $('ul#cat_nav li a').on('click', function () {\n    $('ul#cat_nav li a.active').removeClass('active');\n    $(this).addClass('active');\n  });\n})(window.jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvbWFpbi5qcz9mMzJhIl0sIm5hbWVzIjpbIiQiLCJ3aW5kb3ciLCJvbiIsImZhZGVPdXQiLCJkZWxheSIsImFkZENsYXNzIiwic2Nyb2xsIiwic2Nyb2xsVG9wIiwicmVtb3ZlQ2xhc3MiLCJ0aGVpYVN0aWNreVNpZGViYXIiLCJhZGRpdGlvbmFsTWFyZ2luVG9wIiwiJG1lbnUiLCJtbWVudSIsImNvdW50ZXJzIiwia2V5Ym9hcmROYXZpZ2F0aW9uIiwiZW5hYmxlIiwiZW5oYW5jZSIsIm5hdmJhciIsInRpdGxlIiwibmF2YmFycyIsInBvc2l0aW9uIiwiY29udGVudCIsImNsb25lIiwiY2xhc3NOYW1lcyIsImZpeGVkRWxlbWVudHMiLCJmaXhlZCIsInN0aWNreSIsIiRpY29uIiwiQVBJIiwiZGF0YSIsIm9wZW4iLCJiaW5kIiwic2V0VGltZW91dCIsImUiLCJwcmV2ZW50RGVmYXVsdCIsInRhcmdldCIsImhhc2giLCIkdGFyZ2V0Iiwic3RvcCIsImFuaW1hdGUiLCJvZmZzZXQiLCJ0b3AiLCJsb2NhdGlvbiIsIndvdyIsIldPVyIsImJveENsYXNzIiwiYW5pbWF0ZUNsYXNzIiwibW9iaWxlIiwibGl2ZSIsImNhbGxiYWNrIiwiYm94Iiwic2Nyb2xsQ29udGFpbmVyIiwiaW5pdCIsIm1hZ25pZmljUG9wdXAiLCJ0eXBlIiwiZWFjaCIsImRlbGVnYXRlIiwiZ2FsbGVyeSIsImVuYWJsZWQiLCJyZW1vdmFsRGVsYXkiLCJjYWxsYmFja3MiLCJiZWZvcmVPcGVuIiwic3QiLCJpbWFnZSIsIm1hcmt1cCIsInJlcGxhY2UiLCJtYWluQ2xhc3MiLCJlbCIsImF0dHIiLCJjbG9zZU9uQ29udGVudENsaWNrIiwibWlkQ2xpY2siLCJ0b29sdGlwIiwidG9nZ2xlQ2hldnJvbiIsInByZXYiLCJmaW5kIiwidG9nZ2xlQ2xhc3MiLCJ0b2dnbGVJY29uIiwiU3RyaW5nIiwicHJvdG90eXBlIiwidHJpbSIsInJ0cmltIiwic2xpY2UiLCJjYWxsIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImlucHV0RWwiLCJ2YWx1ZSIsImNsYXNzaWUiLCJhZGQiLCJwYXJlbnROb2RlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uSW5wdXRGb2N1cyIsIm9uSW5wdXRCbHVyIiwiZXYiLCJyZW1vdmUiLCJzZWxlY3Rib3giLCJpQ2hlY2siLCJjaGVja2JveENsYXNzIiwicmFkaW9DbGFzcyIsIm93bENhcm91c2VsIiwiY2VudGVyIiwiaXRlbXMiLCJsb29wIiwibWFyZ2luIiwicmVzcG9uc2l2ZSIsImRvdHMiLCJhdXRvcGxheSIsIm1vdXNlRHJhZyIsIndpZHRoIiwic3RpY2tfaW5fcGFyZW50Iiwib2Zmc2V0X3RvcCIsIiRzdGlja3lfbmF2IiwicGF0aG5hbWUiLCJob3N0bmFtZSIsImxlbmd0aCIsImpRdWVyeSJdLCJtYXBwaW5ncyI6IkFBQUEsQ0FBQyxVQUFVQSxDQUFWLEVBQWE7QUFFYjs7QUFFQUEsR0FBQyxDQUFDQyxNQUFELENBQUQsQ0FBVUMsRUFBVixDQUFhLE1BQWIsRUFBcUIsWUFBWTtBQUNoQ0YsS0FBQyxDQUFDLDZCQUFELENBQUQsQ0FBaUNHLE9BQWpDLEdBRGdDLENBQ1k7O0FBQzVDSCxLQUFDLENBQUMsWUFBRCxDQUFELENBQWdCSSxLQUFoQixDQUFzQixHQUF0QixFQUEyQkQsT0FBM0IsQ0FBbUMsTUFBbkMsRUFGZ0MsQ0FFWTs7QUFDNUNILEtBQUMsQ0FBQyxNQUFELENBQUQsQ0FBVUksS0FBVixDQUFnQixHQUFoQjtBQUNBSixLQUFDLENBQUMsMkJBQUQsQ0FBRCxDQUErQkssUUFBL0IsQ0FBd0MsVUFBeEM7QUFDQUwsS0FBQyxDQUFDLHdCQUFELENBQUQsQ0FBNEJLLFFBQTVCLENBQXFDLGVBQXJDO0FBQ0FMLEtBQUMsQ0FBQ0MsTUFBRCxDQUFELENBQVVLLE1BQVY7QUFDQSxHQVBELEVBSmEsQ0FhYjs7QUFDQU4sR0FBQyxDQUFDQyxNQUFELENBQUQsQ0FBVUMsRUFBVixDQUFhLFFBQWIs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NkMsS0FBVixDQUFnQixDQUFoQixDQUFYLEdBQStCLEdBQWhDLENBQW5DOztBQUNHLFVBQUk5QyxNQUFNLENBQUNnRixNQUFYLEVBQW1CO0FBQ3BCbkgsU0FBQyxDQUFDLFdBQUQsQ0FBRCxDQUFldUMsT0FBZixDQUF1QjtBQUN0QmhDLG1CQUFTLEVBQUU0QixNQUFNLENBQUNLLE1BQVAsR0FBZ0JDLEdBQWhCLEdBQXFCO0FBRFYsU0FBdkIsRUFFRSxHQUZGO0FBR0QsZUFBTyxLQUFQO0FBQ0E7QUFDRDtBQUNELEdBWkQ7QUFhQXpDLEdBQUMsQ0FBQyxpQkFBRCxDQUFELENBQXFCRSxFQUFyQixDQUF3QixPQUF4QixFQUFpQyxZQUFZO0FBQzVDRixLQUFDLENBQUMsd0JBQUQsQ0FBRCxDQUE0QlEsV0FBNUIsQ0FBd0MsUUFBeEM7QUFDQVIsS0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRSyxRQUFSLENBQWlCLFFBQWpCO0FBQ0EsR0FIRDtBQUtBLENBcFVELEVBb1VHSixNQUFNLENBQUNtSCxNQXBVViIsImZpbGUiOiIuL3Jlc291cmNlcy9qcy9tYWluLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uICgkKSB7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0JCh3aW5kb3cpLm9uKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuXHRcdCQoJ1tkYXRhLWxvYWRlcj1cImNpcmNsZS1zaWRlXCJdJykuZmFkZU91dCgpOyAvLyB3aWxsIGZpcnN0IGZhZGUgb3V0IHRoZSBsb2FkaW5nIGFuaW1hdGlvblxuXHRcdCQoJyNwcmVsb2FkZXInKS5kZWxheSgzNTApLmZhZGVPdXQoJ3Nsb3cnKTsgLy8gd2lsbCBmYWRlIG91dCB0aGUgd2hpdGUgRElWIHRoYXQgY292ZXJzIHRoZSB3ZWJzaXRlLlxuXHRcdCQoJ2JvZHknKS5kZWxheSgzNTApO1xuXHRcdCQoJyNoZXJvX2luIGgxLCNoZXJvX2luIGZvcm0nKS5hZGRDbGFzcygnYW5pbWF0ZWQnKTtcblx0XHQkKCcuaGVyb19zaW5nbGUsICNoZXJvX2luJykuYWRkQ2xhc3MoJ3N0YXJ0X2JnX3pvb20nKTtcblx0XHQkKHdpbmRvdykuc2Nyb2xsKCk7XG5cdH0pO1xuXG5cdC8vIFN0aWNreSBuYXZcblx0JCh3aW5kb3cpLm9uKCdzY3JvbGwnLCBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCQodGhpcykuc2Nyb2xsVG9wKCkgPiAxKSB7XG5cdFx0XHQkKCcuaGVhZGVyJykuYWRkQ2xhc3MoXCJzdGlja3lcIik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdCQoJy5oZWFkZXInKS5yZW1vdmVDbGFzcyhcInN0aWNreVwiKTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIFN0aWNreSBzaWRlYmFyXG5cdCQoJyNzaWRlYmFyJykudGhlaWFTdGlja3lTaWRlYmFyKHtcblx0XHRhZGRpdGlvbmFsTWFyZ2luVG9wOiAxNTBcblx0fSk7XG5cblx0Ly8gTW9iaWxlIE1tZW51XG5cdHZhciAkbWVudSA9ICQoXCJuYXYjbWVudVwiKS5tbWVudSh7XG5cdFx0XCJleHRlbnNpb25zXCI6IFtcInBhZ2VkaW0tYmxhY2tcIl0sXG5cdFx0Y291bnRlcnM6IGZhbHNlLFxuXHRcdGtleWJvYXJkTmF2aWdhdGlvbjoge1xuXHRcdFx0ZW5hYmxlOiB0cnVlLFxuXHRcdFx0ZW5oYW5jZTogdHJ1ZVxuXHRcdH0sXG5cdFx0bmF2YmFyOiB7XG5cdFx0XHR0aXRsZTogJ01FTlUnXG5cdFx0fSxcblx0XHRuYXZiYXJzOiBbe3Bvc2l0aW9uOidib3R0b20nLGNvbnRlbnQ6IFsnPGEgaHJlZj1cIiMwXCI+wqkgMjAxOSBsZXRzdHV0ZTwvYT4nXX1dfSxcblx0XHR7XG5cdFx0Ly8gY29uZmlndXJhdGlvblxuXHRcdGNsb25lOiB0cnVlLFxuXHRcdGNsYXNzTmFtZXM6IHtcblx0XHRcdGZpeGVkRWxlbWVudHM6IHtcblx0XHRcdFx0Zml4ZWQ6IFwibWVudV8yXCIsXG5cdFx0XHRcdHN0aWNreTogXCJzdGlja3lcIlxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cdHZhciAkaWNvbiA9ICQoXCIjaGFtYnVyZ2VyXCIpO1xuXHR2YXIgQVBJID0gJG1lbnUuZGF0YShcIm1tZW51XCIpO1xuXHQkaWNvbi5vbihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcblx0XHRBUEkub3BlbigpO1xuXHR9KTtcblx0QVBJLmJpbmQoXCJvcGVuOmZpbmlzaFwiLCBmdW5jdGlvbiAoKSB7XG5cdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHQkaWNvbi5hZGRDbGFzcyhcImlzLWFjdGl2ZVwiKTtcblx0XHR9LCAxMDApO1xuXHR9KTtcblx0QVBJLmJpbmQoXCJjbG9zZTpmaW5pc2hcIiwgZnVuY3Rpb24gKCkge1xuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0JGljb24ucmVtb3ZlQ2xhc3MoXCJpcy1hY3RpdmVcIik7XG5cdFx0fSwgMTAwKTtcblx0fSk7XG5cbiAgICAvLyBIZWFkZXIgYnV0dG9uIGV4cGxvcmVcbiAgICAkKCdhW2hyZWZePVwiI1wiXS5idG5fZXhwbG9yZScpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5oYXNoO1xuXHRcdFx0dmFyICR0YXJnZXQgPSAkKHRhcmdldCk7XG5cdFx0XHQkKCdodG1sLCBib2R5Jykuc3RvcCgpLmFuaW1hdGUoe1xuXHRcdFx0XHQnc2Nyb2xsVG9wJzogJHRhcmdldC5vZmZzZXQoKS50b3Bcblx0XHRcdH0sIDgwMCwgJ3N3aW5nJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR3aW5kb3cubG9jYXRpb24uaGFzaCA9IHRhcmdldDtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdC8vIFdvVyAtIGFuaW1hdGlvbiBvbiBzY3JvbGxcblx0dmFyIHdvdyA9IG5ldyBXT1coXG5cdCAge1xuXHRcdGJveENsYXNzOiAgICAgJ3dvdycsICAgICAgLy8gYW5pbWF0ZWQgZWxlbWVudCBjc3MgY2xhc3MgKGRlZmF1bHQgaXMgd293KVxuXHRcdGFuaW1hdGVDbGFzczogJ2FuaW1hdGVkJywgLy8gYW5pbWF0aW9uIGNzcyBjbGFzcyAoZGVmYXVsdCBpcyBhbmltYXRlZClcblx0XHRvZmZzZXQ6ICAgICAgIDAsICAgICAgICAgIC8vIGRpc3RhbmNlIHRvIHRoZSBlbGVtZW50IHdoZW4gdHJpZ2dlcmluZyB0aGUgYW5pbWF0aW9uIChkZWZhdWx0IGlzIDApXG5cdFx0bW9iaWxlOiAgICAgICB0cnVlLCAgICAgICAvLyB0cmlnZ2VyIGFuaW1hdGlvbnMgb24gbW9iaWxlIGRldmljZXMgKGRlZmF1bHQgaXMgdHJ1ZSlcblx0XHRsaXZlOiAgICAgICAgIHRydWUsICAgICAgIC8vIGFjdCBvbiBhc3luY2hyb25vdXNseSBsb2FkZWQgY29udGVudCAoZGVmYXVsdCBpcyB0cnVlKVxuXHRcdGNhbGxiYWNrOiAgICAgZnVuY3Rpb24oYm94KSB7XG5cdFx0ICAvLyB0aGUgY2FsbGJhY2sgaXMgZmlyZWQgZXZlcnkgdGltZSBhbiBhbmltYXRpb24gaXMgc3RhcnRlZFxuXHRcdCAgLy8gdGhlIGFyZ3VtZW50IHRoYXQgaXMgcGFzc2VkIGluIGlzIHRoZSBET00gbm9kZSBiZWluZyBhbmltYXRlZFxuXHRcdH0sXG5cdFx0c2Nyb2xsQ29udGFpbmVyOiBudWxsIC8vIG9wdGlvbmFsIHNjcm9sbCBjb250YWluZXIgc2VsZWN0b3IsIG90aGVyd2lzZSB1c2Ugd2luZG93XG5cdCAgfVxuXHQpO1xuXHR3b3cuaW5pdCgpO1xuXG5cdC8qICB2aWRlbyBwb3B1cHMgKi9cblx0JCgnLnZpZGVvJykubWFnbmlmaWNQb3B1cCh7dHlwZTonaWZyYW1lJ30pO1x0LyogdmlkZW8gbW9kYWwqL1xuXG5cdC8qICBJbWFnZSBwb3B1cHMgKi9cblx0JCgnLm1hZ25pZmljLWdhbGxlcnknKS5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHQkKHRoaXMpLm1hZ25pZmljUG9wdXAoe1xuXHRcdFx0ZGVsZWdhdGU6ICdhJyxcblx0XHRcdHR5cGU6ICdpbWFnZScsXG5cdFx0XHRnYWxsZXJ5OiB7XG5cdFx0XHRcdGVuYWJsZWQ6IHRydWVcblx0XHRcdH0sXG5cdFx0XHRyZW1vdmFsRGVsYXk6IDUwMCwgLy9kZWxheSByZW1vdmFsIGJ5IFggdG8gYWxsb3cgb3V0LWFuaW1hdGlvblxuXHRcdFx0Y2FsbGJhY2tzOiB7XG5cdFx0XHRcdGJlZm9yZU9wZW46IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHQvLyBqdXN0IGEgaGFjayB0aGF0IGFkZHMgbWZwLWFuaW0gY2xhc3MgdG8gbWFya3VwXG5cdFx0XHRcdFx0dGhpcy5zdC5pbWFnZS5tYXJrdXAgPSB0aGlzLnN0LmltYWdlLm1hcmt1cC5yZXBsYWNlKCdtZnAtZmlndXJlJywgJ21mcC1maWd1cmUgbWZwLXdpdGgtYW5pbScpO1xuXHRcdFx0XHRcdHRoaXMuc3QubWFpbkNsYXNzID0gdGhpcy5zdC5lbC5hdHRyKCdkYXRhLWVmZmVjdCcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Y2xvc2VPbkNvbnRlbnRDbGljazogdHJ1ZSxcblx0XHRcdG1pZENsaWNrOiB0cnVlIC8vIGFsbG93IG9wZW5pbmcgcG9wdXAgb24gbWlkZGxlIG1vdXNlIGNsaWNrLiBBbHdheXMgc2V0IGl0IHRvIHRydWUgaWYgeW91IGRvbid0IHByb3ZpZGUgYWx0ZXJuYXRpdmUgc291cmNlLlxuXHRcdH0pO1xuXHR9KTtcblxuXHQvLyB0b29sdGlwc1xuXHQgJCgnW2RhdGEtdG9nZ2xlPVwidG9vbHRpcFwiXScpLnRvb2x0aXAoKTtcblxuXHQvLyBBY2NvcmRpb25cblx0ZnVuY3Rpb24gdG9nZ2xlQ2hldnJvbihlKSB7XG5cdFx0JChlLnRhcmdldClcblx0XHRcdC5wcmV2KCcuY2FyZC1oZWFkZXInKVxuXHRcdFx0LmZpbmQoXCJpLmluZGljYXRvclwiKVxuXHRcdFx0LnRvZ2dsZUNsYXNzKCd0aS1taW51cyB0aS1wbHVzJyk7XG5cdH1cblx0JCgnI2FjY29yZGlvbl9sZXNzb25zJykub24oJ2hpZGRlbi5icy5jb2xsYXBzZSBzaG93bi5icy5jb2xsYXBzZScsIHRvZ2dsZUNoZXZyb24pO1xuXHRcdGZ1bmN0aW9uIHRvZ2dsZUljb24oZSkge1xuICAgICAgICAkKGUudGFyZ2V0KVxuICAgICAgICAgICAgLnByZXYoJy5wYW5lbC1oZWFkaW5nJylcbiAgICAgICAgICAgIC5maW5kKFwiLmluZGljYXRvclwiKVxuICAgICAgICAgICAgLnRvZ2dsZUNsYXNzKCd0aS1taW51cyB0aS1wbHVzJyk7XG4gICAgfVxuICAgIC8vIEFjY29yZGlvbiAyICh1cGRhdGVkIHYxLjIpXG5cdCQoJy5hY2NvcmRpb25fMicpLm9uKCdoaWRkZW4uYnMuY29sbGFwc2Ugc2hvd24uYnMuY29sbGFwc2UnLCB0b2dnbGVDaGV2cm9uKTtcblx0XHRmdW5jdGlvbiB0b2dnbGVJY29uKGUpIHtcbiAgICAgICAgJChlLnRhcmdldClcbiAgICAgICAgICAgIC5wcmV2KCcucGFuZWwtaGVhZGluZycpXG4gICAgICAgICAgICAuZmluZChcIi5pbmRpY2F0b3JcIilcbiAgICAgICAgICAgIC50b2dnbGVDbGFzcygndGktbWludXMgdGktcGx1cycpO1xuICAgIH1cbiAgICAkKCcucGFuZWwtZ3JvdXAnKS5vbignaGlkZGVuLmJzLmNvbGxhcHNlJywgdG9nZ2xlSWNvbik7XG4gICAgJCgnLnBhbmVsLWdyb3VwJykub24oJ3Nob3duLmJzLmNvbGxhcHNlJywgdG9nZ2xlSWNvbik7XG5cblxuXHQvLyBJbnB1dCBmaWVsZCBlZmZlY3Rcblx0KGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIVN0cmluZy5wcm90b3R5cGUudHJpbSkge1xuXHRcdFx0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXG5cdFx0XHRcdHZhciBydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblx0XHRcdFx0U3RyaW5nLnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLnJlcGxhY2UocnRyaW0sICcnKTtcblx0XHRcdFx0fTtcblx0XHRcdH0pKCk7XG5cdFx0fVxuXHRcdFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQuaW5wdXRfZmllbGQsIHRleHRhcmVhLmlucHV0X2ZpZWxkJykpLmZvckVhY2goZnVuY3Rpb24gKGlucHV0RWwpIHtcblx0XHRcdC8vIGluIGNhc2UgdGhlIGlucHV0IGlzIGFscmVhZHkgZmlsbGVkLi5cblx0XHRcdGlmIChpbnB1dEVsLnZhbHVlLnRyaW0oKSAhPT0gJycpIHtcblx0XHRcdFx0Y2xhc3NpZS5hZGQoaW5wdXRFbC5wYXJlbnROb2RlLCAnaW5wdXQtLWZpbGxlZCcpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBldmVudHM6XG5cdFx0XHRpbnB1dEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgb25JbnB1dEZvY3VzKTtcblx0XHRcdGlucHV0RWwuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIG9uSW5wdXRCbHVyKTtcblx0XHR9KTtcblx0XHRmdW5jdGlvbiBvbklucHV0Rm9jdXMoZXYpIHtcblx0XHRcdGNsYXNzaWUuYWRkKGV2LnRhcmdldC5wYXJlbnROb2RlLCAnaW5wdXQtLWZpbGxlZCcpO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBvbklucHV0Qmx1cihldikge1xuXHRcdFx0aWYgKGV2LnRhcmdldC52YWx1ZS50cmltKCkgPT09ICcnKSB7XG5cdFx0XHRcdGNsYXNzaWUucmVtb3ZlKGV2LnRhcmdldC5wYXJlbnROb2RlLCAnaW5wdXQtLWZpbGxlZCcpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSkoKTtcblxuXHQvLyBTZWxlY3Rib3hcblx0JChcIi5zZWxlY3Rib3hcIikuc2VsZWN0Ym94KCk7XG5cblx0Ly8gQ2hlY2sgYW5kIHJhZGlvIGlucHV0IHN0eWxlc1xuXHQkKCdpbnB1dC5pY2hlY2snKS5pQ2hlY2soe1xuXHRcdGNoZWNrYm94Q2xhc3M6ICdpY2hlY2tib3hfc3F1YXJlLWdyZXknLFxuXHRcdHJhZGlvQ2xhc3M6ICdpcmFkaW9fc3F1YXJlLWdyZXknXG5cdH0pO1xuXG5cdC8vIENhcm91c2Vsc1xuXHQkKCcjY2Fyb3VzZWwnKS5vd2xDYXJvdXNlbCh7XG5cdFx0Y2VudGVyOiB0cnVlLFxuXHRcdGl0ZW1zOiAyLFxuXHRcdGxvb3A6IHRydWUsXG5cdFx0bWFyZ2luOiAxMCxcblx0XHRyZXNwb25zaXZlOiB7XG5cdFx0XHQwOiB7XG5cdFx0XHRcdGl0ZW1zOiAxLFxuXHRcdFx0XHRkb3RzOmZhbHNlXG5cdFx0XHR9LFxuXHRcdFx0NjAwOiB7XG5cdFx0XHRcdGl0ZW1zOiAyXG5cdFx0XHR9LFxuXHRcdFx0MTAwMDoge1xuXHRcdFx0XHRpdGVtczogNFxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0JCgnI2hpZ2hsaWdodF9saXN0Jykub3dsQ2Fyb3VzZWwoe1xuXHRcdGl0ZW1zOjEsXG5cdFx0bG9vcDogdHJ1ZSxcblx0XHRtYXJnaW46MTAsXG5cdFx0cmVzcG9uc2l2ZToge1xuXHRcdFx0MDoge1xuXHRcdFx0XHRpdGVtczogMSxcblx0XHRcdFx0ZG90czp0cnVlLFxuXHRcdFx0XHRsb29wOiB0cnVlLFxuXHRcdFx0XHRhdXRvcGxheTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdDYwMDoge1xuXHRcdFx0XHRpdGVtczogMlxuXHRcdFx0fSxcblx0XHRcdDEwMDA6IHtcblx0XHRcdFx0aXRlbXM6Nyxcblx0XHRcdFx0bW91c2VEcmFnOiBmYWxzZVxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0JCgnI3Rlc3RpbW9uYWlscycpLm93bENhcm91c2VsKHtcblx0XHRpdGVtczoxLFxuXHRcdGxvb3A6IHRydWUsXG5cdFx0bWFyZ2luOjEwLFxuXHRcdG1vdXNlRHJhZzogZmFsc2Vcblx0fSk7XG5cdCQoJyNvdXJwYXJ0bmVycycpLm93bENhcm91c2VsKHtcblx0XHRpdGVtczoxLFxuXHRcdGxvb3A6IHRydWUsXG5cdFx0bWFyZ2luOjEwLFxuXHRcdHJlc3BvbnNpdmU6IHtcblx0XHRcdDA6IHtcblx0XHRcdFx0aXRlbXM6IDEsXG5cdFx0XHRcdGRvdHM6dHJ1ZSxcblx0XHRcdFx0bG9vcDogdHJ1ZSxcblx0XHRcdFx0YXV0b3BsYXk6IHRydWVcblx0XHRcdH0sXG5cdFx0XHQ2MDA6IHtcblx0XHRcdFx0aXRlbXM6IDJcblx0XHRcdH0sXG5cdFx0XHQxMDAwOiB7XG5cdFx0XHRcdGl0ZW1zOjcsXG5cdFx0XHRcdG1vdXNlRHJhZzogZmFsc2Vcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdCQoJyNyZWNjb21lbmRlZCcpLm93bENhcm91c2VsKHtcblx0XHRjZW50ZXI6IHRydWUsXG5cdFx0aXRlbXM6IDIsXG5cdFx0bG9vcDogdHJ1ZSxcblx0XHRtYXJnaW46IDAsXG5cdFx0cmVzcG9uc2l2ZToge1xuXHRcdFx0MDoge1xuXHRcdFx0XHRpdGVtczogMVxuXHRcdFx0fSxcblx0XHRcdDc2Nzoge1xuXHRcdFx0XHRpdGVtczogMlxuXHRcdFx0fSxcblx0XHRcdDEwMDA6IHtcblx0XHRcdFx0aXRlbXM6IDNcblx0XHRcdH0sXG5cdFx0XHQxNDAwOiB7XG5cdFx0XHRcdGl0ZW1zOiA0XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBTdGlja3kgZmlsdGVyc1xuXHQkKHdpbmRvdykuYmluZCgnbG9hZCByZXNpemUnLCBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHdpZHRoID0gJCh3aW5kb3cpLndpZHRoKCk7XG5cdFx0aWYgKHdpZHRoIDw9IDk5MSkge1xuXHRcdFx0JCgnLnN0aWNreV9ob3Jpem9udGFsJykuc3RpY2tfaW5fcGFyZW50KHtcblx0XHRcdFx0b2Zmc2V0X3RvcDogNTBcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQkKCcuc3RpY2t5X2hvcml6b250YWwnKS5zdGlja19pbl9wYXJlbnQoe1xuXHRcdFx0XHRvZmZzZXRfdG9wOiA3M1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9KTtcblxuXHQvLyBTZWNvbmRhcnkgbmF2IHNjcm9sbFxuXHR2YXIgJHN0aWNreV9uYXY9ICQoJy5zZWNvbmRhcnlfbmF2Jyk7XG5cdCRzdGlja3lfbmF2LmZpbmQoJ2EnKS5vbignY2xpY2snLCBmdW5jdGlvbihlKSB7XG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdHZhciB0YXJnZXQgPSB0aGlzLmhhc2g7XG5cdFx0dmFyICR0YXJnZXQgPSAkKHRhcmdldCk7XG5cdFx0JCgnaHRtbCwgYm9keScpLmFuaW1hdGUoe1xuXHRcdFx0J3Njcm9sbFRvcCc6ICR0YXJnZXQub2Zmc2V0KCkudG9wIC0gMTUwXG5cdFx0fSwgODAwLCAnc3dpbmcnKTtcblx0fSk7XG5cdCRzdGlja3lfbmF2LmZpbmQoJ3VsIGxpIGEnKS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG5cdFx0JHN0aWNreV9uYXYuZmluZCgndWwgbGkgYS5hY3RpdmUnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG5cdFx0JCh0aGlzKS5hZGRDbGFzcygnYWN0aXZlJyk7XG5cdH0pO1xuXG5cdC8vIEZhcSBzZWN0aW9uICh1cGRhdGVkIHYxLjIpXG5cdCQoJyNmYXFfYm94IGFbaHJlZl49XCIjXCJdJykub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuXHRcdGlmIChsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9eXFwvLywnJykgPT0gdGhpcy5wYXRobmFtZS5yZXBsYWNlKC9eXFwvLywnJylcblx0XHRcdHx8IGxvY2F0aW9uLmhvc3RuYW1lID09IHRoaXMuaG9zdG5hbWUpIHtcblx0XHRcdHZhciB0YXJnZXQgPSAkKHRoaXMuaGFzaCk7XG5cdFx0XHR0YXJnZXQgPSB0YXJnZXQubGVuZ3RoID8gdGFyZ2V0IDogJCgnW25hbWU9JyArIHRoaXMuaGFzaC5zbGljZSgxKSArJ10nKTtcblx0XHRcdCAgIGlmICh0YXJnZXQubGVuZ3RoKSB7XG5cdFx0XHRcdCAkKCdodG1sLGJvZHknKS5hbmltYXRlKHtcblx0XHRcdFx0XHQgc2Nyb2xsVG9wOiB0YXJnZXQub2Zmc2V0KCkudG9wIC0xODVcblx0XHRcdFx0fSwgODAwKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cdCQoJ3VsI2NhdF9uYXYgbGkgYScpLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcblx0XHQkKCd1bCNjYXRfbmF2IGxpIGEuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuXHRcdCQodGhpcykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuXHR9KTtcblxufSkod2luZG93LmpRdWVyeSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/main.js\n");

/***/ }),

/***/ "./resources/js/validate.js":
/*!**********************************!*\
  !*** ./resources/js/validate.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* <![CDATA[ */\n/// Jquery validate newsletter\njQuery(document).ready(function () {\n  $('#newsletter_form').submit(function () {\n    var action = $(this).attr('action');\n    $(\"#message-newsletter\").slideUp(750, function () {\n      $('#message-newsletter').hide();\n      $('#submit-newsletter').after('<i class=\"icon-spin4 animate-spin loader\"></i>').attr('disabled', 'disabled');\n      $.post(action, {\n        email_newsletter: $('#email_newsletter').val()\n      }, function (data) {\n        document.getElementById('message-newsletter').innerHTML = data;\n        $('#message-newsletter').slideDown('slow');\n        $('#newsletter_form .loader').fadeOut('slow', function () {\n          $(this).remove();\n        });\n        $('#submit-newsletter').removeAttr('disabled');\n        if (data.match('success') != null) $('#newsletter_form').slideUp('slow');\n      });\n    });\n    return false;\n  });\n}); // Jquery validate form contact\n\njQuery(document).on('ready', function () {\n  $('#contactform').submit(function () {\n    var action = $(this).attr('action');\n    $(\"#message-contact\").slideUp(750, function () {\n      $('#message-contact').hide();\n      $('#submit-contact').after('<i class=\"icon-spin4 animate-spin loader\"></i>').attr('disabled', 'disabled');\n      $.post(action, {\n        name_contact: $('#name_contact').val(),\n        lastname_contact: $('#lastname_contact').val(),\n        email_contact: $('#email_contact').val(),\n        phone_contact: $('#phone_contact').val(),\n        message_contact: $('#message_contact').val(),\n        verify_contact: $('#verify_contact').val()\n      }, function (data) {\n        document.getElementById('message-contact').innerHTML = data;\n        $('#message-contact').slideDown('slow');\n        $('#contactform .loader').fadeOut('slow', function () {\n          $(this).remove();\n        });\n        $('#submit-contact').removeAttr('disabled');\n        if (data.match('success') != null) $('#contactform').slideUp('slow');\n      });\n    });\n    return false;\n  });\n});\n/* ]]> *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvdmFsaWRhdGUuanM/YThkYiJdLCJuYW1lcyI6WyJqUXVlcnkiLCJkb2N1bWVudCIsInJlYWR5IiwiJCIsInN1Ym1pdCIsImFjdGlvbiIsImF0dHIiLCJzbGlkZVVwIiwiaGlkZSIsImFmdGVyIiwicG9zdCIsImVtYWlsX25ld3NsZXR0ZXIiLCJ2YWwiLCJkYXRhIiwiZ2V0RWxlbWVudEJ5SWQiLCJpbm5lckhUTUwiLCJzbGlkZURvd24iLCJmYWRlT3V0IiwicmVtb3ZlIiwicmVtb3ZlQXR0ciIsIm1hdGNoIiwib24iLCJuYW1lX2NvbnRhY3QiLCJsYXN0bmFtZV9jb250YWN0IiwiZW1haWxfY29udGFjdCIsInBob25lX2NvbnRhY3QiLCJtZXNzYWdlX2NvbnRhY3QiLCJ2ZXJpZnlfY29udGFjdCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBQSxNQUFNLENBQUNDLFFBQUQsQ0FBTixDQUFpQkMsS0FBakIsQ0FBdUIsWUFBVTtBQUVoQ0MsR0FBQyxDQUFDLGtCQUFELENBQUQsQ0FBc0JDLE1BQXRCLENBQTZCLFlBQVU7QUFFdEMsUUFBSUMsTUFBTSxHQUFHRixDQUFDLENBQUMsSUFBRCxDQUFELENBQVFHLElBQVIsQ0FBYSxRQUFiLENBQWI7QUFFQUgsS0FBQyxDQUFDLHFCQUFELENBQUQsQ0FBeUJJLE9BQXpCLENBQWlDLEdBQWpDLEVBQXFDLFlBQVc7QUFDaERKLE9BQUMsQ0FBQyxxQkFBRCxDQUFELENBQXlCSyxJQUF6QjtBQUVBTCxPQUFDLENBQUMsb0JBQUQsQ0FBRCxDQUNFTSxLQURGLENBQ1EsZ0RBRFIsRUFFRUgsSUFGRixDQUVPLFVBRlAsRUFFa0IsVUFGbEI7QUFJQUgsT0FBQyxDQUFDTyxJQUFGLENBQU9MLE1BQVAsRUFBZTtBQUNkTSx3QkFBZ0IsRUFBRVIsQ0FBQyxDQUFDLG1CQUFELENBQUQsQ0FBdUJTLEdBQXZCO0FBREosT0FBZixFQUdDLFVBQVNDLElBQVQsRUFBYztBQUNiWixnQkFBUSxDQUFDYSxjQUFULENBQXdCLG9CQUF4QixFQUE4Q0MsU0FBOUMsR0FBMERGLElBQTFEO0FBQ0FWLFNBQUMsQ0FBQyxxQkFBRCxDQUFELENBQXlCYSxTQUF6QixDQUFtQyxNQUFuQztBQUNBYixTQUFDLENBQUMsMEJBQUQsQ0FBRCxDQUE4QmMsT0FBOUIsQ0FBc0MsTUFBdEMsRUFBNkMsWUFBVTtBQUFDZCxXQUFDLENBQUMsSUFBRCxDQUFELENBQVFlLE1BQVI7QUFBaUIsU0FBekU7QUFDQWYsU0FBQyxDQUFDLG9CQUFELENBQUQsQ0FBd0JnQixVQUF4QixDQUFtQyxVQUFuQztBQUNBLFlBQUdOLElBQUksQ0FBQ08sS0FBTCxDQUFXLFNBQVgsS0FBeUIsSUFBNUIsRUFBa0NqQixDQUFDLENBQUMsa0JBQUQsQ0FBRCxDQUFzQkksT0FBdEIsQ0FBOEIsTUFBOUI7QUFFbEMsT0FWRjtBQWFDLEtBcEJEO0FBc0JBLFdBQU8sS0FBUDtBQUVBLEdBNUJEO0FBOEJBLENBaENELEUsQ0FrQ0E7O0FBQ0FQLE1BQU0sQ0FBQ0MsUUFBRCxDQUFOLENBQWlCb0IsRUFBakIsQ0FBb0IsT0FBcEIsRUFBNkIsWUFBVTtBQUV0Q2xCLEdBQUMsQ0FBQyxjQUFELENBQUQsQ0FBa0JDLE1BQWxCLENBQXlCLFlBQVU7QUFFbEMsUUFBSUMsTUFBTSxHQUFHRixDQUFDLENBQUMsSUFBRCxDQUFELENBQVFHLElBQVIsQ0FBYSxRQUFiLENBQWI7QUFFQUgsS0FBQyxDQUFDLGtCQUFELENBQUQsQ0FBc0JJLE9BQXRCLENBQThCLEdBQTlCLEVBQWtDLFlBQVc7QUFDN0NKLE9BQUMsQ0FBQyxrQkFBRCxDQUFELENBQXNCSyxJQUF0QjtBQUVDTCxPQUFDLENBQUMsaUJBQUQsQ0FBRCxDQUNDTSxLQURELENBQ08sZ0RBRFAsRUFFQ0gsSUFGRCxDQUVNLFVBRk4sRUFFaUIsVUFGakI7QUFJREgsT0FBQyxDQUFDTyxJQUFGLENBQU9MLE1BQVAsRUFBZTtBQUNkaUIsb0JBQVksRUFBRW5CLENBQUMsQ0FBQyxlQUFELENBQUQsQ0FBbUJTLEdBQW5CLEVBREE7QUFFZFcsd0JBQWdCLEVBQUVwQixDQUFDLENBQUMsbUJBQUQsQ0FBRCxDQUF1QlMsR0FBdkIsRUFGSjtBQUdkWSxxQkFBYSxFQUFFckIsQ0FBQyxDQUFDLGdCQUFELENBQUQsQ0FBb0JTLEdBQXBCLEVBSEQ7QUFJZGEscUJBQWEsRUFBRXRCLENBQUMsQ0FBQyxnQkFBRCxDQUFELENBQW9CUyxHQUFwQixFQUpEO0FBS2RjLHVCQUFlLEVBQUV2QixDQUFDLENBQUMsa0JBQUQsQ0FBRCxDQUFzQlMsR0FBdEIsRUFMSDtBQU1kZSxzQkFBYyxFQUFFeEIsQ0FBQyxDQUFDLGlCQUFELENBQUQsQ0FBcUJTLEdBQXJCO0FBTkYsT0FBZixFQVFDLFVBQVNDLElBQVQsRUFBYztBQUNiWixnQkFBUSxDQUFDYSxjQUFULENBQXdCLGlCQUF4QixFQUEyQ0MsU0FBM0MsR0FBdURGLElBQXZEO0FBQ0FWLFNBQUMsQ0FBQyxrQkFBRCxDQUFELENBQXNCYSxTQUF0QixDQUFnQyxNQUFoQztBQUNBYixTQUFDLENBQUMsc0JBQUQsQ0FBRCxDQUEwQmMsT0FBMUIsQ0FBa0MsTUFBbEMsRUFBeUMsWUFBVTtBQUFDZCxXQUFDLENBQUMsSUFBRCxDQUFELENBQVFlLE1BQVI7QUFBaUIsU0FBckU7QUFDQWYsU0FBQyxDQUFDLGlCQUFELENBQUQsQ0FBcUJnQixVQUFyQixDQUFnQyxVQUFoQztBQUNBLFlBQUdOLElBQUksQ0FBQ08sS0FBTCxDQUFXLFNBQVgsS0FBeUIsSUFBNUIsRUFBa0NqQixDQUFDLENBQUMsY0FBRCxDQUFELENBQWtCSSxPQUFsQixDQUEwQixNQUExQjtBQUVsQyxPQWZGO0FBa0JDLEtBekJEO0FBMEJBLFdBQU8sS0FBUDtBQUNBLEdBL0JEO0FBZ0NBLENBbENEO0FBb0NBIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL2pzL3ZhbGlkYXRlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogPCFbQ0RBVEFbICovXG4vLy8gSnF1ZXJ5IHZhbGlkYXRlIG5ld3NsZXR0ZXJcbmpRdWVyeShkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKXtcblxuXHQkKCcjbmV3c2xldHRlcl9mb3JtJykuc3VibWl0KGZ1bmN0aW9uKCl7XG5cblx0XHR2YXIgYWN0aW9uID0gJCh0aGlzKS5hdHRyKCdhY3Rpb24nKTtcblxuXHRcdCQoXCIjbWVzc2FnZS1uZXdzbGV0dGVyXCIpLnNsaWRlVXAoNzUwLGZ1bmN0aW9uKCkge1xuXHRcdCQoJyNtZXNzYWdlLW5ld3NsZXR0ZXInKS5oaWRlKCk7XG5cdFx0XG5cdFx0JCgnI3N1Ym1pdC1uZXdzbGV0dGVyJylcblx0XHRcdC5hZnRlcignPGkgY2xhc3M9XCJpY29uLXNwaW40IGFuaW1hdGUtc3BpbiBsb2FkZXJcIj48L2k+Jylcblx0XHRcdC5hdHRyKCdkaXNhYmxlZCcsJ2Rpc2FibGVkJyk7XG5cblx0XHQkLnBvc3QoYWN0aW9uLCB7XG5cdFx0XHRlbWFpbF9uZXdzbGV0dGVyOiAkKCcjZW1haWxfbmV3c2xldHRlcicpLnZhbCgpXG5cdFx0fSxcblx0XHRcdGZ1bmN0aW9uKGRhdGEpe1xuXHRcdFx0XHRkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWVzc2FnZS1uZXdzbGV0dGVyJykuaW5uZXJIVE1MID0gZGF0YTtcblx0XHRcdFx0JCgnI21lc3NhZ2UtbmV3c2xldHRlcicpLnNsaWRlRG93bignc2xvdycpO1xuXHRcdFx0XHQkKCcjbmV3c2xldHRlcl9mb3JtIC5sb2FkZXInKS5mYWRlT3V0KCdzbG93JyxmdW5jdGlvbigpeyQodGhpcykucmVtb3ZlKCl9KTtcblx0XHRcdFx0JCgnI3N1Ym1pdC1uZXdzbGV0dGVyJykucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcblx0XHRcdFx0aWYoZGF0YS5tYXRjaCgnc3VjY2VzcycpICE9IG51bGwpICQoJyNuZXdzbGV0dGVyX2Zvcm0nKS5zbGlkZVVwKCdzbG93Jyk7XG5cblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fSk7XG5cbn0pO1xuXG4vLyBKcXVlcnkgdmFsaWRhdGUgZm9ybSBjb250YWN0XG5qUXVlcnkoZG9jdW1lbnQpLm9uKCdyZWFkeScsIGZ1bmN0aW9uKCl7XG5cblx0JCgnI2NvbnRhY3Rmb3JtJykuc3VibWl0KGZ1bmN0aW9uKCl7XG5cblx0XHR2YXIgYWN0aW9uID0gJCh0aGlzKS5hdHRyKCdhY3Rpb24nKTtcblxuXHRcdCQoXCIjbWVzc2FnZS1jb250YWN0XCIpLnNsaWRlVXAoNzUwLGZ1bmN0aW9uKCkge1xuXHRcdCQoJyNtZXNzYWdlLWNvbnRhY3QnKS5oaWRlKCk7XG5cbiBcdFx0JCgnI3N1Ym1pdC1jb250YWN0Jylcblx0XHRcdC5hZnRlcignPGkgY2xhc3M9XCJpY29uLXNwaW40IGFuaW1hdGUtc3BpbiBsb2FkZXJcIj48L2k+Jylcblx0XHRcdC5hdHRyKCdkaXNhYmxlZCcsJ2Rpc2FibGVkJyk7XG5cdFx0XHRcblx0XHQkLnBvc3QoYWN0aW9uLCB7XG5cdFx0XHRuYW1lX2NvbnRhY3Q6ICQoJyNuYW1lX2NvbnRhY3QnKS52YWwoKSxcblx0XHRcdGxhc3RuYW1lX2NvbnRhY3Q6ICQoJyNsYXN0bmFtZV9jb250YWN0JykudmFsKCksXG5cdFx0XHRlbWFpbF9jb250YWN0OiAkKCcjZW1haWxfY29udGFjdCcpLnZhbCgpLFxuXHRcdFx0cGhvbmVfY29udGFjdDogJCgnI3Bob25lX2NvbnRhY3QnKS52YWwoKSxcblx0XHRcdG1lc3NhZ2VfY29udGFjdDogJCgnI21lc3NhZ2VfY29udGFjdCcpLnZhbCgpLFxuXHRcdFx0dmVyaWZ5X2NvbnRhY3Q6ICQoJyN2ZXJpZnlfY29udGFjdCcpLnZhbCgpXG5cdFx0fSxcblx0XHRcdGZ1bmN0aW9uKGRhdGEpe1xuXHRcdFx0XHRkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWVzc2FnZS1jb250YWN0JykuaW5uZXJIVE1MID0gZGF0YTtcblx0XHRcdFx0JCgnI21lc3NhZ2UtY29udGFjdCcpLnNsaWRlRG93bignc2xvdycpO1xuXHRcdFx0XHQkKCcjY29udGFjdGZvcm0gLmxvYWRlcicpLmZhZGVPdXQoJ3Nsb3cnLGZ1bmN0aW9uKCl7JCh0aGlzKS5yZW1vdmUoKX0pO1xuXHRcdFx0XHQkKCcjc3VibWl0LWNvbnRhY3QnKS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuXHRcdFx0XHRpZihkYXRhLm1hdGNoKCdzdWNjZXNzJykgIT0gbnVsbCkgJCgnI2NvbnRhY3Rmb3JtJykuc2xpZGVVcCgnc2xvdycpO1xuXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdH0pO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSk7XG59KTtcblxuLyogXV0+ICovIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/validate.js\n");

/***/ }),

/***/ "./resources/sass/admin/ad_app.scss":
/*!******************************************!*\
  !*** ./resources/sass/admin/ad_app.scss ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Fzcy9hZG1pbi9hZF9hcHAuc2Nzcz8yM2Y4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL3Nhc3MvYWRtaW4vYWRfYXBwLnNjc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/sass/admin/ad_app.scss\n");

/***/ }),

/***/ "./resources/sass/app.scss":
/*!*********************************!*\
  !*** ./resources/sass/app.scss ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Fzcy9hcHAuc2Nzcz9mZjFiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL3Nhc3MvYXBwLnNjc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/sass/app.scss\n");

/***/ }),

/***/ 0:
/*!************************************************************************************************!*\
  !*** multi ./resources/js/app.js ./resources/sass/app.scss ./resources/sass/admin/ad_app.scss ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! C:\wamp64\www\letstute\resources\js\app.js */"./resources/js/app.js");
__webpack_require__(/*! C:\wamp64\www\letstute\resources\sass\app.scss */"./resources/sass/app.scss");
module.exports = __webpack_require__(/*! C:\wamp64\www\letstute\resources\sass\admin\ad_app.scss */"./resources/sass/admin/ad_app.scss");


/***/ })

/******/ });